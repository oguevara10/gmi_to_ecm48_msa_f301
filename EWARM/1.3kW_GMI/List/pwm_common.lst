###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:01
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pwm_common.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW20F9.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pwm_common.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\pwm_common.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\pwm_common.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pwm_common.c
      1          /**
      2            ******************************************************************************
      3            * @file    pwm_common.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement common features
      6            *          of the PWM & Current Feedback component of the Motor Control SDK:
      7            *
      8            *           * start timers (main and auxiliary) synchronously
      9            *
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     14            * All rights reserved.</center></h2>
     15            *
     16            * This software component is licensed by ST under Ultimate Liberty license
     17            * SLA0044, the "License"; You may not use this file except in compliance with
     18            * the License. You may obtain a copy of the License at:
     19            *                             www.st.com/SLA0044
     20            *
     21            ******************************************************************************
     22            */
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "pwm_common.h"
     26          
     27          /** @addtogroup MCSDK
     28            * @{
     29            */
     30          
     31          /** @defgroup pwm_curr_fdbk PWM & Current Feedback
     32            *
     33            * @brief PWM & Current Feedback components of the Motor Control SDK
     34            *
     35            * These components fulfill two functions in a Motor Control subsystem:
     36            *
     37            * - The generation of the Space Vector Pulse Width Modulation on the motor's phases
     38            * - The sampling of the actual motor's phases current
     39            *
     40            * Both these features are closely related as the instants when the values of the phase currents
     41            * should be sampled by the ADC channels are basically triggered by the timers used to generate
     42            * the duty cycles for the PWM.
     43            *
     44            * Several implementation of PWM and Current Feedback components are provided by the Motor Control
     45            * SDK to account for the specificities of the application:
     46            *
     47            * - The selected MCU: the number of ADCs available on a given MCU, the presence of internal
     48            * compoarators or OpAmps, for instance, lead to different implementation of this feature
     49            * - The Current sensing topology also has an impact on the firmware: implementations are provided
     50            * for Insulated Current Sensors, Single Shunt and Three Shunt resistors current sensing topologies
     51            *
     52            * The choice of the implementation mostly depend on these two factors and is performed by the
     53            * Motor Control Workbench tool.
     54            *
     55            * All these implementations are built on a base PWM & Current Feedback component that they extend
     56            * and that provides the functions and data that are common to all of them. This base component is
     57            * never used directly as it does not provide a complete implementation of the features. Rather,
     58            * its handle structure (PWMC_Handle) is reused by all the PWM & Current Feedback specific
     59            * implementations and the functions it provides form the API of the PWM and Current feedback feature.
     60            * Calling them results in calling functions of the component that actually implement the feature.
     61            * See PWMC_Handle for more details on this mechanism.
     62            * @{
     63            */
     64          
     65          #ifdef TIM2
     66          /**
     67           * @brief  It perform the start of all the timers required by the control.
     68           *          It utilizes TIM2 as temporary timer to achieve synchronization between
     69           *          PWM signals.
     70           *          When this function is called, TIM1 and/or TIM8 must be in frozen state
     71           *          with CNT, ARR, REP RATE and trigger correctly set (these setting are
     72           *          usually performed in the Init method accordingly with the configuration)
     73           * @param  none
     74           * @retval none
     75           */

   \                                 In section .text, align 4
     76          __weak void startTimers( void )
     77          {
     78            uint32_t isTIM2ClockOn;
     79            uint32_t trigOut;
     80          
     81            isTIM2ClockOn = LL_APB1_GRP1_IsEnabledClock ( LL_APB1_GRP1_PERIPH_TIM2 );
   \                     startTimers: (+1)
   \        0x0   0x4815             LDR.N    R0,??startTimers_0  ;; 0x4002101c
     82            if ( isTIM2ClockOn == 0 )
   \        0x2   0x4916             LDR.N    R1,??startTimers_0+0x4  ;; 0x40000004
   \        0x4   0xB081             SUB      SP,SP,#+4
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0x07D2             LSLS     R2,R2,#+31
   \        0xA   0xD411             BMI.N    ??startTimers_1
     83            {
     84              /* Temporary Enable TIM2 clock if not already on */
     85              LL_APB1_GRP1_EnableClock ( LL_APB1_GRP1_PERIPH_TIM2 );
   \        0xC   0x6803             LDR      R3,[R0, #+0]
   \        0xE   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x12   0x6003             STR      R3,[R0, #+0]
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x1A   0x9200             STR      R2,[SP, #+0]
   \       0x1C   0x9A00             LDR      R2,[SP, #+0]
     86              LL_TIM_GenerateEvent_UPDATE ( TIM2 );
   \       0x1E   0x690B             LDR      R3,[R1, #+16]
   \       0x20   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x24   0x610B             STR      R3,[R1, #+16]
     87              LL_APB1_GRP1_DisableClock ( LL_APB1_GRP1_PERIPH_TIM2 );
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x0849             LSRS     R1,R1,#+1
   \       0x2A   0x0049             LSLS     R1,R1,#+1
   \       0x2C   0x6001             STR      R1,[R0, #+0]
     88            }
   \       0x2E   0xE011             B.N      ??startTimers_2
     89            else
     90            {
     91              trigOut = LL_TIM_ReadReg( TIM2, CR2 ) & TIM_CR2_MMS;
   \                     ??startTimers_1: (+1)
   \       0x30   0x6808             LDR      R0,[R1, #+0]
     92              LL_TIM_SetTriggerOutput( TIM2, LL_TIM_TRGO_UPDATE );
   \       0x32   0x680A             LDR      R2,[R1, #+0]
   \       0x34   0xF022 0x0270      BIC      R2,R2,#0x70
   \       0x38   0xF042 0x0220      ORR      R2,R2,#0x20
   \       0x3C   0x600A             STR      R2,[R1, #+0]
     93              LL_TIM_GenerateEvent_UPDATE ( TIM2 );
     94              LL_TIM_SetTriggerOutput( TIM2, trigOut );
   \       0x3E   0xF000 0x0070      AND      R0,R0,#0x70
   \       0x42   0x690A             LDR      R2,[R1, #+16]
   \       0x44   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x48   0x610A             STR      R2,[R1, #+16]
   \       0x4A   0x680B             LDR      R3,[R1, #+0]
   \       0x4C   0xF023 0x0370      BIC      R3,R3,#0x70
   \       0x50   0x4318             ORRS     R0,R0,R3
   \       0x52   0x6008             STR      R0,[R1, #+0]
     95            }
     96          }
   \                     ??startTimers_2: (+1)
   \       0x54   0xB001             ADD      SP,SP,#+4
   \       0x56   0x4770             BX       LR               ;; return
   \                     ??startTimers_0:
   \       0x58   0x4002'101C        DC32     0x4002101c
   \       0x5C   0x4000'0004        DC32     0x40000004
     97          #endif
     98          
     99          /**
    100           * @brief  It waits for the end of the polarization. If the polarization exceeds the
    101           *         the number of needed PWM cycles, it reports an error.
    102           * @param  TIMx: timer used to generate PWM
    103           *         SWerror: variable used to report a SW error
    104           *         repCnt: repetition counter value
    105           *         cnt: polarization counter value
    106           * @retval none
    107           */

   \                                 In section .text, align 2
    108          __weak void waitForPolarizationEnd( TIM_TypeDef*  TIMx, uint16_t  *SWerror, uint8_t repCnt, uint8_t *cnt )
    109          {
   \                     waitForPolarizationEnd: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    110            uint16_t hCalibrationPeriodCounter;
    111            uint16_t hMaxPeriodsNumber;
    112          
    113            if ( (LL_TIM_GetCounterMode(TIMx) & LL_TIM_COUNTERMODE_CENTER_UP_DOWN) == LL_TIM_COUNTERMODE_CENTER_UP_DOWN)
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0x1C52             ADDS     R2,R2,#+1
   \        0x6   0xF004 0x0460      AND      R4,R4,#0x60
   \        0xA   0x2C60             CMP      R4,#+96
   \        0xC   0xBF1C             ITT      NE
   \        0xE   0x0412             LSLNE    R2,R2,#+16
   \       0x10   0x0C52             LSRNE    R2,R2,#+17
    114            {
    115              hMaxPeriodsNumber=(2*NB_CONVERSIONS)*(((uint16_t)repCnt+1u));
    116            }
    117            else
    118            {
    119          	hMaxPeriodsNumber=(2*NB_CONVERSIONS)*(((uint16_t)repCnt+1u)>>1);
    120            }
    121          
    122            /* Wait for NB_CONVERSIONS to be executed */
    123            LL_TIM_ClearFlag_CC1(TIMx);
   \       0x12   0xF06F 0x0402      MVN      R4,#+2
   \       0x16   0x0552             LSLS     R2,R2,#+21
   \       0x18   0x6104             STR      R4,[R0, #+16]
    124            hCalibrationPeriodCounter = 0u;
   \       0x1A   0x2500             MOVS     R5,#+0
    125            while (*cnt < NB_CONVERSIONS)
   \                     ??waitForPolarizationEnd_0: (+1)
   \       0x1C   0x781E             LDRB     R6,[R3, #+0]
   \       0x1E   0x2E10             CMP      R6,#+16
   \       0x20   0xD20D             BCS.N    ??waitForPolarizationEnd_1
    126            {
    127              if (LL_TIM_IsActiveFlag_CC1(TIMx))
   \       0x22   0x6906             LDR      R6,[R0, #+16]
   \       0x24   0x07B7             LSLS     R7,R6,#+30
   \       0x26   0xD5F9             BPL.N    ??waitForPolarizationEnd_0
    128              {
    129                LL_TIM_ClearFlag_CC1(TIMx);
    130                hCalibrationPeriodCounter++;
   \       0x28   0x1C6D             ADDS     R5,R5,#+1
    131                if (hCalibrationPeriodCounter >= hMaxPeriodsNumber)
   \       0x2A   0xB2AE             UXTH     R6,R5
   \       0x2C   0xEBB6 0x4F12      CMP      R6,R2, LSR #+16
   \       0x30   0x6104             STR      R4,[R0, #+16]
   \       0x32   0xDBF3             BLT.N    ??waitForPolarizationEnd_0
    132                {
    133                  if (*cnt < NB_CONVERSIONS)
   \       0x34   0x781F             LDRB     R7,[R3, #+0]
   \       0x36   0x2F10             CMP      R7,#+16
   \       0x38   0xD2F0             BCS.N    ??waitForPolarizationEnd_0
    134                  {
    135                    *SWerror = 1u;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x8008             STRH     R0,[R1, #+0]
    136                    break;
    137                  }
    138                }
    139              }
    140            }
    141          }
   \                     ??waitForPolarizationEnd_1: (+1)
   \       0x3E   0xBDF0             POP      {R4-R7,PC}       ;; return
    142          
    143          /**
    144            * @}
    145            */
    146          
    147          /**
    148            * @}
    149            */
    150          
    151          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   startTimers
      20   waitForPolarizationEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      96  startTimers
      64  waitForPolarizationEnd

 
 160 bytes in section .text
 
 0 bytes of CODE memory (+ 160 bytes shared)

Errors: none
Warnings: none
