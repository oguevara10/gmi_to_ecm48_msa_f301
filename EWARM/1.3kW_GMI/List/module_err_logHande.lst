###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:13:53
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Drivers\module_err_logHande.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW227.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Drivers\module_err_logHande.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\module_err_logHande.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\module_err_logHande.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Drivers\module_err_logHande.c
      1          /**
      2            ********************************************************************************************************************************
      3            * @file    module_err_logHandle.c 
      4            * @author  Pamela Lee
      5            * @version V1.0
      6            * @date    28-OCT-2020
      7            * @brief   Kernal module for error or log handling.
      8            * @details All module/s can report their Error or log by either software interrupt(in urgent message) or by structured_memory(for normal data log), 
      9            *          this module will response according to the type of the message, which may either store it in the EEprom as error/data log or just 
     10            *          increase as the relatived counter/s.
     11            *     parameters:-
     12            *          ErrorModule ID(SENDER_MODULE_ID):  Module ID for error occur                    
     13            *          ErrorMesage Type(irqType_u8):      0xE0 = AutoAck-TimeOut, 
     14            *                                             0xE1 = Heap-Memory allocation Error, 
     15            *                                             0xE2 = Module execution exceed time limit error,
     16            *                                             0xE3 = IRQ response execution exceed time limit error,
     17            *                                             0xE4 = Flash Error 
     18            *                                             0xEF = for debug tetsing 
     19            *          Further Detials(irqDatXX):         All the details will send through the various irqDatxx as data, may need to decode in different way (see the particular routine for details)
     20            ********************************************************************************************************************************
     21            */
     22          
     23          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     24          #include "module_err_logHandle.h"

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     25          
     26          //#include "driver_usart2.h"
     27          
     28          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     29          /* Auto acknowledgement handle declaration */
     30          extern ProcessInfo processInfoTable[];
     31          

   \                                 In section .bss, align 8
     32          Err_logHandling_Control* err_logHandling_Control;
     33          
     34          #define Err_logTimePeriod 5000                        //Err_log Handling waiting period
     35          uint64_t Err_log_WaitTime; 
   \                     Err_log_WaitTime:
   \        0x0                      DS8 8
     36          uint64_t testDat = 0;                           
   \                     testDat:
   \        0x8                      DS8 8
   \                     err_logHandling_Control:
   \       0x10                      DS8 4
     37          
     38          enum {
     39            INIT_MODULE,
     40            RUN_MODULE,
     41            // additional states to be added here as necessary.
     42            IRQ_MODULE = DEFAULT_IRQ_STATE,
     43            KILL_MODULE = KILL_APP
     44          };
     45          

   \                                 In section .text, align 4, keep-with-next
     46          uint8_t module_err_log_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     module_err_log_u32: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
     47            uint8_t return_state_u8 = INIT_MODULE;
     48            switch (next_state_u8) {
   \        0x2   0xF241 0x3488      MOVW     R4,#+5000
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x4E1B             LDR.N    R6,??module_err_log_u32_0
   \        0xA   0x27FF             MOVS     R7,#+255
   \        0xC   0xB132             CBZ.N    R2,??module_err_log_u32_1
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD00E             BEQ.N    ??module_err_log_u32_2
   \       0x12   0x2AC8             CMP      R2,#+200
   \       0x14   0xD01C             BEQ.N    ??module_err_log_u32_3
   \       0x16   0x2AFF             CMP      R2,#+255
   \       0x18   0xD023             BEQ.N    ??module_err_log_u32_4
   \       0x1A   0xE02B             B.N      ??module_err_log_u32_5
     49              case INIT_MODULE: {
     50                Err_logHandlingStructMem_u32 = StructMem_CreateInstance(MODULE_ERR_LOGHANDLE, sizeof(Err_logHandling_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory
   \                     ??module_err_log_u32_1: (+1)
   \       0x1C   0x9500             STR      R5,[SP, #+0]
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x2202             MOVS     R2,#+2
   \       0x22   0x2110             MOVS     R1,#+16
   \       0x24   0x2009             MOVS     R0,#+9
   \       0x26   0x....'....        BL       StructMem_CreateInstance
     51                err_logHandling_Control = (Err_logHandling_Control*)(*Err_logHandlingStructMem_u32).p_ramBuf_u8;
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x6131             STR      R1,[R6, #+16]
     52          //      (*err_logHandling_Control)
     53                Err_log_WaitTime = getSysCount() + Err_logTimePeriod;                        //store time tick value  
   \       0x2E   0xE008             B.N      ??module_err_log_u32_6
     54                return_state_u8 = RUN_MODULE;
     55                break;
     56              }
     57              case RUN_MODULE: {                                                  //        
     58                if (getSysCount() >= Err_log_WaitTime) 
   \                     ??module_err_log_u32_2: (+1)
   \       0x30   0x....'....        BL       getSysCount
   \       0x34   0xE9D6 0x2300      LDRD     R2,R3,[R6, #+0]
   \       0x38   0x4299             CMP      R1,R3
   \       0x3A   0xD310             BCC.N    ??module_err_log_u32_7
   \       0x3C   0xD801             BHI.N    ??module_err_log_u32_6
   \       0x3E   0x4290             CMP      R0,R2
   \       0x40   0xD30D             BCC.N    ??module_err_log_u32_7
     59                {
     60                 
     61                  Err_log_WaitTime = getSysCount() + Err_logTimePeriod;                        //store time tick value  
   \                     ??module_err_log_u32_6: (+1)
   \       0x42   0x....'....        BL       getSysCount
   \       0x46   0x1900             ADDS     R0,R0,R4
   \       0x48   0x4169             ADCS     R1,R1,R5
   \       0x4A   0xE9C6 0x0100      STRD     R0,R1,[R6, #+0]
     62                }
     63                return_state_u8 = RUN_MODULE;
   \       0x4E   0xE006             B.N      ??module_err_log_u32_7
     64                break;
     65              }
     66              case IRQ_MODULE: {
     67                  testDat++;
   \                     ??module_err_log_u32_3: (+1)
   \       0x50   0xE9D6 0x0102      LDRD     R0,R1,[R6, #+8]
   \       0x54   0x1C42             ADDS     R2,R0,#+1
   \       0x56   0xF161 0x33FF      SBC      R3,R1,#-1
   \       0x5A   0xE9C6 0x2302      STRD     R2,R3,[R6, #+8]
     68                  return_state_u8 = RUN_MODULE;
   \                     ??module_err_log_u32_7: (+1)
   \       0x5E   0x2701             MOVS     R7,#+1
     69                  break;
   \       0x60   0xE008             B.N      ??module_err_log_u32_5
     70              }
     71              case KILL_MODULE: {
     72                // The USART2 driver module must only be executed once.
     73                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
     74                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??module_err_log_u32_4: (+1)
   \       0x62   0x....'....        BL       getProcessInfoIndex
     75                if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0x66   0x28FF             CMP      R0,#+255
   \       0x68   0xD004             BEQ.N    ??module_err_log_u32_5
     76                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \       0x6A   0x2116             MOVS     R1,#+22
   \       0x6C   0x4A03             LDR.N    R2,??module_err_log_u32_0+0x4
   \       0x6E   0x4348             MULS     R0,R1,R0
   \       0x70   0x4410             ADD      R0,R2,R0
   \       0x72   0x7287             STRB     R7,[R0, #+10]
     77                }
     78                return_state_u8 = KILL_MODULE;
     79                break;
     80              }
     81              default: {
     82                return_state_u8 = KILL_MODULE;
     83                break;
     84              }
     85            }
     86            return return_state_u8;
   \                     ??module_err_log_u32_5: (+1)
   \       0x74   0x4638             MOV      R0,R7
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??module_err_log_u32_0:
   \       0x78   0x....'....        DC32     Err_log_WaitTime
   \       0x7C   0x....'....        DC32     processInfoTable
     87          }
     88          
     89          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   module_err_log_u32
        24   -> StructMem_CreateInstance
        24   -> getProcessInfoIndex
        24   -> getSysCount


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  Err_logHandlingStructMem_u32
      20  Err_log_WaitTime
          testDat
          err_logHandling_Control
     128  module_err_log_u32

 
  24 bytes in section .bss
 128 bytes in section .text
 
 128 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
