###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:33
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\mc_tasks.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW4860.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\mc_tasks.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\mc_tasks.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\mc_tasks.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\mc_tasks.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    mc_tasks.c
      5            * @author  Motor Control SDK Team, ST Microelectronics
      6            * @brief   This file implements tasks definition
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "main.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_GPIO_LockPin(GPIO_TypeDef *, uint32_t)
   \                     LL_GPIO_LockPin: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0xF441 0x3280      ORR      R2,R1,#0x10000
   \        0x6   0x61C2             STR      R2,[R0, #+28]
   \        0x8   0x61C1             STR      R1,[R0, #+28]
   \        0xA   0x61C2             STR      R2,[R0, #+28]
   \        0xC   0x69C0             LDR      R0,[R0, #+28]
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR               ;; return
     24          #include "mc_type.h"
     25          #include "mc_math.h"
     26          #include "motorcontrol.h"
     27          #include "regular_conversion_manager.h"
     28          #include "mc_interface.h"
     29          #include "mc_tuning.h"
     30          #include "digital_output.h"
     31          #include "state_machine.h"
     32          #include "pwm_common.h"
     33          
     34          #include "mc_tasks.h"
     35          #include "parameters_conversion.h"
     36          #include "zz_module_flash.h"

   \                                 In section .rodata, at 0x800f000
   \   __absolute uint16_t const A_POLE_PAIR_NUM
   \                     A_POLE_PAIR_NUM:
   \        0x0   0x0005             DC16 5

   \                                 In section .rodata, at 0x800f002
   \   __absolute uint16_t const A_RS
   \                     A_RS:
   \        0x0   0x0258             DC16 600

   \                                 In section .rodata, at 0x800f004
   \   __absolute uint16_t const A_LS
   \                     A_LS:
   \        0x0   0x0010             DC16 16

   \                                 In section .rodata, at 0x800f006
   \   __absolute uint16_t const A_NOMINAL_CURRENT
   \                     A_NOMINAL_CURRENT:
   \        0x0   0x6A1E             DC16 27'166

   \                                 In section .rodata, at 0x800f008
   \   __absolute uint16_t const A_MAX_APPLICATION_SPEED_RPM
   \                     A_MAX_APPLICATION_SPEED_RPM:
   \        0x0   0x08CA             DC16 2'250

   \                                 In section .rodata, at 0x800f00a
   \   __absolute uint16_t const A_MIN_APPLICATION_SPEED_RPM
   \                     A_MIN_APPLICATION_SPEED_RPM:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f00c
   \   __absolute uint16_t const A_PLL_KP_GAIN
   \                     A_PLL_KP_GAIN:
   \        0x0   0x0214             DC16 532

   \                                 In section .rodata, at 0x800f00e
   \   __absolute uint16_t const A_PLL_KI_GAIN
   \                     A_PLL_KI_GAIN:
   \        0x0   0x0025             DC16 37

   \                                 In section .rodata, at 0x800f010
   \   __absolute uint16_t const A_PWM_FREQUENCY
   \                     A_PWM_FREQUENCY:
   \        0x0   0x2710             DC16 10'000

   \                                 In section .rodata, at 0x800f012
   \   __absolute uint16_t const A_PID_TORQUE_KP_DEFAULT
   \                     A_PID_TORQUE_KP_DEFAULT:
   \        0x0   0x0ECF             DC16 3'791

   \                                 In section .rodata, at 0x800f014
   \   __absolute uint16_t const A_PID_TORQUE_KI_DEFAULT
   \                     A_PID_TORQUE_KI_DEFAULT:
   \        0x0   0x0038             DC16 56

   \                                 In section .rodata, at 0x800f016
   \   __absolute uint16_t const A_PID_FLUX_KP_DEFAULT
   \                     A_PID_FLUX_KP_DEFAULT:
   \        0x0   0x14B7             DC16 5'303

   \                                 In section .rodata, at 0x800f018
   \   __absolute uint16_t const A_PID_FLUX_KI_DEFAULT
   \                     A_PID_FLUX_KI_DEFAULT:
   \        0x0   0x0038             DC16 56

   \                                 In section .rodata, at 0x800f01a
   \   __absolute uint16_t const A_PID_SPEED_KP_DEFAULT
   \                     A_PID_SPEED_KP_DEFAULT:
   \        0x0   0x0064             DC16 100

   \                                 In section .rodata, at 0x800f01c
   \   __absolute uint16_t const A_PID_SPEED_KI_DEFAULT
   \                     A_PID_SPEED_KI_DEFAULT:
   \        0x0   0x03E8             DC16 1'000

   \                                 In section .rodata, at 0x800f01e
   \   __absolute uint16_t const A_IQMAX
   \                     A_IQMAX:
   \        0x0   0x6A1E             DC16 27'166

   \                                 In section .rodata, at 0x800f020
   \   __absolute uint16_t const A_DEFAULT_CONTROL_MODE
   \                     A_DEFAULT_CONTROL_MODE:
   \        0x0   0x0001             DC16 1

   \                                 In section .rodata, at 0x800f022
   \   __absolute uint16_t const A_OV_VOLTAGE_THRESHOLD_V
   \                     A_OV_VOLTAGE_THRESHOLD_V:
   \        0x0   0x01EC             DC16 492

   \                                 In section .rodata, at 0x800f024
   \   __absolute uint16_t const A_UD_VOLTAGE_THRESHOLD_V
   \                     A_UD_VOLTAGE_THRESHOLD_V:
   \        0x0   0x00AF             DC16 175

   \                                 In section .rodata, at 0x800f026
   \   __absolute uint16_t const A_OV_TEMPERATURE_THRESHOLD_C
   \                     A_OV_TEMPERATURE_THRESHOLD_C:
   \        0x0   0x005F             DC16 95

   \                                 In section .rodata, at 0x800f028
   \   __absolute uint16_t const A_OV_TEMPERATURE_HYSTERESIS_C
   \                     A_OV_TEMPERATURE_HYSTERESIS_C:
   \        0x0   0x000A             DC16 10

   \                                 In section .rodata, at 0x800f02a
   \   __absolute uint16_t const A_PHASE1_DURATION
   \                     A_PHASE1_DURATION:
   \        0x0   0x03E8             DC16 1'000

   \                                 In section .rodata, at 0x800f02c
   \   __absolute uint16_t const A_PHASE1_FINAL_SPEED_UNIT
   \                     A_PHASE1_FINAL_SPEED_UNIT:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f02e
   \   __absolute uint16_t const A_PHASE1_FINAL_CURRENT
   \                     A_PHASE1_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f030
   \   __absolute uint16_t const A_PHASE2_DURATION
   \                     A_PHASE2_DURATION:
   \        0x0   0x1770             DC16 6'000

   \                                 In section .rodata, at 0x800f032
   \   __absolute uint16_t const A_PHASE2_FINAL_SPEED_UNIT
   \                     A_PHASE2_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f034
   \   __absolute uint16_t const A_PHASE2_FINAL_CURRENT
   \                     A_PHASE2_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f036
   \   __absolute uint16_t const A_PHASE3_DURATION
   \                     A_PHASE3_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f038
   \   __absolute uint16_t const A_PHASE3_FINAL_SPEED_UNIT
   \                     A_PHASE3_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f03a
   \   __absolute uint16_t const A_PHASE3_FINAL_CURRENT
   \                     A_PHASE3_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f03c
   \   __absolute uint16_t const A_PHASE4_DURATION
   \                     A_PHASE4_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f03e
   \   __absolute uint16_t const A_PHASE4_FINAL_SPEED_UNIT
   \                     A_PHASE4_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f040
   \   __absolute uint16_t const A_PHASE4_FINAL_CURRENT
   \                     A_PHASE4_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f042
   \   __absolute uint16_t const A_PHASE5_DURATION
   \                     A_PHASE5_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f044
   \   __absolute uint16_t const A_PHASE5_FINAL_SPEED_UNIT
   \                     A_PHASE5_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f046
   \   __absolute uint16_t const A_PHASE5_FINAL_CURRENT
   \                     A_PHASE5_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f048
   \   __absolute uint16_t const A_TRANSITION_DURATION
   \                     A_TRANSITION_DURATION:
   \        0x0   0x01F4             DC16 500

   \                                 In section .rodata, at 0x800f04a
   \   __absolute uint16_t const D_HALL_SENSORS_PLACEMENT
   \                     D_HALL_SENSORS_PLACEMENT:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f04c
   \   __absolute uint16_t const D_HALL_PHASE_SHIFT
   \                     D_HALL_PHASE_SHIFT:
   \        0x0   0x012C             DC16 300

   \                                 In section .rodata, at 0x800f04e
   \   __absolute uint16_t const D_M1_ENCODER_PPR
   \                     D_M1_ENCODER_PPR:
   \        0x0   0x0190             DC16 400

   \                                 In section .rodata, at 0x800f050
   \   __absolute int16_t const A_GAIN1
   \                     A_GAIN1:
   \        0x0   0xA02E             DC16 -24'530

   \                                 In section .rodata, at 0x800f052
   \   __absolute int16_t const A_GAIN2
   \                     A_GAIN2:
   \        0x0   0x5EA3             DC16 24'227
     37          
     38          /* USER CODE BEGIN Includes */
     39          #include "bus_voltage_sensor.h"
     40          #include "regal_mc_lib.h"
     41          /* USER CODE END Includes */
     42          
     43          /* USER CODE BEGIN Private define */
     44          /* Private define ------------------------------------------------------------*/
     45          
     46          #define CHARGE_BOOT_CAP_MS  10
     47          #define CHARGE_BOOT_CAP_MS2 10
     48          #define OFFCALIBRWAIT_MS     0
     49          #define OFFCALIBRWAIT_MS2    0
     50          #define STOPPERMANENCY_MS  400
     51          #define STOPPERMANENCY_MS2 400
     52          #define CHARGE_BOOT_CAP_TICKS  (uint16_t)((SYS_TICK_FREQUENCY * CHARGE_BOOT_CAP_MS)/ 1000)
     53          #define CHARGE_BOOT_CAP_TICKS2 (uint16_t)((SYS_TICK_FREQUENCY * CHARGE_BOOT_CAP_MS2)/ 1000)
     54          #define OFFCALIBRWAITTICKS     (uint16_t)((SYS_TICK_FREQUENCY * OFFCALIBRWAIT_MS)/ 1000)
     55          #define OFFCALIBRWAITTICKS2    (uint16_t)((SYS_TICK_FREQUENCY * OFFCALIBRWAIT_MS2)/ 1000)
     56          #define STOPPERMANENCY_TICKS   (uint16_t)((SYS_TICK_FREQUENCY * STOPPERMANENCY_MS)/ 1000)
     57          #define STOPPERMANENCY_TICKS2  (uint16_t)((SYS_TICK_FREQUENCY * STOPPERMANENCY_MS2)/ 1000)
     58          
     59          /* Un-Comment this macro define in order to activate the smooth
     60             braking action on over voltage */
     61          /* #define  MC.SMOOTH_BRAKING_ACTION_ON_OVERVOLTAGE */
     62          
     63          /* USER CODE END Private define */
     64          #define VBUS_TEMP_ERR_MASK (MC_OVER_VOLT| MC_UNDER_VOLT| MC_OVER_TEMP)
     65          
     66          /* Private variables----------------------------------------------------------*/

   \                                 In section .bss, align 4
     67          FOCVars_t FOCVars[NBR_OF_MOTORS];
   \                     FOCVars:
   \        0x0                      DS8 40

   \                                 In section .bss, align 4
     68          MCI_Handle_t Mci[NBR_OF_MOTORS];
     69          MCI_Handle_t * oMCInterface[NBR_OF_MOTORS];
     70          MCT_Handle_t MCT[NBR_OF_MOTORS];
     71          STM_Handle_t STM[NBR_OF_MOTORS];
     72          SpeednTorqCtrl_Handle_t *pSTC[NBR_OF_MOTORS];
     73          PID_Handle_t *pPIDSpeed[NBR_OF_MOTORS];
     74          PID_Handle_t *pPIDIq[NBR_OF_MOTORS];
     75          PID_Handle_t *pPIDId[NBR_OF_MOTORS];
     76          RDivider_Handle_t *pBusSensorM1;
     77          
     78          NTC_Handle_t *pTemperatureSensor[NBR_OF_MOTORS];
     79          PWMC_Handle_t * pwmcHandle[NBR_OF_MOTORS];
     80          DOUT_handle_t *pR_Brake[NBR_OF_MOTORS];
     81          DOUT_handle_t *pOCPDisabling[NBR_OF_MOTORS];
     82          PQD_MotorPowMeas_Handle_t *pMPM[NBR_OF_MOTORS];
     83          CircleLimitation_Handle_t *pCLM[NBR_OF_MOTORS];
     84          RampExtMngr_Handle_t *pREMNG[NBR_OF_MOTORS];   /*!< Ramp manager used to modify the Iq ref
     85                                                              during the start-up switch over.*/
     86          
     87          static volatile uint16_t hMFTaskCounterM1 = 0;
     88          static volatile uint16_t hBootCapDelayCounterM1 = 0;
     89          static volatile uint16_t hStopPermanencyCounterM1 = 0;
     90          
     91          uint8_t bMCBootCompleted = 0;
   \                     bMCBootCompleted:
   \        0x0                      DS8 1
   \        0x1                      DS8 3
   \                     `STM`:
   \        0x4                      DS8 8
   \        0xC                      DS8 2
   \        0xE                      DS8 2
   \       0x10                      DS8 2
   \       0x12                      DS8 2
   \                     oMCInterface:
   \       0x14                      DS8 4
   \                     pSTC:
   \       0x18                      DS8 4
   \                     pPIDSpeed:
   \       0x1C                      DS8 4
   \                     pPIDIq:
   \       0x20                      DS8 4
   \                     pPIDId:
   \       0x24                      DS8 4
   \                     pBusSensorM1:
   \       0x28                      DS8 4
   \                     pTemperatureSensor:
   \       0x2C                      DS8 4
   \                     pwmcHandle:
   \       0x30                      DS8 4
   \                     pMPM:
   \       0x34                      DS8 4
   \                     pCLM:
   \       0x38                      DS8 4
   \                     pREMNG:
   \       0x3C                      DS8 4
   \                     Mci:
   \       0x40                      DS8 28

   \                                 In section .bss, align 4
   \                     MCT:
   \        0x0                      DS8 84

   \                                 In section .bss, align 4
   \                     pR_Brake:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     pOCPDisabling:
   \        0x0                      DS8 4
     92          
     93          /* USER CODE BEGIN Private Variables */
     94          #if (CONTROLLED_BRAKING==1)
     95          PID_Handle_t *pPIDBk[NBR_OF_MOTORS]; //RPa
     96          PID_Handle_t *pPIDIm[NBR_OF_MOTORS]; //RPa
     97          Braking_Handle_t *pBrakeId[NBR_OF_MOTORS];
     98          #endif
     99          /* USER CODE END Private Variables */
    100          
    101          /* Private functions ---------------------------------------------------------*/
    102          void TSK_MediumFrequencyTaskM1(void);
    103          void FOC_Clear(uint8_t bMotor);
    104          void FOC_InitAdditionalMethods(uint8_t bMotor);
    105          void FOC_CalcCurrRef(uint8_t bMotor);
    106          static uint16_t FOC_CurrControllerM1(void);
    107          void TSK_SetChargeBootCapDelayM1(uint16_t hTickCount);
    108          bool TSK_ChargeBootCapDelayHasElapsedM1(void);
    109          void TSK_SetStopPermanencyTimeM1(uint16_t hTickCount);
    110          bool TSK_StopPermanencyTimeHasElapsedM1(void);
    111          void TSK_SafetyTask_PWMOFF(uint8_t motor);
    112          void UI_Scheduler(void);
    113          
    114          /* USER CODE BEGIN Private Functions */
    115          
    116          /* USER CODE END Private Functions */
    117          /**
    118            * @brief  It initializes the whole MC core according to user defined
    119            *         parameters.
    120            * @param  pMCIList pointer to the vector of MCInterface objects that will be
    121            *         created and initialized. The vector must have length equal to the
    122            *         number of motor drives.
    123            * @param  pMCTList pointer to the vector of MCTuning objects that will be
    124            *         created and initialized. The vector must have length equal to the
    125            *         number of motor drives.
    126            * @retval None
    127            */

   \                                 In section .text, align 4
    128          __weak void MCboot( MCI_Handle_t* pMCIList[NBR_OF_MOTORS],MCT_Handle_t* pMCTList[NBR_OF_MOTORS] )
    129          {
   \                     MCboot: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
    130            /* USER CODE BEGIN MCboot 0 */
    131          
    132            /* USER CODE END MCboot 0 */
    133          
    134            /**************************************/
    135            /*    State machine initialization    */
    136            /**************************************/
    137            STM_Init(&STM[M1]);
   \        0x6   0x4E54             LDR.N    R6,??MCboot_0
   \        0x8   0x468B             MOV      R11,R1
   \        0xA   0x1D30             ADDS     R0,R6,#+4
   \        0xC   0x....'....        BL       STM_Init
    138            
    139            bMCBootCompleted = 0;
    140            pCLM[M1] = &CircleLimitationM1;
   \       0x10   0x4852             LDR.N    R0,??MCboot_0+0x4
    141          
    142            /**********************************************************/
    143            /*    PWM and current sensing component initialization    */
    144            /**********************************************************/
    145            pwmcHandle[M1] = &PWM_Handle_M1._Super;
   \       0x12   0x4F53             LDR.N    R7,??MCboot_0+0x8
   \       0x14   0xF8DF 0x814C      LDR.W    R8,??MCboot_0+0xC
   \       0x18   0xF8DF 0x914C      LDR.W    R9,??MCboot_0+0x10
   \       0x1C   0x4C53             LDR.N    R4,??MCboot_0+0x14
   \       0x1E   0x4D54             LDR.N    R5,??MCboot_0+0x18
   \       0x20   0x63B0             STR      R0,[R6, #+56]
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x4853             LDR.N    R0,??MCboot_0+0x1C
   \       0x26   0x7031             STRB     R1,[R6, #+0]
   \       0x28   0x6330             STR      R0,[R6, #+48]
    146            R3_1_Init(&PWM_Handle_M1);
   \       0x2A   0x....'....        BL       R3_1_Init
    147            /* USER CODE BEGIN MCboot 1 */
    148          
    149            /* USER CODE END MCboot 1 */
    150          
    151            /**************************************/
    152            /*    Start timers synchronously      */
    153            /**************************************/
    154            startTimers();    
   \       0x2E   0x....'....        BL       startTimers
    155          
    156            /******************************************************/
    157            /*     Init Regal user flash setting parameters       */
    158            /******************************************************/
    159            RegalSetting_Init();
   \       0x32   0x....'....        BL       RegalSetting_Init
    160            /******************************************************/
    161            /*   PID component initialization: speed regulation   */
    162            /******************************************************/
    163            PID_HandleInit(&PIDSpeedHandle_M1);
   \       0x36   0x4638             MOV      R0,R7
   \       0x38   0x....'....        BL       PID_HandleInit
    164            pPIDSpeed[M1] = &PIDSpeedHandle_M1;
   \       0x3C   0x61F7             STR      R7,[R6, #+28]
    165            
    166            /******************************************************/
    167            /*   Main speed sensor component initialization       */
    168            /******************************************************/
    169            pSTC[M1] = &SpeednTorqCtrlM1;
   \       0x3E   0x484E             LDR.N    R0,??MCboot_0+0x20
    170            STO_PLL_Init (&STO_PLL_M1);
   \       0x40   0x4F4E             LDR.N    R7,??MCboot_0+0x24
   \       0x42   0x61B0             STR      R0,[R6, #+24]
   \       0x44   0x4638             MOV      R0,R7
   \       0x46   0x....'....        BL       STO_PLL_Init
    171            
    172          
    173            /******************************************************/
    174            /*   Speed & torque component initialization          */
    175            /******************************************************/
    176            STC_Init(pSTC[M1],pPIDSpeed[M1], &STO_PLL_M1._Super);
   \       0x4A   0x69F1             LDR      R1,[R6, #+28]
   \       0x4C   0x69B0             LDR      R0,[R6, #+24]
   \       0x4E   0x463A             MOV      R2,R7
   \       0x50   0x....'....        BL       STC_Init
    177            
    178            /******************************************************/
    179            /*   Auxiliary speed sensor component initialization  */
    180            /******************************************************/
    181            //HALL_Init (&HALL_M1);
    182            
    183            /****************************************************/
    184            /*   Virtual speed sensor component initialization  */
    185            /****************************************************/ 
    186            VSS_Init (&VirtualSpeedSensorM1);
   \       0x54   0x4640             MOV      R0,R8
   \       0x56   0x....'....        BL       VSS_Init
    187            
    188            /**************************************/
    189            /*   Rev-up component initialization  */
    190            /**************************************/
    191            RUC_Init(&RevUpControlM1,pSTC[M1],&VirtualSpeedSensorM1, &STO_M1, pwmcHandle[M1]);  
   \       0x5A   0x6B30             LDR      R0,[R6, #+48]
   \       0x5C   0x69B1             LDR      R1,[R6, #+24]
   \       0x5E   0x4B48             LDR.N    R3,??MCboot_0+0x28
   \       0x60   0x9000             STR      R0,[SP, #+0]
   \       0x62   0x4642             MOV      R2,R8
   \       0x64   0x4648             MOV      R0,R9
   \       0x66   0x....'....        BL       RUC_Init
    192                
    193            /********************************************************/
    194            /*   PID component initialization: current regulation   */
    195            /********************************************************/
    196            PID_HandleInit(&PIDIqHandle_M1);
   \       0x6A   0x4620             MOV      R0,R4
   \       0x6C   0x....'....        BL       PID_HandleInit
    197            PID_HandleInit(&PIDIdHandle_M1);
   \       0x70   0x4628             MOV      R0,R5
   \       0x72   0x....'....        BL       PID_HandleInit
    198            pPIDIq[M1] = &PIDIqHandle_M1;
   \       0x76   0x6234             STR      R4,[R6, #+32]
    199            pPIDId[M1] = &PIDIdHandle_M1;
   \       0x78   0x6275             STR      R5,[R6, #+36]
    200            
    201            /********************************************************/
    202            /*   Bus voltage sensor component initialization        */
    203            /********************************************************/
    204            pBusSensorM1 = &RealBusVoltageSensorParamsM1;
   \       0x7A   0x4842             LDR.N    R0,??MCboot_0+0x2C
   \       0x7C   0x4C42             LDR.N    R4,??MCboot_0+0x30
   \       0x7E   0x4D43             LDR.N    R5,??MCboot_0+0x34
   \       0x80   0x62B0             STR      R0,[R6, #+40]
    205            RVBS_Init(pBusSensorM1);
   \       0x82   0x....'....        BL       RVBS_Init
    206            
    207            /*************************************************/
    208            /*   Power measurement component initialization  */
    209            /*************************************************/
    210            pMPM[M1] = &PQD_MotorPowMeasM1;
   \       0x86   0x4842             LDR.N    R0,??MCboot_0+0x38
    211            pMPM[M1]->pVBS = &(pBusSensorM1->_Super);
   \       0x88   0x6AB1             LDR      R1,[R6, #+40]
   \       0x8A   0x6370             STR      R0,[R6, #+52]
   \       0x8C   0xF500 0x7086      ADD      R0,R0,#+268
   \       0x90   0x6041             STR      R1,[R0, #+4]
    212            pMPM[M1]->pFOCVars = &FOCVars[M1];
   \       0x92   0x6004             STR      R4,[R0, #+0]
    213            
    214            /*******************************************************/
    215            /*   Temperature measurement component initialization  */
    216            /*******************************************************/
    217            NTC_Init(&TempSensorParamsM1);    
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x....'....        BL       NTC_Init
    218            pTemperatureSensor[M1] = &TempSensorParamsM1;
   \       0x9A   0x62F5             STR      R5,[R6, #+44]
    219              
    220          
    221            pREMNG[M1] = &RampExtMngrHFParamsM1;
   \       0x9C   0xF104 0x0514      ADD      R5,R4,#+20
   \       0xA0   0x483C             LDR.N    R0,??MCboot_0+0x3C
   \       0xA2   0x63F0             STR      R0,[R6, #+60]
    222            REMNG_Init(pREMNG[M1]);
   \       0xA4   0x....'....        BL       REMNG_Init
    223          
    224            FOC_Clear(M1);
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x....'....        BL       FOC_Clear
    225            FOCVars[M1].bDriveInput = EXTERNAL;
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0x7428             STRB     R0,[R5, #+16]
    226            FOCVars[M1].Iqdref = STC_GetDefaultIqdref(pSTC[M1]);
   \       0xB2   0x69B0             LDR      R0,[R6, #+24]
   \       0xB4   0x....'....        BL       STC_GetDefaultIqdref
   \       0xB8   0x6120             STR      R0,[R4, #+16]
    227            FOCVars[M1].UserIdref = STC_GetDefaultIqdref(pSTC[M1]).d;
   \       0xBA   0x69B0             LDR      R0,[R6, #+24]
   \       0xBC   0x....'....        BL       STC_GetDefaultIqdref
   \       0xC0   0x9000             STR      R0,[SP, #+0]
    228            oMCInterface[M1] = & Mci[M1];
   \       0xC2   0xF106 0x0140      ADD      R1,R6,#+64
   \       0xC6   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \       0xCA   0x8028             STRH     R0,[R5, #+0]
   \       0xCC   0x6171             STR      R1,[R6, #+20]
    229            MCI_Init(oMCInterface[M1], &STM[M1], pSTC[M1], &FOCVars[M1] );
   \       0xCE   0x4623             MOV      R3,R4
   \       0xD0   0x69B2             LDR      R2,[R6, #+24]
   \       0xD2   0x1D31             ADDS     R1,R6,#+4
   \       0xD4   0xF106 0x0040      ADD      R0,R6,#+64
   \       0xD8   0x....'....        BL       MCI_Init
    230            MCI_ExecSpeedRamp(oMCInterface[M1],
    231            STC_GetMecSpeedRefUnitDefault(pSTC[M1]),0); /*First command to STC*/
   \       0xDC   0x69B0             LDR      R0,[R6, #+24]
   \       0xDE   0x....'....        BL       STC_GetMecSpeedRefUnitDefault
   \       0xE2   0x4601             MOV      R1,R0
   \       0xE4   0x6970             LDR      R0,[R6, #+20]
   \       0xE6   0x2200             MOVS     R2,#+0
   \       0xE8   0x....'....        BL       MCI_ExecSpeedRamp
    232            pMCIList[M1] = oMCInterface[M1];
   \       0xEC   0x6970             LDR      R0,[R6, #+20]
   \       0xEE   0xF8CA 0x0000      STR      R0,[R10, #+0]
    233            MCT[M1].pPIDSpeed = pPIDSpeed[M1];
    234            MCT[M1].pPIDIq = pPIDIq[M1];
    235            MCT[M1].pPIDId = pPIDId[M1];
    236            MCT[M1].pPIDFluxWeakening = MC_NULL; /* if M1 doesn't has FW */
    237            MCT[M1].pPWMnCurrFdbk = pwmcHandle[M1];
    238            MCT[M1].pRevupCtrl = &RevUpControlM1;              /* only if M1 is sensorless*/
    239            MCT[M1].pSpeedSensorMain = (SpeednPosFdbk_Handle_t *) &STO_PLL_M1; 
    240            MCT[M1].pSpeedSensorAux = MC_NULL;
    241            MCT[M1].pSpeedSensorVirtual = &VirtualSpeedSensorM1;  /* only if M1 is sensorless*/
    242            MCT[M1].pSpeednTorqueCtrl = pSTC[M1];
    243            MCT[M1].pStateMachine = &STM[M1];
    244            MCT[M1].pTemperatureSensor = (NTC_Handle_t *) pTemperatureSensor[M1];
    245            MCT[M1].pBusVoltageSensor = &(pBusSensorM1->_Super);
    246            MCT[M1].pBrakeDigitalOutput = MC_NULL;   /* brake is defined, oBrakeM1*/
    247            MCT[M1].pNTCRelay = MC_NULL;             /* relay is defined, oRelayM1*/
   \       0xF2   0x2300             MOVS     R3,#+0
   \       0xF4   0x4828             LDR.N    R0,??MCboot_0+0x40
   \       0xF6   0x69F1             LDR      R1,[R6, #+28]
   \       0xF8   0x6001             STR      R1,[R0, #+0]
   \       0xFA   0x6A32             LDR      R2,[R6, #+32]
   \       0xFC   0x6042             STR      R2,[R0, #+4]
   \       0xFE   0x2200             MOVS     R2,#+0
   \      0x100   0x6A71             LDR      R1,[R6, #+36]
   \      0x102   0x6081             STR      R1,[R0, #+8]
   \      0x104   0x60C2             STR      R2,[R0, #+12]
   \      0x106   0x6B31             LDR      R1,[R6, #+48]
   \      0x108   0x6101             STR      R1,[R0, #+16]
   \      0x10A   0xF8C0 0x9014      STR      R9,[R0, #+20]
   \      0x10E   0x6187             STR      R7,[R0, #+24]
   \      0x110   0x61C2             STR      R2,[R0, #+28]
   \      0x112   0xF8C0 0x8020      STR      R8,[R0, #+32]
   \      0x116   0x1D32             ADDS     R2,R6,#+4
   \      0x118   0x69B1             LDR      R1,[R6, #+24]
   \      0x11A   0x6241             STR      R1,[R0, #+36]
   \      0x11C   0x6282             STR      R2,[R0, #+40]
   \      0x11E   0x2200             MOVS     R2,#+0
   \      0x120   0x6AF1             LDR      R1,[R6, #+44]
   \      0x122   0x62C1             STR      R1,[R0, #+44]
   \      0x124   0x6AB1             LDR      R1,[R6, #+40]
   \      0x126   0x6342             STR      R2,[R0, #+52]
   \      0x128   0x6301             STR      R1,[R0, #+48]
   \      0x12A   0x6383             STR      R3,[R0, #+56]
    248            MCT[M1].pMPM =  (MotorPowMeas_Handle_t*)pMPM[M1];
   \      0x12C   0x6B72             LDR      R2,[R6, #+52]
   \      0x12E   0x63C2             STR      R2,[R0, #+60]
    249            MCT[M1].pFW = MC_NULL;
   \      0x130   0x6403             STR      R3,[R0, #+64]
    250            MCT[M1].pFF = MC_NULL;
   \      0x132   0x6443             STR      R3,[R0, #+68]
    251          
    252            MCT[M1].pPosCtrl = MC_NULL;
   \      0x134   0x6483             STR      R3,[R0, #+72]
    253          
    254            MCT[M1].pSCC = MC_NULL;
   \      0x136   0x64C3             STR      R3,[R0, #+76]
    255            MCT[M1].pOTT = MC_NULL;
   \      0x138   0x6503             STR      R3,[R0, #+80]
    256            pMCTList[M1] = &MCT[M1];
   \      0x13A   0xF8CB 0x0000      STR      R0,[R11, #+0]
    257           
    258            //DOUT_SetOutputState(&ICLDOUTParamsM1, INACTIVE);
    259            ICL_Init(&ICL_M1, &(pBusSensorM1->_Super), &ICLDOUTParamsM1);
   \      0x13E   0x4A17             LDR.N    R2,??MCboot_0+0x44
   \      0x140   0x4817             LDR.N    R0,??MCboot_0+0x48
   \      0x142   0x....'....        BL       ICL_Init
    260            STM_NextState(&STM[M1],ICLWAIT);
   \      0x146   0x210C             MOVS     R1,#+12
   \      0x148   0x1D30             ADDS     R0,R6,#+4
   \      0x14A   0x....'....        BL       STM_NextState
    261          
    262            /* USER CODE BEGIN MCboot 2 */
    263          #if (CONTROLLED_BRAKING==1)
    264            PID_HandleInit(&PIDBkHandle_M1);//RPa
    265            PID_HandleInit(&PIDImHandle_M1);//RPa
    266            BrakingStruct_Init(&BrakeHandle_M1, pSTC[M1] );
    267            pPIDBk[M1] = &PIDBkHandle_M1;//RPa
    268            pPIDIm[M1] = &PIDImHandle_M1;//RPa
    269            pBrakeId[M1] = &BrakeHandle_M1;
    270          #endif
    271            /* USER CODE END MCboot 2 */
    272          
    273            bMCBootCompleted = 1;
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0x7030             STRB     R0,[R6, #+0]
    274          }
   \      0x152   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   \      0x156   0xBF00             Nop
   \                     ??MCboot_0:
   \      0x158   0x....'....        DC32     bMCBootCompleted
   \      0x15C   0x....'....        DC32     CircleLimitationM1
   \      0x160   0x....'....        DC32     PIDSpeedHandle_M1
   \      0x164   0x....'....        DC32     VirtualSpeedSensorM1
   \      0x168   0x....'....        DC32     RevUpControlM1
   \      0x16C   0x....'....        DC32     PIDIqHandle_M1
   \      0x170   0x....'....        DC32     PIDIdHandle_M1
   \      0x174   0x....'....        DC32     PWM_Handle_M1
   \      0x178   0x....'....        DC32     SpeednTorqCtrlM1
   \      0x17C   0x....'....        DC32     STO_PLL_M1
   \      0x180   0x....'....        DC32     STO_M1
   \      0x184   0x....'....        DC32     RealBusVoltageSensorParamsM1
   \      0x188   0x....'....        DC32     FOCVars
   \      0x18C   0x....'....        DC32     TempSensorParamsM1
   \      0x190   0x....'....        DC32     PQD_MotorPowMeasM1
   \      0x194   0x....'....        DC32     RampExtMngrHFParamsM1
   \      0x198   0x....'....        DC32     MCT
   \      0x19C   0x....'....        DC32     ICLDOUTParamsM1
   \      0x1A0   0x....'....        DC32     ICL_M1
    275          
    276          /**
    277           * @brief Runs all the Tasks of the Motor Control cockpit
    278           *
    279           * This function is to be called periodically at least at the Medium Frequency task
    280           * rate (It is typically called on the Systick interrupt). Exact invokation rate is 
    281           * the Speed regulator execution rate set in the Motor Contorl Workbench.
    282           *
    283           * The following tasks are executed in this order:
    284           *
    285           * - Medium Frequency Tasks of each motors
    286           * - Safety Task
    287           * - Power Factor Correction Task (if enabled)
    288           * - User Interface task. 
    289           */

   \                                 In section .text, align 4
    290          __weak void MC_RunMotorControlTasks(void)
    291          {
   \                     MC_RunMotorControlTasks: (+1)
   \        0x0   0x4906             LDR.N    R1,??MC_RunMotorControlTasks_0
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD100             BNE.N    ??MC_RunMotorControlTasks_1
   \        0x8   0x4770             BX       LR
   \                     ??MC_RunMotorControlTasks_1: (+1)
   \        0xA   0xB580             PUSH     {R7,LR}
    292            if ( bMCBootCompleted ) {
    293              /* ** Medium Frequency Tasks ** */
    294              MC_Scheduler();
   \        0xC   0x....'....        BL       MC_Scheduler
    295          
    296              /* Safety task is run after Medium Frequency task so that  
    297               * it can overcome actions they initiated if needed. */
    298              TSK_SafetyTask();
   \       0x10   0x....'....        BL       TSK_SafetyTask
    299              
    300          
    301              /* ** User Interface Task ** */
    302              UI_Scheduler();
   \       0x14   0xE8BD 0x4001      POP      {R0,LR}
   \       0x18   0x....'....        B.W      UI_Scheduler
   \                     ??MC_RunMotorControlTasks_0:
   \       0x1C   0x....'....        DC32     bMCBootCompleted
    303            }
    304          }
    305          
    306          /**
    307           * @brief  Executes the Medium Frequency Task functions for each drive instance. 
    308           *
    309           * It is to be clocked at the Systick frequency.
    310           */

   \                                 In section .text, align 4
    311          __weak void MC_Scheduler(void)
    312          {
   \                     MC_Scheduler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    313          /* USER CODE BEGIN MC_Scheduler 0 */
    314          
    315          /* USER CODE END MC_Scheduler 0 */
    316          
    317            if (bMCBootCompleted == 1)
   \        0x2   0x4C0C             LDR.N    R4,??MC_Scheduler_0
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD113             BNE.N    ??MC_Scheduler_1
    318            {    
    319              if(hMFTaskCounterM1 > 0u)
   \        0xA   0x89A0             LDRH     R0,[R4, #+12]
   \        0xC   0xB118             CBZ.N    R0,??MC_Scheduler_2
    320              {
    321                hMFTaskCounterM1--;
   \        0xE   0x89A0             LDRH     R0,[R4, #+12]
   \       0x10   0x1E41             SUBS     R1,R0,#+1
   \       0x12   0x81A1             STRH     R1,[R4, #+12]
   \       0x14   0xE003             B.N      ??MC_Scheduler_3
    322              }
    323              else
    324              {
    325                TSK_MediumFrequencyTaskM1();
   \                     ??MC_Scheduler_2: (+1)
   \       0x16   0x....'....        BL       TSK_MediumFrequencyTaskM1
    326                /* USER CODE BEGIN MC_Scheduler 1 */
    327          
    328                /* USER CODE END MC_Scheduler 1 */
    329                hMFTaskCounterM1 = MF_TASK_OCCURENCE_TICKS;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x81A0             STRH     R0,[R4, #+12]
    330              }
    331              if(hBootCapDelayCounterM1 > 0u)
   \                     ??MC_Scheduler_3: (+1)
   \       0x1E   0x89E0             LDRH     R0,[R4, #+14]
   \       0x20   0xB110             CBZ.N    R0,??MC_Scheduler_4
    332              {
    333                hBootCapDelayCounterM1--;
   \       0x22   0x89E0             LDRH     R0,[R4, #+14]
   \       0x24   0x1E41             SUBS     R1,R0,#+1
   \       0x26   0x81E1             STRH     R1,[R4, #+14]
    334              }
    335              if(hStopPermanencyCounterM1 > 0u)
   \                     ??MC_Scheduler_4: (+1)
   \       0x28   0x8A20             LDRH     R0,[R4, #+16]
   \       0x2A   0xB110             CBZ.N    R0,??MC_Scheduler_1
    336              {
    337                hStopPermanencyCounterM1--;
   \       0x2C   0x8A20             LDRH     R0,[R4, #+16]
   \       0x2E   0x1E41             SUBS     R1,R0,#+1
   \       0x30   0x8221             STRH     R1,[R4, #+16]
    338              }
    339            }
    340            else
    341            {
    342            }
    343            /* USER CODE BEGIN MC_Scheduler 2 */
    344          
    345            /* USER CODE END MC_Scheduler 2 */
    346          }
   \                     ??MC_Scheduler_1: (+1)
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
   \                     ??MC_Scheduler_0:
   \       0x34   0x....'....        DC32     bMCBootCompleted
    347          
    348          /**
    349            * @brief Executes medium frequency periodic Motor Control tasks
    350            *
    351            * This function performs some of the control duties on Motor 1 according to the 
    352            * present state of its state machine. In particular, duties requiring a periodic 
    353            * execution at a medium frequency rate (such as the speed controller for instance) 
    354            * are executed here.
    355            */

   \                                 In section .text, align 4
    356          __weak void TSK_MediumFrequencyTaskM1(void)
    357          {
   \                     TSK_MediumFrequencyTaskM1: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
    358            /* USER CODE BEGIN MediumFrequencyTask M1 0 */
    359          
    360            /* USER CODE END MediumFrequencyTask M1 0 */
    361          
    362            State_t StateM1;
    363            int16_t wAux = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    364          
    365            ICL_State_t ICLstate = ICL_Exec( &ICL_M1 );
   \        0xA   0x4884             LDR.N    R0,??TSK_MediumFrequencyTaskM1_1
   \        0xC   0x4C84             LDR.N    R4,??TSK_MediumFrequencyTaskM1_1+0x4
   \        0xE   0x4D85             LDR.N    R5,??TSK_MediumFrequencyTaskM1_1+0x8
   \       0x10   0x4E85             LDR.N    R6,??TSK_MediumFrequencyTaskM1_1+0xC
   \       0x12   0x4F86             LDR.N    R7,??TSK_MediumFrequencyTaskM1_1+0x10
   \       0x14   0xF8DF 0x8218      LDR.W    R8,??TSK_MediumFrequencyTaskM1_1+0x14
   \       0x18   0x....'....        BL       ICL_Exec
   \       0x1C   0x4681             MOV      R9,R0
    366            bool IsSpeedReliable = STO_PLL_CalcAvrgMecSpeedUnit( &STO_PLL_M1, &wAux );
   \       0x1E   0xF10D 0x0102      ADD      R1,SP,#+2
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       STO_PLL_CalcAvrgMecSpeedUnit
   \       0x28   0x4682             MOV      R10,R0
    367            PQD_CalcElMotorPower( pMPM[M1] );
   \       0x2A   0x6B68             LDR      R0,[R5, #+52]
   \       0x2C   0x....'....        BL       PQD_CalcElMotorPower
    368          
    369            StateM1 = STM_GetState( &STM[M1] );
    370          
    371            switch ( StateM1 )
   \       0x30   0x1D28             ADDS     R0,R5,#+4
   \       0x32   0x....'....        BL       STM_GetState
   \       0x36   0x1EC0             SUBS     R0,R0,#+3
   \       0x38   0x2810             CMP      R0,#+16
   \       0x3A   0xD843             BHI.N    ??TSK_MediumFrequencyTaskM1_2
   \       0x3C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??TSK_MediumFrequencyTaskM1_0:
   \       0x40   0x0E 0x43          DC8      0xE,0x43,0x9F,0xB4

   \              0x9F 0xB4
   \       0x44   0xC3 0xD2          DC8      0xC3,0xD2,0xDD,0xEB

   \              0xDD 0xEB
   \       0x48   0xEB 0x09          DC8      0xEB,0x9,0xEB,0xEB

   \              0xEB 0xEB
   \       0x4C   0xEB 0x1A          DC8      0xEB,0x1A,0x24,0x2C

   \              0x24 0x2C
   \       0x50   0x83 0x00          DC8      0x83,0x0
    372            {
    373            case ICLWAIT:
    374              if ( ICLstate == ICL_INACTIVE )
   \                     ??TSK_MediumFrequencyTaskM1_3: (+1)
   \       0x52   0xF1B9 0x0F04      CMP      R9,#+4
   \       0x56   0xD135             BNE.N    ??TSK_MediumFrequencyTaskM1_2
    375              {
    376                /* If ICL is Inactive, move to IDLE */
    377                STM_NextState( &STM[M1], IDLE );
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0xE0D9             B.N      ??TSK_MediumFrequencyTaskM1_4
    378              }
    379              break;
    380          
    381            case IDLE_START:
    382              RUC_Clear( &RevUpControlM1, MCI_GetImposedMotorDirection( oMCInterface[M1] ) );
   \                     ??TSK_MediumFrequencyTaskM1_5: (+1)
   \       0x5C   0x6968             LDR      R0,[R5, #+20]
   \       0x5E   0x....'....        BL       MCI_GetImposedMotorDirection
   \       0x62   0x4601             MOV      R1,R0
   \       0x64   0x4638             MOV      R0,R7
   \       0x66   0x....'....        BL       RUC_Clear
    383              //R3_1_TurnOnLowSides( pwmcHandle[M1] );
    384              TSK_SetChargeBootCapDelayM1( CHARGE_BOOT_CAP_TICKS );
   \       0x6A   0x2014             MOVS     R0,#+20
   \       0x6C   0x....'....        BL       TSK_SetChargeBootCapDelayM1
    385              STM_NextState( &STM[M1], CHARGE_BOOT_CAP );
   \       0x70   0x2110             MOVS     R1,#+16
   \       0x72   0xE0CD             B.N      ??TSK_MediumFrequencyTaskM1_4
    386              break;
    387          
    388            case CHARGE_BOOT_CAP:
    389              if ( TSK_ChargeBootCapDelayHasElapsedM1() )
   \                     ??TSK_MediumFrequencyTaskM1_6: (+1)
   \       0x74   0x....'....        BL       TSK_ChargeBootCapDelayHasElapsedM1
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD023             BEQ.N    ??TSK_MediumFrequencyTaskM1_2
    390              {
    391                PWMC_CurrentReadingCalibr( pwmcHandle[M1], CRC_START );
   \       0x7C   0x6B28             LDR      R0,[R5, #+48]
   \       0x7E   0x2100             MOVS     R1,#+0
   \       0x80   0x....'....        BL       PWMC_CurrentReadingCalibr
    392          
    393                /* USER CODE BEGIN MediumFrequencyTask M1 Charge BootCap elapsed */
    394          
    395                /* USER CODE END MediumFrequencyTask M1 Charge BootCap elapsed */
    396          
    397                STM_NextState(&STM[M1],OFFSET_CALIB);
   \       0x84   0x2111             MOVS     R1,#+17
   \       0x86   0xE0C3             B.N      ??TSK_MediumFrequencyTaskM1_4
    398              }
    399              break;
    400          
    401            case OFFSET_CALIB:
    402              if ( PWMC_CurrentReadingCalibr( pwmcHandle[M1], CRC_EXEC ) )
   \                     ??TSK_MediumFrequencyTaskM1_7: (+1)
   \       0x88   0x6B28             LDR      R0,[R5, #+48]
   \       0x8A   0x2101             MOVS     R1,#+1
   \       0x8C   0x....'....        BL       PWMC_CurrentReadingCalibr
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD017             BEQ.N    ??TSK_MediumFrequencyTaskM1_2
    403              {
    404                STM_NextState( &STM[M1], CLEAR );
   \       0x94   0x2112             MOVS     R1,#+18
   \       0x96   0xE0BB             B.N      ??TSK_MediumFrequencyTaskM1_4
    405              }
    406              break;
    407          
    408            case CLEAR:
    409              /* In a sensorless configuration. Initiate the Revup procedure */
    410              FOCVars[M1].bDriveInput = EXTERNAL;
   \                     ??TSK_MediumFrequencyTaskM1_8: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xF886 0x0024      STRB     R0,[R6, #+36]
    411              STC_SetSpeedSensor( pSTC[M1], &VirtualSpeedSensorM1._Super );
   \       0x9E   0x4641             MOV      R1,R8
   \       0xA0   0x69A8             LDR      R0,[R5, #+24]
   \       0xA2   0x....'....        BL       STC_SetSpeedSensor
    412              STO_PLL_Clear( &STO_PLL_M1 );
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x....'....        BL       STO_PLL_Clear
    413              //HALL_Clear( &HALL_M1 );
    414          
    415              if ( STM_NextState( &STM[M1], START ) == true )
   \       0xAC   0x2104             MOVS     R1,#+4
   \       0xAE   0x1D28             ADDS     R0,R5,#+4
   \       0xB0   0x....'....        BL       STM_NextState
   \       0xB4   0x2801             CMP      R0,#+1
   \       0xB6   0xD105             BNE.N    ??TSK_MediumFrequencyTaskM1_2
    416              {
    417          #if (CONTROLLED_BRAKING==1)
    418                BrakeHandle_M1.Adapt_BusVoltageRef = VBS_GetAvBusVoltage_V(&(pBusSensorM1->_Super)) + BrakeHandle_M1.Vbus_Add;
    419                pPIDSpeed[M1]->wUpperIntegralLimit = (int32_t)IQMAX * (int32_t)SP_KIDIV;
    420                pPIDSpeed[M1]->wLowerIntegralLimit = -(int32_t)IQMAX * (int32_t)SP_KIDIV;
    421                pPIDSpeed[M1]->hUpperOutputLimit = (int16_t)IQMAX;
    422                pPIDSpeed[M1]->hLowerOutputLimit = -(int16_t)IQMAX;
    423          #endif      
    424                FOC_Clear( M1 );
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x....'....        BL       FOC_Clear
    425          
    426                R3_1_SwitchOnPWM( pwmcHandle[M1] );
   \       0xBE   0x6B28             LDR      R0,[R5, #+48]
   \       0xC0   0x....'....        BL       R3_1_SwitchOnPWM
   \                     ??TSK_MediumFrequencyTaskM1_2: (+1)
   \       0xC4   0xE0A7             B.N      ??TSK_MediumFrequencyTaskM1_9
    427              }
    428              break;
    429          
    430            case START:
    431              {
    432            
    433                /* Mechanical speed as imposed by the Virtual Speed Sensor during the Rev Up phase. */
    434                int16_t hForcedMecSpeedUnit;
    435                qd_t IqdRef;
    436                bool ObserverConverged = false;
    437          
    438                /* Execute the Rev Up procedure */
    439                if( ! RUC_Exec( &RevUpControlM1 ) )
   \                     ??TSK_MediumFrequencyTaskM1_10: (+1)
   \       0xC6   0x4638             MOV      R0,R7
   \       0xC8   0x....'....        BL       RUC_Exec
   \       0xCC   0xB928             CBNZ.N   R0,??TSK_MediumFrequencyTaskM1_11
    440                {
    441                  /* The time allowed for the startup sequence has expired */
    442                  STM_FaultProcessing( &STM[M1], MC_START_UP, 0 );  
   \       0xCE   0x2200             MOVS     R2,#+0
   \       0xD0   0x2110             MOVS     R1,#+16
   \       0xD2   0x1D28             ADDS     R0,R5,#+4
   \       0xD4   0x....'....        BL       STM_FaultProcessing
   \       0xD8   0xE006             B.N      ??TSK_MediumFrequencyTaskM1_12
    443                }
    444                else
    445                {
    446                  /* Execute the torque open loop current start-up ramp:
    447                   * Compute the Iq reference current as configured in the Rev Up sequence */
    448                  IqdRef.q = STC_CalcTorqueReference( pSTC[M1] );
   \                     ??TSK_MediumFrequencyTaskM1_11: (+1)
   \       0xDA   0x69A8             LDR      R0,[R5, #+24]
   \       0xDC   0x....'....        BL       STC_CalcTorqueReference
    449                  IqdRef.d = FOCVars[M1].UserIdref;
   \       0xE0   0xF9B6 0x1014      LDRSH    R1,[R6, #+20]
    450                  /* Iqd reference current used by the High Frequency Loop to generate the PWM output */
    451                  FOCVars[M1].Iqdref = IqdRef;
   \       0xE4   0x8230             STRH     R0,[R6, #+16]
   \       0xE6   0x8271             STRH     R1,[R6, #+18]
    452                }
    453          
    454                (void) VSS_CalcAvrgMecSpeedUnit( &VirtualSpeedSensorM1, &hForcedMecSpeedUnit );
   \                     ??TSK_MediumFrequencyTaskM1_12: (+1)
   \       0xE8   0x4669             MOV      R1,SP
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0x....'....        BL       VSS_CalcAvrgMecSpeedUnit
    455          
    456                /* check that startup stage where the observer has to be used has been reached */
    457                if (RUC_FirstAccelerationStageReached(&RevUpControlM1) == true)
   \       0xF0   0x4638             MOV      R0,R7
   \       0xF2   0x....'....        BL       RUC_FirstAccelerationStageReached
   \       0xF6   0x2801             CMP      R0,#+1
   \       0xF8   0xD1E4             BNE.N    ??TSK_MediumFrequencyTaskM1_2
    458                {
    459                  ObserverConverged = STO_PLL_IsObserverConverged( &STO_PLL_M1,hForcedMecSpeedUnit );
   \       0xFA   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \       0xFE   0x4620             MOV      R0,R4
   \      0x100   0x....'....        BL       STO_PLL_IsObserverConverged
   \      0x104   0x4607             MOV      R7,R0
    460                  (void) VSS_SetStartTransition( &VirtualSpeedSensorM1, ObserverConverged );
   \      0x106   0x4639             MOV      R1,R7
   \      0x108   0x4640             MOV      R0,R8
   \      0x10A   0x....'....        BL       VSS_SetStartTransition
    461                }
    462          
    463                if ( ObserverConverged )
   \      0x10E   0x2F00             CMP      R7,#+0
   \      0x110   0xD0D8             BEQ.N    ??TSK_MediumFrequencyTaskM1_2
    464                {
    465                  qd_t StatorCurrent = MCM_Park( FOCVars[M1].Ialphabeta, SPD_GetElAngle( &STO_PLL_M1._Super ) );
   \      0x112   0x4620             MOV      R0,R4
   \      0x114   0x....'....        BL       SPD_GetElAngle
   \      0x118   0x4601             MOV      R1,R0
   \      0x11A   0x6870             LDR      R0,[R6, #+4]
   \      0x11C   0x....'....        BL       MCM_Park
   \      0x120   0x9001             STR      R0,[SP, #+4]
    466          
    467                  /* Start switch over ramp. This ramp will transition from the revup to the closed loop FOC. */
    468                  REMNG_Init( pREMNG[M1] );
   \      0x122   0x6BE8             LDR      R0,[R5, #+60]
   \      0x124   0x....'....        BL       REMNG_Init
    469                  REMNG_ExecRamp( pREMNG[M1], FOCVars[M1].Iqdref.q, 0 );
   \      0x128   0xF9B6 0x1010      LDRSH    R1,[R6, #+16]
   \      0x12C   0x6BE8             LDR      R0,[R5, #+60]
   \      0x12E   0x2200             MOVS     R2,#+0
   \      0x130   0x....'....        BL       REMNG_ExecRamp
    470                  REMNG_ExecRamp( pREMNG[M1], StatorCurrent.q, TRANSITION_DURATION );
   \      0x134   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \      0x138   0x6BE8             LDR      R0,[R5, #+60]
   \      0x13A   0xF44F 0x72FA      MOV      R2,#+500
   \      0x13E   0x....'....        BL       REMNG_ExecRamp
    471                  
    472                  STM_NextState( &STM[M1], SWITCH_OVER );
   \      0x142   0x2113             MOVS     R1,#+19
   \      0x144   0xE064             B.N      ??TSK_MediumFrequencyTaskM1_4
    473                }
    474              }
    475              break;
    476              
    477           
    478            case SWITCH_OVER:
    479              {
    480                bool LoopClosed;
    481                int16_t hForcedMecSpeedUnit;
    482                
    483                 
    484                if( ! RUC_Exec( &RevUpControlM1 ) )
   \                     ??TSK_MediumFrequencyTaskM1_13: (+1)
   \      0x146   0x4638             MOV      R0,R7
   \      0x148   0x....'....        BL       RUC_Exec
   \      0x14C   0xB910             CBNZ.N   R0,??TSK_MediumFrequencyTaskM1_14
    485                {
    486                    /* The time allowed for the startup sequence has expired */
    487                    STM_FaultProcessing( &STM[M1], MC_START_UP, 0 );  
   \      0x14E   0x2200             MOVS     R2,#+0
   \      0x150   0x2110             MOVS     R1,#+16
   \      0x152   0xE034             B.N      ??TSK_MediumFrequencyTaskM1_15
    488                } 
    489                else
    490                { 
    491                  /* Compute the virtual speed and positions of the rotor. 
    492                     The function returns true if the virtual speed is in the reliability range */
    493                  LoopClosed = VSS_CalcAvrgMecSpeedUnit(&VirtualSpeedSensorM1,&hForcedMecSpeedUnit);
   \                     ??TSK_MediumFrequencyTaskM1_14: (+1)
   \      0x154   0x4669             MOV      R1,SP
   \      0x156   0x4640             MOV      R0,R8
   \      0x158   0x....'....        BL       VSS_CalcAvrgMecSpeedUnit
   \      0x15C   0x4604             MOV      R4,R0
    494                  /* Check if the transition ramp has completed. */ 
    495                  LoopClosed |= VSS_TransitionEnded( &VirtualSpeedSensorM1 );
   \      0x15E   0x4640             MOV      R0,R8
   \      0x160   0x....'....        BL       VSS_TransitionEnded
   \      0x164   0x4304             ORRS     R4,R0,R4
   \      0x166   0xD056             BEQ.N    ??TSK_MediumFrequencyTaskM1_9
    496                  
    497                  /* If any of the above conditions is true, the loop is considered closed. 
    498                     The state machine transitions to the START_RUN state. */
    499                  if ( LoopClosed == true ) 
    500                  {
    501                    #if ( PID_SPEED_INTEGRAL_INIT_DIV == 0 )  
    502                    PID_SetIntegralTerm( pPIDSpeed[M1], 0 );
    503                    #else
    504                    PID_SetIntegralTerm( pPIDSpeed[M1],
    505                                         (int32_t) ( FOCVars[M1].Iqdref.q * PID_GetKIDivisor(pPIDSpeed[M1]) /
    506                                         PID_SPEED_INTEGRAL_INIT_DIV ) );
   \      0x168   0x69E8             LDR      R0,[R5, #+28]
   \      0x16A   0x....'....        BL       PID_GetKIDivisor
   \      0x16E   0xF9B6 0x1010      LDRSH    R1,[R6, #+16]
   \      0x172   0x4341             MULS     R1,R1,R0
   \      0x174   0x69E8             LDR      R0,[R5, #+28]
   \      0x176   0x....'....        BL       PID_SetIntegralTerm
    507                    #endif
    508                    
    509                    STM_NextState( &STM[M1], START_RUN );
   \      0x17A   0x2105             MOVS     R1,#+5
   \      0x17C   0xE048             B.N      ??TSK_MediumFrequencyTaskM1_4
    510                  }  
    511                }
    512              }
    513          
    514              break;
    515          
    516            case START_RUN:
    517           /* only for sensor-less control */
    518              STC_SetSpeedSensor(pSTC[M1], &STO_PLL_M1._Super); /*Observer has converged*/
   \                     ??TSK_MediumFrequencyTaskM1_16: (+1)
   \      0x17E   0x69A8             LDR      R0,[R5, #+24]
   \      0x180   0x4621             MOV      R1,R4
   \      0x182   0x....'....        BL       STC_SetSpeedSensor
    519              {
    520                /* USER CODE BEGIN MediumFrequencyTask M1 1 */
    521          #if (CONTROLLED_BRAKING==1)
    522                //Regenerative control during motor run state
    523                RegenControlM1(pBrakeId[M1], pPIDBk[M1],pPIDSpeed[M1], pSTC[M1], pBusSensorM1);
    524          #endif
    525                /* USER CODE END MediumFrequencyTask M1 1 */      
    526          	  FOC_InitAdditionalMethods(M1);
   \      0x186   0x2000             MOVS     R0,#+0
   \      0x188   0x....'....        BL       FOC_InitAdditionalMethods
    527                FOC_CalcCurrRef( M1 );
   \      0x18C   0x2000             MOVS     R0,#+0
   \      0x18E   0x....'....        BL       FOC_CalcCurrRef
    528                STM_NextState( &STM[M1], RUN );
   \      0x192   0x2106             MOVS     R1,#+6
   \      0x194   0x1D28             ADDS     R0,R5,#+4
   \      0x196   0x....'....        BL       STM_NextState
    529              }
    530              STC_ForceSpeedReferenceToCurrentSpeed( pSTC[M1] ); /* Init the reference speed to current speed */
   \      0x19A   0x69A8             LDR      R0,[R5, #+24]
   \      0x19C   0x....'....        BL       STC_ForceSpeedReferenceToCurrentSpeed
    531              MCI_ExecBufferedCommands( oMCInterface[M1] ); /* Exec the speed ramp after changing of the speed sensor */
   \      0x1A0   0x6968             LDR      R0,[R5, #+20]
   \      0x1A2   0x....'....        BL       MCI_ExecBufferedCommands
    532          	
    533              break;
   \      0x1A6   0xE036             B.N      ??TSK_MediumFrequencyTaskM1_9
    534          
    535            case RUN:
    536              /* USER CODE BEGIN MediumFrequencyTask M1 2 */
    537          #if (CONTROLLED_BRAKING==1)
    538              //Regenerative control during motor run state
    539              RegenControlM1(pBrakeId[M1], pPIDBk[M1],pPIDSpeed[M1], pSTC[M1], pBusSensorM1);
    540          #endif
    541              /* USER CODE END MediumFrequencyTask M1 2 */
    542          
    543              MCI_ExecBufferedCommands( oMCInterface[M1] );
   \                     ??TSK_MediumFrequencyTaskM1_17: (+1)
   \      0x1A8   0x6968             LDR      R0,[R5, #+20]
   \      0x1AA   0x....'....        BL       MCI_ExecBufferedCommands
    544              FOC_CalcCurrRef( M1 );
   \      0x1AE   0x2000             MOVS     R0,#+0
   \      0x1B0   0x....'....        BL       FOC_CalcCurrRef
    545           
    546              if( !IsSpeedReliable )
   \      0x1B4   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x1B8   0xD12D             BNE.N    ??TSK_MediumFrequencyTaskM1_9
    547              {
    548                STM_FaultProcessing( &STM[M1], MC_SPEED_FDBK, 0 );
   \      0x1BA   0x2200             MOVS     R2,#+0
   \      0x1BC   0x2120             MOVS     R1,#+32
   \                     ??TSK_MediumFrequencyTaskM1_15: (+1)
   \      0x1BE   0x1D28             ADDS     R0,R5,#+4
   \      0x1C0   0x....'....        BL       STM_FaultProcessing
   \      0x1C4   0xE027             B.N      ??TSK_MediumFrequencyTaskM1_9
    549              }
    550          
    551              /* USER CODE BEGIN MediumFrequencyTask M1 3 */
    552          
    553              /* USER CODE END MediumFrequencyTask M1 3 */
    554              break;
    555          
    556            case ANY_STOP:
    557          #if (CONTROLLED_BRAKING == 0)
    558              R3_1_SwitchOffPWM( pwmcHandle[M1] );
   \                     ??TSK_MediumFrequencyTaskM1_18: (+1)
   \      0x1C6   0x6B28             LDR      R0,[R5, #+48]
   \      0x1C8   0x....'....        BL       R3_1_SwitchOffPWM
    559              FOC_Clear( M1 );
   \      0x1CC   0x2000             MOVS     R0,#+0
   \      0x1CE   0x....'....        BL       FOC_Clear
    560              MPM_Clear( (MotorPowMeas_Handle_t*) pMPM[M1] );
   \      0x1D2   0x6B68             LDR      R0,[R5, #+52]
   \      0x1D4   0x....'....        BL       MPM_Clear
    561              TSK_SetStopPermanencyTimeM1( STOPPERMANENCY_TICKS );
   \      0x1D8   0xF44F 0x7048      MOV      R0,#+800
   \      0x1DC   0x....'....        BL       TSK_SetStopPermanencyTimeM1
    562              /* USER CODE BEGIN MediumFrequencyTask M1 4 */
    563          #elif (CONTROLLED_BRAKING == 1)
    564              pBrakeId[M1]->IMax_Ref = BRAKING_CURRENTSEEDING; //RPa: seeding of current reference
    565              pBrakeId[M1]->BrakingPhase = STARTRAMP;
    566              pBrakeId[M1]->rMeasuredSpeed = SPD_GetAvrgMecSpeedUnit( pSTC[M1]->SPD );
    567              pBrakeId[M1]->Adapt_IMax = (int32_t)((RAMP_a * (int32_t) pBrakeId[M1]->rMeasuredSpeed * (int32_t) pBrakeId[M1]->rMeasuredSpeed)>>BYTE_SHIFT) + \
    568                (int32_t)(RAMP_b * (int32_t)pBrakeId[M1]->rMeasuredSpeed) + RAMP_c;
    569          #endif
    570              /* USER CODE END MediumFrequencyTask M1 4 */
    571          
    572              STM_NextState( &STM[M1], STOP );
   \      0x1E0   0x2108             MOVS     R1,#+8
   \      0x1E2   0xE015             B.N      ??TSK_MediumFrequencyTaskM1_4
    573              break;
    574          
    575            case STOP:
    576          #if (CONTROLLED_BRAKING == 1)
    577              //RPa: Non-regenerative braking
    578              MotorBraking_StateMachine(pBrakeId[M1], pPIDBk[M1], pPIDIm[M1], pSTC[M1], &FOCVars[M1], pBusSensorM1 );
    579              if (pBrakeId[M1]->BrakingPhase == STARTRAMP)//RPa: this state can only be called from LOWSPEED_IQHOLD
    580              {
    581                FOC_Clear( M1 );
    582                MPM_Clear( (MotorPowMeas_Handle_t*) pMPM[M1] ); 
    583                STM_NextState( &STM[M1], STOP_IDLE );      
    584              }
    585          #else
    586              if ( TSK_StopPermanencyTimeHasElapsedM1())
   \                     ??TSK_MediumFrequencyTaskM1_19: (+1)
   \      0x1E4   0x....'....        BL       TSK_StopPermanencyTimeHasElapsedM1
   \      0x1E8   0xB1A8             CBZ.N    R0,??TSK_MediumFrequencyTaskM1_9
    587              {
    588                FOC_Clear( M1 );
   \      0x1EA   0x2000             MOVS     R0,#+0
   \      0x1EC   0x....'....        BL       FOC_Clear
    589                MPM_Clear( (MotorPowMeas_Handle_t*) pMPM[M1] ); 
   \      0x1F0   0x6B68             LDR      R0,[R5, #+52]
   \      0x1F2   0x....'....        BL       MPM_Clear
    590                STM_NextState( &STM[M1], STOP_IDLE );
   \      0x1F6   0x2109             MOVS     R1,#+9
   \      0x1F8   0xE00A             B.N      ??TSK_MediumFrequencyTaskM1_4
    591              }
    592          #endif
    593              break;
    594          
    595            case STOP_IDLE:
    596              STC_SetSpeedSensor( pSTC[M1],&VirtualSpeedSensorM1._Super );  	/*  sensor-less */
   \                     ??TSK_MediumFrequencyTaskM1_20: (+1)
   \      0x1FA   0x69A8             LDR      R0,[R5, #+24]
   \      0x1FC   0x4641             MOV      R1,R8
   \      0x1FE   0x....'....        BL       STC_SetSpeedSensor
    597              VSS_Clear( &VirtualSpeedSensorM1 ); /* Reset measured speed in IDLE */
   \      0x202   0x4640             MOV      R0,R8
   \      0x204   0x....'....        BL       VSS_Clear
    598          
    599              /* USER CODE BEGIN MediumFrequencyTask M1 5 */
    600              R3_1_SwitchOffPWM( pwmcHandle[M1] );
   \      0x208   0x6B28             LDR      R0,[R5, #+48]
   \      0x20A   0x....'....        BL       R3_1_SwitchOffPWM
    601              /* USER CODE END MediumFrequencyTask M1 5 */
    602              STM_NextState( &STM[M1], ICLWAIT );
   \      0x20E   0x210C             MOVS     R1,#+12
   \                     ??TSK_MediumFrequencyTaskM1_4: (+1)
   \      0x210   0x1D28             ADDS     R0,R5,#+4
   \      0x212   0x....'....        BL       STM_NextState
    603              break;
    604          
    605            default:
    606              break;
    607            }
    608          
    609            /* USER CODE BEGIN MediumFrequencyTask M1 6 */
    610          
    611            /* USER CODE END MediumFrequencyTask M1 6 */
    612          }
   \                     ??TSK_MediumFrequencyTaskM1_9: (+1)
   \      0x216   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   \      0x21A   0xBF00             Nop
   \                     ??TSK_MediumFrequencyTaskM1_1:
   \      0x21C   0x....'....        DC32     ICL_M1
   \      0x220   0x....'....        DC32     STO_PLL_M1
   \      0x224   0x....'....        DC32     bMCBootCompleted
   \      0x228   0x....'....        DC32     FOCVars
   \      0x22C   0x....'....        DC32     RevUpControlM1
   \      0x230   0x....'....        DC32     VirtualSpeedSensorM1
    613          
    614          /**
    615            * @brief  It re-initializes the current and voltage variables. Moreover
    616            *         it clears qd currents PI controllers, voltage sensor and SpeednTorque
    617            *         controller. It must be called before each motor restart.
    618            *         It does not clear speed sensor.
    619            * @param  bMotor related motor it can be M1 or M2
    620            * @retval none
    621            */

   \                                 In section .text, align 4
    622          __weak void FOC_Clear(uint8_t bMotor)
    623          {
   \                     FOC_Clear: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x2204             MOVS     R2,#+4
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xA802             ADD      R0,SP,#+8
   \        0xA   0x....'....        BL       memset
   \        0xE   0x2204             MOVS     R2,#+4
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x....'....        BL       memset
   \       0x18   0x2204             MOVS     R2,#+4
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0xA801             ADD      R0,SP,#+4
   \       0x1E   0x....'....        BL       memset
    624            /* USER CODE BEGIN FOC_Clear 0 */
    625          
    626            /* USER CODE END FOC_Clear 0 */
    627            ab_t NULL_ab = {(int16_t)0, (int16_t)0};
    628            qd_t NULL_qd = {(int16_t)0, (int16_t)0};
    629            alphabeta_t NULL_alphabeta = {(int16_t)0, (int16_t)0};
    630            
    631            FOCVars[bMotor].Iab = NULL_ab;
   \       0x22   0x2126             MOVS     R1,#+38
   \       0x24   0x4813             LDR.N    R0,??FOC_Clear_0
   \       0x26   0x9A02             LDR      R2,[SP, #+8]
   \       0x28   0xFB11 0xF104      SMULBB   R1,R1,R4
   \       0x2C   0x4408             ADD      R0,R0,R1
   \       0x2E   0x6002             STR      R2,[R0, #+0]
    632            FOCVars[bMotor].Ialphabeta = NULL_alphabeta;
   \       0x30   0x9901             LDR      R1,[SP, #+4]
   \       0x32   0x6041             STR      R1,[R0, #+4]
    633            FOCVars[bMotor].Iqd = NULL_qd;
   \       0x34   0x9A00             LDR      R2,[SP, #+0]
   \       0x36   0x60C2             STR      R2,[R0, #+12]
    634            FOCVars[bMotor].Iqdref = NULL_qd;
    635            FOCVars[bMotor].hTeref = (int16_t)0;
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0x9900             LDR      R1,[SP, #+0]
   \       0x3C   0x6101             STR      R1,[R0, #+16]
   \       0x3E   0x83C2             STRH     R2,[R0, #+30]
    636            FOCVars[bMotor].Vqd = NULL_qd;
   \       0x40   0x9900             LDR      R1,[SP, #+0]
   \       0x42   0xF8C0 0x1016      STR      R1,[R0, #+22]
    637            FOCVars[bMotor].Valphabeta = NULL_alphabeta;
    638            FOCVars[bMotor].hElAngle = (int16_t)0;
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x9A01             LDR      R2,[SP, #+4]
   \       0x4A   0xF8C0 0x201A      STR      R2,[R0, #+26]
   \       0x4E   0x8401             STRH     R1,[R0, #+32]
    639          
    640            PID_SetIntegralTerm(pPIDIq[bMotor], (int32_t)0);
   \       0x50   0x4809             LDR.N    R0,??FOC_Clear_0+0x4
   \       0x52   0xEB00 0x0484      ADD      R4,R0,R4, LSL #+2
   \       0x56   0x6A20             LDR      R0,[R4, #+32]
   \       0x58   0x....'....        BL       PID_SetIntegralTerm
    641            PID_SetIntegralTerm(pPIDId[bMotor], (int32_t)0);
   \       0x5C   0x6A60             LDR      R0,[R4, #+36]
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x....'....        BL       PID_SetIntegralTerm
    642          
    643            STC_Clear(pSTC[bMotor]);
   \       0x64   0x69A0             LDR      R0,[R4, #+24]
   \       0x66   0x....'....        BL       STC_Clear
    644          
    645            PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
   \       0x6A   0x6B20             LDR      R0,[R4, #+48]
   \       0x6C   0x....'....        BL       PWMC_SwitchOffPWM
    646          
    647            /* USER CODE BEGIN FOC_Clear 1 */
    648          
    649            /* USER CODE END FOC_Clear 1 */
    650          }
   \       0x70   0xBD1F             POP      {R0-R4,PC}       ;; return
   \       0x72   0xBF00             Nop
   \                     ??FOC_Clear_0:
   \       0x74   0x....'....        DC32     FOCVars
   \       0x78   0x....'....        DC32     bMCBootCompleted
    651          
    652          /**
    653            * @brief  Use this method to initialize additional methods (if any) in
    654            *         START_TO_RUN state
    655            * @param  bMotor related motor it can be M1 or M2
    656            * @retval none
    657            */

   \                                 In section .text, align 2
    658          __weak void FOC_InitAdditionalMethods(uint8_t bMotor)
    659          {
    660            /* USER CODE BEGIN FOC_InitAdditionalMethods 0 */
    661          
    662            /* USER CODE END FOC_InitAdditionalMethods 0 */
    663          }
   \                     FOC_InitAdditionalMethods: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    664          
    665          /**
    666            * @brief  It computes the new values of Iqdref (current references on qd
    667            *         reference frame) based on the required electrical torque information
    668            *         provided by oTSC object (internally clocked).
    669            *         If implemented in the derived class it executes flux weakening and/or
    670            *         MTPA algorithm(s). It must be called with the periodicity specified
    671            *         in oTSC parameters
    672            * @param  bMotor related motor it can be M1 or M2
    673            * @retval none
    674            */

   \                                 In section .text, align 4
    675          __weak void FOC_CalcCurrRef(uint8_t bMotor)
    676          {
   \                     FOC_CalcCurrRef: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    677              
    678            /* USER CODE BEGIN FOC_CalcCurrRef 0 */
    679          
    680            /* USER CODE END FOC_CalcCurrRef 0 */
    681            if(FOCVars[bMotor].bDriveInput == INTERNAL)
   \        0x2   0x2326             MOVS     R3,#+38
   \        0x4   0x4A07             LDR.N    R2,??FOC_CalcCurrRef_0
   \        0x6   0xFB13 0xF300      SMULBB   R3,R3,R0
   \        0xA   0x18D4             ADDS     R4,R2,R3
   \        0xC   0xF894 0x1024      LDRB     R1,[R4, #+36]
   \       0x10   0xB939             CBNZ.N   R1,??FOC_CalcCurrRef_1
    682            {
    683              FOCVars[bMotor].hTeref = STC_CalcTorqueReference(pSTC[bMotor]);
   \       0x12   0x4A05             LDR.N    R2,??FOC_CalcCurrRef_0+0x4
   \       0x14   0xEB02 0x0180      ADD      R1,R2,R0, LSL #+2
   \       0x18   0x6988             LDR      R0,[R1, #+24]
   \       0x1A   0x....'....        BL       STC_CalcTorqueReference
   \       0x1E   0x83E0             STRH     R0,[R4, #+30]
    684              FOCVars[bMotor].Iqdref.q = FOCVars[bMotor].hTeref;
   \       0x20   0x8220             STRH     R0,[R4, #+16]
    685          
    686            }
    687            /* USER CODE BEGIN FOC_CalcCurrRef 1 */
    688          
    689            /* USER CODE END FOC_CalcCurrRef 1 */
    690          }
   \                     ??FOC_CalcCurrRef_1: (+1)
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   \                     ??FOC_CalcCurrRef_0:
   \       0x24   0x....'....        DC32     FOCVars
   \       0x28   0x....'....        DC32     bMCBootCompleted
    691          
    692          /**
    693            * @brief  It set a counter intended to be used for counting the delay required
    694            *         for drivers boot capacitors charging of motor 1
    695            * @param  hTickCount number of ticks to be counted
    696            * @retval void
    697            */

   \                                 In section .text, align 4
    698          __weak void TSK_SetChargeBootCapDelayM1(uint16_t hTickCount)
    699          {
    700             hBootCapDelayCounterM1 = hTickCount;
   \                     TSK_SetChargeBootCapDelayM1: (+1)
   \        0x0   0x4901             LDR.N    R1,??TSK_SetChargeBootCapDelayM1_0
   \        0x2   0x81C8             STRH     R0,[R1, #+14]
    701          }
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??TSK_SetChargeBootCapDelayM1_0:
   \        0x8   0x....'....        DC32     bMCBootCompleted
    702          
    703          /**
    704            * @brief  Use this function to know whether the time required to charge boot
    705            *         capacitors of motor 1 has elapsed
    706            * @param  none
    707            * @retval bool true if time has elapsed, false otherwise
    708            */

   \                                 In section .text, align 4
    709          __weak bool TSK_ChargeBootCapDelayHasElapsedM1(void)
    710          {
    711            bool retVal = false;
    712            if (hBootCapDelayCounterM1 == 0)
   \                     TSK_ChargeBootCapDelayHasElapsedM1: (+1)
   \        0x0   0x4A02             LDR.N    R2,??TSK_ChargeBootCapDelayHasElapsedM1_0
   \        0x2   0x89D1             LDRH     R1,[R2, #+14]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xB901             CBNZ.N   R1,??TSK_ChargeBootCapDelayHasElapsedM1_1
    713            {
    714              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    715            }
    716            return (retVal);
   \                     ??TSK_ChargeBootCapDelayHasElapsedM1_1: (+1)
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??TSK_ChargeBootCapDelayHasElapsedM1_0:
   \        0xC   0x....'....        DC32     bMCBootCompleted
    717          }
    718          
    719          /**
    720            * @brief  It set a counter intended to be used for counting the permanency
    721            *         time in STOP state of motor 1
    722            * @param  hTickCount number of ticks to be counted
    723            * @retval void
    724            */

   \                                 In section .text, align 4
    725          __weak void TSK_SetStopPermanencyTimeM1(uint16_t hTickCount)
    726          {
    727            hStopPermanencyCounterM1 = hTickCount;
   \                     TSK_SetStopPermanencyTimeM1: (+1)
   \        0x0   0x4901             LDR.N    R1,??TSK_SetStopPermanencyTimeM1_0
   \        0x2   0x8208             STRH     R0,[R1, #+16]
    728          }
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??TSK_SetStopPermanencyTimeM1_0:
   \        0x8   0x....'....        DC32     bMCBootCompleted
    729          
    730          /**
    731            * @brief  Use this function to know whether the permanency time in STOP state
    732            *         of motor 1 has elapsed
    733            * @param  none
    734            * @retval bool true if time is elapsed, false otherwise
    735            */

   \                                 In section .text, align 4
    736          __weak bool TSK_StopPermanencyTimeHasElapsedM1(void)
    737          {
    738            bool retVal = false;
    739            if (hStopPermanencyCounterM1 == 0)
   \                     TSK_StopPermanencyTimeHasElapsedM1: (+1)
   \        0x0   0x4A02             LDR.N    R2,??TSK_StopPermanencyTimeHasElapsedM1_0
   \        0x2   0x8A11             LDRH     R1,[R2, #+16]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xB901             CBNZ.N   R1,??TSK_StopPermanencyTimeHasElapsedM1_1
    740            {
    741              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    742            }
    743            return (retVal);
   \                     ??TSK_StopPermanencyTimeHasElapsedM1_1: (+1)
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??TSK_StopPermanencyTimeHasElapsedM1_0:
   \        0xC   0x....'....        DC32     bMCBootCompleted
    744          }
    745          
    746          #if defined (CCMRAM_ENABLED)
    747          #if defined (__ICCARM__)
    748          #pragma location = ".ccmram"
    749          #elif defined (__CC_ARM)
    750          __attribute__((section (".ccmram")))
    751          #endif
    752          #endif
    753          /**
    754            * @brief  Executes the Motor Control duties that require a high frequency rate and a precise timing
    755            *
    756            *  This is mainly the FOC current control loop. It is executed depending on the state of the Motor Control 
    757            * subsystem (see the state machine(s)).
    758            *
    759            * @retval Number of the  motor instance which FOC loop was executed.
    760            */

   \                                 In section .text, align 4
    761          __weak uint8_t TSK_HighFrequencyTask(void)
    762          {
   \                     TSK_HighFrequencyTask: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    763            /* USER CODE BEGIN HighFrequencyTask 0 */
    764          
    765            /* USER CODE END HighFrequencyTask 0 */
    766            
    767            uint8_t bMotorNbr = 0;
    768            uint16_t hFOCreturn;
    769           
    770          
    771            uint16_t hState;  /*  only if sensorless main*/
    772            Observer_Inputs_t STO_Inputs; /*  only if sensorless main*/
    773          
    774            //HALL_CalcElAngle (&HALL_M1); 
    775          
    776            STO_Inputs.Valfa_beta = FOCVars[M1].Valphabeta;  /* only if sensorless*/
   \        0x4   0x4D44             LDR.N    R5,??TSK_HighFrequencyTask_0
    777            if ( STM[M1].bState == SWITCH_OVER )
   \        0x6   0x4C45             LDR.N    R4,??TSK_HighFrequencyTask_0+0x4
   \        0x8   0xF8D5 0x001A      LDR      R0,[R5, #+26]
   \        0xC   0xB086             SUB      SP,SP,#+24
   \        0xE   0x9003             STR      R0,[SP, #+12]
   \       0x10   0x7920             LDRB     R0,[R4, #+4]
   \       0x12   0x2813             CMP      R0,#+19
   \       0x14   0xD107             BNE.N    ??TSK_HighFrequencyTask_1
    778            {
    779              if (!REMNG_RampCompleted(pREMNG[M1]))
   \       0x16   0x6BE0             LDR      R0,[R4, #+60]
   \       0x18   0x....'....        BL       REMNG_RampCompleted
   \       0x1C   0xB918             CBNZ.N   R0,??TSK_HighFrequencyTask_1
    780              {
    781                FOCVars[M1].Iqdref.q = REMNG_Calc(pREMNG[M1]);
   \       0x1E   0x6BE0             LDR      R0,[R4, #+60]
   \       0x20   0x....'....        BL       REMNG_Calc
   \       0x24   0x8228             STRH     R0,[R5, #+16]
    782              }
    783            }
    784            /* USER CODE BEGIN HighFrequencyTask SINGLEDRIVE_1 */
    785          
    786            /* USER CODE END HighFrequencyTask SINGLEDRIVE_1 */
    787            hFOCreturn = FOC_CurrControllerM1();
   \                     ??TSK_HighFrequencyTask_1: (+1)
   \       0x26   0x69A0             LDR      R0,[R4, #+24]
   \       0x28   0x....'....        BL       STC_GetSpeedSensor
   \       0x2C   0x4680             MOV      R8,R0
   \       0x2E   0x....'....        BL       SPD_GetElAngle
   \       0x32   0x4606             MOV      R6,R0
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x....'....        BL       SPD_GetInstElSpeedDpp
   \       0x3A   0x6B20             LDR      R0,[R4, #+48]
   \       0x3C   0xA901             ADD      R1,SP,#+4
   \       0x3E   0x....'....        BL       PWMC_GetPhaseCurrents
   \       0x42   0x9801             LDR      R0,[SP, #+4]
   \       0x44   0x....'....        BL       MCM_Clarke
   \       0x48   0x4607             MOV      R7,R0
   \       0x4A   0x4631             MOV      R1,R6
   \       0x4C   0x....'....        BL       MCM_Park
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xF9B5 0x1010      LDRSH    R1,[R5, #+16]
   \       0x56   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \       0x5A   0x1A09             SUBS     R1,R1,R0
   \       0x5C   0x6A20             LDR      R0,[R4, #+32]
   \       0x5E   0x....'....        BL       PI_Controller
   \       0x62   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \       0x66   0xF9B5 0x1012      LDRSH    R1,[R5, #+18]
   \       0x6A   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \       0x6E   0x1A09             SUBS     R1,R1,R0
   \       0x70   0x6A60             LDR      R0,[R4, #+36]
   \       0x72   0x....'....        BL       PI_Controller
   \       0x76   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \       0x7A   0x9902             LDR      R1,[SP, #+8]
   \       0x7C   0x6BA0             LDR      R0,[R4, #+56]
   \       0x7E   0x....'....        BL       Circle_Limitation
   \       0x82   0x4681             MOV      R9,R0
   \       0x84   0x4640             MOV      R0,R8
   \       0x86   0x....'....        BL       SPD_GetInstElSpeedDpp
   \       0x8A   0x4631             MOV      R1,R6
   \       0x8C   0x4648             MOV      R0,R9
   \       0x8E   0x....'....        BL       MCM_Rev_Park
   \       0x92   0x4680             MOV      R8,R0
   \       0x94   0x6B20             LDR      R0,[R4, #+48]
   \       0x96   0x4641             MOV      R1,R8
   \       0x98   0x....'....        BL       PWMC_SetPhaseVoltage
   \       0x9C   0x9901             LDR      R1,[SP, #+4]
   \       0x9E   0x9A00             LDR      R2,[SP, #+0]
   \       0xA0   0xF8C5 0x9016      STR      R9,[R5, #+22]
    788            /* USER CODE BEGIN HighFrequencyTask SINGLEDRIVE_2 */
    789          
    790            /* USER CODE END HighFrequencyTask SINGLEDRIVE_2 */
    791            if(hFOCreturn == MC_FOC_DURATION)
   \       0xA4   0x2801             CMP      R0,#+1
   \       0xA6   0x6029             STR      R1,[R5, #+0]
   \       0xA8   0x606F             STR      R7,[R5, #+4]
   \       0xAA   0x60EA             STR      R2,[R5, #+12]
   \       0xAC   0xF8C5 0x801A      STR      R8,[R5, #+26]
   \       0xB0   0x842E             STRH     R6,[R5, #+32]
   \       0xB2   0xD105             BNE.N    ??TSK_HighFrequencyTask_2
    792            {
    793              STM_FaultProcessing(&STM[M1], MC_FOC_DURATION, 0);
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x2101             MOVS     R1,#+1
   \       0xB8   0x1D20             ADDS     R0,R4,#+4
   \       0xBA   0x....'....        BL       STM_FaultProcessing
   \       0xBE   0xE027             B.N      ??TSK_HighFrequencyTask_3
    794            }
    795            else
    796            {
    797              bool IsAccelerationStageReached = RUC_FirstAccelerationStageReached(&RevUpControlM1); 
   \                     ??TSK_HighFrequencyTask_2: (+1)
   \       0xC0   0x4817             LDR.N    R0,??TSK_HighFrequencyTask_0+0x8
   \       0xC2   0x....'....        BL       RUC_FirstAccelerationStageReached
   \       0xC6   0x4606             MOV      R6,R0
    798              STO_Inputs.Ialfa_beta = FOCVars[M1].Ialphabeta; /*  only if sensorless*/
   \       0xC8   0x6868             LDR      R0,[R5, #+4]
    799              STO_Inputs.Vbus = VBS_GetAvBusVoltage_d(&(pBusSensorM1->_Super)); /*  only for sensorless*/
   \       0xCA   0x4D16             LDR.N    R5,??TSK_HighFrequencyTask_0+0xC
   \       0xCC   0x9004             STR      R0,[SP, #+16]
   \       0xCE   0x6AA0             LDR      R0,[R4, #+40]
   \       0xD0   0x....'....        BL       VBS_GetAvBusVoltage_d
   \       0xD4   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    800              STO_PLL_CalcElAngle (&STO_PLL_M1, &STO_Inputs);
   \       0xD8   0xA903             ADD      R1,SP,#+12
   \       0xDA   0x4628             MOV      R0,R5
   \       0xDC   0x....'....        BL       STO_PLL_CalcElAngle
    801              STO_PLL_CalcAvrgElSpeedDpp (&STO_PLL_M1); /*  Only in case of Sensor-less */
   \       0xE0   0x4628             MOV      R0,R5
   \       0xE2   0x....'....        BL       STO_PLL_CalcAvrgElSpeedDpp
    802          	 if (IsAccelerationStageReached == false)
   \       0xE6   0xB916             CBNZ.N   R6,??TSK_HighFrequencyTask_4
    803              {
    804                STO_ResetPLL(&STO_PLL_M1);
   \       0xE8   0x4628             MOV      R0,R5
   \       0xEA   0x....'....        BL       STO_ResetPLL
    805              }  
    806              hState = STM_GetState(&STM[M1]);
   \                     ??TSK_HighFrequencyTask_4: (+1)
   \       0xEE   0x1D20             ADDS     R0,R4,#+4
   \       0xF0   0x....'....        BL       STM_GetState
    807              if((hState == START) || (hState == SWITCH_OVER) || (hState == START_RUN)) /*  only for sensor-less*/
   \       0xF4   0x2804             CMP      R0,#+4
   \       0xF6   0xBF1C             ITT      NE
   \       0xF8   0x2813             CMPNE    R0,#+19
   \       0xFA   0x2805             CMPNE    R0,#+5
   \       0xFC   0xD108             BNE.N    ??TSK_HighFrequencyTask_3
    808              {
    809                int16_t hObsAngle = SPD_GetElAngle(&STO_PLL_M1._Super);      
   \       0xFE   0x4628             MOV      R0,R5
   \      0x100   0x....'....        BL       SPD_GetElAngle
   \      0x104   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    810                VSS_CalcElAngle(&VirtualSpeedSensorM1,&hObsAngle);  
   \      0x108   0x4669             MOV      R1,SP
   \      0x10A   0x4807             LDR.N    R0,??TSK_HighFrequencyTask_0+0x10
   \      0x10C   0x....'....        BL       VSS_CalcElAngle
    811              }
    812              /* USER CODE BEGIN HighFrequencyTask SINGLEDRIVE_3 */
    813          
    814              /* USER CODE END HighFrequencyTask SINGLEDRIVE_3 */  
    815            }
    816            /* USER CODE BEGIN HighFrequencyTask 1 */
    817          
    818            /* USER CODE END HighFrequencyTask 1 */
    819          
    820            return bMotorNbr;
   \                     ??TSK_HighFrequencyTask_3: (+1)
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0xB007             ADD      SP,SP,#+28
   \      0x114   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   \                     ??TSK_HighFrequencyTask_0:
   \      0x118   0x....'....        DC32     FOCVars
   \      0x11C   0x....'....        DC32     bMCBootCompleted
   \      0x120   0x....'....        DC32     RevUpControlM1
   \      0x124   0x....'....        DC32     STO_PLL_M1
   \      0x128   0x....'....        DC32     VirtualSpeedSensorM1
    821          }
    822          
    823          #if defined (CCMRAM)
    824          #if defined (__ICCARM__)
    825          #pragma location = ".ccmram"
    826          #elif defined (__CC_ARM) || defined(__GNUC__)
    827          __attribute__((section (".ccmram")))
    828          #endif
    829          #endif
    830          /**
    831            * @brief It executes the core of FOC drive that is the controllers for Iqd
    832            *        currents regulation. Reference frame transformations are carried out
    833            *        accordingly to the active speed sensor. It must be called periodically
    834            *        when new motor currents have been converted
    835            * @param this related object of class CFOC.
    836            * @retval int16_t It returns MC_NO_FAULTS if the FOC has been ended before
    837            *         next PWM Update event, MC_FOC_DURATION otherwise
    838            */
    839          inline uint16_t FOC_CurrControllerM1(void)
    840          {
    841            qd_t Iqd, Vqd;
    842            ab_t Iab;
    843            alphabeta_t Ialphabeta, Valphabeta;
    844          
    845            int16_t hElAngle;
    846            uint16_t hCodeError;
    847            SpeednPosFdbk_Handle_t *speedHandle;
    848          
    849            speedHandle = STC_GetSpeedSensor(pSTC[M1]);
    850            hElAngle = SPD_GetElAngle(speedHandle);
    851            hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*PARK_ANGLE_COMPENSATION_FACTOR;
    852            PWMC_GetPhaseCurrents(pwmcHandle[M1], &Iab);
    853            Ialphabeta = MCM_Clarke(Iab);
    854            Iqd = MCM_Park(Ialphabeta, hElAngle);
    855            Vqd.q = PI_Controller(pPIDIq[M1],
    856                      (int32_t)(FOCVars[M1].Iqdref.q) - Iqd.q);
    857          
    858            Vqd.d = PI_Controller(pPIDId[M1],
    859                      (int32_t)(FOCVars[M1].Iqdref.d) - Iqd.d);
    860            
    861            Vqd = Circle_Limitation(pCLM[M1], Vqd);
    862            hElAngle += SPD_GetInstElSpeedDpp(speedHandle)*REV_PARK_ANGLE_COMPENSATION_FACTOR;
    863            Valphabeta = MCM_Rev_Park(Vqd, hElAngle);
    864            hCodeError = PWMC_SetPhaseVoltage(pwmcHandle[M1], Valphabeta);
    865            FOCVars[M1].Vqd = Vqd;
    866            FOCVars[M1].Iab = Iab;
    867            FOCVars[M1].Ialphabeta = Ialphabeta;
    868            FOCVars[M1].Iqd = Iqd;
    869            FOCVars[M1].Valphabeta = Valphabeta;
    870            FOCVars[M1].hElAngle = hElAngle;
    871            return(hCodeError);
    872          }
    873          
    874          /**
    875            * @brief  Executes safety checks (e.g. bus voltage and temperature) for all drive instances. 
    876            *
    877            * Faults flags are updated here.
    878            */

   \                                 In section .text, align 4
    879          __weak void TSK_SafetyTask(void)
    880          {
   \                     TSK_SafetyTask: (+1)
   \        0x0   0x4806             LDR.N    R0,??TSK_SafetyTask_0
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD000             BEQ.N    ??TSK_SafetyTask_1
   \        0x8   0x4770             BX       LR
   \                     ??TSK_SafetyTask_1: (+1)
   \        0xA   0xB580             PUSH     {R7,LR}
    881            /* USER CODE BEGIN TSK_SafetyTask 0 */
    882          
    883            /* USER CODE END TSK_SafetyTask 0 */
    884            if (bMCBootCompleted == 1)
    885            {  
    886              TSK_SafetyTask_PWMOFF(M1);
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x....'....        BL       TSK_SafetyTask_PWMOFF
    887              /* User conversion execution */
    888              RCM_ExecUserConv ();
   \       0x12   0xE8BD 0x4001      POP      {R0,LR}
   \       0x16   0x....'....        B.W      RCM_ExecUserConv
   \       0x1A   0xBF00             Nop
   \                     ??TSK_SafetyTask_0:
   \       0x1C   0x....'....        DC32     bMCBootCompleted
    889            /* USER CODE BEGIN TSK_SafetyTask 1 */
    890          
    891            /* USER CODE END TSK_SafetyTask 1 */
    892            }
    893          }
    894          
    895          /**
    896            * @brief  Safety task implementation if  MC.ON_OVER_VOLTAGE == TURN_OFF_PWM
    897            * @param  bMotor Motor reference number defined
    898            *         \link Motors_reference_number here \endlink
    899            * @retval None
    900            */

   \                                 In section .text, align 4
    901          __weak void TSK_SafetyTask_PWMOFF(uint8_t bMotor)
    902          {
   \                     TSK_SafetyTask_PWMOFF: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
    903            /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 0 */
    904          
    905            /* USER CODE END TSK_SafetyTask_PWMOFF 0 */
    906            
    907            uint16_t CodeReturn = MC_NO_ERROR;
    908            uint16_t errMask[NBR_OF_MOTORS] = {VBUS_TEMP_ERR_MASK};
   \        0x6   0x481E             LDR.N    R0,??TSK_SafetyTask_PWMOFF_0
    909          
    910            CodeReturn |= errMask[bMotor] & NTC_CalcAvTemp(pTemperatureSensor[bMotor]); /* check for fault if FW protection is activated. It returns MC_OVER_TEMP or MC_NO_ERROR */
   \        0x8   0xF8DF 0x9078      LDR.W    R9,??TSK_SafetyTask_PWMOFF_0+0x4
   \        0xC   0x8800             LDRH     R0,[R0, #+0]
   \        0xE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x12   0x4646             MOV      R6,R8
   \       0x14   0xEB09 0x0586      ADD      R5,R9,R6, LSL #+2
   \       0x18   0x6AE8             LDR      R0,[R5, #+44]
   \       0x1A   0x....'....        BL       NTC_CalcAvTemp
    911            CodeReturn |= PWMC_CheckOverCurrent(pwmcHandle[bMotor]);                    /* check for fault. It return MC_BREAK_IN or MC_NO_FAULTS 
   \       0x1E   0xF83D 0x4016      LDRH     R4,[SP, R6, LSL #+1]
   \       0x22   0x4004             ANDS     R4,R0,R4
   \       0x24   0x6B28             LDR      R0,[R5, #+48]
   \       0x26   0x....'....        BL       PWMC_CheckOverCurrent
   \       0x2A   0x4304             ORRS     R4,R0,R4
    912                                                                                           (for STM32F30x can return MC_OVER_VOLT in case of HW Overvoltage) */
    913            if(bMotor == M1)
   \       0x2C   0xEA5F 0x0008      MOVS     R0,R8
   \       0x30   0xD107             BNE.N    ??TSK_SafetyTask_PWMOFF_1
    914            {
    915              CodeReturn |=  errMask[bMotor] & RVBS_CalcAvVbusFilt(pBusSensorM1);
   \       0x32   0xF8BD 0x7000      LDRH     R7,[SP, #+0]
   \       0x36   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \       0x3A   0x....'....        BL       RVBS_CalcAvVbusFilt
   \       0x3E   0x4007             ANDS     R7,R0,R7
   \       0x40   0x433C             ORRS     R4,R7,R4
    916            }
    917          
    918            STM_FaultProcessing(&STM[bMotor], CodeReturn, ~CodeReturn); /* Update the STM according error code */
   \                     ??TSK_SafetyTask_PWMOFF_1: (+1)
   \       0x42   0x2006             MOVS     R0,#+6
   \       0x44   0x4346             MULS     R6,R0,R6
   \       0x46   0x43E0             MVNS     R0,R4
   \       0x48   0x444E             ADD      R6,R9,R6
   \       0x4A   0xB282             UXTH     R2,R0
   \       0x4C   0x4621             MOV      R1,R4
   \       0x4E   0x1D30             ADDS     R0,R6,#+4
   \       0x50   0x....'....        BL       STM_FaultProcessing
    919            switch (STM_GetState(&STM[bMotor])) /* Acts on PWM outputs in case of faults */
   \       0x54   0x1D30             ADDS     R0,R6,#+4
   \       0x56   0x....'....        BL       STM_GetState
   \       0x5A   0x280A             CMP      R0,#+10
   \       0x5C   0xD005             BEQ.N    ??TSK_SafetyTask_PWMOFF_2
   \       0x5E   0x280B             CMP      R0,#+11
   \       0x60   0xBF04             ITT      EQ
    920            {
    921            case FAULT_NOW:
    922              PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
    923              FOC_Clear(bMotor);
    924              MPM_Clear((MotorPowMeas_Handle_t*)pMPM[bMotor]);
    925              /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 1 */
    926          
    927              /* USER CODE END TSK_SafetyTask_PWMOFF 1 */
    928              break;
    929            case FAULT_OVER:
    930              PWMC_SwitchOffPWM(pwmcHandle[bMotor]);
   \       0x62   0x6B28             LDREQ    R0,[R5, #+48]
   \       0x64   0x....'....        BLEQ     PWMC_SwitchOffPWM
   \       0x68   0xE008             B.N      ??TSK_SafetyTask_PWMOFF_3
   \                     ??TSK_SafetyTask_PWMOFF_2: (+1)
   \       0x6A   0x6B28             LDR      R0,[R5, #+48]
   \       0x6C   0x....'....        BL       PWMC_SwitchOffPWM
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x....'....        BL       FOC_Clear
   \       0x76   0x6B68             LDR      R0,[R5, #+52]
   \       0x78   0x....'....        BL       MPM_Clear
    931          	/* USER CODE BEGIN TSK_SafetyTask_PWMOFF 2 */
    932          
    933              /* USER CODE END TSK_SafetyTask_PWMOFF 2 */
    934              break;
    935            default:
    936              break;
    937            }
    938            /* USER CODE BEGIN TSK_SafetyTask_PWMOFF 3 */
    939          
    940            /* USER CODE END TSK_SafetyTask_PWMOFF 3 */
    941          }
   \                     ??TSK_SafetyTask_PWMOFF_3: (+1)
   \       0x7C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??TSK_SafetyTask_PWMOFF_0:
   \       0x80   0x....'....        DC32     ?_0
   \       0x84   0x....'....        DC32     bMCBootCompleted
    942          
    943          /**
    944            * @brief  This function returns the reference of the MCInterface relative to
    945            *         the selected drive.
    946            * @param  bMotor Motor reference number defined
    947            *         \link Motors_reference_number here \endlink
    948            * @retval MCI_Handle_t * Reference to MCInterface relative to the selected drive.
    949            *         Note: it can be MC_NULL if MCInterface of selected drive is not
    950            *         allocated.
    951            */

   \                                 In section .text, align 4
    952          __weak MCI_Handle_t * GetMCI(uint8_t bMotor)
    953          {
   \                     GetMCI: (+1)
   \        0x0   0x4601             MOV      R1,R0
    954            MCI_Handle_t * retVal = MC_NULL;
   \        0x2   0x2000             MOVS     R0,#+0
    955            if (bMotor < NBR_OF_MOTORS)
   \        0x4   0xB909             CBNZ.N   R1,??GetMCI_1
    956            {
    957              retVal = oMCInterface[bMotor];
   \        0x6   0x4801             LDR.N    R0,??GetMCI_0
   \        0x8   0x6940             LDR      R0,[R0, #+20]
    958            }
    959            return retVal;
   \                     ??GetMCI_1: (+1)
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??GetMCI_0:
   \        0xC   0x....'....        DC32     bMCBootCompleted
    960          }
    961          
    962          /**
    963            * @brief  This function returns the reference of the MCTuning relative to
    964            *         the selected drive.
    965            * @param  bMotor Motor reference number defined
    966            *         \link Motors_reference_number here \endlink
    967            * @retval MCT_Handle_t motor control tuning handler for the selected drive.
    968            *         Note: it can be MC_NULL if MCInterface of selected drive is not
    969            *         allocated.
    970            */

   \                                 In section .text, align 4
    971          __weak MCT_Handle_t* GetMCT(uint8_t bMotor)
    972          {
   \                     GetMCT: (+1)
   \        0x0   0x4601             MOV      R1,R0
    973            MCT_Handle_t* retVal = MC_NULL;
   \        0x2   0x2000             MOVS     R0,#+0
    974            if (bMotor < NBR_OF_MOTORS)
   \        0x4   0xB901             CBNZ.N   R1,??GetMCT_1
    975            {
    976              retVal = &MCT[bMotor];
   \        0x6   0x4801             LDR.N    R0,??GetMCT_0
    977            }
    978            return retVal;
   \                     ??GetMCT_1: (+1)
   \        0x8   0x4770             BX       LR               ;; return
   \        0xA   0xBF00             Nop
   \                     ??GetMCT_0:
   \        0xC   0x....'....        DC32     MCT
    979          }
    980          
    981          /**
    982            * @brief  Puts the Motor Control subsystem in in safety conditions on a Hard Fault
    983            *
    984            *  This function is to be executed when a general hardware failure has been detected  
    985            * by the microcontroller and is used to put the system in safety condition.
    986            */

   \                                 In section .text, align 4
    987          __weak void TSK_HardwareFaultTask(void)
    988          {
   \                     TSK_HardwareFaultTask: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    989            /* USER CODE BEGIN TSK_HardwareFaultTask 0 */
    990          
    991            /* USER CODE END TSK_HardwareFaultTask 0 */
    992            
    993            R3_1_SwitchOffPWM(pwmcHandle[M1]);
   \        0x2   0x4C05             LDR.N    R4,??TSK_HardwareFaultTask_0
   \        0x4   0x6B20             LDR      R0,[R4, #+48]
   \        0x6   0x....'....        BL       R3_1_SwitchOffPWM
    994            STM_FaultProcessing(&STM[M1], MC_SW_ERROR, 0);
   \        0xA   0x1D20             ADDS     R0,R4,#+4
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2180             MOVS     R1,#+128
   \       0x14   0x....'....        B.W      STM_FaultProcessing
   \                     ??TSK_HardwareFaultTask_0:
   \       0x18   0x....'....        DC32     bMCBootCompleted
    995            /* USER CODE BEGIN TSK_HardwareFaultTask 1 */
    996          
    997            /* USER CODE END TSK_HardwareFaultTask 1 */
    998          }
    999           /**
   1000            * @brief  Locks GPIO pins used for Motor Control to prevent accidental reconfiguration 
   1001            */

   \                                 In section .text, align 4
   1002          __weak void mc_lock_pins (void)
   1003          {
   \                     mc_lock_pins: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1004          //LL_GPIO_LockPin(M1_HALL_H2_GPIO_Port, M1_HALL_H2_Pin);
   1005          //LL_GPIO_LockPin(M1_HALL_H3_GPIO_Port, M1_HALL_H3_Pin);
   1006          //LL_GPIO_LockPin(M1_HALL_H1_GPIO_Port, M1_HALL_H1_Pin);
   1007          LL_GPIO_LockPin(M1_PWM_UH_GPIO_Port, M1_PWM_UH_Pin);
   \        0x2   0xF44F 0x7180      MOV      R1,#+256
   \        0x6   0xF04F 0x4090      MOV      R0,#+1207959552
   \        0xA   0x....'....        BL       LL_GPIO_LockPin
   1008          LL_GPIO_LockPin(M1_PWM_VH_GPIO_Port, M1_PWM_VH_Pin);
   \        0xE   0xF44F 0x7100      MOV      R1,#+512
   \       0x12   0xF04F 0x4090      MOV      R0,#+1207959552
   \       0x16   0x....'....        BL       LL_GPIO_LockPin
   1009          LL_GPIO_LockPin(M1_OCP_GPIO_Port, M1_OCP_Pin);
   \       0x1A   0xF44F 0x6100      MOV      R1,#+2048
   \       0x1E   0xF04F 0x4090      MOV      R0,#+1207959552
   \       0x22   0x....'....        BL       LL_GPIO_LockPin
   1010          //LL_GPIO_LockPin(M1_OVP_GPIO_Port, M1_OVP_Pin);
   1011          LL_GPIO_LockPin(M1_PWM_VL_GPIO_Port, M1_PWM_VL_Pin);
   \       0x26   0x4C15             LDR.N    R4,??mc_lock_pins_0  ;; 0x48000400
   \       0x28   0xF44F 0x4180      MOV      R1,#+16384
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....'....        BL       LL_GPIO_LockPin
   1012          LL_GPIO_LockPin(M1_PWM_WH_GPIO_Port, M1_PWM_WH_Pin);
   \       0x32   0xF44F 0x6180      MOV      R1,#+1024
   \       0x36   0xF04F 0x4090      MOV      R0,#+1207959552
   \       0x3A   0x....'....        BL       LL_GPIO_LockPin
   1013          LL_GPIO_LockPin(M1_PWM_WL_GPIO_Port, M1_PWM_WL_Pin);
   \       0x3E   0xF44F 0x4100      MOV      R1,#+32768
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x....'....        BL       LL_GPIO_LockPin
   1014          LL_GPIO_LockPin(M1_PWM_UL_GPIO_Port, M1_PWM_UL_Pin);
   \       0x48   0xF44F 0x5100      MOV      R1,#+8192
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       LL_GPIO_LockPin
   1015          //LL_GPIO_LockPin(M1_ICL_SHUT_OUT_GPIO_Port, M1_ICL_SHUT_OUT_Pin);
   1016          LL_GPIO_LockPin(M1_CURR_AMPL_V_GPIO_Port, M1_CURR_AMPL_V_Pin);
   \       0x52   0x2102             MOVS     R1,#+2
   \       0x54   0xF04F 0x4090      MOV      R0,#+1207959552
   \       0x58   0x....'....        BL       LL_GPIO_LockPin
   1017          //LL_GPIO_LockPin(M1_TEMPERATURE_GPIO_Port, M1_TEMPERATURE_Pin);
   1018          LL_GPIO_LockPin(M1_CURR_AMPL_U_GPIO_Port, M1_CURR_AMPL_U_Pin);
   \       0x5C   0x2101             MOVS     R1,#+1
   \       0x5E   0xF04F 0x4090      MOV      R0,#+1207959552
   \       0x62   0x....'....        BL       LL_GPIO_LockPin
   1019          LL_GPIO_LockPin(M1_CURR_AMPL_W_GPIO_Port, M1_CURR_AMPL_W_Pin);
   \       0x66   0x2140             MOVS     R1,#+64
   \       0x68   0xF04F 0x4090      MOV      R0,#+1207959552
   \       0x6C   0x....'....        BL       LL_GPIO_LockPin
   1020          LL_GPIO_LockPin(M1_BUS_VOLTAGE_GPIO_Port, M1_BUS_VOLTAGE_Pin);
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0xE8BD 0x4010      POP      {R4,LR}
   \       0x76   0x2101             MOVS     R1,#+1
   \       0x78   0x....'....        B.W      LL_GPIO_LockPin
   \                     ??mc_lock_pins_0:
   \       0x7C   0x4800'0400        DC32     0x48000400
   1021          }

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \        0x0   0x000E             DC16 14
   1022          
   1023          /* USER CODE BEGIN mc_task 0 */
   1024          
   1025          /* USER CODE END mc_task 0 */
   1026          
   1027          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FOC_CalcCurrRef
         8   -> STC_CalcTorqueReference
      24   FOC_Clear
        24   -> PID_SetIntegralTerm
        24   -> PWMC_SwitchOffPWM
        24   -> STC_Clear
        24   -> memset
       0   FOC_InitAdditionalMethods
       0   GetMCI
       0   GetMCT
       4   LL_GPIO_LockPin
       8   MC_RunMotorControlTasks
         8   -> MC_Scheduler
         8   -> TSK_SafetyTask
         0   -> UI_Scheduler
       8   MC_Scheduler
         8   -> TSK_MediumFrequencyTaskM1
      40   MCboot
        40   -> FOC_Clear
        40   -> ICL_Init
        40   -> MCI_ExecSpeedRamp
        40   -> MCI_Init
        40   -> NTC_Init
        40   -> PID_HandleInit
        40   -> R3_1_Init
        40   -> REMNG_Init
        40   -> RUC_Init
        40   -> RVBS_Init
        40   -> RegalSetting_Init
        40   -> STC_GetDefaultIqdref
        40   -> STC_GetMecSpeedRefUnitDefault
        40   -> STC_Init
        40   -> STM_Init
        40   -> STM_NextState
        40   -> STO_PLL_Init
        40   -> VSS_Init
        40   -> startTimers
       0   TSK_ChargeBootCapDelayHasElapsedM1
       8   TSK_HardwareFaultTask
         8   -> R3_1_SwitchOffPWM
         0   -> STM_FaultProcessing
      56   TSK_HighFrequencyTask
        56   -> Circle_Limitation
        56   -> MCM_Clarke
        56   -> MCM_Park
        56   -> MCM_Rev_Park
        56   -> PI_Controller
        56   -> PWMC_GetPhaseCurrents
        56   -> PWMC_SetPhaseVoltage
        56   -> REMNG_Calc
        56   -> REMNG_RampCompleted
        56   -> RUC_FirstAccelerationStageReached
        56   -> SPD_GetElAngle
        56   -> SPD_GetInstElSpeedDpp
        56   -> STC_GetSpeedSensor
        56   -> STM_FaultProcessing
        56   -> STM_GetState
        56   -> STO_PLL_CalcAvrgElSpeedDpp
        56   -> STO_PLL_CalcElAngle
        56   -> STO_ResetPLL
        56   -> VBS_GetAvBusVoltage_d
        56   -> VSS_CalcElAngle
      40   TSK_MediumFrequencyTaskM1
        40   -> FOC_CalcCurrRef
        40   -> FOC_Clear
        40   -> FOC_InitAdditionalMethods
        40   -> ICL_Exec
        40   -> MCI_ExecBufferedCommands
        40   -> MCI_GetImposedMotorDirection
        40   -> MCM_Park
        40   -> MPM_Clear
        40   -> PID_GetKIDivisor
        40   -> PID_SetIntegralTerm
        40   -> PQD_CalcElMotorPower
        40   -> PWMC_CurrentReadingCalibr
        40   -> R3_1_SwitchOffPWM
        40   -> R3_1_SwitchOnPWM
        40   -> REMNG_ExecRamp
        40   -> REMNG_Init
        40   -> RUC_Clear
        40   -> RUC_Exec
        40   -> RUC_FirstAccelerationStageReached
        40   -> SPD_GetElAngle
        40   -> STC_CalcTorqueReference
        40   -> STC_ForceSpeedReferenceToCurrentSpeed
        40   -> STC_SetSpeedSensor
        40   -> STM_FaultProcessing
        40   -> STM_GetState
        40   -> STM_NextState
        40   -> STO_PLL_CalcAvrgMecSpeedUnit
        40   -> STO_PLL_Clear
        40   -> STO_PLL_IsObserverConverged
        40   -> TSK_ChargeBootCapDelayHasElapsedM1
        40   -> TSK_SetChargeBootCapDelayM1
        40   -> TSK_SetStopPermanencyTimeM1
        40   -> TSK_StopPermanencyTimeHasElapsedM1
        40   -> VSS_CalcAvrgMecSpeedUnit
        40   -> VSS_Clear
        40   -> VSS_SetStartTransition
        40   -> VSS_TransitionEnded
       8   TSK_SafetyTask
         0   -> RCM_ExecUserConv
         8   -> TSK_SafetyTask_PWMOFF
      32   TSK_SafetyTask_PWMOFF
        32   -> FOC_Clear
        32   -> MPM_Clear
        32   -> NTC_CalcAvTemp
        32   -> PWMC_CheckOverCurrent
        32   -> PWMC_SwitchOffPWM
        32   -> RVBS_CalcAvVbusFilt
        32   -> STM_FaultProcessing
        32   -> STM_GetState
       0   TSK_SetChargeBootCapDelayM1
       0   TSK_SetStopPermanencyTimeM1
       0   TSK_StopPermanencyTimeHasElapsedM1
       8   mc_lock_pins
         0   -> LL_GPIO_LockPin
         8   -> LL_GPIO_LockPin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?_0
       2  A_DEFAULT_CONTROL_MODE
       2  A_GAIN1
       2  A_GAIN2
       2  A_IQMAX
       2  A_LS
       2  A_MAX_APPLICATION_SPEED_RPM
       2  A_MIN_APPLICATION_SPEED_RPM
       2  A_NOMINAL_CURRENT
       2  A_OV_TEMPERATURE_HYSTERESIS_C
       2  A_OV_TEMPERATURE_THRESHOLD_C
       2  A_OV_VOLTAGE_THRESHOLD_V
       2  A_PHASE1_DURATION
       2  A_PHASE1_FINAL_CURRENT
       2  A_PHASE1_FINAL_SPEED_UNIT
       2  A_PHASE2_DURATION
       2  A_PHASE2_FINAL_CURRENT
       2  A_PHASE2_FINAL_SPEED_UNIT
       2  A_PHASE3_DURATION
       2  A_PHASE3_FINAL_CURRENT
       2  A_PHASE3_FINAL_SPEED_UNIT
       2  A_PHASE4_DURATION
       2  A_PHASE4_FINAL_CURRENT
       2  A_PHASE4_FINAL_SPEED_UNIT
       2  A_PHASE5_DURATION
       2  A_PHASE5_FINAL_CURRENT
       2  A_PHASE5_FINAL_SPEED_UNIT
       2  A_PID_FLUX_KI_DEFAULT
       2  A_PID_FLUX_KP_DEFAULT
       2  A_PID_SPEED_KI_DEFAULT
       2  A_PID_SPEED_KP_DEFAULT
       2  A_PID_TORQUE_KI_DEFAULT
       2  A_PID_TORQUE_KP_DEFAULT
       2  A_PLL_KI_GAIN
       2  A_PLL_KP_GAIN
       2  A_POLE_PAIR_NUM
       2  A_PWM_FREQUENCY
       2  A_RS
       2  A_TRANSITION_DURATION
       2  A_UD_VOLTAGE_THRESHOLD_V
       2  D_HALL_PHASE_SHIFT
       2  D_HALL_SENSORS_PLACEMENT
       2  D_M1_ENCODER_PPR
      40  FOCVars
      44  FOC_CalcCurrRef
     124  FOC_Clear
       2  FOC_InitAdditionalMethods
      16  GetMCI
      16  GetMCT
      22  LL_GPIO_LockPin
      84  MCT
      32  MC_RunMotorControlTasks
      56  MC_Scheduler
     420  MCboot
      16  TSK_ChargeBootCapDelayHasElapsedM1
      28  TSK_HardwareFaultTask
     300  TSK_HighFrequencyTask
     564  TSK_MediumFrequencyTaskM1
      32  TSK_SafetyTask
     136  TSK_SafetyTask_PWMOFF
      12  TSK_SetChargeBootCapDelayM1
      12  TSK_SetStopPermanencyTimeM1
      16  TSK_StopPermanencyTimeHasElapsedM1
      92  bMCBootCompleted
          STM
          hMFTaskCounterM1
          hBootCapDelayCounterM1
          hStopPermanencyCounterM1
          oMCInterface
          pSTC
          pPIDSpeed
          pPIDIq
          pPIDId
          pBusSensorM1
          pTemperatureSensor
          pwmcHandle
          pMPM
          pCLM
          pREMNG
          Mci
     128  mc_lock_pins
       4  pOCPDisabling
       4  pR_Brake

 
   224 bytes in section .bss
     2 bytes in section .rodata
    84 bytes in section .rodata  (abs)
 1'976 bytes in section .text
 
  22 bytes of CODE  memory (+ 1'954 bytes shared)
   2 bytes of CONST memory (+    84 bytes shared)
 224 bytes of DATA  memory

Errors: none
Warnings: 1
