###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:46
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\speed_torq_ctrl.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW7D39.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\speed_torq_ctrl.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\speed_torq_ctrl.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\speed_torq_ctrl.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\speed_torq_ctrl.c
      1          /*
      2            ******************************************************************************
      3            * @file    speed_torq_ctrl.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the following features
      6            *          of the Speed & Torque Control component of the Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "speed_torq_ctrl.h"
     24          #include "speed_pos_fdbk.h"
     25          
     26          #include "mc_type.h"
     27          
     28          #define CHECK_BOUNDARY
     29          
     30          /** @addtogroup MCSDK
     31            * @{
     32            */
     33          
     34          /** @defgroup SpeednTorqCtrl Speed & Torque Control
     35            * @brief Speed & Torque Control component of the Motor Control SDK
     36            *
     37            * @todo Document the Speed & Torque Control "module".
     38            *
     39            * @{
     40            */
     41          
     42          /**
     43            * @brief  Initializes all the object variables, usually it has to be called
     44            *         once right after object creation.
     45            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
     46            * @param  oPI the PI object used as controller for the speed regulation.
     47            *         It can be equal to MC_NULL if the STC is initialized in torque mode
     48            *         and it will never be configured in speed mode.
     49            * @param  oSPD the speed sensor used to perform the speed regulation.
     50            *         It can be equal to MC_NULL if the STC is used only in torque
     51            *         mode.
     52            * @retval none.
     53            */

   \                                 In section .text, align 2
     54          __weak void STC_Init( SpeednTorqCtrl_Handle_t * pHandle, PID_Handle_t * pPI, SpeednPosFdbk_Handle_t * SPD_Handle )
     55          {
     56          
     57            pHandle->PISpeed = pPI;
   \                     STC_Init: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
     58            pHandle->SPD = SPD_Handle;
   \        0x2   0x6142             STR      R2,[R0, #+20]
     59            pHandle->Mode = pHandle->ModeDefault;
   \        0x4   0xF100 0x012A      ADD      R1,R0,#+42
   \        0x8   0x780A             LDRB     R2,[R1, #+0]
   \        0xA   0x7002             STRB     R2,[R0, #+0]
     60            pHandle->SpeedRefUnitExt = ( int32_t )pHandle->MecSpeedRefUnitDefault * 65536;
     61            pHandle->TorqueRef = ( int32_t )pHandle->TorqueRefDefault * 65536;
     62            pHandle->TargetFinal = 0;
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0xF9B1 0x3002      LDRSH    R3,[R1, #+2]
   \       0x12   0x041B             LSLS     R3,R3,#+16
   \       0x14   0x6043             STR      R3,[R0, #+4]
   \       0x16   0xF9B1 0x1004      LDRSH    R1,[R1, #+4]
   \       0x1A   0x8042             STRH     R2,[R0, #+2]
   \       0x1C   0x0409             LSLS     R1,R1,#+16
   \       0x1E   0x6081             STR      R1,[R0, #+8]
     63            pHandle->RampRemainingStep = 0u;
   \       0x20   0x60C2             STR      R2,[R0, #+12]
     64            pHandle->IncDecAmount = 0;
   \       0x22   0x6182             STR      R2,[R0, #+24]
     65          }
   \       0x24   0x4770             BX       LR               ;; return
     66          
     67          /**
     68            * @brief It sets in real time the speed sensor utilized by the STC.
     69            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
     70            * @param SPD_Handle Speed sensor component to be set.
     71            * @retval none
     72            */

   \                                 In section .text, align 2
     73          __weak void STC_SetSpeedSensor( SpeednTorqCtrl_Handle_t * pHandle, SpeednPosFdbk_Handle_t * SPD_Handle )
     74          {
     75            pHandle->SPD = SPD_Handle;
   \                     STC_SetSpeedSensor: (+1)
   \        0x0   0x6141             STR      R1,[R0, #+20]
     76          }
   \        0x2   0x4770             BX       LR               ;; return
     77          
     78          /**
     79            * @brief It returns the speed sensor utilized by the FOC.
     80            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
     81            * @retval SpeednPosFdbk_Handle_t speed sensor utilized by the FOC.
     82            */

   \                                 In section .text, align 2
     83          __weak SpeednPosFdbk_Handle_t * STC_GetSpeedSensor( SpeednTorqCtrl_Handle_t * pHandle )
     84          {
     85            return ( pHandle->SPD );
   \                     STC_GetSpeedSensor: (+1)
   \        0x0   0x6940             LDR      R0,[R0, #+20]
   \        0x2   0x4770             BX       LR               ;; return
     86          }
     87          
     88          /**
     89            * @brief  It should be called before each motor restart. If STC is set in
     90                      speed mode, this method resets the integral term of speed regulator.
     91            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
     92            * @retval none.
     93            */

   \                                 In section .text, align 2
     94          __weak void STC_Clear( SpeednTorqCtrl_Handle_t * pHandle )
     95          {
     96            if ( pHandle->Mode == STC_SPEED_MODE )
   \                     STC_Clear: (+1)
   \        0x0   0x7801             LDRB     R1,[R0, #+0]
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xD103             BNE.N    ??STC_Clear_0
     97            {
     98              PID_SetIntegralTerm( pHandle->PISpeed, 0 );
   \        0x6   0x6900             LDR      R0,[R0, #+16]
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....'....        B.W      PID_SetIntegralTerm
     99            }
    100          }
   \                     ??STC_Clear_0: (+1)
   \        0xE   0x4770             BX       LR               ;; return
    101          
    102          /**
    103            * @brief  Get the current mechanical rotor speed reference expressed in tenths
    104            *         of HZ.
    105            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    106            * @retval int16_t current mechanical rotor speed reference expressed in tenths
    107            *         of HZ.
    108            */

   \                                 In section .text, align 2
    109          __weak int16_t STC_GetMecSpeedRefUnit( SpeednTorqCtrl_Handle_t * pHandle )
    110          {
    111            return ( ( int16_t )( pHandle->SpeedRefUnitExt / 65536 ) );
   \                     STC_GetMecSpeedRefUnit: (+1)
   \        0x0   0x6840             LDR      R0,[R0, #+4]
   \        0x2   0x13C1             ASRS     R1,R0,#+15
   \        0x4   0xEB00 0x4011      ADD      R0,R0,R1, LSR #+16
   \        0x8   0x1400             ASRS     R0,R0,#+16
   \        0xA   0x4770             BX       LR               ;; return
    112          }
    113          
    114          /**
    115            * @brief  Get the current motor torque reference. This value represents
    116            *         actually the Iq current reference expressed in digit.
    117            *         To convert current expressed in digit to current expressed in Amps
    118            *         is possible to use the formula:
    119            *         Current(Amp) = [Current(digit) * Vdd micro] / [65536 * Rshunt * Aop]
    120            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    121            * @retval int16_t current motor torque reference. This value represents
    122            *         actually the Iq current expressed in digit.
    123            */

   \                                 In section .text, align 2
    124          __weak int16_t STC_GetTorqueRef( SpeednTorqCtrl_Handle_t * pHandle )
    125          {
    126            return ( ( int16_t )( pHandle->TorqueRef / 65536 ) );
   \                     STC_GetTorqueRef: (+1)
   \        0x0   0x6880             LDR      R0,[R0, #+8]
   \        0x2   0x13C1             ASRS     R1,R0,#+15
   \        0x4   0xEB00 0x4011      ADD      R0,R0,R1, LSR #+16
   \        0x8   0x1400             ASRS     R0,R0,#+16
   \        0xA   0x4770             BX       LR               ;; return
    127          }
    128          
    129          /**
    130            * @brief  Set the modality of the speed and torque controller. Two modality
    131            *         are available Torque mode and Speed mode.
    132            *         In Torque mode is possible to set directly the motor torque
    133            *         reference or execute a motor torque ramp. This value represents
    134            *         actually the Iq current reference expressed in digit.
    135            *         In Speed mode is possible to set the mechanical rotor speed
    136            *         reference or execute a speed ramp. The required motor torque is
    137            *         automatically calculated by the STC.
    138            *         This command interrupts the execution of any previous ramp command
    139            *         maintaining the last value of Iq.
    140            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    141            * @param  bMode modality of STC. It can be one of these two settings:
    142            *         STC_TORQUE_MODE to enable the Torque mode or STC_SPEED_MODE to
    143            *         enable the Speed mode.
    144            * @retval none
    145            */

   \                                 In section .text, align 2
    146          __weak void STC_SetControlMode( SpeednTorqCtrl_Handle_t * pHandle, STC_Modality_t bMode )
    147          {
    148            pHandle->Mode = bMode;
   \                     STC_SetControlMode: (+1)
   \        0x0   0x7001             STRB     R1,[R0, #+0]
    149            pHandle->RampRemainingStep = 0u; /* Interrupts previous ramp. */
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x60C1             STR      R1,[R0, #+12]
    150          }
   \        0x6   0x4770             BX       LR               ;; return
    151          
    152          /**
    153            * @brief  Get the modality of the speed and torque controller.
    154            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    155            * @retval STC_Modality_t It returns the modality of STC. It can be one of
    156            *         these two values: STC_TORQUE_MODE or STC_SPEED_MODE.
    157            */

   \                                 In section .text, align 2
    158          __weak STC_Modality_t STC_GetControlMode( SpeednTorqCtrl_Handle_t * pHandle )
    159          {
    160            return pHandle->Mode;
   \                     STC_GetControlMode: (+1)
   \        0x0   0x7800             LDRB     R0,[R0, #+0]
   \        0x2   0x4770             BX       LR               ;; return
    161          }
    162          
    163          /**
    164            * @brief  Starts the execution of a ramp using new target and duration. This
    165            *         command interrupts the execution of any previous ramp command.
    166            *         The generated ramp will be in the modality previously set by
    167            *         STC_SetControlMode method.
    168            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    169            * @param  hTargetFinal final value of command. This is different accordingly
    170            *         the STC modality.
    171            *         If STC is in Torque mode hTargetFinal is the value of motor torque
    172            *         reference at the end of the ramp. This value represents actually the
    173            *         Iq current expressed in digit.
    174            *         To convert current expressed in Amps to current expressed in digit
    175            *         is possible to use the formula:
    176            *         Current(digit) = [Current(Amp) * 65536 * Rshunt * Aop]  /  Vdd micro
    177            *         If STC is in Speed mode hTargetFinal is the value of mechanical
    178            *         rotor speed reference at the end of the ramp expressed in tenths of
    179            *         HZ.
    180            * @param  hDurationms the duration of the ramp expressed in milliseconds. It
    181            *         is possible to set 0 to perform an instantaneous change in the value.
    182            * @retval bool It return false if the absolute value of hTargetFinal is out of
    183            *         the boundary of the application (Above max application speed or max
    184            *         application torque or below min application speed depending on
    185            *         current modality of TSC) in this case the command is ignored and the
    186            *         previous ramp is not interrupted, otherwise it returns true.
    187            */

   \                                 In section .text, align 2
    188          __weak bool STC_ExecRamp( SpeednTorqCtrl_Handle_t * pHandle, int16_t hTargetFinal, uint32_t hDurationms )
    189          {
   \                     STC_ExecRamp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
    190            bool AllowedRange = true;
    191            uint32_t wAux;
    192            int32_t wAux1;
    193            int16_t hCurrentReference;
    194          
    195            /* Check if the hTargetFinal is out of the bound of application. */
    196            if ( pHandle->Mode == STC_TORQUE_MODE )
   \        0x6   0x7830             LDRB     R0,[R6, #+0]
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x2501             MOVS     R5,#+1
   \        0xC   0xB9A0             CBNZ.N   R0,??STC_ExecRamp_0
    197            {
    198              hCurrentReference = STC_GetTorqueRef( pHandle );
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x....'....        BL       STC_GetTorqueRef
    199          #ifdef CHECK_BOUNDARY
    200              if ( ( int32_t )hTargetFinal > ( int32_t )pHandle->MaxPositiveTorque )
   \       0x14   0x8CF1             LDRH     R1,[R6, #+38]
    201              {
    202                AllowedRange = false;
    203              }
    204              if ( ( int32_t )hTargetFinal < ( int32_t )pHandle->MinNegativeTorque )
   \       0x16   0xF9B6 0x2028      LDRSH    R2,[R6, #+40]
   \       0x1A   0x42A1             CMP      R1,R4
   \       0x1C   0xBFB8             IT       LT
   \       0x1E   0x2500             MOVLT    R5,#+0
   \       0x20   0x4294             CMP      R4,R2
   \       0x22   0xDB1C             BLT.N    ??STC_ExecRamp_1
    205              {
    206                AllowedRange = false;
    207              }
    208          #endif
    209            }
    210            else
    211            {
    212              hCurrentReference = ( int16_t )( pHandle->SpeedRefUnitExt / 65536 );
    213          
    214          #ifdef CHECK_BOUNDARY
    215              if ( ( int32_t )hTargetFinal > ( int32_t )pHandle->MaxAppPositiveMecSpeedUnit )
    216              {
    217                AllowedRange = false;
    218              }
    219              else if ( hTargetFinal < pHandle->MinAppNegativeMecSpeedUnit )
    220              {
    221                AllowedRange = false;
    222              }
    223              else if ( ( int32_t )hTargetFinal < ( int32_t )pHandle->MinAppPositiveMecSpeedUnit )
    224              {
    225                if ( hTargetFinal > pHandle->MaxAppNegativeMecSpeedUnit )
    226                {
    227                  AllowedRange = false;
    228                }
    229              }
    230              else {}
    231          #endif
    232            }
    233          
    234            if ( AllowedRange == true )
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0xD02E             BEQ.N    ??STC_ExecRamp_2
    235            {
    236              /* Interrupts the execution of any previous ramp command */
    237              if ( hDurationms == 0u )
   \                     ??STC_ExecRamp_3: (+1)
   \       0x28   0xB9F7             CBNZ.N   R7,??STC_ExecRamp_4
    238              {
    239                if ( pHandle->Mode == STC_SPEED_MODE )
   \       0x2A   0x7830             LDRB     R0,[R6, #+0]
   \       0x2C   0x0427             LSLS     R7,R4,#+16
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xBF0C             ITE      EQ
   \       0x32   0x6077             STREQ    R7,[R6, #+4]
   \       0x34   0x60B7             STRNE    R7,[R6, #+8]
    240                {
    241                  pHandle->SpeedRefUnitExt = ( int32_t )hTargetFinal * 65536;
    242                }
    243                else
    244                {
    245                  pHandle->TorqueRef = ( int32_t )hTargetFinal * 65536;
   \       0x36   0xE014             B.N      ??STC_ExecRamp_5
    246                }
   \                     ??STC_ExecRamp_0: (+1)
   \       0x38   0x6870             LDR      R0,[R6, #+4]
   \       0x3A   0x13C1             ASRS     R1,R0,#+15
   \       0x3C   0xEB00 0x4011      ADD      R0,R0,R1, LSR #+16
   \       0x40   0x8BF1             LDRH     R1,[R6, #+30]
   \       0x42   0x1400             ASRS     R0,R0,#+16
   \       0x44   0x42A1             CMP      R1,R4
   \       0x46   0xBFA4             ITT      GE
   \       0x48   0xF9B6 0x2024      LDRSHGE  R2,[R6, #+36]
   \       0x4C   0x4294             CMPGE    R4,R2
   \       0x4E   0xDB06             BLT.N    ??STC_ExecRamp_1
   \       0x50   0x8C31             LDRH     R1,[R6, #+32]
   \       0x52   0x428C             CMP      R4,R1
   \       0x54   0xBFBC             ITT      LT
   \       0x56   0xF9B6 0x2022      LDRSHLT  R2,[R6, #+34]
   \       0x5A   0x42A2             CMPLT    R2,R4
   \       0x5C   0xDAE4             BGE.N    ??STC_ExecRamp_3
   \                     ??STC_ExecRamp_1: (+1)
   \       0x5E   0x2500             MOVS     R5,#+0
   \       0x60   0xE011             B.N      ??STC_ExecRamp_2
    247                pHandle->RampRemainingStep = 0u;
   \                     ??STC_ExecRamp_5: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x60F0             STR      R0,[R6, #+12]
    248                pHandle->IncDecAmount = 0;
   \       0x66   0xE00D             B.N      ??STC_ExecRamp_6
    249              }
    250              else
    251              {
    252                /* Store the hTargetFinal to be applied in the last step */
    253                pHandle->TargetFinal = hTargetFinal;
   \                     ??STC_ExecRamp_4: (+1)
   \       0x68   0x8074             STRH     R4,[R6, #+2]
    254          
    255                /* Compute the (wRampRemainingStep) number of steps remaining to complete
    256                the ramp. */
    257                wAux = ( uint32_t )hDurationms * ( uint32_t )pHandle->STCFrequencyHz;
    258                wAux /= 1000u;
    259                pHandle->RampRemainingStep = wAux;
    260                pHandle->RampRemainingStep++;
   \       0x6A   0xF44F 0x727A      MOV      R2,#+1000
   \       0x6E   0x8BB1             LDRH     R1,[R6, #+28]
   \       0x70   0xFB01 0xF307      MUL      R3,R1,R7
   \       0x74   0xFBB3 0xF1F2      UDIV     R1,R3,R2
    261          
    262                /* Compute the increment/decrement amount (wIncDecAmount) to be applied to
    263                the reference value at each CalcTorqueReference. */
    264                wAux1 = ( ( int32_t )hTargetFinal - ( int32_t )hCurrentReference ) * 65536;
    265                wAux1 /= ( int32_t )pHandle->RampRemainingStep;
    266                pHandle->IncDecAmount = wAux1;
   \       0x78   0x1A27             SUBS     R7,R4,R0
   \       0x7A   0x1C49             ADDS     R1,R1,#+1
   \       0x7C   0x043F             LSLS     R7,R7,#+16
   \       0x7E   0x60F1             STR      R1,[R6, #+12]
   \       0x80   0xFB97 0xF0F1      SDIV     R0,R7,R1
   \                     ??STC_ExecRamp_6: (+1)
   \       0x84   0x61B0             STR      R0,[R6, #+24]
    267              }
    268            }
    269          
    270            return AllowedRange;
   \                     ??STC_ExecRamp_2: (+1)
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    271          }
    272          
    273          /**
    274            * @brief  This command interrupts the execution of any previous ramp command.
    275            *         If STC has been set in Torque mode the last value of Iq is
    276            *         maintained.
    277            *         If STC has been set in Speed mode the last value of mechanical
    278            *         rotor speed reference is maintained.
    279            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    280            * @retval none
    281            */

   \                                 In section .text, align 2
    282          __weak void STC_StopRamp( SpeednTorqCtrl_Handle_t * pHandle )
    283          {
    284          
    285            pHandle->RampRemainingStep = 0u;
   \                     STC_StopRamp: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x60C1             STR      R1,[R0, #+12]
    286            pHandle->IncDecAmount = 0;
   \        0x4   0x6181             STR      R1,[R0, #+24]
    287          }
   \        0x6   0x4770             BX       LR               ;; return
    288          
    289          /**
    290            * @brief  It is used to compute the new value of motor torque reference. It
    291            *         must be called at fixed time equal to hSTCFrequencyHz. It is called
    292            *         passing as parameter the speed sensor used to perform the speed
    293            *         regulation.
    294            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    295            * @retval int16_t motor torque reference. This value represents actually the
    296            *         Iq current expressed in digit.
    297            *         To convert current expressed in Amps to current expressed in digit
    298            *         is possible to use the formula:
    299            *         Current(digit) = [Current(Amp) * 65536 * Rshunt * Aop]  /  Vdd micro
    300            */

   \                                 In section .text, align 2
    301          __weak int16_t STC_CalcTorqueReference( SpeednTorqCtrl_Handle_t * pHandle )
    302          {
   \                     STC_CalcTorqueReference: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    303            int32_t wCurrentReference;
    304            int16_t hTorqueReference = 0;
    305            int16_t hMeasuredSpeed;
    306            int16_t hTargetSpeed;
    307            int16_t hError;
    308          
    309            if ( pHandle->Mode == STC_TORQUE_MODE )
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
    310            {
    311              wCurrentReference = pHandle->TorqueRef;
    312            }
    313            else
    314            {
    315              wCurrentReference = pHandle->SpeedRefUnitExt;
    316            }
    317          
    318            /* Update the speed reference or the torque reference according to the mode
    319               and terminates the ramp if needed. */
    320            if ( pHandle->RampRemainingStep > 1u )
   \        0x6   0x68E2             LDR      R2,[R4, #+12]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xBF0C             ITE      EQ
   \        0xC   0x68A5             LDREQ    R5,[R4, #+8]
   \        0xE   0x6865             LDRNE    R5,[R4, #+4]
   \       0x10   0x2A01             CMP      R2,#+1
   \       0x12   0xD904             BLS.N    ??STC_CalcTorqueReference_0
    321            {
    322              /* Increment/decrement the reference value. */
    323              wCurrentReference += pHandle->IncDecAmount;
   \       0x14   0x69A1             LDR      R1,[R4, #+24]
    324          
    325              /* Decrement the number of remaining steps */
    326              pHandle->RampRemainingStep--;
   \       0x16   0x1E52             SUBS     R2,R2,#+1
   \       0x18   0x194D             ADDS     R5,R1,R5
   \       0x1A   0x60E2             STR      R2,[R4, #+12]
   \       0x1C   0xE005             B.N      ??STC_CalcTorqueReference_1
    327            }
    328            else if ( pHandle->RampRemainingStep == 1u )
   \                     ??STC_CalcTorqueReference_0: (+1)
   \       0x1E   0xD104             BNE.N    ??STC_CalcTorqueReference_1
    329            {
    330              /* Set the backup value of hTargetFinal. */
    331              wCurrentReference = ( int32_t )pHandle->TargetFinal * 65536;
   \       0x20   0xF9B4 0x5002      LDRSH    R5,[R4, #+2]
    332              pHandle->RampRemainingStep = 0u;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x042D             LSLS     R5,R5,#+16
   \       0x28   0x60E1             STR      R1,[R4, #+12]
    333            }
    334            else
    335            {
    336              /* Do nothing. */
    337            }
    338          
    339            if ( pHandle->Mode == STC_SPEED_MODE )
   \                     ??STC_CalcTorqueReference_1: (+1)
   \       0x2A   0x13EA             ASRS     R2,R5,#+15
   \       0x2C   0xEB05 0x4612      ADD      R6,R5,R2, LSR #+16
   \       0x30   0x1436             ASRS     R6,R6,#+16
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD10A             BNE.N    ??STC_CalcTorqueReference_2
    340            {
    341              /* Run the speed control loop */
    342          
    343              /* Compute speed error */
    344              hTargetSpeed = ( int16_t )( wCurrentReference / 65536 );
    345              hMeasuredSpeed = SPD_GetAvrgMecSpeedUnit( pHandle->SPD );
   \       0x36   0x6960             LDR      R0,[R4, #+20]
   \       0x38   0x....'....        BL       SPD_GetAvrgMecSpeedUnit
    346              hError = hTargetSpeed - hMeasuredSpeed;
    347              hTorqueReference = PI_Controller( pHandle->PISpeed, ( int32_t )hError );
   \       0x3C   0x1A36             SUBS     R6,R6,R0
   \       0x3E   0x6920             LDR      R0,[R4, #+16]
   \       0x40   0xB231             SXTH     R1,R6
   \       0x42   0x....'....        BL       PI_Controller
    348          
    349              pHandle->SpeedRefUnitExt = wCurrentReference;
   \       0x46   0x6065             STR      R5,[R4, #+4]
   \       0x48   0x4606             MOV      R6,R0
    350              pHandle->TorqueRef = ( int32_t )hTorqueReference * 65536;
   \       0x4A   0x0435             LSLS     R5,R6,#+16
    351            }
    352            else
    353            {
    354              pHandle->TorqueRef = wCurrentReference;
    355              hTorqueReference = ( int16_t )( wCurrentReference / 65536 );
   \                     ??STC_CalcTorqueReference_2: (+1)
   \       0x4C   0x60A5             STR      R5,[R4, #+8]
    356            }
    357          
    358            return hTorqueReference;
   \       0x4E   0x4630             MOV      R0,R6
   \       0x50   0xBD70             POP      {R4-R6,PC}       ;; return
    359          }
    360          
    361          /**
    362            * @brief  Get the Default mechanical rotor speed reference expressed in tenths
    363            *         of HZ.
    364            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    365            * @retval int16_t It returns the Default mechanical rotor speed. reference
    366            *         expressed in tenths of HZ.
    367            */

   \                                 In section .text, align 2
    368          __weak int16_t STC_GetMecSpeedRefUnitDefault( SpeednTorqCtrl_Handle_t * pHandle )
    369          {
    370            return pHandle->MecSpeedRefUnitDefault;
   \                     STC_GetMecSpeedRefUnitDefault: (+1)
   \        0x0   0xF9B0 0x002C      LDRSH    R0,[R0, #+44]
   \        0x4   0x4770             BX       LR               ;; return
    371          }
    372          
    373          /**
    374            * @brief  Returns the Application maximum positive value of rotor speed. Expressed in the unit defined by #SPEED_UNIT.
    375            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    376            */

   \                                 In section .text, align 2
    377          __weak uint16_t STC_GetMaxAppPositiveMecSpeedUnit( SpeednTorqCtrl_Handle_t * pHandle )
    378          {
    379            return pHandle->MaxAppPositiveMecSpeedUnit;
   \                     STC_GetMaxAppPositiveMecSpeedUnit: (+1)
   \        0x0   0x8BC0             LDRH     R0,[R0, #+30]
   \        0x2   0x4770             BX       LR               ;; return
    380          }
    381          
    382          /**
    383            * @brief  Returns the Application minimum negative value of rotor speed. Expressed in the unit defined by #SPEED_UNIT.
    384            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    385            */

   \                                 In section .text, align 2
    386          __weak int16_t STC_GetMinAppNegativeMecSpeedUnit( SpeednTorqCtrl_Handle_t * pHandle )
    387          {
    388            return pHandle->MinAppNegativeMecSpeedUnit;
   \                     STC_GetMinAppNegativeMecSpeedUnit: (+1)
   \        0x0   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \        0x4   0x4770             BX       LR               ;; return
    389          }
    390          
    391          /**
    392            * @brief  Check if the settled speed or torque ramp has been completed.
    393            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    394            * @retval bool It returns true if the ramp is completed, false otherwise.
    395            */

   \                                 In section .text, align 2
    396          __weak bool STC_RampCompleted( SpeednTorqCtrl_Handle_t * pHandle )
    397          {
   \                     STC_RampCompleted: (+1)
   \        0x0   0x4601             MOV      R1,R0
    398            bool retVal = false;
   \        0x2   0x2000             MOVS     R0,#+0
    399            if ( pHandle->RampRemainingStep == 0u )
   \        0x4   0x68C9             LDR      R1,[R1, #+12]
   \        0x6   0xB901             CBNZ.N   R1,??STC_RampCompleted_0
    400            {
    401              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    402            }
    403            return retVal;
   \                     ??STC_RampCompleted_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return
    404          }
    405          
    406          /**
    407            * @brief  Stop the execution of speed ramp.
    408            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    409            * @retval bool It returns true if the command is executed, false otherwise.
    410            */

   \                                 In section .text, align 2
    411          __weak bool STC_StopSpeedRamp( SpeednTorqCtrl_Handle_t * pHandle )
    412          {
   \                     STC_StopSpeedRamp: (+1)
   \        0x0   0x4601             MOV      R1,R0
    413            bool retVal = false;
   \        0x2   0x2000             MOVS     R0,#+0
    414            if ( pHandle->Mode == STC_SPEED_MODE )
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xBF04             ITT      EQ
   \        0xA   0x60C8             STREQ    R0,[R1, #+12]
   \        0xC   0x2001             MOVEQ    R0,#+1
    415            {
    416              pHandle->RampRemainingStep = 0u;
    417              retVal = true;
    418            }
    419            return retVal;
   \        0xE   0x4770             BX       LR               ;; return
    420          }
    421          
    422          /**
    423            * @brief It returns the default values of Iqdref.
    424            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    425            * @retval default values of Iqdref.
    426            */

   \                                 In section .text, align 2
    427          __weak qd_t STC_GetDefaultIqdref( SpeednTorqCtrl_Handle_t * pHandle )
    428          {
   \                     STC_GetDefaultIqdref: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    429            qd_t IqdRefDefault;
    430            IqdRefDefault.q = pHandle->TorqueRefDefault;
   \        0x2   0xF9B0 0x102E      LDRSH    R1,[R0, #+46]
   \        0x6   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    431            IqdRefDefault.d = pHandle->IdrefDefault;
   \        0xA   0x8E00             LDRH     R0,[R0, #+48]
   \        0xC   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    432            return IqdRefDefault;
   \       0x10   0x9800             LDR      R0,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR               ;; return
    433          }
    434          
    435          /**
    436            * @brief  Change the nominal current .
    437            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    438            * @param  hNominalCurrent This value represents actually the maximum Iq current
    439                      expressed in digit.
    440            * @retval none
    441            */

   \                                 In section .text, align 2
    442          __weak void STC_SetNominalCurrent( SpeednTorqCtrl_Handle_t * pHandle, uint16_t hNominalCurrent )
    443          {
    444            pHandle->MaxPositiveTorque = hNominalCurrent;
   \                     STC_SetNominalCurrent: (+1)
   \        0x0   0x84C1             STRH     R1,[R0, #+38]
    445            pHandle->MinNegativeTorque = -hNominalCurrent;
   \        0x2   0x4249             RSBS     R1,R1,#+0
   \        0x4   0x8501             STRH     R1,[R0, #+40]
    446          }
   \        0x6   0x4770             BX       LR               ;; return
    447          
    448          /**
    449            * @brief  Force the speed reference to the curren speed. It is used
    450            *         at the START_RUN state to initialize the speed reference.
    451            * @param  pHandle: handler of the current instance of the SpeednTorqCtrl component
    452            * @retval none
    453            */

   \                                 In section .text, align 2
    454          __weak void STC_ForceSpeedReferenceToCurrentSpeed( SpeednTorqCtrl_Handle_t * pHandle )
    455          {
   \                     STC_ForceSpeedReferenceToCurrentSpeed: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    456            pHandle->SpeedRefUnitExt = ( int32_t )SPD_GetAvrgMecSpeedUnit( pHandle->SPD ) * ( int32_t )65536;
   \        0x4   0x6960             LDR      R0,[R4, #+20]
   \        0x6   0x....'....        BL       SPD_GetAvrgMecSpeedUnit
   \        0xA   0x0400             LSLS     R0,R0,#+16
   \        0xC   0x6060             STR      R0,[R4, #+4]
    457          }
   \        0xE   0xBD10             POP      {R4,PC}          ;; return
    458          
    459          /**
    460            * @}
    461            */
    462          
    463          /**
    464            * @}
    465            */
    466          
    467          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   STC_CalcTorqueReference
        16   -> PI_Controller
        16   -> SPD_GetAvrgMecSpeedUnit
       0   STC_Clear
         0   -> PID_SetIntegralTerm
      24   STC_ExecRamp
        24   -> STC_GetTorqueRef
       8   STC_ForceSpeedReferenceToCurrentSpeed
         8   -> SPD_GetAvrgMecSpeedUnit
       0   STC_GetControlMode
       4   STC_GetDefaultIqdref
       0   STC_GetMaxAppPositiveMecSpeedUnit
       0   STC_GetMecSpeedRefUnit
       0   STC_GetMecSpeedRefUnitDefault
       0   STC_GetMinAppNegativeMecSpeedUnit
       0   STC_GetSpeedSensor
       0   STC_GetTorqueRef
       0   STC_Init
       0   STC_RampCompleted
       0   STC_SetControlMode
       0   STC_SetNominalCurrent
       0   STC_SetSpeedSensor
       0   STC_StopRamp
       0   STC_StopSpeedRamp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      82  STC_CalcTorqueReference
      16  STC_Clear
     138  STC_ExecRamp
      16  STC_ForceSpeedReferenceToCurrentSpeed
       4  STC_GetControlMode
      22  STC_GetDefaultIqdref
       4  STC_GetMaxAppPositiveMecSpeedUnit
      12  STC_GetMecSpeedRefUnit
       6  STC_GetMecSpeedRefUnitDefault
       6  STC_GetMinAppNegativeMecSpeedUnit
       4  STC_GetSpeedSensor
      12  STC_GetTorqueRef
      38  STC_Init
      12  STC_RampCompleted
       8  STC_SetControlMode
       8  STC_SetNominalCurrent
       4  STC_SetSpeedSensor
       8  STC_StopRamp
      16  STC_StopSpeedRamp

 
 416 bytes in section .text
 
 0 bytes of CODE memory (+ 416 bytes shared)

Errors: none
Warnings: none
