###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:55
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pid_regulator.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW10D7.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pid_regulator.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\pid_regulator.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\pid_regulator.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pid_regulator.c
      1          /**
      2           ******************************************************************************
      3           * @file    pid_regulator.c
      4           * @author  Motor Control SDK Team, ST Microelectronics
      5           * @brief   This file provides firmware functions that implement the following features
      6           *          of the PID regulator component of the Motor Control SDK:
      7           *
      8           *           * proportional, integral and derivative computation funcions
      9           *           * read and write gain functions
     10           *
     11           ******************************************************************************
     12            * @attention
     13            *
     14            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     15            * All rights reserved.</center></h2>
     16            *
     17            * This software component is licensed by ST under Ultimate Liberty license
     18            * SLA0044, the "License"; You may not use this file except in compliance with
     19            * the License. You may obtain a copy of the License at:
     20            *                             www.st.com/SLA0044
     21            *
     22           ******************************************************************************
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "pid_regulator.h"
     27          
     28          #include "mc_type.h"
     29          
     30          /** @addtogroup MCSDK
     31           * @{
     32           */
     33          
     34          /**
     35           * @defgroup PIDRegulator PID Regulator
     36           * @brief PID regulator component of the Motor Control SDK
     37           *
     38           * The PID regulator component implements the following control function:
     39           *
     40           * @f[
     41           * u(t) = K_{p} e(t) + K_{i} \int_0^t e(\tau) \,d\tau + K_{d} \frac{de(t)}{dt}
     42           * @f]
     43           *
     44           * with the proportional, integral and derivative gains expressed as rational numbers, with a gain and a divisor parameter :
     45           *
     46           * @f[
     47           * K_{p} = \frac{K_{pg}}{K_{pd}}
     48           * @f]
     49           * @f[
     50           * K_{i} = \frac{K_{ig}}{K_{id}}
     51           * @f]
     52           * @f[
     53           * K_{d} = \frac{K_{dg}}{K_{dd}}
     54           * @f]
     55           *
     56           *  Each of the gain and divisor parameters, @f$K_{{p}g}@f$, @f$K_{{i}g}@f$, @f$K_{{d}g}@f$, @f$K_{{p}d}@f$,
     57           * @f$K_{id}@f$, @f$K_{dd}@f$, can be set independently. via the PID_SetKP(), PID_SetKPDivisorPOW2(), PID_SetKI(),
     58           * PID_SetKIDivisorPOW2(), PID_SetKD()
     59           *
     60           * @{
     61           */
     62          
     63          /**
     64           * @brief  It initializes the handle
     65           * @param  pHandle: handler of the current instance of the PID component
     66           * @retval None
     67           */

   \                                 In section .text, align 2
     68          __weak void PID_HandleInit( PID_Handle_t * pHandle )
     69          {
     70            pHandle->hKpGain =  pHandle->hDefKpGain;
   \                     PID_HandleInit: (+1)
   \        0x0   0x8801             LDRH     R1,[R0, #+0]
     71            pHandle->hKiGain =  pHandle->hDefKiGain;
   \        0x2   0x8842             LDRH     R2,[R0, #+2]
   \        0x4   0x8081             STRH     R1,[R0, #+4]
   \        0x6   0x80C2             STRH     R2,[R0, #+6]
     72            pHandle->hKdGain =  pHandle->hDefKdGain;
     73            pHandle->wIntegralTerm = 0x00000000UL;
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x8C01             LDRH     R1,[R0, #+32]
   \        0xC   0x8441             STRH     R1,[R0, #+34]
   \        0xE   0x6082             STR      R2,[R0, #+8]
     74            pHandle->wPrevProcessVarError = 0x00000000UL;
   \       0x10   0x6282             STR      R2,[R0, #+40]
     75          }
   \       0x12   0x4770             BX       LR               ;; return
     76          
     77          /**
     78           * @brief  It updates the Kp gain
     79           * @param  pHandle: handler of the current instance of the PID component
     80           * @param  hKpGain: new Kp gain
     81           * @retval None
     82           */

   \                                 In section .text, align 2
     83          __weak void PID_SetKP( PID_Handle_t * pHandle, int16_t hKpGain )
     84          {
     85            pHandle->hKpGain = hKpGain;
   \                     PID_SetKP: (+1)
   \        0x0   0x8081             STRH     R1,[R0, #+4]
     86          }
   \        0x2   0x4770             BX       LR               ;; return
     87          
     88          /**
     89           * @brief  It updates the Ki gain
     90           * @param  pHandle: handler of the current instance of the PID component
     91           * @param  hKiGain: new Ki gain
     92           * @retval None
     93           */

   \                                 In section .text, align 2
     94          __weak void PID_SetKI( PID_Handle_t * pHandle, int16_t hKiGain )
     95          {
     96            pHandle->hKiGain = hKiGain;
   \                     PID_SetKI: (+1)
   \        0x0   0x80C1             STRH     R1,[R0, #+6]
     97          }
   \        0x2   0x4770             BX       LR               ;; return
     98          
     99          /**
    100           * @brief  It returns the Kp gain
    101           * @param  pHandle: handler of the current instance of the PID component
    102           * @retval Kp gain
    103           */

   \                                 In section .text, align 2
    104          __weak int16_t PID_GetKP( PID_Handle_t * pHandle )
    105          {
    106            return ( pHandle->hKpGain );
   \                     PID_GetKP: (+1)
   \        0x0   0xF9B0 0x0004      LDRSH    R0,[R0, #+4]
   \        0x4   0x4770             BX       LR               ;; return
    107          }
    108          
    109          /**
    110           * @brief  It returns the Ki gain
    111           * @param  pHandle: handler of the current instance of the PID component
    112           * @retval Ki gain
    113           */

   \                                 In section .text, align 2
    114          __weak int16_t PID_GetKI( PID_Handle_t * pHandle )
    115          {
    116            return ( pHandle->hKiGain );
   \                     PID_GetKI: (+1)
   \        0x0   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \        0x4   0x4770             BX       LR               ;; return
    117          }
    118          
    119          /**
    120           * @brief  It returns the Default Kp gain
    121           * @param  pHandle: handler of the current instance of the PID component
    122           * @retval default Kp gain
    123           */

   \                                 In section .text, align 2
    124          __weak int16_t PID_GetDefaultKP( PID_Handle_t * pHandle )
    125          {
    126            return ( pHandle->hDefKpGain );
   \                     PID_GetDefaultKP: (+1)
   \        0x0   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    127          }
    128          
    129          /**
    130           * @brief  It returns the Default Ki gain of the passed PI object
    131           * @param  pHandle: handler of the current instance of the PID component
    132           * @retval default Ki gain
    133           */

   \                                 In section .text, align 2
    134          __weak int16_t PID_GetDefaultKI( PID_Handle_t * pHandle )
    135          {
    136            return ( pHandle->hDefKiGain );
   \                     PID_GetDefaultKI: (+1)
   \        0x0   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \        0x4   0x4770             BX       LR               ;; return
    137          }
    138          
    139          /**
    140           * @brief  It set a new value into the PI integral term
    141           * pHandle: handler of the current instance of the PID component
    142           * @param  wIntegralTermValue: new integral term value
    143           * @retval None
    144           */

   \                                 In section .text, align 2
    145          __weak void PID_SetIntegralTerm( PID_Handle_t * pHandle, int32_t wIntegralTermValue )
    146          {
    147            pHandle->wIntegralTerm = wIntegralTermValue;
   \                     PID_SetIntegralTerm: (+1)
   \        0x0   0x6081             STR      R1,[R0, #+8]
    148          
    149            return;
   \        0x2   0x4770             BX       LR               ;; return
    150          }
    151          
    152          /**
    153           * @brief  It returns the Kp gain divisor
    154           * @param  pHandle: handler of the current instance of the PID component
    155           * @retval Kp gain divisor
    156           */

   \                                 In section .text, align 2
    157          __weak uint16_t PID_GetKPDivisor( PID_Handle_t * pHandle )
    158          {
    159            return ( pHandle->hKpDivisor );
   \                     PID_GetKPDivisor: (+1)
   \        0x0   0x8B00             LDRH     R0,[R0, #+24]
   \        0x2   0x4770             BX       LR               ;; return
    160          }
    161          
    162          /**
    163           * @brief  It updates the Kp divisor
    164           * @param  pHandle: handler of the current instance of the PID component
    165           * @param  hKpDivisorPOW2: new Kp divisor expressed as power of 2
    166           * @retval None
    167           */

   \                                 In section .text, align 2
    168          __weak void PID_SetKPDivisorPOW2( PID_Handle_t * pHandle, uint16_t hKpDivisorPOW2 )
    169          {
    170            pHandle->hKpDivisorPOW2 = hKpDivisorPOW2;
   \                     PID_SetKPDivisorPOW2: (+1)
   \        0x0   0x8381             STRH     R1,[R0, #+28]
    171            pHandle->hKpDivisor = ( ( uint16_t )( 1u ) << hKpDivisorPOW2 );
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0xFA02 0xF101      LSL      R1,R2,R1
   \        0x8   0x8301             STRH     R1,[R0, #+24]
    172          }
   \        0xA   0x4770             BX       LR               ;; return
    173          
    174          /**
    175           * @brief  It returns the Ki gain divisor of the passed PI object
    176           * @param  pHandle: handler of the current instance of the PID component
    177           * @retval Ki gain divisor
    178           */

   \                                 In section .text, align 2
    179          __weak uint16_t PID_GetKIDivisor( PID_Handle_t * pHandle )
    180          {
    181            return ( pHandle->hKiDivisor );
   \                     PID_GetKIDivisor: (+1)
   \        0x0   0x8B40             LDRH     R0,[R0, #+26]
   \        0x2   0x4770             BX       LR               ;; return
    182          }
    183          
    184          /**
    185           * @brief  It updates the Ki divisor
    186           * @param  pHandle: handler of the current instance of the PID component
    187           * @param  hKiDivisorPOW2: new Ki divisor expressed as power of 2
    188           * @retval None
    189           */

   \                                 In section .text, align 2
    190          __weak void PID_SetKIDivisorPOW2( PID_Handle_t * pHandle, uint16_t hKiDivisorPOW2 )
    191          {
   \                     PID_SetKIDivisorPOW2: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    192            int32_t wKiDiv = ( ( int32_t )( 1u ) << hKiDivisorPOW2 );
   \        0x4   0x2501             MOVS     R5,#+1
    193            pHandle->hKiDivisorPOW2 = hKiDivisorPOW2;
   \        0x6   0x83E1             STRH     R1,[R4, #+30]
   \        0x8   0x408D             LSLS     R5,R5,R1
    194            pHandle->hKiDivisor = ( uint16_t )( wKiDiv );
   \        0xA   0x8365             STRH     R5,[R4, #+26]
    195            PID_SetUpperIntegralTermLimit( pHandle, ( int32_t )INT16_MAX * wKiDiv );
   \        0xC   0xEBC5 0x31C5      RSB      R1,R5,R5, LSL #+15
   \       0x10   0x....'....        BL       PID_SetUpperIntegralTermLimit
    196            PID_SetLowerIntegralTermLimit( pHandle, ( int32_t ) - INT16_MAX * wKiDiv );
   \       0x14   0xEBA5 0x31C5      SUB      R1,R5,R5, LSL #+15
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x1E   0x....'....        B.W      PID_SetLowerIntegralTermLimit
    197          }
    198          
    199          /**
    200           * @brief  It set a new value for lower integral term limit
    201           * @param  pHandle: handler of the current instance of the PID component
    202           * @param  wLowerLimit: new lower integral term limit value
    203           * @retval None
    204           */

   \                                 In section .text, align 2
    205          __weak void PID_SetLowerIntegralTermLimit( PID_Handle_t * pHandle, int32_t wLowerLimit )
    206          {
    207            pHandle->wLowerIntegralLimit = wLowerLimit;
   \                     PID_SetLowerIntegralTermLimit: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
    208          }
   \        0x2   0x4770             BX       LR               ;; return
    209          
    210          /**
    211           * @brief  It set a new value for upper integral term limit
    212           * @param  pHandle: handler of the current instance of the PID component
    213           * @param  wUpperLimit: new upper integral term limit value
    214           * @retval None
    215           */

   \                                 In section .text, align 2
    216          __weak void PID_SetUpperIntegralTermLimit( PID_Handle_t * pHandle, int32_t wUpperLimit )
    217          {
    218            pHandle->wUpperIntegralLimit = wUpperLimit;
   \                     PID_SetUpperIntegralTermLimit: (+1)
   \        0x0   0x60C1             STR      R1,[R0, #+12]
    219          }
   \        0x2   0x4770             BX       LR               ;; return
    220          
    221          /**
    222           * @brief  It set a new value for lower output limit
    223           * @param  pHandle: handler of the current instance of the PID component
    224           * @param  hLowerLimit: new lower output limit value
    225           * @retval None
    226           */

   \                                 In section .text, align 2
    227          __weak void PID_SetLowerOutputLimit( PID_Handle_t * pHandle, int16_t hLowerLimit )
    228          {
    229            pHandle->hLowerOutputLimit = hLowerLimit;
   \                     PID_SetLowerOutputLimit: (+1)
   \        0x0   0x82C1             STRH     R1,[R0, #+22]
    230          }
   \        0x2   0x4770             BX       LR               ;; return
    231          
    232          /**
    233           * @brief  It set a new value for upper output limit
    234           * @param  pHandle: handler of the current instance of the PID component
    235           * @param  hUpperLimit: new upper output limit value
    236           * @retval None
    237           */

   \                                 In section .text, align 2
    238          __weak void PID_SetUpperOutputLimit( PID_Handle_t * pHandle, int16_t hUpperLimit )
    239          {
    240            pHandle->hUpperOutputLimit = hUpperLimit;
   \                     PID_SetUpperOutputLimit: (+1)
   \        0x0   0x8281             STRH     R1,[R0, #+20]
    241          }
   \        0x2   0x4770             BX       LR               ;; return
    242          
    243          /**
    244           * @brief  It set a new value into the PID Previous error variable required to
    245           *         compute derivative term
    246           * @param  pHandle: handler of the current instance of the PID component
    247           * @param  wPrevProcessVarError: New previous error variable
    248           * @retval None
    249           */

   \                                 In section .text, align 2
    250          __weak void PID_SetPrevError( PID_Handle_t * pHandle, int32_t wPrevProcessVarError )
    251          {
    252            pHandle->wPrevProcessVarError = wPrevProcessVarError;
   \                     PID_SetPrevError: (+1)
   \        0x0   0x6281             STR      R1,[R0, #+40]
    253            return;
   \        0x2   0x4770             BX       LR               ;; return
    254          }
    255          
    256          /**
    257           * @brief  It updates the Kd gain
    258           * @param  pHandle: handler of the current instance of the PID component
    259           * @param  hKdGain: new Kd gain
    260           * @retval None
    261           */

   \                                 In section .text, align 2
    262          __weak void PID_SetKD( PID_Handle_t * pHandle, int16_t hKdGain )
    263          {
    264            pHandle->hKdGain = hKdGain;
   \                     PID_SetKD: (+1)
   \        0x0   0x8441             STRH     R1,[R0, #+34]
    265          }
   \        0x2   0x4770             BX       LR               ;; return
    266          
    267          /**
    268           * @brief  It returns the Kd gain
    269           * @param  pHandle: handler of the current instance of the PID component
    270           * @retval Kd gain
    271           */

   \                                 In section .text, align 2
    272          __weak int16_t PID_GetKD( PID_Handle_t * pHandle )
    273          {
    274            return pHandle->hKdGain;
   \                     PID_GetKD: (+1)
   \        0x0   0xF9B0 0x0022      LDRSH    R0,[R0, #+34]
   \        0x4   0x4770             BX       LR               ;; return
    275          }
    276          
    277          /**
    278           * @brief  It returns the Kd gain divisor of the PID object passed
    279           * @param  pHandle: handler of the current instance of the PID component
    280           * @retval Kd gain divisor
    281           */

   \                                 In section .text, align 2
    282          __weak uint16_t PID_GetKDDivisor( PID_Handle_t * pHandle )
    283          {
    284            return ( pHandle->hKdDivisor );
   \                     PID_GetKDDivisor: (+1)
   \        0x0   0x8C80             LDRH     R0,[R0, #+36]
   \        0x2   0x4770             BX       LR               ;; return
    285          }
    286          
    287          /**
    288           * @brief Sets @f$K_{dd}@f$, the derivative divisor parameter of the PID component
    289           *
    290           * @param pHandle handle on the instance of the PID component to update
    291           * @param hKdDivisorPOW2
    292           */

   \                                 In section .text, align 2
    293          __weak void PID_SetKDDivisorPOW2( PID_Handle_t * pHandle, uint16_t hKdDivisorPOW2 )
    294          {
    295            pHandle->hKdDivisorPOW2 = hKdDivisorPOW2;
   \                     PID_SetKDDivisorPOW2: (+1)
   \        0x0   0x84C1             STRH     R1,[R0, #+38]
    296            pHandle->hKdDivisor = ( ( uint16_t )( 1u ) << hKdDivisorPOW2 );
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0xFA02 0xF101      LSL      R1,R2,R1
   \        0x8   0x8481             STRH     R1,[R0, #+36]
    297          }
   \        0xA   0x4770             BX       LR               ;; return
    298          
    299          #if defined (CCMRAM)
    300          #if defined (__ICCARM__)
    301          #pragma location = ".ccmram"
    302          #elif defined (__CC_ARM) || defined(__GNUC__)
    303          __attribute__( ( section ( ".ccmram" ) ) )
    304          #endif
    305          #endif
    306          /**
    307           * @brief  This function compute the output of a PI regulator sum of its
    308           *         proportional and integral terms
    309           * @param  pHandle: handler of the current instance of the PID component
    310           * @param  wProcessVarError: current process variable error, intended as the reference
    311           *         value minus the present process variable value
    312           * @retval computed PI output
    313           */

   \                                 In section .text, align 4
    314          __weak int16_t PI_Controller( PID_Handle_t * pHandle, int32_t wProcessVarError )
    315          {
   \                     PI_Controller: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    316            int32_t wProportional_Term, wIntegral_Term, wOutput_32, wIntegral_sum_temp;
    317            int32_t wDischarge = 0;
    318            int16_t hUpperOutputLimit = pHandle->hUpperOutputLimit;
    319            int16_t hLowerOutputLimit = pHandle->hLowerOutputLimit;
    320          
    321            /* Proportional term computation*/
    322            wProportional_Term = pHandle->hKpGain * wProcessVarError;
   \        0x2   0xF9B0 0x3004      LDRSH    R3,[R0, #+4]
   \        0x6   0xF9B0 0x5014      LDRSH    R5,[R0, #+20]
   \        0xA   0xF9B0 0x6016      LDRSH    R6,[R0, #+22]
    323          
    324            /* Integral term computation */
    325            if ( pHandle->hKiGain == 0 )
   \        0xE   0xF9B0 0x2006      LDRSH    R2,[R0, #+6]
   \       0x12   0x2400             MOVS     R4,#+0
   \       0x14   0x434B             MULS     R3,R1,R3
   \       0x16   0xB1AA             CBZ.N    R2,??PI_Controller_1
    326            {
    327              pHandle->wIntegralTerm = 0;
    328            }
    329            else
    330            {
    331              wIntegral_Term = pHandle->hKiGain * wProcessVarError;
   \       0x18   0x4351             MULS     R1,R1,R2
    332              wIntegral_sum_temp = pHandle->wIntegralTerm + wIntegral_Term;
   \       0x1A   0x6882             LDR      R2,[R0, #+8]
   \       0x1C   0x188F             ADDS     R7,R1,R2
    333          
    334              if ( wIntegral_sum_temp < 0 )
   \       0x1E   0xD506             BPL.N    ??PI_Controller_2
    335              {
    336                if ( pHandle->wIntegralTerm > 0 )
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xBFC8             IT       GT
   \       0x24   0x2900             CMPGT    R1,#+0
    337                {
    338                  if ( wIntegral_Term > 0 )
   \       0x26   0xDD06             BLE.N    ??PI_Controller_3
    339                  {
    340                    wIntegral_sum_temp = INT32_MAX;
   \       0x28   0xF06F 0x4700      MVN      R7,#-2147483648
   \       0x2C   0xE003             B.N      ??PI_Controller_3
    341                  }
    342                }
    343              }
    344              else
    345              {
    346                if ( pHandle->wIntegralTerm < 0 )
   \                     ??PI_Controller_2: (+1)
   \       0x2E   0x2A00             CMP      R2,#+0
   \       0x30   0xBF44             ITT      MI
   \       0x32   0x2900             CMPMI    R1,#+0
   \       0x34   0x4F0D             LDRMI.N  R7,??PI_Controller_0  ;; 0x80000001
    347                {
    348                  if ( wIntegral_Term < 0 )
    349                  {
    350                    wIntegral_sum_temp = -INT32_MAX;
    351                  }
    352                }
    353              }
    354          
    355              if ( wIntegral_sum_temp > pHandle->wUpperIntegralLimit )
   \                     ??PI_Controller_3: (+1)
   \       0x36   0x68C2             LDR      R2,[R0, #+12]
   \       0x38   0x42BA             CMP      R2,R7
   \       0x3A   0xDB03             BLT.N    ??PI_Controller_1
    356              {
    357                pHandle->wIntegralTerm = pHandle->wUpperIntegralLimit;
    358              }
    359              else if ( wIntegral_sum_temp < pHandle->wLowerIntegralLimit )
   \       0x3C   0x6902             LDR      R2,[R0, #+16]
   \       0x3E   0x42BA             CMP      R2,R7
   \       0x40   0xBFB8             IT       LT
   \       0x42   0x463A             MOVLT    R2,R7
    360              {
    361                pHandle->wIntegralTerm = pHandle->wLowerIntegralLimit;
    362              }
    363              else
    364              {
    365                pHandle->wIntegralTerm = wIntegral_sum_temp;
    366              }
    367            }
    368          
    369          #ifdef FULL_MISRA_C_COMPLIANCY
    370            wOutput_32 = ( wProportional_Term / ( int32_t )pHandle->hKpDivisor ) + ( pHandle->wIntegralTerm /
    371                         ( int32_t )pHandle->hKiDivisor );
    372          #else
    373            /* WARNING: the below instruction is not MISRA compliant, user should verify
    374                       that Cortex-M3 assembly instruction ASR (arithmetic shift right)
    375                       is used by the compiler to perform the shifts (instead of LSR
    376                       logical shift right)*/
    377            wOutput_32 = ( wProportional_Term >> pHandle->hKpDivisorPOW2 ) + ( pHandle->wIntegralTerm >> pHandle->hKiDivisorPOW2 );
   \                     ??PI_Controller_1: (+1)
   \       0x44   0x8B87             LDRH     R7,[R0, #+28]
   \       0x46   0x413B             ASRS     R3,R3,R7
   \       0x48   0x8BC7             LDRH     R7,[R0, #+30]
   \       0x4A   0xFA42 0xF107      ASR      R1,R2,R7
   \       0x4E   0x18CB             ADDS     R3,R1,R3
    378          #endif
    379          
    380            if ( wOutput_32 > hUpperOutputLimit )
   \       0x50   0x429D             CMP      R5,R3
   \       0x52   0xDA02             BGE.N    ??PI_Controller_4
    381            {
    382          
    383              wDischarge = hUpperOutputLimit - wOutput_32;
   \       0x54   0x1AEC             SUBS     R4,R5,R3
    384              wOutput_32 = hUpperOutputLimit;
   \       0x56   0x462B             MOV      R3,R5
   \       0x58   0xE003             B.N      ??PI_Controller_5
    385            }
    386            else if ( wOutput_32 < hLowerOutputLimit )
   \                     ??PI_Controller_4: (+1)
   \       0x5A   0x42B3             CMP      R3,R6
   \       0x5C   0xBFBC             ITT      LT
   \       0x5E   0x1AF4             SUBLT    R4,R6,R3
   \       0x60   0x4633             MOVLT    R3,R6
    387            {
    388          
    389              wDischarge = hLowerOutputLimit - wOutput_32;
    390              wOutput_32 = hLowerOutputLimit;
    391            }
    392            else { /* Nothing to do here */ }
    393          
    394            pHandle->wIntegralTerm += wDischarge;
   \                     ??PI_Controller_5: (+1)
   \       0x62   0x18A4             ADDS     R4,R4,R2
   \       0x64   0x6084             STR      R4,[R0, #+8]
    395          
    396            return ( ( int16_t )( wOutput_32 ) );
   \       0x66   0xB218             SXTH     R0,R3
   \       0x68   0xBDF0             POP      {R4-R7,PC}       ;; return
   \       0x6A   0xBF00             Nop
   \                     ??PI_Controller_0:
   \       0x6C   0x8000'0001        DC32     0x80000001
    397          }
    398          
    399          #if defined (CCMRAM)
    400          #if defined (__ICCARM__)
    401          #pragma location = ".ccmram"
    402          #elif defined (__CC_ARM) || defined(__GNUC__)
    403          __attribute__( ( section ( ".ccmram" ) ) )
    404          #endif
    405          #endif
    406          /**
    407           * @brief  This function compute the output of a PID regulator sum of its
    408           *         proportional, integral and derivative terms
    409           * @param  pHandle: handler of the current instance of the PID component
    410           * @param  wProcessVarError: current process variable error, intended as the
    411           *         reference value minus the present process variable value
    412           * @retval PID computed output
    413           */
    414          

   \                                 In section .text, align 2
    415          __weak int16_t PID_Controller( PID_Handle_t * pHandle, int32_t wProcessVarError )
    416          {
   \                     PID_Controller: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
    417            int32_t wDifferential_Term;
    418            int32_t wDeltaError;
    419            int32_t wTemp_output;
    420          
    421            if ( pHandle->hKdGain != 0 ) /* derivative terms not used */
   \        0x4   0xF9B5 0x4022      LDRSH    R4,[R5, #+34]
   \        0x8   0xB194             CBZ.N    R4,??PID_Controller_0
    422            {
    423              wDeltaError = wProcessVarError - pHandle->wPrevProcessVarError;
    424              wDifferential_Term = pHandle->hKdGain * wDeltaError;
    425          
    426          #ifdef FULL_MISRA_C_COMPLIANCY
    427              wDifferential_Term /= ( int32_t )pHandle->hKdDivisor;
    428          #else
    429              /* WARNING: the below instruction is not MISRA compliant, user should verify
    430              that Cortex-M3 assembly instruction ASR (arithmetic shift right)
    431              is used by the compiler to perform the shifts (instead of LSR
    432              logical shift right)*/
    433              wDifferential_Term >>= pHandle->hKdDivisorPOW2;
   \        0xA   0x6AAA             LDR      R2,[R5, #+40]
   \        0xC   0x8CEB             LDRH     R3,[R5, #+38]
    434          #endif
    435          
    436              pHandle->wPrevProcessVarError = wProcessVarError;
   \        0xE   0x62A9             STR      R1,[R5, #+40]
   \       0x10   0x1A8A             SUBS     R2,R1,R2
   \       0x12   0x4354             MULS     R4,R2,R4
   \       0x14   0x411C             ASRS     R4,R4,R3
    437          
    438              wTemp_output = PI_Controller( pHandle, wProcessVarError ) + wDifferential_Term;
   \       0x16   0x....'....        BL       PI_Controller
    439          
    440              if ( wTemp_output > pHandle->hUpperOutputLimit )
   \       0x1A   0xF9B5 0x1014      LDRSH    R1,[R5, #+20]
   \       0x1E   0x1820             ADDS     R0,R4,R0
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xBFA4             ITT      GE
   \       0x24   0xF9B5 0x1016      LDRSHGE  R1,[R5, #+22]
   \       0x28   0x4288             CMPGE    R0,R1
    441              {
    442                wTemp_output = pHandle->hUpperOutputLimit;
    443              }
    444              else if ( wTemp_output < pHandle->hLowerOutputLimit )
   \       0x2A   0xDA03             BGE.N    ??PID_Controller_1
    445              {
    446                wTemp_output = pHandle->hLowerOutputLimit;
   \       0x2C   0x4608             MOV      R0,R1
   \       0x2E   0xE001             B.N      ??PID_Controller_1
    447              }
    448              else
    449              {}
    450            }
    451            else
    452            {
    453              wTemp_output = PI_Controller( pHandle, wProcessVarError );
   \                     ??PID_Controller_0: (+1)
   \       0x30   0x....'....        BL       PI_Controller
    454            }
    455            return ( ( int16_t ) wTemp_output );
   \                     ??PID_Controller_1: (+1)
   \       0x34   0xB200             SXTH     R0,R0
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    456          }
    457          /**
    458           * @}
    459           */
    460          
    461          /**
    462           * @}
    463           */
    464          
    465          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   PID_Controller
        16   -> PI_Controller
       0   PID_GetDefaultKI
       0   PID_GetDefaultKP
       0   PID_GetKD
       0   PID_GetKDDivisor
       0   PID_GetKI
       0   PID_GetKIDivisor
       0   PID_GetKP
       0   PID_GetKPDivisor
       0   PID_HandleInit
       0   PID_SetIntegralTerm
       0   PID_SetKD
       0   PID_SetKDDivisorPOW2
       0   PID_SetKI
      16   PID_SetKIDivisorPOW2
         0   -> PID_SetLowerIntegralTermLimit
        16   -> PID_SetUpperIntegralTermLimit
       0   PID_SetKP
       0   PID_SetKPDivisorPOW2
       0   PID_SetLowerIntegralTermLimit
       0   PID_SetLowerOutputLimit
       0   PID_SetPrevError
       0   PID_SetUpperIntegralTermLimit
       0   PID_SetUpperOutputLimit
      20   PI_Controller


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  PID_Controller
       6  PID_GetDefaultKI
       6  PID_GetDefaultKP
       6  PID_GetKD
       4  PID_GetKDDivisor
       6  PID_GetKI
       4  PID_GetKIDivisor
       6  PID_GetKP
       4  PID_GetKPDivisor
      20  PID_HandleInit
       4  PID_SetIntegralTerm
       4  PID_SetKD
      12  PID_SetKDDivisorPOW2
       4  PID_SetKI
      34  PID_SetKIDivisorPOW2
       4  PID_SetKP
      12  PID_SetKPDivisorPOW2
       4  PID_SetLowerIntegralTermLimit
       4  PID_SetLowerOutputLimit
       4  PID_SetPrevError
       4  PID_SetUpperIntegralTermLimit
       4  PID_SetUpperOutputLimit
     112  PI_Controller

 
 324 bytes in section .text
 
 0 bytes of CODE memory (+ 324 bytes shared)

Errors: none
Warnings: none
