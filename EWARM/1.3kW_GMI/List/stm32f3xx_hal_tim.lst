###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:09
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_tim.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW4AE3.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_tim.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\stm32f3xx_hal_tim.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\stm32f3xx_hal_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output
     45                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     46                      several timers together.
     47                 (#) Supports incremental encoder for positioning purposes
     48          
     49                      ##### How to use this driver #####
     50            ==============================================================================
     51              [..]
     52               (#) Initialize the TIM low level resources by implementing the following functions
     53                   depending on the selected feature:
     54                     (++) Time Base : HAL_TIM_Base_MspInit()
     55                     (++) Input Capture : HAL_TIM_IC_MspInit()
     56                     (++) Output Compare : HAL_TIM_OC_MspInit()
     57                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     58                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     59                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     60          
     61               (#) Initialize the TIM low level resources :
     62                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     63                  (##) TIM pins configuration
     64                      (+++) Enable the clock for the TIM GPIOs using the following function:
     65                       __HAL_RCC_GPIOx_CLK_ENABLE();
     66                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     67          
     68               (#) The external Clock can be configured, if needed (the default clock is the
     69                   internal clock from the APBx), using the following function:
     70                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     71                   any start function.
     72          
     73               (#) Configure the TIM in the desired functioning mode using one of the
     74                 Initialization function of this driver:
     75                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     76                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     77                      Output Compare signal.
     78                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     79                      PWM signal.
     80                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     81                      external signal.
     82                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     83                      in One Pulse Mode.
     84                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     85          
     86               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     87                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     88                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     89                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     90                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     91                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     92                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     93          
     94               (#) The DMA Burst is managed with the two following functions:
     95                   HAL_TIM_DMABurst_WriteStart()
     96                   HAL_TIM_DMABurst_ReadStart()
     97          
     98              *** Callback registration ***
     99            =============================================
    100          
    101            [..]
    102            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    103            allows the user to configure dynamically the driver callbacks.
    104          
    105            [..]
    106            Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
    107            @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    108            the Callback ID and a pointer to the user callback function.
    109          
    110            [..]
    111            Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
    112            weak function.
    113            @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    114            and the Callback ID.
    115          
    116            [..]
    117            These functions allow to register/unregister following callbacks:
    118              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    119              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    120              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    121              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    122              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    123              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    124              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    125              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    126              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    127              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    128              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    129              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    130              (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    131              (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    132              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    133              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    134              (+) TriggerCallback                   : TIM Trigger Callback.
    135              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    136              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    137              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    138              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    139              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    140              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    141              (+) ErrorCallback                     : TIM Error Callback.
    142              (+) CommutationCallback               : TIM Commutation Callback.
    143              (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    144              (+) BreakCallback                     : TIM Break Callback.
    145              (+) Break2Callback                    : TIM Break2 Callback (when supported).
    146          
    147            [..]
    148          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    149          all interrupt callbacks are set to the corresponding weak functions:
    150            examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().
    151          
    152            [..]
    153            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    154            functionalities in the Init / DeInit only when these callbacks are null
    155            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    156              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    157          
    158            [..]
    159              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    160              Exception done MspInit / MspDeInit that can be registered / unregistered
    161              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    162              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    163            In that case first register the MspInit/MspDeInit user callbacks
    164                using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    165          
    166            [..]
    167                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    168                not defined, the callback registration feature is not available and all callbacks
    169                are set to the corresponding weak functions.
    170          
    171            @endverbatim
    172            ******************************************************************************
    173            * @attention
    174            *
    175            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    176            * All rights reserved.</center></h2>
    177            *
    178            * This software component is licensed by ST under BSD 3-Clause license,
    179            * the "License"; You may not use this file except in compliance with the
    180            * License. You may obtain a copy of the License at:
    181            *                        opensource.org/licenses/BSD-3-Clause
    182            *
    183            ******************************************************************************
    184            */
    185          
    186          /* Includes ------------------------------------------------------------------*/
    187          #include "stm32f3xx_hal.h"
    188          
    189          /** @addtogroup STM32F3xx_HAL_Driver
    190            * @{
    191            */
    192          
    193          /** @defgroup TIM TIM
    194            * @brief TIM HAL module driver
    195            * @{
    196            */
    197          
    198          #ifdef HAL_TIM_MODULE_ENABLED
    199          
    200          /* Private typedef -----------------------------------------------------------*/
    201          /* Private define ------------------------------------------------------------*/
    202          /* Private macro -------------------------------------------------------------*/
    203          /* Private variables ---------------------------------------------------------*/
    204          /* Private function prototypes -----------------------------------------------*/
    205          /** @addtogroup TIM_Private_Functions
    206            * @{
    207            */
    208          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    209          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    210          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    211          #if defined(TIM_CCER_CC5E)
    212          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    213          #endif /* TIM_CCER_CC5E */
    214          #if defined(TIM_CCER_CC6E)
    215          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    216          #endif /* TIM_CCER_CC6E */
    217          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    218          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    219                                        uint32_t TIM_ICFilter);
    220          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    221          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    222                                        uint32_t TIM_ICFilter);
    223          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    224                                        uint32_t TIM_ICFilter);
    225          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    226          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    227          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    228          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    229          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    230          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    231                                                            TIM_SlaveConfigTypeDef *sSlaveConfig);
    232          /**
    233            * @}
    234            */
    235          /* Exported functions --------------------------------------------------------*/
    236          
    237          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    238            * @{
    239            */
    240          
    241          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    242            *  @brief    Time Base functions
    243            *
    244          @verbatim
    245            ==============================================================================
    246                        ##### Time Base functions #####
    247            ==============================================================================
    248            [..]
    249              This section provides functions allowing to:
    250              (+) Initialize and configure the TIM base.
    251              (+) De-initialize the TIM base.
    252              (+) Start the Time Base.
    253              (+) Stop the Time Base.
    254              (+) Start the Time Base and enable interrupt.
    255              (+) Stop the Time Base and disable interrupt.
    256              (+) Start the Time Base and enable DMA transfer.
    257              (+) Stop the Time Base and disable DMA transfer.
    258          
    259          @endverbatim
    260            * @{
    261            */
    262          /**
    263            * @brief  Initializes the TIM Time base Unit according to the specified
    264            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    265            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    266            *         requires a timer reset to avoid unexpected direction
    267            *         due to DIR bit readonly in center aligned mode.
    268            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    269            * @param  htim TIM Base handle
    270            * @retval HAL status
    271            */
    272          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    273          {
    274            /* Check the TIM handle allocation */
    275            if (htim == NULL)
    276            {
    277              return HAL_ERROR;
    278            }
    279          
    280            /* Check the parameters */
    281            assert_param(IS_TIM_INSTANCE(htim->Instance));
    282            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    283            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    284            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    285          
    286            if (htim->State == HAL_TIM_STATE_RESET)
    287            {
    288              /* Allocate lock resource and initialize it */
    289              htim->Lock = HAL_UNLOCKED;
    290          
    291          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    292              /* Reset interrupt callbacks to legacy weak callbacks */
    293              TIM_ResetCallback(htim);
    294          
    295              if (htim->Base_MspInitCallback == NULL)
    296              {
    297                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    298              }
    299              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    300              htim->Base_MspInitCallback(htim);
    301          #else
    302              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    303              HAL_TIM_Base_MspInit(htim);
    304          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    305            }
    306          
    307            /* Set the TIM state */
    308            htim->State = HAL_TIM_STATE_BUSY;
    309          
    310            /* Set the Time Base configuration */
    311            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    312          
    313            /* Initialize the TIM state*/
    314            htim->State = HAL_TIM_STATE_READY;
    315          
    316            return HAL_OK;
    317          }
    318          
    319          /**
    320            * @brief  DeInitializes the TIM Base peripheral
    321            * @param  htim TIM Base handle
    322            * @retval HAL status
    323            */
    324          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    325          {
    326            /* Check the parameters */
    327            assert_param(IS_TIM_INSTANCE(htim->Instance));
    328          
    329            htim->State = HAL_TIM_STATE_BUSY;
    330          
    331            /* Disable the TIM Peripheral Clock */
    332            __HAL_TIM_DISABLE(htim);
    333          
    334          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    335            if (htim->Base_MspDeInitCallback == NULL)
    336            {
    337              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    338            }
    339            /* DeInit the low level hardware */
    340            htim->Base_MspDeInitCallback(htim);
    341          #else
    342            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    343            HAL_TIM_Base_MspDeInit(htim);
    344          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    345          
    346            /* Change TIM state */
    347            htim->State = HAL_TIM_STATE_RESET;
    348          
    349            /* Release Lock */
    350            __HAL_UNLOCK(htim);
    351          
    352            return HAL_OK;
    353          }
    354          
    355          /**
    356            * @brief  Initializes the TIM Base MSP.
    357            * @param  htim TIM Base handle
    358            * @retval None
    359            */
    360          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    361          {
    362            /* Prevent unused argument(s) compilation warning */
    363            UNUSED(htim);
    364          
    365            /* NOTE : This function should not be modified, when the callback is needed,
    366                      the HAL_TIM_Base_MspInit could be implemented in the user file
    367             */
    368          }
    369          
    370          /**
    371            * @brief  DeInitializes TIM Base MSP.
    372            * @param  htim TIM Base handle
    373            * @retval None
    374            */
    375          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    376          {
    377            /* Prevent unused argument(s) compilation warning */
    378            UNUSED(htim);
    379          
    380            /* NOTE : This function should not be modified, when the callback is needed,
    381                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    382             */
    383          }
    384          
    385          
    386          /**
    387            * @brief  Starts the TIM Base generation.
    388            * @param  htim TIM Base handle
    389            * @retval HAL status
    390            */
    391          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    392          {
    393            uint32_t tmpsmcr;
    394          
    395            /* Check the parameters */
    396            assert_param(IS_TIM_INSTANCE(htim->Instance));
    397          
    398            /* Set the TIM state */
    399            htim->State = HAL_TIM_STATE_BUSY;
    400          
    401            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    402            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    403            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    404            {
    405              __HAL_TIM_ENABLE(htim);
    406            }
    407          
    408            /* Change the TIM state*/
    409            htim->State = HAL_TIM_STATE_READY;
    410          
    411            /* Return function status */
    412            return HAL_OK;
    413          }
    414          
    415          /**
    416            * @brief  Stops the TIM Base generation.
    417            * @param  htim TIM Base handle
    418            * @retval HAL status
    419            */
    420          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_TIM_INSTANCE(htim->Instance));
    424          
    425            /* Set the TIM state */
    426            htim->State = HAL_TIM_STATE_BUSY;
    427          
    428            /* Disable the Peripheral */
    429            __HAL_TIM_DISABLE(htim);
    430          
    431            /* Change the TIM state*/
    432            htim->State = HAL_TIM_STATE_READY;
    433          
    434            /* Return function status */
    435            return HAL_OK;
    436          }
    437          
    438          /**
    439            * @brief  Starts the TIM Base generation in interrupt mode.
    440            * @param  htim TIM Base handle
    441            * @retval HAL status
    442            */
    443          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    444          {
    445            uint32_t tmpsmcr;
    446          
    447            /* Check the parameters */
    448            assert_param(IS_TIM_INSTANCE(htim->Instance));
    449          
    450            /* Enable the TIM Update interrupt */
    451            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
    452          
    453            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    454            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    455            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    456            {
    457              __HAL_TIM_ENABLE(htim);
    458            }
    459          
    460            /* Return function status */
    461            return HAL_OK;
    462          }
    463          
    464          /**
    465            * @brief  Stops the TIM Base generation in interrupt mode.
    466            * @param  htim TIM Base handle
    467            * @retval HAL status
    468            */
    469          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    470          {
    471            /* Check the parameters */
    472            assert_param(IS_TIM_INSTANCE(htim->Instance));
    473            /* Disable the TIM Update interrupt */
    474            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
    475          
    476            /* Disable the Peripheral */
    477            __HAL_TIM_DISABLE(htim);
    478          
    479            /* Return function status */
    480            return HAL_OK;
    481          }
    482          
    483          /**
    484            * @brief  Starts the TIM Base generation in DMA mode.
    485            * @param  htim TIM Base handle
    486            * @param  pData The source Buffer address.
    487            * @param  Length The length of data to be transferred from memory to peripheral.
    488            * @retval HAL status
    489            */
    490          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    491          {
    492            uint32_t tmpsmcr;
    493          
    494            /* Check the parameters */
    495            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    496          
    497            if (htim->State == HAL_TIM_STATE_BUSY)
    498            {
    499              return HAL_BUSY;
    500            }
    501            else if (htim->State == HAL_TIM_STATE_READY)
    502            {
    503              if ((pData == NULL) && (Length > 0U))
    504              {
    505                return HAL_ERROR;
    506              }
    507              else
    508              {
    509                htim->State = HAL_TIM_STATE_BUSY;
    510              }
    511            }
    512            else
    513            {
    514              /* nothing to do */
    515            }
    516          
    517            /* Set the DMA Period elapsed callbacks */
    518            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
    519            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
    520          
    521            /* Set the DMA error callback */
    522            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
    523          
    524            /* Enable the DMA channel */
    525            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
    526            {
    527              return HAL_ERROR;
    528            }
    529          
    530            /* Enable the TIM Update DMA request */
    531            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
    532          
    533            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    534            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    535            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    536            {
    537              __HAL_TIM_ENABLE(htim);
    538            }
    539          
    540            /* Return function status */
    541            return HAL_OK;
    542          }
    543          
    544          /**
    545            * @brief  Stops the TIM Base generation in DMA mode.
    546            * @param  htim TIM Base handle
    547            * @retval HAL status
    548            */
    549          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    550          {
    551            /* Check the parameters */
    552            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    553          
    554            /* Disable the TIM Update DMA request */
    555            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
    556          
    557            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
    558          
    559            /* Disable the Peripheral */
    560            __HAL_TIM_DISABLE(htim);
    561          
    562            /* Change the htim state */
    563            htim->State = HAL_TIM_STATE_READY;
    564          
    565            /* Return function status */
    566            return HAL_OK;
    567          }
    568          
    569          /**
    570            * @}
    571            */
    572          
    573          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    574            *  @brief    TIM Output Compare functions
    575            *
    576          @verbatim
    577            ==============================================================================
    578                            ##### TIM Output Compare functions #####
    579            ==============================================================================
    580            [..]
    581              This section provides functions allowing to:
    582              (+) Initialize and configure the TIM Output Compare.
    583              (+) De-initialize the TIM Output Compare.
    584              (+) Start the TIM Output Compare.
    585              (+) Stop the TIM Output Compare.
    586              (+) Start the TIM Output Compare and enable interrupt.
    587              (+) Stop the TIM Output Compare and disable interrupt.
    588              (+) Start the TIM Output Compare and enable DMA transfer.
    589              (+) Stop the TIM Output Compare and disable DMA transfer.
    590          
    591          @endverbatim
    592            * @{
    593            */
    594          /**
    595            * @brief  Initializes the TIM Output Compare according to the specified
    596            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    597            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    598            *         requires a timer reset to avoid unexpected direction
    599            *         due to DIR bit readonly in center aligned mode.
    600            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    601            * @param  htim TIM Output Compare handle
    602            * @retval HAL status
    603            */
    604          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    605          {
    606            /* Check the TIM handle allocation */
    607            if (htim == NULL)
    608            {
    609              return HAL_ERROR;
    610            }
    611          
    612            /* Check the parameters */
    613            assert_param(IS_TIM_INSTANCE(htim->Instance));
    614            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    615            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    616            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    617          
    618            if (htim->State == HAL_TIM_STATE_RESET)
    619            {
    620              /* Allocate lock resource and initialize it */
    621              htim->Lock = HAL_UNLOCKED;
    622          
    623          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    624              /* Reset interrupt callbacks to legacy weak callbacks */
    625              TIM_ResetCallback(htim);
    626          
    627              if (htim->OC_MspInitCallback == NULL)
    628              {
    629                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    630              }
    631              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    632              htim->OC_MspInitCallback(htim);
    633          #else
    634              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    635              HAL_TIM_OC_MspInit(htim);
    636          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    637            }
    638          
    639            /* Set the TIM state */
    640            htim->State = HAL_TIM_STATE_BUSY;
    641          
    642            /* Init the base time for the Output Compare */
    643            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
    644          
    645            /* Initialize the TIM state*/
    646            htim->State = HAL_TIM_STATE_READY;
    647          
    648            return HAL_OK;
    649          }
    650          
    651          /**
    652            * @brief  DeInitializes the TIM peripheral
    653            * @param  htim TIM Output Compare handle
    654            * @retval HAL status
    655            */
    656          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    657          {
    658            /* Check the parameters */
    659            assert_param(IS_TIM_INSTANCE(htim->Instance));
    660          
    661            htim->State = HAL_TIM_STATE_BUSY;
    662          
    663            /* Disable the TIM Peripheral Clock */
    664            __HAL_TIM_DISABLE(htim);
    665          
    666          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    667            if (htim->OC_MspDeInitCallback == NULL)
    668            {
    669              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    670            }
    671            /* DeInit the low level hardware */
    672            htim->OC_MspDeInitCallback(htim);
    673          #else
    674            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    675            HAL_TIM_OC_MspDeInit(htim);
    676          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    677          
    678            /* Change TIM state */
    679            htim->State = HAL_TIM_STATE_RESET;
    680          
    681            /* Release Lock */
    682            __HAL_UNLOCK(htim);
    683          
    684            return HAL_OK;
    685          }
    686          
    687          /**
    688            * @brief  Initializes the TIM Output Compare MSP.
    689            * @param  htim TIM Output Compare handle
    690            * @retval None
    691            */
    692          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    693          {
    694            /* Prevent unused argument(s) compilation warning */
    695            UNUSED(htim);
    696          
    697            /* NOTE : This function should not be modified, when the callback is needed,
    698                      the HAL_TIM_OC_MspInit could be implemented in the user file
    699             */
    700          }
    701          
    702          /**
    703            * @brief  DeInitializes TIM Output Compare MSP.
    704            * @param  htim TIM Output Compare handle
    705            * @retval None
    706            */
    707          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    708          {
    709            /* Prevent unused argument(s) compilation warning */
    710            UNUSED(htim);
    711          
    712            /* NOTE : This function should not be modified, when the callback is needed,
    713                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    714             */
    715          }
    716          
    717          /**
    718            * @brief  Starts the TIM Output Compare signal generation.
    719            * @param  htim TIM Output Compare handle
    720            * @param  Channel TIM Channel to be enabled
    721            *          This parameter can be one of the following values:
    722            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    723            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    724            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    725            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    726            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected (*)
    727            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected (*)
    728            *         (*) Value not defined for all devices
    729            * @retval HAL status
    730            */
    731          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    732          {
    733            uint32_t tmpsmcr;
    734          
    735            /* Check the parameters */
    736            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    737          
    738            /* Enable the Output compare channel */
    739            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    740          
    741            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    742            {
    743              /* Enable the main output */
    744              __HAL_TIM_MOE_ENABLE(htim);
    745            }
    746          
    747            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    748            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    749            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    750            {
    751              __HAL_TIM_ENABLE(htim);
    752            }
    753          
    754            /* Return function status */
    755            return HAL_OK;
    756          }
    757          
    758          /**
    759            * @brief  Stops the TIM Output Compare signal generation.
    760            * @param  htim TIM Output Compare handle
    761            * @param  Channel TIM Channel to be disabled
    762            *          This parameter can be one of the following values:
    763            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    764            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    765            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    766            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    767            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected (*)
    768            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected (*)
    769            *         (*) Value not defined for all devices
    770            * @retval HAL status
    771            */
    772          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    773          {
    774            /* Check the parameters */
    775            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    776          
    777            /* Disable the Output compare channel */
    778            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    779          
    780            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    781            {
    782              /* Disable the Main Output */
    783              __HAL_TIM_MOE_DISABLE(htim);
    784            }
    785          
    786            /* Disable the Peripheral */
    787            __HAL_TIM_DISABLE(htim);
    788          
    789            /* Return function status */
    790            return HAL_OK;
    791          }
    792          
    793          /**
    794            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    795            * @param  htim TIM Output Compare handle
    796            * @param  Channel TIM Channel to be enabled
    797            *          This parameter can be one of the following values:
    798            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    799            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    800            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    801            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    802            * @retval HAL status
    803            */
    804          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    805          {
    806            uint32_t tmpsmcr;
    807          
    808            /* Check the parameters */
    809            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    810          
    811            switch (Channel)
    812            {
    813              case TIM_CHANNEL_1:
    814              {
    815                /* Enable the TIM Capture/Compare 1 interrupt */
    816                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    817                break;
    818              }
    819          
    820              case TIM_CHANNEL_2:
    821              {
    822                /* Enable the TIM Capture/Compare 2 interrupt */
    823                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    824                break;
    825              }
    826          
    827              case TIM_CHANNEL_3:
    828              {
    829                /* Enable the TIM Capture/Compare 3 interrupt */
    830                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    831                break;
    832              }
    833          
    834              case TIM_CHANNEL_4:
    835              {
    836                /* Enable the TIM Capture/Compare 4 interrupt */
    837                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    838                break;
    839              }
    840          
    841              default:
    842                break;
    843            }
    844          
    845            /* Enable the Output compare channel */
    846            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    847          
    848            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    849            {
    850              /* Enable the main output */
    851              __HAL_TIM_MOE_ENABLE(htim);
    852            }
    853          
    854            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    855            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
    856            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
    857            {
    858              __HAL_TIM_ENABLE(htim);
    859            }
    860          
    861            /* Return function status */
    862            return HAL_OK;
    863          }
    864          
    865          /**
    866            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    867            * @param  htim TIM Output Compare handle
    868            * @param  Channel TIM Channel to be disabled
    869            *          This parameter can be one of the following values:
    870            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    871            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    872            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    873            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    874            * @retval HAL status
    875            */
    876          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    877          {
    878            /* Check the parameters */
    879            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    880          
    881            switch (Channel)
    882            {
    883              case TIM_CHANNEL_1:
    884              {
    885                /* Disable the TIM Capture/Compare 1 interrupt */
    886                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    887                break;
    888              }
    889          
    890              case TIM_CHANNEL_2:
    891              {
    892                /* Disable the TIM Capture/Compare 2 interrupt */
    893                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    894                break;
    895              }
    896          
    897              case TIM_CHANNEL_3:
    898              {
    899                /* Disable the TIM Capture/Compare 3 interrupt */
    900                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    901                break;
    902              }
    903          
    904              case TIM_CHANNEL_4:
    905              {
    906                /* Disable the TIM Capture/Compare 4 interrupt */
    907                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
    908                break;
    909              }
    910          
    911              default:
    912                break;
    913            }
    914          
    915            /* Disable the Output compare channel */
    916            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    917          
    918            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    919            {
    920              /* Disable the Main Output */
    921              __HAL_TIM_MOE_DISABLE(htim);
    922            }
    923          
    924            /* Disable the Peripheral */
    925            __HAL_TIM_DISABLE(htim);
    926          
    927            /* Return function status */
    928            return HAL_OK;
    929          }
    930          
    931          /**
    932            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    933            * @param  htim TIM Output Compare handle
    934            * @param  Channel TIM Channel to be enabled
    935            *          This parameter can be one of the following values:
    936            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    937            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    938            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    939            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    940            * @param  pData The source Buffer address.
    941            * @param  Length The length of data to be transferred from memory to TIM peripheral
    942            * @retval HAL status
    943            */
    944          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    945          {
    946            uint32_t tmpsmcr;
    947          
    948            /* Check the parameters */
    949            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    950          
    951            if (htim->State == HAL_TIM_STATE_BUSY)
    952            {
    953              return HAL_BUSY;
    954            }
    955            else if (htim->State == HAL_TIM_STATE_READY)
    956            {
    957              if ((pData == NULL) && (Length > 0U))
    958              {
    959                return HAL_ERROR;
    960              }
    961              else
    962              {
    963                htim->State = HAL_TIM_STATE_BUSY;
    964              }
    965            }
    966            else
    967            {
    968              /* nothing to do */
    969            }
    970          
    971            switch (Channel)
    972            {
    973              case TIM_CHANNEL_1:
    974              {
    975                /* Set the DMA compare callbacks */
    976                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
    977                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    978          
    979                /* Set the DMA error callback */
    980                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    981          
    982                /* Enable the DMA channel */
    983                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
    984                {
    985                  return HAL_ERROR;
    986                }
    987          
    988                /* Enable the TIM Capture/Compare 1 DMA request */
    989                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    990                break;
    991              }
    992          
    993              case TIM_CHANNEL_2:
    994              {
    995                /* Set the DMA compare callbacks */
    996                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
    997                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    998          
    999                /* Set the DMA error callback */
   1000                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1001          
   1002                /* Enable the DMA channel */
   1003                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   1004                {
   1005                  return HAL_ERROR;
   1006                }
   1007          
   1008                /* Enable the TIM Capture/Compare 2 DMA request */
   1009                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1010                break;
   1011              }
   1012          
   1013              case TIM_CHANNEL_3:
   1014              {
   1015                /* Set the DMA compare callbacks */
   1016                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1017                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1018          
   1019                /* Set the DMA error callback */
   1020                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1021          
   1022                /* Enable the DMA channel */
   1023                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   1024                {
   1025                  return HAL_ERROR;
   1026                }
   1027                /* Enable the TIM Capture/Compare 3 DMA request */
   1028                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1029                break;
   1030              }
   1031          
   1032              case TIM_CHANNEL_4:
   1033              {
   1034                /* Set the DMA compare callbacks */
   1035                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1036                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1037          
   1038                /* Set the DMA error callback */
   1039                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1040          
   1041                /* Enable the DMA channel */
   1042                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   1043                {
   1044                  return HAL_ERROR;
   1045                }
   1046                /* Enable the TIM Capture/Compare 4 DMA request */
   1047                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1048                break;
   1049              }
   1050          
   1051              default:
   1052                break;
   1053            }
   1054          
   1055            /* Enable the Output compare channel */
   1056            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1057          
   1058            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1059            {
   1060              /* Enable the main output */
   1061              __HAL_TIM_MOE_ENABLE(htim);
   1062            }
   1063          
   1064            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1065            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1066            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1067            {
   1068              __HAL_TIM_ENABLE(htim);
   1069            }
   1070          
   1071            /* Return function status */
   1072            return HAL_OK;
   1073          }
   1074          
   1075          /**
   1076            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1077            * @param  htim TIM Output Compare handle
   1078            * @param  Channel TIM Channel to be disabled
   1079            *          This parameter can be one of the following values:
   1080            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1081            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1082            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1083            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1084            * @retval HAL status
   1085            */
   1086          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1087          {
   1088            /* Check the parameters */
   1089            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1090          
   1091            switch (Channel)
   1092            {
   1093              case TIM_CHANNEL_1:
   1094              {
   1095                /* Disable the TIM Capture/Compare 1 DMA request */
   1096                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1097                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1098                break;
   1099              }
   1100          
   1101              case TIM_CHANNEL_2:
   1102              {
   1103                /* Disable the TIM Capture/Compare 2 DMA request */
   1104                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1105                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1106                break;
   1107              }
   1108          
   1109              case TIM_CHANNEL_3:
   1110              {
   1111                /* Disable the TIM Capture/Compare 3 DMA request */
   1112                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1113                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1114                break;
   1115              }
   1116          
   1117              case TIM_CHANNEL_4:
   1118              {
   1119                /* Disable the TIM Capture/Compare 4 interrupt */
   1120                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1121                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1122                break;
   1123              }
   1124          
   1125              default:
   1126                break;
   1127            }
   1128          
   1129            /* Disable the Output compare channel */
   1130            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1131          
   1132            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1133            {
   1134              /* Disable the Main Output */
   1135              __HAL_TIM_MOE_DISABLE(htim);
   1136            }
   1137          
   1138            /* Disable the Peripheral */
   1139            __HAL_TIM_DISABLE(htim);
   1140          
   1141            /* Change the htim state */
   1142            htim->State = HAL_TIM_STATE_READY;
   1143          
   1144            /* Return function status */
   1145            return HAL_OK;
   1146          }
   1147          
   1148          /**
   1149            * @}
   1150            */
   1151          
   1152          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1153            *  @brief    TIM PWM functions
   1154            *
   1155          @verbatim
   1156            ==============================================================================
   1157                                    ##### TIM PWM functions #####
   1158            ==============================================================================
   1159            [..]
   1160              This section provides functions allowing to:
   1161              (+) Initialize and configure the TIM PWM.
   1162              (+) De-initialize the TIM PWM.
   1163              (+) Start the TIM PWM.
   1164              (+) Stop the TIM PWM.
   1165              (+) Start the TIM PWM and enable interrupt.
   1166              (+) Stop the TIM PWM and disable interrupt.
   1167              (+) Start the TIM PWM and enable DMA transfer.
   1168              (+) Stop the TIM PWM and disable DMA transfer.
   1169          
   1170          @endverbatim
   1171            * @{
   1172            */
   1173          /**
   1174            * @brief  Initializes the TIM PWM Time Base according to the specified
   1175            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1176            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1177            *         requires a timer reset to avoid unexpected direction
   1178            *         due to DIR bit readonly in center aligned mode.
   1179            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1180            * @param  htim TIM PWM handle
   1181            * @retval HAL status
   1182            */
   1183          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1184          {
   1185            /* Check the TIM handle allocation */
   1186            if (htim == NULL)
   1187            {
   1188              return HAL_ERROR;
   1189            }
   1190          
   1191            /* Check the parameters */
   1192            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1193            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1194            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1195            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1196          
   1197            if (htim->State == HAL_TIM_STATE_RESET)
   1198            {
   1199              /* Allocate lock resource and initialize it */
   1200              htim->Lock = HAL_UNLOCKED;
   1201          
   1202          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1203              /* Reset interrupt callbacks to legacy weak callbacks */
   1204              TIM_ResetCallback(htim);
   1205          
   1206              if (htim->PWM_MspInitCallback == NULL)
   1207              {
   1208                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1209              }
   1210              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1211              htim->PWM_MspInitCallback(htim);
   1212          #else
   1213              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1214              HAL_TIM_PWM_MspInit(htim);
   1215          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1216            }
   1217          
   1218            /* Set the TIM state */
   1219            htim->State = HAL_TIM_STATE_BUSY;
   1220          
   1221            /* Init the base time for the PWM */
   1222            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1223          
   1224            /* Initialize the TIM state*/
   1225            htim->State = HAL_TIM_STATE_READY;
   1226          
   1227            return HAL_OK;
   1228          }
   1229          
   1230          /**
   1231            * @brief  DeInitializes the TIM peripheral
   1232            * @param  htim TIM PWM handle
   1233            * @retval HAL status
   1234            */
   1235          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1236          {
   1237            /* Check the parameters */
   1238            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1239          
   1240            htim->State = HAL_TIM_STATE_BUSY;
   1241          
   1242            /* Disable the TIM Peripheral Clock */
   1243            __HAL_TIM_DISABLE(htim);
   1244          
   1245          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1246            if (htim->PWM_MspDeInitCallback == NULL)
   1247            {
   1248              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1249            }
   1250            /* DeInit the low level hardware */
   1251            htim->PWM_MspDeInitCallback(htim);
   1252          #else
   1253            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1254            HAL_TIM_PWM_MspDeInit(htim);
   1255          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1256          
   1257            /* Change TIM state */
   1258            htim->State = HAL_TIM_STATE_RESET;
   1259          
   1260            /* Release Lock */
   1261            __HAL_UNLOCK(htim);
   1262          
   1263            return HAL_OK;
   1264          }
   1265          
   1266          /**
   1267            * @brief  Initializes the TIM PWM MSP.
   1268            * @param  htim TIM PWM handle
   1269            * @retval None
   1270            */
   1271          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1272          {
   1273            /* Prevent unused argument(s) compilation warning */
   1274            UNUSED(htim);
   1275          
   1276            /* NOTE : This function should not be modified, when the callback is needed,
   1277                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1278             */
   1279          }
   1280          
   1281          /**
   1282            * @brief  DeInitializes TIM PWM MSP.
   1283            * @param  htim TIM PWM handle
   1284            * @retval None
   1285            */
   1286          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1287          {
   1288            /* Prevent unused argument(s) compilation warning */
   1289            UNUSED(htim);
   1290          
   1291            /* NOTE : This function should not be modified, when the callback is needed,
   1292                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1293             */
   1294          }
   1295          
   1296          /**
   1297            * @brief  Starts the PWM signal generation.
   1298            * @param  htim TIM handle
   1299            * @param  Channel TIM Channels to be enabled
   1300            *          This parameter can be one of the following values:
   1301            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1302            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1303            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1304            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1305            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected (*)
   1306            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected (*)
   1307            *         (*) Value not defined for all devices
   1308            * @retval HAL status
   1309            */
   1310          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1311          {
   1312            uint32_t tmpsmcr;
   1313          
   1314            /* Check the parameters */
   1315            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1316          
   1317            /* Enable the Capture compare channel */
   1318            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1319          
   1320            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1321            {
   1322              /* Enable the main output */
   1323              __HAL_TIM_MOE_ENABLE(htim);
   1324            }
   1325          
   1326            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1327            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1328            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1329            {
   1330              __HAL_TIM_ENABLE(htim);
   1331            }
   1332          
   1333            /* Return function status */
   1334            return HAL_OK;
   1335          }
   1336          
   1337          /**
   1338            * @brief  Stops the PWM signal generation.
   1339            * @param  htim TIM PWM handle
   1340            * @param  Channel TIM Channels to be disabled
   1341            *          This parameter can be one of the following values:
   1342            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1343            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1344            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1345            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1346            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected (*)
   1347            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected (*)
   1348            *         (*) Value not defined for all devices
   1349            * @retval HAL status
   1350            */
   1351          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1352          {
   1353            /* Check the parameters */
   1354            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1355          
   1356            /* Disable the Capture compare channel */
   1357            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1358          
   1359            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1360            {
   1361              /* Disable the Main Output */
   1362              __HAL_TIM_MOE_DISABLE(htim);
   1363            }
   1364          
   1365            /* Disable the Peripheral */
   1366            __HAL_TIM_DISABLE(htim);
   1367          
   1368            /* Change the htim state */
   1369            htim->State = HAL_TIM_STATE_READY;
   1370          
   1371            /* Return function status */
   1372            return HAL_OK;
   1373          }
   1374          
   1375          /**
   1376            * @brief  Starts the PWM signal generation in interrupt mode.
   1377            * @param  htim TIM PWM handle
   1378            * @param  Channel TIM Channel to be enabled
   1379            *          This parameter can be one of the following values:
   1380            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1381            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1382            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1383            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1384            * @retval HAL status
   1385            */
   1386          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1387          {
   1388            uint32_t tmpsmcr;
   1389            /* Check the parameters */
   1390            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1391          
   1392            switch (Channel)
   1393            {
   1394              case TIM_CHANNEL_1:
   1395              {
   1396                /* Enable the TIM Capture/Compare 1 interrupt */
   1397                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1398                break;
   1399              }
   1400          
   1401              case TIM_CHANNEL_2:
   1402              {
   1403                /* Enable the TIM Capture/Compare 2 interrupt */
   1404                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1405                break;
   1406              }
   1407          
   1408              case TIM_CHANNEL_3:
   1409              {
   1410                /* Enable the TIM Capture/Compare 3 interrupt */
   1411                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1412                break;
   1413              }
   1414          
   1415              case TIM_CHANNEL_4:
   1416              {
   1417                /* Enable the TIM Capture/Compare 4 interrupt */
   1418                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1419                break;
   1420              }
   1421          
   1422              default:
   1423                break;
   1424            }
   1425          
   1426            /* Enable the Capture compare channel */
   1427            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1428          
   1429            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1430            {
   1431              /* Enable the main output */
   1432              __HAL_TIM_MOE_ENABLE(htim);
   1433            }
   1434          
   1435            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1436            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1437            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1438            {
   1439              __HAL_TIM_ENABLE(htim);
   1440            }
   1441          
   1442            /* Return function status */
   1443            return HAL_OK;
   1444          }
   1445          
   1446          /**
   1447            * @brief  Stops the PWM signal generation in interrupt mode.
   1448            * @param  htim TIM PWM handle
   1449            * @param  Channel TIM Channels to be disabled
   1450            *          This parameter can be one of the following values:
   1451            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1452            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1453            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1454            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1455            * @retval HAL status
   1456            */
   1457          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1458          {
   1459            /* Check the parameters */
   1460            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1461          
   1462            switch (Channel)
   1463            {
   1464              case TIM_CHANNEL_1:
   1465              {
   1466                /* Disable the TIM Capture/Compare 1 interrupt */
   1467                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1468                break;
   1469              }
   1470          
   1471              case TIM_CHANNEL_2:
   1472              {
   1473                /* Disable the TIM Capture/Compare 2 interrupt */
   1474                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1475                break;
   1476              }
   1477          
   1478              case TIM_CHANNEL_3:
   1479              {
   1480                /* Disable the TIM Capture/Compare 3 interrupt */
   1481                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1482                break;
   1483              }
   1484          
   1485              case TIM_CHANNEL_4:
   1486              {
   1487                /* Disable the TIM Capture/Compare 4 interrupt */
   1488                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1489                break;
   1490              }
   1491          
   1492              default:
   1493                break;
   1494            }
   1495          
   1496            /* Disable the Capture compare channel */
   1497            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1498          
   1499            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1500            {
   1501              /* Disable the Main Output */
   1502              __HAL_TIM_MOE_DISABLE(htim);
   1503            }
   1504          
   1505            /* Disable the Peripheral */
   1506            __HAL_TIM_DISABLE(htim);
   1507          
   1508            /* Return function status */
   1509            return HAL_OK;
   1510          }
   1511          
   1512          /**
   1513            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1514            * @param  htim TIM PWM handle
   1515            * @param  Channel TIM Channels to be enabled
   1516            *          This parameter can be one of the following values:
   1517            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1518            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1519            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1520            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1521            * @param  pData The source Buffer address.
   1522            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1523            * @retval HAL status
   1524            */
   1525          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1526          {
   1527            uint32_t tmpsmcr;
   1528          
   1529            /* Check the parameters */
   1530            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1531          
   1532            if (htim->State == HAL_TIM_STATE_BUSY)
   1533            {
   1534              return HAL_BUSY;
   1535            }
   1536            else if (htim->State == HAL_TIM_STATE_READY)
   1537            {
   1538              if ((pData == NULL) && (Length > 0U))
   1539              {
   1540                return HAL_ERROR;
   1541              }
   1542              else
   1543              {
   1544                htim->State = HAL_TIM_STATE_BUSY;
   1545              }
   1546            }
   1547            else
   1548            {
   1549              /* nothing to do */
   1550            }
   1551          
   1552            switch (Channel)
   1553            {
   1554              case TIM_CHANNEL_1:
   1555              {
   1556                /* Set the DMA compare callbacks */
   1557                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1558                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1559          
   1560                /* Set the DMA error callback */
   1561                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1562          
   1563                /* Enable the DMA channel */
   1564                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   1565                {
   1566                  return HAL_ERROR;
   1567                }
   1568          
   1569                /* Enable the TIM Capture/Compare 1 DMA request */
   1570                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1571                break;
   1572              }
   1573          
   1574              case TIM_CHANNEL_2:
   1575              {
   1576                /* Set the DMA compare callbacks */
   1577                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1578                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1579          
   1580                /* Set the DMA error callback */
   1581                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1582          
   1583                /* Enable the DMA channel */
   1584                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   1585                {
   1586                  return HAL_ERROR;
   1587                }
   1588                /* Enable the TIM Capture/Compare 2 DMA request */
   1589                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1590                break;
   1591              }
   1592          
   1593              case TIM_CHANNEL_3:
   1594              {
   1595                /* Set the DMA compare callbacks */
   1596                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1597                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1598          
   1599                /* Set the DMA error callback */
   1600                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1601          
   1602                /* Enable the DMA channel */
   1603                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   1604                {
   1605                  return HAL_ERROR;
   1606                }
   1607                /* Enable the TIM Output Capture/Compare 3 request */
   1608                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1609                break;
   1610              }
   1611          
   1612              case TIM_CHANNEL_4:
   1613              {
   1614                /* Set the DMA compare callbacks */
   1615                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1616                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1617          
   1618                /* Set the DMA error callback */
   1619                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1620          
   1621                /* Enable the DMA channel */
   1622                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   1623                {
   1624                  return HAL_ERROR;
   1625                }
   1626                /* Enable the TIM Capture/Compare 4 DMA request */
   1627                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1628                break;
   1629              }
   1630          
   1631              default:
   1632                break;
   1633            }
   1634          
   1635            /* Enable the Capture compare channel */
   1636            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1637          
   1638            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1639            {
   1640              /* Enable the main output */
   1641              __HAL_TIM_MOE_ENABLE(htim);
   1642            }
   1643          
   1644            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1645            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1646            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1647            {
   1648              __HAL_TIM_ENABLE(htim);
   1649            }
   1650          
   1651            /* Return function status */
   1652            return HAL_OK;
   1653          }
   1654          
   1655          /**
   1656            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1657            * @param  htim TIM PWM handle
   1658            * @param  Channel TIM Channels to be disabled
   1659            *          This parameter can be one of the following values:
   1660            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1661            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1662            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1663            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1664            * @retval HAL status
   1665            */
   1666          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1667          {
   1668            /* Check the parameters */
   1669            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1670          
   1671            switch (Channel)
   1672            {
   1673              case TIM_CHANNEL_1:
   1674              {
   1675                /* Disable the TIM Capture/Compare 1 DMA request */
   1676                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1677                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   1678                break;
   1679              }
   1680          
   1681              case TIM_CHANNEL_2:
   1682              {
   1683                /* Disable the TIM Capture/Compare 2 DMA request */
   1684                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1685                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   1686                break;
   1687              }
   1688          
   1689              case TIM_CHANNEL_3:
   1690              {
   1691                /* Disable the TIM Capture/Compare 3 DMA request */
   1692                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1693                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   1694                break;
   1695              }
   1696          
   1697              case TIM_CHANNEL_4:
   1698              {
   1699                /* Disable the TIM Capture/Compare 4 interrupt */
   1700                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1701                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   1702                break;
   1703              }
   1704          
   1705              default:
   1706                break;
   1707            }
   1708          
   1709            /* Disable the Capture compare channel */
   1710            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1711          
   1712            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1713            {
   1714              /* Disable the Main Output */
   1715              __HAL_TIM_MOE_DISABLE(htim);
   1716            }
   1717          
   1718            /* Disable the Peripheral */
   1719            __HAL_TIM_DISABLE(htim);
   1720          
   1721            /* Change the htim state */
   1722            htim->State = HAL_TIM_STATE_READY;
   1723          
   1724            /* Return function status */
   1725            return HAL_OK;
   1726          }
   1727          
   1728          /**
   1729            * @}
   1730            */
   1731          
   1732          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1733            *  @brief    TIM Input Capture functions
   1734            *
   1735          @verbatim
   1736            ==============================================================================
   1737                        ##### TIM Input Capture functions #####
   1738            ==============================================================================
   1739           [..]
   1740             This section provides functions allowing to:
   1741             (+) Initialize and configure the TIM Input Capture.
   1742             (+) De-initialize the TIM Input Capture.
   1743             (+) Start the TIM Input Capture.
   1744             (+) Stop the TIM Input Capture.
   1745             (+) Start the TIM Input Capture and enable interrupt.
   1746             (+) Stop the TIM Input Capture and disable interrupt.
   1747             (+) Start the TIM Input Capture and enable DMA transfer.
   1748             (+) Stop the TIM Input Capture and disable DMA transfer.
   1749          
   1750          @endverbatim
   1751            * @{
   1752            */
   1753          /**
   1754            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1755            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1756            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1757            *         requires a timer reset to avoid unexpected direction
   1758            *         due to DIR bit readonly in center aligned mode.
   1759            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1760            * @param  htim TIM Input Capture handle
   1761            * @retval HAL status
   1762            */
   1763          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1764          {
   1765            /* Check the TIM handle allocation */
   1766            if (htim == NULL)
   1767            {
   1768              return HAL_ERROR;
   1769            }
   1770          
   1771            /* Check the parameters */
   1772            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1773            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1774            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1775            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1776          
   1777            if (htim->State == HAL_TIM_STATE_RESET)
   1778            {
   1779              /* Allocate lock resource and initialize it */
   1780              htim->Lock = HAL_UNLOCKED;
   1781          
   1782          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1783              /* Reset interrupt callbacks to legacy weak callbacks */
   1784              TIM_ResetCallback(htim);
   1785          
   1786              if (htim->IC_MspInitCallback == NULL)
   1787              {
   1788                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   1789              }
   1790              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1791              htim->IC_MspInitCallback(htim);
   1792          #else
   1793              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1794              HAL_TIM_IC_MspInit(htim);
   1795          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1796            }
   1797          
   1798            /* Set the TIM state */
   1799            htim->State = HAL_TIM_STATE_BUSY;
   1800          
   1801            /* Init the base time for the input capture */
   1802            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1803          
   1804            /* Initialize the TIM state*/
   1805            htim->State = HAL_TIM_STATE_READY;
   1806          
   1807            return HAL_OK;
   1808          }
   1809          
   1810          /**
   1811            * @brief  DeInitializes the TIM peripheral
   1812            * @param  htim TIM Input Capture handle
   1813            * @retval HAL status
   1814            */
   1815          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1816          {
   1817            /* Check the parameters */
   1818            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1819          
   1820            htim->State = HAL_TIM_STATE_BUSY;
   1821          
   1822            /* Disable the TIM Peripheral Clock */
   1823            __HAL_TIM_DISABLE(htim);
   1824          
   1825          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1826            if (htim->IC_MspDeInitCallback == NULL)
   1827            {
   1828              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   1829            }
   1830            /* DeInit the low level hardware */
   1831            htim->IC_MspDeInitCallback(htim);
   1832          #else
   1833            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1834            HAL_TIM_IC_MspDeInit(htim);
   1835          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1836          
   1837            /* Change TIM state */
   1838            htim->State = HAL_TIM_STATE_RESET;
   1839          
   1840            /* Release Lock */
   1841            __HAL_UNLOCK(htim);
   1842          
   1843            return HAL_OK;
   1844          }
   1845          
   1846          /**
   1847            * @brief  Initializes the TIM Input Capture MSP.
   1848            * @param  htim TIM Input Capture handle
   1849            * @retval None
   1850            */
   1851          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1852          {
   1853            /* Prevent unused argument(s) compilation warning */
   1854            UNUSED(htim);
   1855          
   1856            /* NOTE : This function should not be modified, when the callback is needed,
   1857                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1858             */
   1859          }
   1860          
   1861          /**
   1862            * @brief  DeInitializes TIM Input Capture MSP.
   1863            * @param  htim TIM handle
   1864            * @retval None
   1865            */
   1866          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1867          {
   1868            /* Prevent unused argument(s) compilation warning */
   1869            UNUSED(htim);
   1870          
   1871            /* NOTE : This function should not be modified, when the callback is needed,
   1872                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1873             */
   1874          }
   1875          
   1876          /**
   1877            * @brief  Starts the TIM Input Capture measurement.
   1878            * @param  htim TIM Input Capture handle
   1879            * @param  Channel TIM Channels to be enabled
   1880            *          This parameter can be one of the following values:
   1881            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1882            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1883            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1884            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1885            * @retval HAL status
   1886            */
   1887          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1888          {
   1889            uint32_t tmpsmcr;
   1890          
   1891            /* Check the parameters */
   1892            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1893          
   1894            /* Enable the Input Capture channel */
   1895            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1896          
   1897            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1898            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1899            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1900            {
   1901              __HAL_TIM_ENABLE(htim);
   1902            }
   1903          
   1904            /* Return function status */
   1905            return HAL_OK;
   1906          }
   1907          
   1908          /**
   1909            * @brief  Stops the TIM Input Capture measurement.
   1910            * @param  htim TIM Input Capture handle
   1911            * @param  Channel TIM Channels to be disabled
   1912            *          This parameter can be one of the following values:
   1913            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1914            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1915            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1916            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1917            * @retval HAL status
   1918            */
   1919          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1920          {
   1921            /* Check the parameters */
   1922            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1923          
   1924            /* Disable the Input Capture channel */
   1925            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1926          
   1927            /* Disable the Peripheral */
   1928            __HAL_TIM_DISABLE(htim);
   1929          
   1930            /* Return function status */
   1931            return HAL_OK;
   1932          }
   1933          
   1934          /**
   1935            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1936            * @param  htim TIM Input Capture handle
   1937            * @param  Channel TIM Channels to be enabled
   1938            *          This parameter can be one of the following values:
   1939            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1940            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1941            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1942            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1943            * @retval HAL status
   1944            */
   1945          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1946          {
   1947            uint32_t tmpsmcr;
   1948          
   1949            /* Check the parameters */
   1950            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1951          
   1952            switch (Channel)
   1953            {
   1954              case TIM_CHANNEL_1:
   1955              {
   1956                /* Enable the TIM Capture/Compare 1 interrupt */
   1957                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1958                break;
   1959              }
   1960          
   1961              case TIM_CHANNEL_2:
   1962              {
   1963                /* Enable the TIM Capture/Compare 2 interrupt */
   1964                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1965                break;
   1966              }
   1967          
   1968              case TIM_CHANNEL_3:
   1969              {
   1970                /* Enable the TIM Capture/Compare 3 interrupt */
   1971                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1972                break;
   1973              }
   1974          
   1975              case TIM_CHANNEL_4:
   1976              {
   1977                /* Enable the TIM Capture/Compare 4 interrupt */
   1978                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1979                break;
   1980              }
   1981          
   1982              default:
   1983                break;
   1984            }
   1985            /* Enable the Input Capture channel */
   1986            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1987          
   1988            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1989            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   1990            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   1991            {
   1992              __HAL_TIM_ENABLE(htim);
   1993            }
   1994          
   1995            /* Return function status */
   1996            return HAL_OK;
   1997          }
   1998          
   1999          /**
   2000            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   2001            * @param  htim TIM Input Capture handle
   2002            * @param  Channel TIM Channels to be disabled
   2003            *          This parameter can be one of the following values:
   2004            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2005            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2006            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2007            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2008            * @retval HAL status
   2009            */
   2010          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2011          {
   2012            /* Check the parameters */
   2013            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2014          
   2015            switch (Channel)
   2016            {
   2017              case TIM_CHANNEL_1:
   2018              {
   2019                /* Disable the TIM Capture/Compare 1 interrupt */
   2020                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2021                break;
   2022              }
   2023          
   2024              case TIM_CHANNEL_2:
   2025              {
   2026                /* Disable the TIM Capture/Compare 2 interrupt */
   2027                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2028                break;
   2029              }
   2030          
   2031              case TIM_CHANNEL_3:
   2032              {
   2033                /* Disable the TIM Capture/Compare 3 interrupt */
   2034                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   2035                break;
   2036              }
   2037          
   2038              case TIM_CHANNEL_4:
   2039              {
   2040                /* Disable the TIM Capture/Compare 4 interrupt */
   2041                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   2042                break;
   2043              }
   2044          
   2045              default:
   2046                break;
   2047            }
   2048          
   2049            /* Disable the Input Capture channel */
   2050            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2051          
   2052            /* Disable the Peripheral */
   2053            __HAL_TIM_DISABLE(htim);
   2054          
   2055            /* Return function status */
   2056            return HAL_OK;
   2057          }
   2058          
   2059          /**
   2060            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   2061            * @param  htim TIM Input Capture handle
   2062            * @param  Channel TIM Channels to be enabled
   2063            *          This parameter can be one of the following values:
   2064            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2065            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2066            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2067            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2068            * @param  pData The destination Buffer address.
   2069            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2070            * @retval HAL status
   2071            */
   2072          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   2073          {
   2074            uint32_t tmpsmcr;
   2075          
   2076            /* Check the parameters */
   2077            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2078            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2079          
   2080            if (htim->State == HAL_TIM_STATE_BUSY)
   2081            {
   2082              return HAL_BUSY;
   2083            }
   2084            else if (htim->State == HAL_TIM_STATE_READY)
   2085            {
   2086              if ((pData == NULL) && (Length > 0U))
   2087              {
   2088                return HAL_ERROR;
   2089              }
   2090              else
   2091              {
   2092                htim->State = HAL_TIM_STATE_BUSY;
   2093              }
   2094            }
   2095            else
   2096            {
   2097              /* nothing to do */
   2098            }
   2099          
   2100            switch (Channel)
   2101            {
   2102              case TIM_CHANNEL_1:
   2103              {
   2104                /* Set the DMA capture callbacks */
   2105                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2106                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2107          
   2108                /* Set the DMA error callback */
   2109                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2110          
   2111                /* Enable the DMA channel */
   2112                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   2113                {
   2114                  return HAL_ERROR;
   2115                }
   2116                /* Enable the TIM Capture/Compare 1 DMA request */
   2117                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2118                break;
   2119              }
   2120          
   2121              case TIM_CHANNEL_2:
   2122              {
   2123                /* Set the DMA capture callbacks */
   2124                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2125                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2126          
   2127                /* Set the DMA error callback */
   2128                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   2129          
   2130                /* Enable the DMA channel */
   2131                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
   2132                {
   2133                  return HAL_ERROR;
   2134                }
   2135                /* Enable the TIM Capture/Compare 2  DMA request */
   2136                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2137                break;
   2138              }
   2139          
   2140              case TIM_CHANNEL_3:
   2141              {
   2142                /* Set the DMA capture callbacks */
   2143                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   2144                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2145          
   2146                /* Set the DMA error callback */
   2147                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   2148          
   2149                /* Enable the DMA channel */
   2150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
   2151                {
   2152                  return HAL_ERROR;
   2153                }
   2154                /* Enable the TIM Capture/Compare 3  DMA request */
   2155                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   2156                break;
   2157              }
   2158          
   2159              case TIM_CHANNEL_4:
   2160              {
   2161                /* Set the DMA capture callbacks */
   2162                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   2163                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   2164          
   2165                /* Set the DMA error callback */
   2166                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   2167          
   2168                /* Enable the DMA channel */
   2169                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
   2170                {
   2171                  return HAL_ERROR;
   2172                }
   2173                /* Enable the TIM Capture/Compare 4  DMA request */
   2174                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   2175                break;
   2176              }
   2177          
   2178              default:
   2179                break;
   2180            }
   2181          
   2182            /* Enable the Input Capture channel */
   2183            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   2184          
   2185            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2186            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   2187            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   2188            {
   2189              __HAL_TIM_ENABLE(htim);
   2190            }
   2191          
   2192            /* Return function status */
   2193            return HAL_OK;
   2194          }
   2195          
   2196          /**
   2197            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2198            * @param  htim TIM Input Capture handle
   2199            * @param  Channel TIM Channels to be disabled
   2200            *          This parameter can be one of the following values:
   2201            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2202            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2203            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2204            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2205            * @retval HAL status
   2206            */
   2207          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2208          {
   2209            /* Check the parameters */
   2210            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2211            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2212          
   2213            switch (Channel)
   2214            {
   2215              case TIM_CHANNEL_1:
   2216              {
   2217                /* Disable the TIM Capture/Compare 1 DMA request */
   2218                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2219                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   2220                break;
   2221              }
   2222          
   2223              case TIM_CHANNEL_2:
   2224              {
   2225                /* Disable the TIM Capture/Compare 2 DMA request */
   2226                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2227                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   2228                break;
   2229              }
   2230          
   2231              case TIM_CHANNEL_3:
   2232              {
   2233                /* Disable the TIM Capture/Compare 3  DMA request */
   2234                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   2235                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   2236                break;
   2237              }
   2238          
   2239              case TIM_CHANNEL_4:
   2240              {
   2241                /* Disable the TIM Capture/Compare 4  DMA request */
   2242                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   2243                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   2244                break;
   2245              }
   2246          
   2247              default:
   2248                break;
   2249            }
   2250          
   2251            /* Disable the Input Capture channel */
   2252            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2253          
   2254            /* Disable the Peripheral */
   2255            __HAL_TIM_DISABLE(htim);
   2256          
   2257            /* Change the htim state */
   2258            htim->State = HAL_TIM_STATE_READY;
   2259          
   2260            /* Return function status */
   2261            return HAL_OK;
   2262          }
   2263          /**
   2264            * @}
   2265            */
   2266          
   2267          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2268            *  @brief    TIM One Pulse functions
   2269            *
   2270          @verbatim
   2271            ==============================================================================
   2272                                  ##### TIM One Pulse functions #####
   2273            ==============================================================================
   2274            [..]
   2275              This section provides functions allowing to:
   2276              (+) Initialize and configure the TIM One Pulse.
   2277              (+) De-initialize the TIM One Pulse.
   2278              (+) Start the TIM One Pulse.
   2279              (+) Stop the TIM One Pulse.
   2280              (+) Start the TIM One Pulse and enable interrupt.
   2281              (+) Stop the TIM One Pulse and disable interrupt.
   2282              (+) Start the TIM One Pulse and enable DMA transfer.
   2283              (+) Stop the TIM One Pulse and disable DMA transfer.
   2284          
   2285          @endverbatim
   2286            * @{
   2287            */
   2288          /**
   2289            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2290            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2291            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2292            *         requires a timer reset to avoid unexpected direction
   2293            *         due to DIR bit readonly in center aligned mode.
   2294            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2295            * @param  htim TIM One Pulse handle
   2296            * @param  OnePulseMode Select the One pulse mode.
   2297            *         This parameter can be one of the following values:
   2298            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2299            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2300            * @retval HAL status
   2301            */
   2302          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2303          {
   2304            /* Check the TIM handle allocation */
   2305            if (htim == NULL)
   2306            {
   2307              return HAL_ERROR;
   2308            }
   2309          
   2310            /* Check the parameters */
   2311            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2312            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2313            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2314            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2315            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2316          
   2317            if (htim->State == HAL_TIM_STATE_RESET)
   2318            {
   2319              /* Allocate lock resource and initialize it */
   2320              htim->Lock = HAL_UNLOCKED;
   2321          
   2322          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2323              /* Reset interrupt callbacks to legacy weak callbacks */
   2324              TIM_ResetCallback(htim);
   2325          
   2326              if (htim->OnePulse_MspInitCallback == NULL)
   2327              {
   2328                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2329              }
   2330              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2331              htim->OnePulse_MspInitCallback(htim);
   2332          #else
   2333              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2334              HAL_TIM_OnePulse_MspInit(htim);
   2335          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2336            }
   2337          
   2338            /* Set the TIM state */
   2339            htim->State = HAL_TIM_STATE_BUSY;
   2340          
   2341            /* Configure the Time base in the One Pulse Mode */
   2342            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2343          
   2344            /* Reset the OPM Bit */
   2345            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   2346          
   2347            /* Configure the OPM Mode */
   2348            htim->Instance->CR1 |= OnePulseMode;
   2349          
   2350            /* Initialize the TIM state*/
   2351            htim->State = HAL_TIM_STATE_READY;
   2352          
   2353            return HAL_OK;
   2354          }
   2355          
   2356          /**
   2357            * @brief  DeInitializes the TIM One Pulse
   2358            * @param  htim TIM One Pulse handle
   2359            * @retval HAL status
   2360            */
   2361          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2362          {
   2363            /* Check the parameters */
   2364            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2365          
   2366            htim->State = HAL_TIM_STATE_BUSY;
   2367          
   2368            /* Disable the TIM Peripheral Clock */
   2369            __HAL_TIM_DISABLE(htim);
   2370          
   2371          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2372            if (htim->OnePulse_MspDeInitCallback == NULL)
   2373            {
   2374              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2375            }
   2376            /* DeInit the low level hardware */
   2377            htim->OnePulse_MspDeInitCallback(htim);
   2378          #else
   2379            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2380            HAL_TIM_OnePulse_MspDeInit(htim);
   2381          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2382          
   2383            /* Change TIM state */
   2384            htim->State = HAL_TIM_STATE_RESET;
   2385          
   2386            /* Release Lock */
   2387            __HAL_UNLOCK(htim);
   2388          
   2389            return HAL_OK;
   2390          }
   2391          
   2392          /**
   2393            * @brief  Initializes the TIM One Pulse MSP.
   2394            * @param  htim TIM One Pulse handle
   2395            * @retval None
   2396            */
   2397          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2398          {
   2399            /* Prevent unused argument(s) compilation warning */
   2400            UNUSED(htim);
   2401          
   2402            /* NOTE : This function should not be modified, when the callback is needed,
   2403                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2404             */
   2405          }
   2406          
   2407          /**
   2408            * @brief  DeInitializes TIM One Pulse MSP.
   2409            * @param  htim TIM One Pulse handle
   2410            * @retval None
   2411            */
   2412          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2413          {
   2414            /* Prevent unused argument(s) compilation warning */
   2415            UNUSED(htim);
   2416          
   2417            /* NOTE : This function should not be modified, when the callback is needed,
   2418                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2419             */
   2420          }
   2421          
   2422          /**
   2423            * @brief  Starts the TIM One Pulse signal generation.
   2424            * @param  htim TIM One Pulse handle
   2425            * @param  OutputChannel TIM Channels to be enabled
   2426            *          This parameter can be one of the following values:
   2427            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2428            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2429            * @retval HAL status
   2430            */
   2431          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2432          {
   2433            /* Prevent unused argument(s) compilation warning */
   2434            UNUSED(OutputChannel);
   2435          
   2436            /* Enable the Capture compare and the Input Capture channels
   2437              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2438              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2439              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2440              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2441          
   2442              No need to enable the counter, it's enabled automatically by hardware
   2443              (the counter starts in response to a stimulus and generate a pulse */
   2444          
   2445            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2446            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2447          
   2448            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2449            {
   2450              /* Enable the main output */
   2451              __HAL_TIM_MOE_ENABLE(htim);
   2452            }
   2453          
   2454            /* Return function status */
   2455            return HAL_OK;
   2456          }
   2457          
   2458          /**
   2459            * @brief  Stops the TIM One Pulse signal generation.
   2460            * @param  htim TIM One Pulse handle
   2461            * @param  OutputChannel TIM Channels to be disable
   2462            *          This parameter can be one of the following values:
   2463            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2464            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2465            * @retval HAL status
   2466            */
   2467          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2468          {
   2469            /* Prevent unused argument(s) compilation warning */
   2470            UNUSED(OutputChannel);
   2471          
   2472            /* Disable the Capture compare and the Input Capture channels
   2473            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2474            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2475            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2476            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2477          
   2478            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2479            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2480          
   2481            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2482            {
   2483              /* Disable the Main Output */
   2484              __HAL_TIM_MOE_DISABLE(htim);
   2485            }
   2486          
   2487            /* Disable the Peripheral */
   2488            __HAL_TIM_DISABLE(htim);
   2489          
   2490            /* Return function status */
   2491            return HAL_OK;
   2492          }
   2493          
   2494          /**
   2495            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2496            * @param  htim TIM One Pulse handle
   2497            * @param  OutputChannel TIM Channels to be enabled
   2498            *          This parameter can be one of the following values:
   2499            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2500            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2501            * @retval HAL status
   2502            */
   2503          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2504          {
   2505            /* Prevent unused argument(s) compilation warning */
   2506            UNUSED(OutputChannel);
   2507          
   2508            /* Enable the Capture compare and the Input Capture channels
   2509              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2510              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2511              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2512              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2513          
   2514              No need to enable the counter, it's enabled automatically by hardware
   2515              (the counter starts in response to a stimulus and generate a pulse */
   2516          
   2517            /* Enable the TIM Capture/Compare 1 interrupt */
   2518            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2519          
   2520            /* Enable the TIM Capture/Compare 2 interrupt */
   2521            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2522          
   2523            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2524            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2525          
   2526            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2527            {
   2528              /* Enable the main output */
   2529              __HAL_TIM_MOE_ENABLE(htim);
   2530            }
   2531          
   2532            /* Return function status */
   2533            return HAL_OK;
   2534          }
   2535          
   2536          /**
   2537            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2538            * @param  htim TIM One Pulse handle
   2539            * @param  OutputChannel TIM Channels to be enabled
   2540            *          This parameter can be one of the following values:
   2541            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2542            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2543            * @retval HAL status
   2544            */
   2545          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2546          {
   2547            /* Prevent unused argument(s) compilation warning */
   2548            UNUSED(OutputChannel);
   2549          
   2550            /* Disable the TIM Capture/Compare 1 interrupt */
   2551            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2552          
   2553            /* Disable the TIM Capture/Compare 2 interrupt */
   2554            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2555          
   2556            /* Disable the Capture compare and the Input Capture channels
   2557            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2558            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2559            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2560            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2561            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2562            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2563          
   2564            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2565            {
   2566              /* Disable the Main Output */
   2567              __HAL_TIM_MOE_DISABLE(htim);
   2568            }
   2569          
   2570            /* Disable the Peripheral */
   2571            __HAL_TIM_DISABLE(htim);
   2572          
   2573            /* Return function status */
   2574            return HAL_OK;
   2575          }
   2576          
   2577          /**
   2578            * @}
   2579            */
   2580          
   2581          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   2582            *  @brief    TIM Encoder functions
   2583            *
   2584          @verbatim
   2585            ==============================================================================
   2586                                    ##### TIM Encoder functions #####
   2587            ==============================================================================
   2588            [..]
   2589              This section provides functions allowing to:
   2590              (+) Initialize and configure the TIM Encoder.
   2591              (+) De-initialize the TIM Encoder.
   2592              (+) Start the TIM Encoder.
   2593              (+) Stop the TIM Encoder.
   2594              (+) Start the TIM Encoder and enable interrupt.
   2595              (+) Stop the TIM Encoder and disable interrupt.
   2596              (+) Start the TIM Encoder and enable DMA transfer.
   2597              (+) Stop the TIM Encoder and disable DMA transfer.
   2598          
   2599          @endverbatim
   2600            * @{
   2601            */
   2602          /**
   2603            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   2604            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2605            *         requires a timer reset to avoid unexpected direction
   2606            *         due to DIR bit readonly in center aligned mode.
   2607            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2608            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   2609            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   2610            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   2611            * @param  htim TIM Encoder Interface handle
   2612            * @param  sConfig TIM Encoder Interface configuration structure
   2613            * @retval HAL status
   2614            */
   2615          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
   2616          {
   2617            uint32_t tmpsmcr;
   2618            uint32_t tmpccmr1;
   2619            uint32_t tmpccer;
   2620          
   2621            /* Check the TIM handle allocation */
   2622            if (htim == NULL)
   2623            {
   2624              return HAL_ERROR;
   2625            }
   2626          
   2627            /* Check the parameters */
   2628            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2629            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2630            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2631            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2632            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2633            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2634            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2635            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));
   2636            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));
   2637            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2638            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2639            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2640            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2641          
   2642            if (htim->State == HAL_TIM_STATE_RESET)
   2643            {
   2644              /* Allocate lock resource and initialize it */
   2645              htim->Lock = HAL_UNLOCKED;
   2646          
   2647          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2648              /* Reset interrupt callbacks to legacy weak callbacks */
   2649              TIM_ResetCallback(htim);
   2650          
   2651              if (htim->Encoder_MspInitCallback == NULL)
   2652              {
   2653                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   2654              }
   2655              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2656              htim->Encoder_MspInitCallback(htim);
   2657          #else
   2658              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2659              HAL_TIM_Encoder_MspInit(htim);
   2660          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2661            }
   2662          
   2663            /* Set the TIM state */
   2664            htim->State = HAL_TIM_STATE_BUSY;
   2665          
   2666            /* Reset the SMS and ECE bits */
   2667            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   2668          
   2669            /* Configure the Time base in the Encoder Mode */
   2670            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2671          
   2672            /* Get the TIMx SMCR register value */
   2673            tmpsmcr = htim->Instance->SMCR;
   2674          
   2675            /* Get the TIMx CCMR1 register value */
   2676            tmpccmr1 = htim->Instance->CCMR1;
   2677          
   2678            /* Get the TIMx CCER register value */
   2679            tmpccer = htim->Instance->CCER;
   2680          
   2681            /* Set the encoder Mode */
   2682            tmpsmcr |= sConfig->EncoderMode;
   2683          
   2684            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2685            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2686            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2687          
   2688            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2689            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2690            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2691            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2692            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   2693          
   2694            /* Set the TI1 and the TI2 Polarities */
   2695            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2696            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2697            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   2698          
   2699            /* Write to TIMx SMCR */
   2700            htim->Instance->SMCR = tmpsmcr;
   2701          
   2702            /* Write to TIMx CCMR1 */
   2703            htim->Instance->CCMR1 = tmpccmr1;
   2704          
   2705            /* Write to TIMx CCER */
   2706            htim->Instance->CCER = tmpccer;
   2707          
   2708            /* Initialize the TIM state*/
   2709            htim->State = HAL_TIM_STATE_READY;
   2710          
   2711            return HAL_OK;
   2712          }
   2713          
   2714          
   2715          /**
   2716            * @brief  DeInitializes the TIM Encoder interface
   2717            * @param  htim TIM Encoder Interface handle
   2718            * @retval HAL status
   2719            */
   2720          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2721          {
   2722            /* Check the parameters */
   2723            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2724          
   2725            htim->State = HAL_TIM_STATE_BUSY;
   2726          
   2727            /* Disable the TIM Peripheral Clock */
   2728            __HAL_TIM_DISABLE(htim);
   2729          
   2730          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2731            if (htim->Encoder_MspDeInitCallback == NULL)
   2732            {
   2733              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   2734            }
   2735            /* DeInit the low level hardware */
   2736            htim->Encoder_MspDeInitCallback(htim);
   2737          #else
   2738            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2739            HAL_TIM_Encoder_MspDeInit(htim);
   2740          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2741          
   2742            /* Change TIM state */
   2743            htim->State = HAL_TIM_STATE_RESET;
   2744          
   2745            /* Release Lock */
   2746            __HAL_UNLOCK(htim);
   2747          
   2748            return HAL_OK;
   2749          }
   2750          
   2751          /**
   2752            * @brief  Initializes the TIM Encoder Interface MSP.
   2753            * @param  htim TIM Encoder Interface handle
   2754            * @retval None
   2755            */
   2756          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2757          {
   2758            /* Prevent unused argument(s) compilation warning */
   2759            UNUSED(htim);
   2760          
   2761            /* NOTE : This function should not be modified, when the callback is needed,
   2762                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2763             */
   2764          }
   2765          
   2766          /**
   2767            * @brief  DeInitializes TIM Encoder Interface MSP.
   2768            * @param  htim TIM Encoder Interface handle
   2769            * @retval None
   2770            */
   2771          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2772          {
   2773            /* Prevent unused argument(s) compilation warning */
   2774            UNUSED(htim);
   2775          
   2776            /* NOTE : This function should not be modified, when the callback is needed,
   2777                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2778             */
   2779          }
   2780          
   2781          /**
   2782            * @brief  Starts the TIM Encoder Interface.
   2783            * @param  htim TIM Encoder Interface handle
   2784            * @param  Channel TIM Channels to be enabled
   2785            *          This parameter can be one of the following values:
   2786            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2787            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2788            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2789            * @retval HAL status
   2790            */
   2791          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2792          {
   2793            /* Check the parameters */
   2794            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2795          
   2796            /* Enable the encoder interface channels */
   2797            switch (Channel)
   2798            {
   2799              case TIM_CHANNEL_1:
   2800              {
   2801                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2802                break;
   2803              }
   2804          
   2805              case TIM_CHANNEL_2:
   2806              {
   2807                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2808                break;
   2809              }
   2810          
   2811              default :
   2812              {
   2813                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2814                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2815                break;
   2816              }
   2817            }
   2818            /* Enable the Peripheral */
   2819            __HAL_TIM_ENABLE(htim);
   2820          
   2821            /* Return function status */
   2822            return HAL_OK;
   2823          }
   2824          
   2825          /**
   2826            * @brief  Stops the TIM Encoder Interface.
   2827            * @param  htim TIM Encoder Interface handle
   2828            * @param  Channel TIM Channels to be disabled
   2829            *          This parameter can be one of the following values:
   2830            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2831            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2832            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2833            * @retval HAL status
   2834            */
   2835          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2836          {
   2837            /* Check the parameters */
   2838            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2839          
   2840            /* Disable the Input Capture channels 1 and 2
   2841              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2842            switch (Channel)
   2843            {
   2844              case TIM_CHANNEL_1:
   2845              {
   2846                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2847                break;
   2848              }
   2849          
   2850              case TIM_CHANNEL_2:
   2851              {
   2852                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2853                break;
   2854              }
   2855          
   2856              default :
   2857              {
   2858                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2859                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2860                break;
   2861              }
   2862            }
   2863          
   2864            /* Disable the Peripheral */
   2865            __HAL_TIM_DISABLE(htim);
   2866          
   2867            /* Return function status */
   2868            return HAL_OK;
   2869          }
   2870          
   2871          /**
   2872            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2873            * @param  htim TIM Encoder Interface handle
   2874            * @param  Channel TIM Channels to be enabled
   2875            *          This parameter can be one of the following values:
   2876            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2877            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2878            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2879            * @retval HAL status
   2880            */
   2881          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2882          {
   2883            /* Check the parameters */
   2884            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2885          
   2886            /* Enable the encoder interface channels */
   2887            /* Enable the capture compare Interrupts 1 and/or 2 */
   2888            switch (Channel)
   2889            {
   2890              case TIM_CHANNEL_1:
   2891              {
   2892                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2893                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2894                break;
   2895              }
   2896          
   2897              case TIM_CHANNEL_2:
   2898              {
   2899                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2900                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2901                break;
   2902              }
   2903          
   2904              default :
   2905              {
   2906                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2907                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2908                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2909                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2910                break;
   2911              }
   2912            }
   2913          
   2914            /* Enable the Peripheral */
   2915            __HAL_TIM_ENABLE(htim);
   2916          
   2917            /* Return function status */
   2918            return HAL_OK;
   2919          }
   2920          
   2921          /**
   2922            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2923            * @param  htim TIM Encoder Interface handle
   2924            * @param  Channel TIM Channels to be disabled
   2925            *          This parameter can be one of the following values:
   2926            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2927            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2928            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2929            * @retval HAL status
   2930            */
   2931          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2932          {
   2933            /* Check the parameters */
   2934            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2935          
   2936            /* Disable the Input Capture channels 1 and 2
   2937              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2938            if (Channel == TIM_CHANNEL_1)
   2939            {
   2940              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2941          
   2942              /* Disable the capture compare Interrupts 1 */
   2943              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2944            }
   2945            else if (Channel == TIM_CHANNEL_2)
   2946            {
   2947              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2948          
   2949              /* Disable the capture compare Interrupts 2 */
   2950              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2951            }
   2952            else
   2953            {
   2954              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2955              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2956          
   2957              /* Disable the capture compare Interrupts 1 and 2 */
   2958              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2959              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2960            }
   2961          
   2962            /* Disable the Peripheral */
   2963            __HAL_TIM_DISABLE(htim);
   2964          
   2965            /* Change the htim state */
   2966            htim->State = HAL_TIM_STATE_READY;
   2967          
   2968            /* Return function status */
   2969            return HAL_OK;
   2970          }
   2971          
   2972          /**
   2973            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2974            * @param  htim TIM Encoder Interface handle
   2975            * @param  Channel TIM Channels to be enabled
   2976            *          This parameter can be one of the following values:
   2977            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2978            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2979            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2980            * @param  pData1 The destination Buffer address for IC1.
   2981            * @param  pData2 The destination Buffer address for IC2.
   2982            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2983            * @retval HAL status
   2984            */
   2985          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
   2986                                                      uint32_t *pData2, uint16_t Length)
   2987          {
   2988            /* Check the parameters */
   2989            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2990          
   2991            if (htim->State == HAL_TIM_STATE_BUSY)
   2992            {
   2993              return HAL_BUSY;
   2994            }
   2995            else if (htim->State == HAL_TIM_STATE_READY)
   2996            {
   2997              if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
   2998              {
   2999                return HAL_ERROR;
   3000              }
   3001              else
   3002              {
   3003                htim->State = HAL_TIM_STATE_BUSY;
   3004              }
   3005            }
   3006            else
   3007            {
   3008              /* nothing to do */
   3009            }
   3010          
   3011            switch (Channel)
   3012            {
   3013              case TIM_CHANNEL_1:
   3014              {
   3015                /* Set the DMA capture callbacks */
   3016                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3017                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3018          
   3019                /* Set the DMA error callback */
   3020                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3021          
   3022                /* Enable the DMA channel */
   3023                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   3024                {
   3025                  return HAL_ERROR;
   3026                }
   3027                /* Enable the TIM Input Capture DMA request */
   3028                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   3029          
   3030                /* Enable the Peripheral */
   3031                __HAL_TIM_ENABLE(htim);
   3032          
   3033                /* Enable the Capture compare channel */
   3034                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3035                break;
   3036              }
   3037          
   3038              case TIM_CHANNEL_2:
   3039              {
   3040                /* Set the DMA capture callbacks */
   3041                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3042                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3043          
   3044                /* Set the DMA error callback */
   3045                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   3046                /* Enable the DMA channel */
   3047                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   3048                {
   3049                  return HAL_ERROR;
   3050                }
   3051                /* Enable the TIM Input Capture  DMA request */
   3052                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   3053          
   3054                /* Enable the Peripheral */
   3055                __HAL_TIM_ENABLE(htim);
   3056          
   3057                /* Enable the Capture compare channel */
   3058                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3059                break;
   3060              }
   3061          
   3062              case TIM_CHANNEL_ALL:
   3063              {
   3064                /* Set the DMA capture callbacks */
   3065                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3066                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3067          
   3068                /* Set the DMA error callback */
   3069                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3070          
   3071                /* Enable the DMA channel */
   3072                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   3073                {
   3074                  return HAL_ERROR;
   3075                }
   3076          
   3077                /* Set the DMA capture callbacks */
   3078                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3079                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   3080          
   3081                /* Set the DMA error callback */
   3082                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3083          
   3084                /* Enable the DMA channel */
   3085                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   3086                {
   3087                  return HAL_ERROR;
   3088                }
   3089                /* Enable the Peripheral */
   3090                __HAL_TIM_ENABLE(htim);
   3091          
   3092                /* Enable the Capture compare channel */
   3093                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   3094                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   3095          
   3096                /* Enable the TIM Input Capture  DMA request */
   3097                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   3098                /* Enable the TIM Input Capture  DMA request */
   3099                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   3100                break;
   3101              }
   3102          
   3103              default:
   3104                break;
   3105            }
   3106            /* Return function status */
   3107            return HAL_OK;
   3108          }
   3109          
   3110          /**
   3111            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3112            * @param  htim TIM Encoder Interface handle
   3113            * @param  Channel TIM Channels to be enabled
   3114            *          This parameter can be one of the following values:
   3115            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3116            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3117            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3118            * @retval HAL status
   3119            */
   3120          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3121          {
   3122            /* Check the parameters */
   3123            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   3124          
   3125            /* Disable the Input Capture channels 1 and 2
   3126              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3127            if (Channel == TIM_CHANNEL_1)
   3128            {
   3129              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3130          
   3131              /* Disable the capture compare DMA Request 1 */
   3132              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   3133              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3134            }
   3135            else if (Channel == TIM_CHANNEL_2)
   3136            {
   3137              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3138          
   3139              /* Disable the capture compare DMA Request 2 */
   3140              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   3141              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   3142            }
   3143            else
   3144            {
   3145              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   3146              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   3147          
   3148              /* Disable the capture compare DMA Request 1 and 2 */
   3149              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   3150              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   3151              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   3152              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   3153            }
   3154          
   3155            /* Disable the Peripheral */
   3156            __HAL_TIM_DISABLE(htim);
   3157          
   3158            /* Change the htim state */
   3159            htim->State = HAL_TIM_STATE_READY;
   3160          
   3161            /* Return function status */
   3162            return HAL_OK;
   3163          }
   3164          
   3165          /**
   3166            * @}
   3167            */
   3168          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3169            *  @brief    TIM IRQ handler management
   3170            *
   3171          @verbatim
   3172            ==============================================================================
   3173                                  ##### IRQ handler management #####
   3174            ==============================================================================
   3175            [..]
   3176              This section provides Timer IRQ handler function.
   3177          
   3178          @endverbatim
   3179            * @{
   3180            */
   3181          /**
   3182            * @brief  This function handles TIM interrupts requests.
   3183            * @param  htim TIM  handle
   3184            * @retval None
   3185            */
   3186          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3187          {
   3188            /* Capture compare 1 event */
   3189            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   3190            {
   3191              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
   3192              {
   3193                {
   3194                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   3195                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   3196          
   3197                  /* Input capture event */
   3198                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   3199                  {
   3200          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3201                    htim->IC_CaptureCallback(htim);
   3202          #else
   3203                    HAL_TIM_IC_CaptureCallback(htim);
   3204          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3205                  }
   3206                  /* Output compare event */
   3207                  else
   3208                  {
   3209          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3210                    htim->OC_DelayElapsedCallback(htim);
   3211                    htim->PWM_PulseFinishedCallback(htim);
   3212          #else
   3213                    HAL_TIM_OC_DelayElapsedCallback(htim);
   3214                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   3215          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3216                  }
   3217                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3218                }
   3219              }
   3220            }
   3221            /* Capture compare 2 event */
   3222            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   3223            {
   3224              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
   3225              {
   3226                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   3227                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   3228                /* Input capture event */
   3229                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   3230                {
   3231          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3232                  htim->IC_CaptureCallback(htim);
   3233          #else
   3234                  HAL_TIM_IC_CaptureCallback(htim);
   3235          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3236                }
   3237                /* Output compare event */
   3238                else
   3239                {
   3240          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3241                  htim->OC_DelayElapsedCallback(htim);
   3242                  htim->PWM_PulseFinishedCallback(htim);
   3243          #else
   3244                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3245                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3246          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3247                }
   3248                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3249              }
   3250            }
   3251            /* Capture compare 3 event */
   3252            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   3253            {
   3254              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
   3255              {
   3256                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   3257                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   3258                /* Input capture event */
   3259                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   3260                {
   3261          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3262                  htim->IC_CaptureCallback(htim);
   3263          #else
   3264                  HAL_TIM_IC_CaptureCallback(htim);
   3265          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3266                }
   3267                /* Output compare event */
   3268                else
   3269                {
   3270          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3271                  htim->OC_DelayElapsedCallback(htim);
   3272                  htim->PWM_PulseFinishedCallback(htim);
   3273          #else
   3274                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3275                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3276          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3277                }
   3278                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3279              }
   3280            }
   3281            /* Capture compare 4 event */
   3282            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   3283            {
   3284              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
   3285              {
   3286                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   3287                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   3288                /* Input capture event */
   3289                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   3290                {
   3291          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3292                  htim->IC_CaptureCallback(htim);
   3293          #else
   3294                  HAL_TIM_IC_CaptureCallback(htim);
   3295          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3296                }
   3297                /* Output compare event */
   3298                else
   3299                {
   3300          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3301                  htim->OC_DelayElapsedCallback(htim);
   3302                  htim->PWM_PulseFinishedCallback(htim);
   3303          #else
   3304                  HAL_TIM_OC_DelayElapsedCallback(htim);
   3305                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   3306          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3307                }
   3308                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   3309              }
   3310            }
   3311            /* TIM Update event */
   3312            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   3313            {
   3314              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
   3315              {
   3316                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   3317          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3318                htim->PeriodElapsedCallback(htim);
   3319          #else
   3320                HAL_TIM_PeriodElapsedCallback(htim);
   3321          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3322              }
   3323            }
   3324            /* TIM Break input event */
   3325            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   3326            {
   3327              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   3328              {
   3329                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   3330          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3331                htim->BreakCallback(htim);
   3332          #else
   3333                HAL_TIMEx_BreakCallback(htim);
   3334          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3335              }
   3336            }
   3337          #if defined(TIM_BDTR_BK2E)
   3338            /* TIM Break2 input event */
   3339            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
   3340            {
   3341              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   3342              {
   3343                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
   3344          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3345                htim->Break2Callback(htim);
   3346          #else
   3347                HAL_TIMEx_Break2Callback(htim);
   3348          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3349              }
   3350            }
   3351          #endif /* TIM_BDTR_BK2E */
   3352            /* TIM Trigger detection event */
   3353            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   3354            {
   3355              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
   3356              {
   3357                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   3358          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3359                htim->TriggerCallback(htim);
   3360          #else
   3361                HAL_TIM_TriggerCallback(htim);
   3362          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3363              }
   3364            }
   3365            /* TIM commutation event */
   3366            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   3367            {
   3368              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
   3369              {
   3370                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   3371          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3372                htim->CommutationCallback(htim);
   3373          #else
   3374                HAL_TIMEx_CommutCallback(htim);
   3375          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3376              }
   3377            }
   3378          }
   3379          
   3380          /**
   3381            * @}
   3382            */
   3383          
   3384          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   3385            *  @brief    TIM Peripheral Control functions
   3386            *
   3387          @verbatim
   3388            ==============================================================================
   3389                             ##### Peripheral Control functions #####
   3390            ==============================================================================
   3391           [..]
   3392             This section provides functions allowing to:
   3393                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   3394                (+) Configure External Clock source.
   3395                (+) Configure Complementary channels, break features and dead time.
   3396                (+) Configure Master and the Slave synchronization.
   3397                (+) Configure the DMA Burst Mode.
   3398          
   3399          @endverbatim
   3400            * @{
   3401            */
   3402          
   3403          /**
   3404            * @brief  Initializes the TIM Output Compare Channels according to the specified
   3405            *         parameters in the TIM_OC_InitTypeDef.
   3406            * @param  htim TIM Output Compare handle
   3407            * @param  sConfig TIM Output Compare configuration structure
   3408            * @param  Channel TIM Channels to configure
   3409            *          This parameter can be one of the following values:
   3410            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3411            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3412            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3413            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3414            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected (*)
   3415            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected (*)
   3416            *         (*) Value not defined for all devices
   3417            * @retval HAL status
   3418            */
   3419          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   3420                                                     TIM_OC_InitTypeDef *sConfig,
   3421                                                     uint32_t Channel)
   3422          {
   3423            /* Check the parameters */
   3424            assert_param(IS_TIM_CHANNELS(Channel));
   3425            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   3426            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3427          
   3428            /* Process Locked */
   3429            __HAL_LOCK(htim);
   3430          
   3431            htim->State = HAL_TIM_STATE_BUSY;
   3432          
   3433            switch (Channel)
   3434            {
   3435              case TIM_CHANNEL_1:
   3436              {
   3437                /* Check the parameters */
   3438                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3439          
   3440                /* Configure the TIM Channel 1 in Output Compare */
   3441                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3442                break;
   3443              }
   3444          
   3445              case TIM_CHANNEL_2:
   3446              {
   3447                /* Check the parameters */
   3448                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3449          
   3450                /* Configure the TIM Channel 2 in Output Compare */
   3451                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3452                break;
   3453              }
   3454          
   3455              case TIM_CHANNEL_3:
   3456              {
   3457                /* Check the parameters */
   3458                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3459          
   3460                /* Configure the TIM Channel 3 in Output Compare */
   3461                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3462                break;
   3463              }
   3464          
   3465              case TIM_CHANNEL_4:
   3466              {
   3467                /* Check the parameters */
   3468                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3469          
   3470                /* Configure the TIM Channel 4 in Output Compare */
   3471                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3472                break;
   3473              }
   3474          
   3475          #if defined(TIM_CCER_CC5E)
   3476              case TIM_CHANNEL_5:
   3477              {
   3478                /* Check the parameters */
   3479                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   3480          
   3481                /* Configure the TIM Channel 5 in Output Compare */
   3482                TIM_OC5_SetConfig(htim->Instance, sConfig);
   3483                break;
   3484              }
   3485          #endif /* TIM_CCER_CC5E */
   3486          
   3487          #if defined(TIM_CCER_CC6E)
   3488              case TIM_CHANNEL_6:
   3489              {
   3490                /* Check the parameters */
   3491                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   3492          
   3493                /* Configure the TIM Channel 6 in Output Compare */
   3494                TIM_OC6_SetConfig(htim->Instance, sConfig);
   3495                break;
   3496              }
   3497          #endif /* TIM_CCER_CC6E */
   3498          
   3499              default:
   3500                break;
   3501            }
   3502          
   3503            htim->State = HAL_TIM_STATE_READY;
   3504          
   3505            __HAL_UNLOCK(htim);
   3506          
   3507            return HAL_OK;
   3508          }
   3509          
   3510          /**
   3511            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3512            *         parameters in the TIM_IC_InitTypeDef.
   3513            * @param  htim TIM IC handle
   3514            * @param  sConfig TIM Input Capture configuration structure
   3515            * @param  Channel TIM Channel to configure
   3516            *          This parameter can be one of the following values:
   3517            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3518            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3519            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3520            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3521            * @retval HAL status
   3522            */
   3523          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   3524          {
   3525            /* Check the parameters */
   3526            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3527            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3528            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3529            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3530            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3531          
   3532            /* Process Locked */
   3533            __HAL_LOCK(htim);
   3534          
   3535            htim->State = HAL_TIM_STATE_BUSY;
   3536          
   3537            if (Channel == TIM_CHANNEL_1)
   3538            {
   3539              /* TI1 Configuration */
   3540              TIM_TI1_SetConfig(htim->Instance,
   3541                                sConfig->ICPolarity,
   3542                                sConfig->ICSelection,
   3543                                sConfig->ICFilter);
   3544          
   3545              /* Reset the IC1PSC Bits */
   3546              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3547          
   3548              /* Set the IC1PSC value */
   3549              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   3550            }
   3551            else if (Channel == TIM_CHANNEL_2)
   3552            {
   3553              /* TI2 Configuration */
   3554              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3555          
   3556              TIM_TI2_SetConfig(htim->Instance,
   3557                                sConfig->ICPolarity,
   3558                                sConfig->ICSelection,
   3559                                sConfig->ICFilter);
   3560          
   3561              /* Reset the IC2PSC Bits */
   3562              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3563          
   3564              /* Set the IC2PSC value */
   3565              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   3566            }
   3567            else if (Channel == TIM_CHANNEL_3)
   3568            {
   3569              /* TI3 Configuration */
   3570              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3571          
   3572              TIM_TI3_SetConfig(htim->Instance,
   3573                                sConfig->ICPolarity,
   3574                                sConfig->ICSelection,
   3575                                sConfig->ICFilter);
   3576          
   3577              /* Reset the IC3PSC Bits */
   3578              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   3579          
   3580              /* Set the IC3PSC value */
   3581              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   3582            }
   3583            else
   3584            {
   3585              /* TI4 Configuration */
   3586              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3587          
   3588              TIM_TI4_SetConfig(htim->Instance,
   3589                                sConfig->ICPolarity,
   3590                                sConfig->ICSelection,
   3591                                sConfig->ICFilter);
   3592          
   3593              /* Reset the IC4PSC Bits */
   3594              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   3595          
   3596              /* Set the IC4PSC value */
   3597              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   3598            }
   3599          
   3600            htim->State = HAL_TIM_STATE_READY;
   3601          
   3602            __HAL_UNLOCK(htim);
   3603          
   3604            return HAL_OK;
   3605          }
   3606          
   3607          /**
   3608            * @brief  Initializes the TIM PWM  channels according to the specified
   3609            *         parameters in the TIM_OC_InitTypeDef.
   3610            * @param  htim TIM PWM handle
   3611            * @param  sConfig TIM PWM configuration structure
   3612            * @param  Channel TIM Channels to be configured
   3613            *          This parameter can be one of the following values:
   3614            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3615            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3616            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3617            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3618            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected (*)
   3619            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected (*)
   3620            *         (*) Value not defined for all devices
   3621            * @retval HAL status
   3622            */
   3623          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   3624                                                      TIM_OC_InitTypeDef *sConfig,
   3625                                                      uint32_t Channel)
   3626          {
   3627            /* Check the parameters */
   3628            assert_param(IS_TIM_CHANNELS(Channel));
   3629            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3630            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3631            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3632          
   3633            /* Process Locked */
   3634            __HAL_LOCK(htim);
   3635          
   3636            htim->State = HAL_TIM_STATE_BUSY;
   3637          
   3638            switch (Channel)
   3639            {
   3640              case TIM_CHANNEL_1:
   3641              {
   3642                /* Check the parameters */
   3643                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3644          
   3645                /* Configure the Channel 1 in PWM mode */
   3646                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3647          
   3648                /* Set the Preload enable bit for channel1 */
   3649                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   3650          
   3651                /* Configure the Output Fast mode */
   3652                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   3653                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   3654                break;
   3655              }
   3656          
   3657              case TIM_CHANNEL_2:
   3658              {
   3659                /* Check the parameters */
   3660                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3661          
   3662                /* Configure the Channel 2 in PWM mode */
   3663                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3664          
   3665                /* Set the Preload enable bit for channel2 */
   3666                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   3667          
   3668                /* Configure the Output Fast mode */
   3669                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3670                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   3671                break;
   3672              }
   3673          
   3674              case TIM_CHANNEL_3:
   3675              {
   3676                /* Check the parameters */
   3677                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3678          
   3679                /* Configure the Channel 3 in PWM mode */
   3680                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3681          
   3682                /* Set the Preload enable bit for channel3 */
   3683                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   3684          
   3685                /* Configure the Output Fast mode */
   3686                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   3687                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   3688                break;
   3689              }
   3690          
   3691              case TIM_CHANNEL_4:
   3692              {
   3693                /* Check the parameters */
   3694                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3695          
   3696                /* Configure the Channel 4 in PWM mode */
   3697                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3698          
   3699                /* Set the Preload enable bit for channel4 */
   3700                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   3701          
   3702                /* Configure the Output Fast mode */
   3703                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   3704                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   3705                break;
   3706              }
   3707          
   3708          #if defined(TIM_CCER_CC5E)
   3709              case TIM_CHANNEL_5:
   3710              {
   3711                /* Check the parameters */
   3712                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   3713          
   3714                /* Configure the Channel 5 in PWM mode */
   3715                TIM_OC5_SetConfig(htim->Instance, sConfig);
   3716          
   3717                /* Set the Preload enable bit for channel5*/
   3718                htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   3719          
   3720                /* Configure the Output Fast mode */
   3721                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   3722                htim->Instance->CCMR3 |= sConfig->OCFastMode;
   3723                break;
   3724              }
   3725          #endif /* TIM_CCER_CC5E */
   3726          
   3727          #if defined(TIM_CCER_CC6E)
   3728              case TIM_CHANNEL_6:
   3729              {
   3730                /* Check the parameters */
   3731                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   3732          
   3733                /* Configure the Channel 6 in PWM mode */
   3734                TIM_OC6_SetConfig(htim->Instance, sConfig);
   3735          
   3736                /* Set the Preload enable bit for channel6 */
   3737                htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   3738          
   3739                /* Configure the Output Fast mode */
   3740                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   3741                htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
   3742                break;
   3743              }
   3744          #endif /* TIM_CCER_CC6E */
   3745          
   3746              default:
   3747                break;
   3748            }
   3749          
   3750            htim->State = HAL_TIM_STATE_READY;
   3751          
   3752            __HAL_UNLOCK(htim);
   3753          
   3754            return HAL_OK;
   3755          }
   3756          
   3757          /**
   3758            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3759            *         parameters in the TIM_OnePulse_InitTypeDef.
   3760            * @param  htim TIM One Pulse handle
   3761            * @param  sConfig TIM One Pulse configuration structure
   3762            * @param  OutputChannel TIM output channel to configure
   3763            *          This parameter can be one of the following values:
   3764            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3765            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3766            * @param  InputChannel TIM input Channel to configure
   3767            *          This parameter can be one of the following values:
   3768            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3769            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3770            * @note  To output a waveform with a minimum delay user can enable the fast
   3771            *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
   3772            *        output is forced in response to the edge detection on TIx input,
   3773            *        without taking in account the comparison.
   3774            * @retval HAL status
   3775            */
   3776          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
   3777                                                           uint32_t OutputChannel,  uint32_t InputChannel)
   3778          {
   3779            TIM_OC_InitTypeDef temp1;
   3780          
   3781            /* Check the parameters */
   3782            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3783            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3784          
   3785            if (OutputChannel != InputChannel)
   3786            {
   3787              /* Process Locked */
   3788              __HAL_LOCK(htim);
   3789          
   3790              htim->State = HAL_TIM_STATE_BUSY;
   3791          
   3792              /* Extract the Output compare configuration from sConfig structure */
   3793              temp1.OCMode = sConfig->OCMode;
   3794              temp1.Pulse = sConfig->Pulse;
   3795              temp1.OCPolarity = sConfig->OCPolarity;
   3796              temp1.OCNPolarity = sConfig->OCNPolarity;
   3797              temp1.OCIdleState = sConfig->OCIdleState;
   3798              temp1.OCNIdleState = sConfig->OCNIdleState;
   3799          
   3800              switch (OutputChannel)
   3801              {
   3802                case TIM_CHANNEL_1:
   3803                {
   3804                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3805          
   3806                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   3807                  break;
   3808                }
   3809                case TIM_CHANNEL_2:
   3810                {
   3811                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3812          
   3813                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   3814                  break;
   3815                }
   3816                default:
   3817                  break;
   3818              }
   3819          
   3820              switch (InputChannel)
   3821              {
   3822                case TIM_CHANNEL_1:
   3823                {
   3824                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3825          
   3826                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3827                                    sConfig->ICSelection, sConfig->ICFilter);
   3828          
   3829                  /* Reset the IC1PSC Bits */
   3830                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3831          
   3832                  /* Select the Trigger source */
   3833                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3834                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   3835          
   3836                  /* Select the Slave Mode */
   3837                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3838                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3839                  break;
   3840                }
   3841                case TIM_CHANNEL_2:
   3842                {
   3843                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3844          
   3845                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3846                                    sConfig->ICSelection, sConfig->ICFilter);
   3847          
   3848                  /* Reset the IC2PSC Bits */
   3849                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3850          
   3851                  /* Select the Trigger source */
   3852                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3853                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   3854          
   3855                  /* Select the Slave Mode */
   3856                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3857                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3858                  break;
   3859                }
   3860          
   3861                default:
   3862                  break;
   3863              }
   3864          
   3865              htim->State = HAL_TIM_STATE_READY;
   3866          
   3867              __HAL_UNLOCK(htim);
   3868          
   3869              return HAL_OK;
   3870            }
   3871            else
   3872            {
   3873              return HAL_ERROR;
   3874            }
   3875          }
   3876          
   3877          /**
   3878            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3879            * @param  htim TIM handle
   3880            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   3881            *         This parameter can be one of the following values:
   3882            *            @arg TIM_DMABASE_CR1
   3883            *            @arg TIM_DMABASE_CR2
   3884            *            @arg TIM_DMABASE_SMCR
   3885            *            @arg TIM_DMABASE_DIER
   3886            *            @arg TIM_DMABASE_SR
   3887            *            @arg TIM_DMABASE_EGR
   3888            *            @arg TIM_DMABASE_CCMR1
   3889            *            @arg TIM_DMABASE_CCMR2
   3890            *            @arg TIM_DMABASE_CCER
   3891            *            @arg TIM_DMABASE_CNT
   3892            *            @arg TIM_DMABASE_PSC
   3893            *            @arg TIM_DMABASE_ARR
   3894            *            @arg TIM_DMABASE_RCR
   3895            *            @arg TIM_DMABASE_CCR1
   3896            *            @arg TIM_DMABASE_CCR2
   3897            *            @arg TIM_DMABASE_CCR3
   3898            *            @arg TIM_DMABASE_CCR4
   3899            *            @arg TIM_DMABASE_BDTR
   3900            *            @arg TIM_DMABASE_OR
   3901            *            @arg TIM_DMABASE_CCMR3 (*)
   3902            *            @arg TIM_DMABASE_CCR5 (*)
   3903            *            @arg TIM_DMABASE_CCR6 (*)
   3904            *         (*) value not defined in all devices
   3905            * @param  BurstRequestSrc TIM DMA Request sources
   3906            *         This parameter can be one of the following values:
   3907            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3908            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3909            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3910            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3911            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3912            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3913            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3914            * @param  BurstBuffer The Buffer address.
   3915            * @param  BurstLength DMA Burst length. This parameter can be one value
   3916            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3917            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   3918            * @retval HAL status
   3919            */
   3920          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   3921                                                        uint32_t BurstRequestSrc, uint32_t *BurstBuffer, uint32_t  BurstLength)
   3922          {
   3923            return HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
   3924                                                    ((BurstLength) >> 8U) + 1U);
   3925          }
   3926          
   3927          /**
   3928            * @brief  Configure the DMA Burst to transfer multiple Data from the memory to the TIM peripheral
   3929            * @param  htim TIM handle
   3930            * @param  BurstBaseAddress TIM Base address from where the DMA will start the Data write
   3931            *         This parameter can be one of the following values:
   3932            *            @arg TIM_DMABASE_CR1
   3933            *            @arg TIM_DMABASE_CR2
   3934            *            @arg TIM_DMABASE_SMCR
   3935            *            @arg TIM_DMABASE_DIER
   3936            *            @arg TIM_DMABASE_SR
   3937            *            @arg TIM_DMABASE_EGR
   3938            *            @arg TIM_DMABASE_CCMR1
   3939            *            @arg TIM_DMABASE_CCMR2
   3940            *            @arg TIM_DMABASE_CCER
   3941            *            @arg TIM_DMABASE_CNT
   3942            *            @arg TIM_DMABASE_PSC
   3943            *            @arg TIM_DMABASE_ARR
   3944            *            @arg TIM_DMABASE_RCR
   3945            *            @arg TIM_DMABASE_CCR1
   3946            *            @arg TIM_DMABASE_CCR2
   3947            *            @arg TIM_DMABASE_CCR3
   3948            *            @arg TIM_DMABASE_CCR4
   3949            *            @arg TIM_DMABASE_BDTR
   3950            *            @arg TIM_DMABASE_OR
   3951            *            @arg TIM_DMABASE_CCMR3 (*)
   3952            *            @arg TIM_DMABASE_CCR5 (*)
   3953            *            @arg TIM_DMABASE_CCR6 (*)
   3954            *         (*) value not defined in all devices
   3955            * @param  BurstRequestSrc TIM DMA Request sources
   3956            *         This parameter can be one of the following values:
   3957            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3958            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3959            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3960            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3961            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3962            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3963            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3964            * @param  BurstBuffer The Buffer address.
   3965            * @param  BurstLength DMA Burst length. This parameter can be one value
   3966            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3967            * @param  DataLength Data length. This parameter can be one value
   3968            *         between 1 and 0xFFFF.
   3969            * @retval HAL status
   3970            */
   3971          HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   3972                                                             uint32_t BurstRequestSrc, uint32_t *BurstBuffer,
   3973                                                             uint32_t  BurstLength,  uint32_t  DataLength)
   3974          {
   3975            /* Check the parameters */
   3976            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3977            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3978            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3979            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3980            assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
   3981          
   3982            if (htim->State == HAL_TIM_STATE_BUSY)
   3983            {
   3984              return HAL_BUSY;
   3985            }
   3986            else if (htim->State == HAL_TIM_STATE_READY)
   3987            {
   3988              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   3989              {
   3990                return HAL_ERROR;
   3991              }
   3992              else
   3993              {
   3994                htim->State = HAL_TIM_STATE_BUSY;
   3995              }
   3996            }
   3997            else
   3998            {
   3999              /* nothing to do */
   4000            }
   4001            switch (BurstRequestSrc)
   4002            {
   4003              case TIM_DMA_UPDATE:
   4004              {
   4005                /* Set the DMA Period elapsed callbacks */
   4006                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   4007                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   4008          
   4009                /* Set the DMA error callback */
   4010                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   4011          
   4012                /* Enable the DMA channel */
   4013                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer,
   4014                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4015                {
   4016                  return HAL_ERROR;
   4017                }
   4018                break;
   4019              }
   4020              case TIM_DMA_CC1:
   4021              {
   4022                /* Set the DMA compare callbacks */
   4023                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4024                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4025          
   4026                /* Set the DMA error callback */
   4027                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   4028          
   4029                /* Enable the DMA channel */
   4030                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
   4031                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4032                {
   4033                  return HAL_ERROR;
   4034                }
   4035                break;
   4036              }
   4037              case TIM_DMA_CC2:
   4038              {
   4039                /* Set the DMA compare callbacks */
   4040                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4041                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4042          
   4043                /* Set the DMA error callback */
   4044                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   4045          
   4046                /* Enable the DMA channel */
   4047                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
   4048                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4049                {
   4050                  return HAL_ERROR;
   4051                }
   4052                break;
   4053              }
   4054              case TIM_DMA_CC3:
   4055              {
   4056                /* Set the DMA compare callbacks */
   4057                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4058                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4059          
   4060                /* Set the DMA error callback */
   4061                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   4062          
   4063                /* Enable the DMA channel */
   4064                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
   4065                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4066                {
   4067                  return HAL_ERROR;
   4068                }
   4069                break;
   4070              }
   4071              case TIM_DMA_CC4:
   4072              {
   4073                /* Set the DMA compare callbacks */
   4074                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   4075                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   4076          
   4077                /* Set the DMA error callback */
   4078                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   4079          
   4080                /* Enable the DMA channel */
   4081                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
   4082                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4083                {
   4084                  return HAL_ERROR;
   4085                }
   4086                break;
   4087              }
   4088              case TIM_DMA_COM:
   4089              {
   4090                /* Set the DMA commutation callbacks */
   4091                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   4092                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   4093          
   4094                /* Set the DMA error callback */
   4095                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   4096          
   4097                /* Enable the DMA channel */
   4098                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
   4099                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4100                {
   4101                  return HAL_ERROR;
   4102                }
   4103                break;
   4104              }
   4105              case TIM_DMA_TRIGGER:
   4106              {
   4107                /* Set the DMA trigger callbacks */
   4108                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   4109                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   4110          
   4111                /* Set the DMA error callback */
   4112                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   4113          
   4114                /* Enable the DMA channel */
   4115                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
   4116                                     (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
   4117                {
   4118                  return HAL_ERROR;
   4119                }
   4120                break;
   4121              }
   4122              default:
   4123                break;
   4124            }
   4125          
   4126            /* Configure the DMA Burst Mode */
   4127            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   4128            /* Enable the TIM DMA Request */
   4129            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   4130          
   4131            htim->State = HAL_TIM_STATE_READY;
   4132          
   4133            /* Return function status */
   4134            return HAL_OK;
   4135          }
   4136          
   4137          /**
   4138            * @brief  Stops the TIM DMA Burst mode
   4139            * @param  htim TIM handle
   4140            * @param  BurstRequestSrc TIM DMA Request sources to disable
   4141            * @retval HAL status
   4142            */
   4143          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4144          {
   4145            HAL_StatusTypeDef status = HAL_OK;
   4146            /* Check the parameters */
   4147            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4148          
   4149            /* Abort the DMA transfer (at least disable the DMA channel) */
   4150            switch (BurstRequestSrc)
   4151            {
   4152              case TIM_DMA_UPDATE:
   4153              {
   4154                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   4155                break;
   4156              }
   4157              case TIM_DMA_CC1:
   4158              {
   4159                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   4160                break;
   4161              }
   4162              case TIM_DMA_CC2:
   4163              {
   4164                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4165                break;
   4166              }
   4167              case TIM_DMA_CC3:
   4168              {
   4169                status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4170                break;
   4171              }
   4172              case TIM_DMA_CC4:
   4173              {
   4174                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4175                break;
   4176              }
   4177              case TIM_DMA_COM:
   4178              {
   4179                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   4180                break;
   4181              }
   4182              case TIM_DMA_TRIGGER:
   4183              {
   4184                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4185                break;
   4186              }
   4187              default:
   4188                break;
   4189            }
   4190          
   4191            if (HAL_OK == status)
   4192            {
   4193              /* Disable the TIM Update DMA request */
   4194              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4195            }
   4196          
   4197            /* Return function status */
   4198            return status;
   4199          }
   4200          
   4201          /**
   4202            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4203            * @param  htim TIM handle
   4204            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4205            *         This parameter can be one of the following values:
   4206            *            @arg TIM_DMABASE_CR1
   4207            *            @arg TIM_DMABASE_CR2
   4208            *            @arg TIM_DMABASE_SMCR
   4209            *            @arg TIM_DMABASE_DIER
   4210            *            @arg TIM_DMABASE_SR
   4211            *            @arg TIM_DMABASE_EGR
   4212            *            @arg TIM_DMABASE_CCMR1
   4213            *            @arg TIM_DMABASE_CCMR2
   4214            *            @arg TIM_DMABASE_CCER
   4215            *            @arg TIM_DMABASE_CNT
   4216            *            @arg TIM_DMABASE_PSC
   4217            *            @arg TIM_DMABASE_ARR
   4218            *            @arg TIM_DMABASE_RCR
   4219            *            @arg TIM_DMABASE_CCR1
   4220            *            @arg TIM_DMABASE_CCR2
   4221            *            @arg TIM_DMABASE_CCR3
   4222            *            @arg TIM_DMABASE_CCR4
   4223            *            @arg TIM_DMABASE_BDTR
   4224            *            @arg TIM_DMABASE_OR
   4225            *            @arg TIM_DMABASE_CCMR3 (*)
   4226            *            @arg TIM_DMABASE_CCR5 (*)
   4227            *            @arg TIM_DMABASE_CCR6 (*)
   4228            *         (*) value not defined in all devices
   4229            * @param  BurstRequestSrc TIM DMA Request sources
   4230            *         This parameter can be one of the following values:
   4231            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4232            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4233            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4234            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4235            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4236            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4237            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4238            * @param  BurstBuffer The Buffer address.
   4239            * @param  BurstLength DMA Burst length. This parameter can be one value
   4240            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4241            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4242            * @retval HAL status
   4243            */
   4244          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4245                                                       uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
   4246          {
   4247            return HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
   4248                                                   ((BurstLength) >> 8U) + 1U);
   4249          }
   4250          
   4251          /**
   4252            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4253            * @param  htim TIM handle
   4254            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4255            *         This parameter can be one of the following values:
   4256            *            @arg TIM_DMABASE_CR1
   4257            *            @arg TIM_DMABASE_CR2
   4258            *            @arg TIM_DMABASE_SMCR
   4259            *            @arg TIM_DMABASE_DIER
   4260            *            @arg TIM_DMABASE_SR
   4261            *            @arg TIM_DMABASE_EGR
   4262            *            @arg TIM_DMABASE_CCMR1
   4263            *            @arg TIM_DMABASE_CCMR2
   4264            *            @arg TIM_DMABASE_CCER
   4265            *            @arg TIM_DMABASE_CNT
   4266            *            @arg TIM_DMABASE_PSC
   4267            *            @arg TIM_DMABASE_ARR
   4268            *            @arg TIM_DMABASE_RCR
   4269            *            @arg TIM_DMABASE_CCR1
   4270            *            @arg TIM_DMABASE_CCR2
   4271            *            @arg TIM_DMABASE_CCR3
   4272            *            @arg TIM_DMABASE_CCR4
   4273            *            @arg TIM_DMABASE_BDTR
   4274            *            @arg TIM_DMABASE_OR
   4275            *            @arg TIM_DMABASE_CCMR3 (*)
   4276            *            @arg TIM_DMABASE_CCR5 (*)
   4277            *            @arg TIM_DMABASE_CCR6 (*)
   4278            *         (*) value not defined in all devices
   4279            * @param  BurstRequestSrc TIM DMA Request sources
   4280            *         This parameter can be one of the following values:
   4281            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4282            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4283            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4284            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4285            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4286            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4287            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4288            * @param  BurstBuffer The Buffer address.
   4289            * @param  BurstLength DMA Burst length. This parameter can be one value
   4290            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4291            * @param  DataLength Data length. This parameter can be one value
   4292            *         between 1 and 0xFFFF.
   4293            * @retval HAL status
   4294            */
   4295          HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4296                                                            uint32_t BurstRequestSrc, uint32_t  *BurstBuffer,
   4297                                                            uint32_t  BurstLength, uint32_t  DataLength)
   4298          {
   4299            /* Check the parameters */
   4300            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4301            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4302            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4303            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   4304            assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
   4305          
   4306            if (htim->State == HAL_TIM_STATE_BUSY)
   4307            {
   4308              return HAL_BUSY;
   4309            }
   4310            else if (htim->State == HAL_TIM_STATE_READY)
   4311            {
   4312              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   4313              {
   4314                return HAL_ERROR;
   4315              }
   4316              else
   4317              {
   4318                htim->State = HAL_TIM_STATE_BUSY;
   4319              }
   4320            }
   4321            else
   4322            {
   4323              /* nothing to do */
   4324            }
   4325            switch (BurstRequestSrc)
   4326            {
   4327              case TIM_DMA_UPDATE:
   4328              {
   4329                /* Set the DMA Period elapsed callbacks */
   4330                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   4331                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   4332          
   4333                /* Set the DMA error callback */
   4334                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   4335          
   4336                /* Enable the DMA channel */
   4337                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4338                                     DataLength) != HAL_OK)
   4339                {
   4340                  return HAL_ERROR;
   4341                }
   4342                break;
   4343              }
   4344              case TIM_DMA_CC1:
   4345              {
   4346                /* Set the DMA capture callbacks */
   4347                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   4348                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4349          
   4350                /* Set the DMA error callback */
   4351                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   4352          
   4353                /* Enable the DMA channel */
   4354                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4355                                     DataLength) != HAL_OK)
   4356                {
   4357                  return HAL_ERROR;
   4358                }
   4359                break;
   4360              }
   4361              case TIM_DMA_CC2:
   4362              {
   4363                /* Set the DMA capture callbacks */
   4364                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   4365                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4366          
   4367                /* Set the DMA error callback */
   4368                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   4369          
   4370                /* Enable the DMA channel */
   4371                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4372                                     DataLength) != HAL_OK)
   4373                {
   4374                  return HAL_ERROR;
   4375                }
   4376                break;
   4377              }
   4378              case TIM_DMA_CC3:
   4379              {
   4380                /* Set the DMA capture callbacks */
   4381                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   4382                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4383          
   4384                /* Set the DMA error callback */
   4385                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   4386          
   4387                /* Enable the DMA channel */
   4388                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4389                                     DataLength) != HAL_OK)
   4390                {
   4391                  return HAL_ERROR;
   4392                }
   4393                break;
   4394              }
   4395              case TIM_DMA_CC4:
   4396              {
   4397                /* Set the DMA capture callbacks */
   4398                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   4399                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   4400          
   4401                /* Set the DMA error callback */
   4402                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   4403          
   4404                /* Enable the DMA channel */
   4405                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4406                                     DataLength) != HAL_OK)
   4407                {
   4408                  return HAL_ERROR;
   4409                }
   4410                break;
   4411              }
   4412              case TIM_DMA_COM:
   4413              {
   4414                /* Set the DMA commutation callbacks */
   4415                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   4416                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   4417          
   4418                /* Set the DMA error callback */
   4419                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   4420          
   4421                /* Enable the DMA channel */
   4422                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4423                                     DataLength) != HAL_OK)
   4424                {
   4425                  return HAL_ERROR;
   4426                }
   4427                break;
   4428              }
   4429              case TIM_DMA_TRIGGER:
   4430              {
   4431                /* Set the DMA trigger callbacks */
   4432                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   4433                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   4434          
   4435                /* Set the DMA error callback */
   4436                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   4437          
   4438                /* Enable the DMA channel */
   4439                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
   4440                                     DataLength) != HAL_OK)
   4441                {
   4442                  return HAL_ERROR;
   4443                }
   4444                break;
   4445              }
   4446              default:
   4447                break;
   4448            }
   4449          
   4450            /* Configure the DMA Burst Mode */
   4451            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   4452          
   4453            /* Enable the TIM DMA Request */
   4454            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   4455          
   4456            htim->State = HAL_TIM_STATE_READY;
   4457          
   4458            /* Return function status */
   4459            return HAL_OK;
   4460          }
   4461          
   4462          /**
   4463            * @brief  Stop the DMA burst reading
   4464            * @param  htim TIM handle
   4465            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   4466            * @retval HAL status
   4467            */
   4468          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4469          {
   4470            HAL_StatusTypeDef status = HAL_OK;
   4471            /* Check the parameters */
   4472            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4473          
   4474            /* Abort the DMA transfer (at least disable the DMA channel) */
   4475            switch (BurstRequestSrc)
   4476            {
   4477              case TIM_DMA_UPDATE:
   4478              {
   4479                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   4480                break;
   4481              }
   4482              case TIM_DMA_CC1:
   4483              {
   4484                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   4485                break;
   4486              }
   4487              case TIM_DMA_CC2:
   4488              {
   4489                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   4490                break;
   4491              }
   4492              case TIM_DMA_CC3:
   4493              {
   4494                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   4495                break;
   4496              }
   4497              case TIM_DMA_CC4:
   4498              {
   4499                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   4500                break;
   4501              }
   4502              case TIM_DMA_COM:
   4503              {
   4504                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   4505                break;
   4506              }
   4507              case TIM_DMA_TRIGGER:
   4508              {
   4509                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   4510                break;
   4511              }
   4512              default:
   4513                break;
   4514            }
   4515          
   4516            if (HAL_OK == status)
   4517            {
   4518              /* Disable the TIM Update DMA request */
   4519              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   4520            }
   4521          
   4522            /* Return function status */
   4523            return status;
   4524          }
   4525          
   4526          /**
   4527            * @brief  Generate a software event
   4528            * @param  htim TIM handle
   4529            * @param  EventSource specifies the event source.
   4530            *          This parameter can be one of the following values:
   4531            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   4532            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   4533            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   4534            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   4535            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   4536            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
   4537            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   4538            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   4539            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source
   4540            * @note   Basic timers can only generate an update event.
   4541            * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
   4542            * @note   TIM_EVENTSOURCE_BREAK are relevant only for timer instances
   4543            *         supporting a break input.
   4544            * @retval HAL status
   4545            */
   4546          
   4547          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   4548          {
   4549            /* Check the parameters */
   4550            assert_param(IS_TIM_INSTANCE(htim->Instance));
   4551            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   4552          
   4553            /* Process Locked */
   4554            __HAL_LOCK(htim);
   4555          
   4556            /* Change the TIM state */
   4557            htim->State = HAL_TIM_STATE_BUSY;
   4558          
   4559            /* Set the event sources */
   4560            htim->Instance->EGR = EventSource;
   4561          
   4562            /* Change the TIM state */
   4563            htim->State = HAL_TIM_STATE_READY;
   4564          
   4565            __HAL_UNLOCK(htim);
   4566          
   4567            /* Return function status */
   4568            return HAL_OK;
   4569          }
   4570          
   4571          /**
   4572            * @brief  Configures the OCRef clear feature
   4573            * @param  htim TIM handle
   4574            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   4575            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   4576            * @param  Channel specifies the TIM Channel
   4577            *          This parameter can be one of the following values:
   4578            *            @arg TIM_CHANNEL_1: TIM Channel 1
   4579            *            @arg TIM_CHANNEL_2: TIM Channel 2
   4580            *            @arg TIM_CHANNEL_3: TIM Channel 3
   4581            *            @arg TIM_CHANNEL_4: TIM Channel 4
   4582            *            @arg TIM_CHANNEL_5: TIM Channel 5 (*)
   4583            *            @arg TIM_CHANNEL_6: TIM Channel 6 (*)
   4584            *         (*) Value not defined for all devices
   4585            * @retval HAL status
   4586            */
   4587          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   4588                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   4589                                                     uint32_t Channel)
   4590          {
   4591            /* Check the parameters */
   4592            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   4593            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   4594          
   4595            /* Process Locked */
   4596            __HAL_LOCK(htim);
   4597          
   4598            htim->State = HAL_TIM_STATE_BUSY;
   4599          
   4600            switch (sClearInputConfig->ClearInputSource)
   4601            {
   4602              case TIM_CLEARINPUTSOURCE_NONE:
   4603              {
   4604                /* Clear the OCREF clear selection bit and the the ETR Bits */
   4605          #if defined(TIM_SMCR_OCCS)
   4606                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_OCCS | TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   4607          #else
   4608                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   4609          #endif /* TIM_SMCR_OCCS */
   4610                break;
   4611              }
   4612          #if defined(TIM_SMCR_OCCS)
   4613              case TIM_CLEARINPUTSOURCE_OCREFCLR:
   4614              {
   4615                /* Clear the OCREF clear selection bit */
   4616                CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   4617              }
   4618              break;
   4619          #endif /* TIM_SMCR_OCCS */
   4620          
   4621              case TIM_CLEARINPUTSOURCE_ETR:
   4622              {
   4623                /* Check the parameters */
   4624                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   4625                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   4626                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   4627          
   4628                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   4629                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   4630                {
   4631                  htim->State = HAL_TIM_STATE_READY;
   4632                  __HAL_UNLOCK(htim);
   4633                  return HAL_ERROR;
   4634                }
   4635          
   4636                TIM_ETR_SetConfig(htim->Instance,
   4637                                  sClearInputConfig->ClearInputPrescaler,
   4638                                  sClearInputConfig->ClearInputPolarity,
   4639                                  sClearInputConfig->ClearInputFilter);
   4640          #if defined(TIM_SMCR_OCCS)
   4641          
   4642                /* Set the OCREF clear selection bit */
   4643                SET_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   4644          #endif /* TIM_SMCR_OCCS */
   4645                break;
   4646              }
   4647          
   4648              default:
   4649                break;
   4650            }
   4651          
   4652            switch (Channel)
   4653            {
   4654              case TIM_CHANNEL_1:
   4655              {
   4656                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4657                {
   4658                  /* Enable the OCREF clear feature for Channel 1 */
   4659                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   4660                }
   4661                else
   4662                {
   4663                  /* Disable the OCREF clear feature for Channel 1 */
   4664                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   4665                }
   4666                break;
   4667              }
   4668              case TIM_CHANNEL_2:
   4669              {
   4670                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4671                {
   4672                  /* Enable the OCREF clear feature for Channel 2 */
   4673                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   4674                }
   4675                else
   4676                {
   4677                  /* Disable the OCREF clear feature for Channel 2 */
   4678                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   4679                }
   4680                break;
   4681              }
   4682              case TIM_CHANNEL_3:
   4683              {
   4684                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4685                {
   4686                  /* Enable the OCREF clear feature for Channel 3 */
   4687                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   4688                }
   4689                else
   4690                {
   4691                  /* Disable the OCREF clear feature for Channel 3 */
   4692                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   4693                }
   4694                break;
   4695              }
   4696              case TIM_CHANNEL_4:
   4697              {
   4698                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4699                {
   4700                  /* Enable the OCREF clear feature for Channel 4 */
   4701                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   4702                }
   4703                else
   4704                {
   4705                  /* Disable the OCREF clear feature for Channel 4 */
   4706                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   4707                }
   4708                break;
   4709              }
   4710          #if defined(TIM_CCER_CC5E)
   4711              case TIM_CHANNEL_5:
   4712              {
   4713                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4714                {
   4715                  /* Enable the OCREF clear feature for Channel 5 */
   4716                  SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
   4717                }
   4718                else
   4719                {
   4720                  /* Disable the OCREF clear feature for Channel 5 */
   4721                  CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
   4722                }
   4723                break;
   4724              }
   4725          #endif /* TIM_CCER_CC5E */
   4726          #if defined(TIM_CCER_CC6E)
   4727              case TIM_CHANNEL_6:
   4728              {
   4729                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   4730                {
   4731                  /* Enable the OCREF clear feature for Channel 6 */
   4732                  SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
   4733                }
   4734                else
   4735                {
   4736                  /* Disable the OCREF clear feature for Channel 6 */
   4737                  CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
   4738                }
   4739                break;
   4740              }
   4741          #endif /* TIM_CCER_CC6E */
   4742              default:
   4743                break;
   4744            }
   4745          
   4746            htim->State = HAL_TIM_STATE_READY;
   4747          
   4748            __HAL_UNLOCK(htim);
   4749          
   4750            return HAL_OK;
   4751          }
   4752          
   4753          /**
   4754            * @brief   Configures the clock source to be used
   4755            * @param  htim TIM handle
   4756            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   4757            *         contains the clock source information for the TIM peripheral.
   4758            * @retval HAL status
   4759            */
   4760          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
   4761          {
   4762            uint32_t tmpsmcr;
   4763          
   4764            /* Process Locked */
   4765            __HAL_LOCK(htim);
   4766          
   4767            htim->State = HAL_TIM_STATE_BUSY;
   4768          
   4769            /* Check the parameters */
   4770            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   4771          
   4772            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   4773            tmpsmcr = htim->Instance->SMCR;
   4774            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   4775            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   4776            htim->Instance->SMCR = tmpsmcr;
   4777          
   4778            switch (sClockSourceConfig->ClockSource)
   4779            {
   4780              case TIM_CLOCKSOURCE_INTERNAL:
   4781              {
   4782                assert_param(IS_TIM_INSTANCE(htim->Instance));
   4783                break;
   4784              }
   4785          
   4786              case TIM_CLOCKSOURCE_ETRMODE1:
   4787              {
   4788                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   4789                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4790          
   4791                /* Check ETR input conditioning related parameters */
   4792                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4793                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4794                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4795          
   4796                /* Configure the ETR Clock source */
   4797                TIM_ETR_SetConfig(htim->Instance,
   4798                                  sClockSourceConfig->ClockPrescaler,
   4799                                  sClockSourceConfig->ClockPolarity,
   4800                                  sClockSourceConfig->ClockFilter);
   4801          
   4802                /* Select the External clock mode1 and the ETRF trigger */
   4803                tmpsmcr = htim->Instance->SMCR;
   4804                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   4805                /* Write to TIMx SMCR */
   4806                htim->Instance->SMCR = tmpsmcr;
   4807                break;
   4808              }
   4809          
   4810              case TIM_CLOCKSOURCE_ETRMODE2:
   4811              {
   4812                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4813                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4814          
   4815                /* Check ETR input conditioning related parameters */
   4816                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4817                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4818                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4819          
   4820                /* Configure the ETR Clock source */
   4821                TIM_ETR_SetConfig(htim->Instance,
   4822                                  sClockSourceConfig->ClockPrescaler,
   4823                                  sClockSourceConfig->ClockPolarity,
   4824                                  sClockSourceConfig->ClockFilter);
   4825                /* Enable the External clock mode2 */
   4826                htim->Instance->SMCR |= TIM_SMCR_ECE;
   4827                break;
   4828              }
   4829          
   4830              case TIM_CLOCKSOURCE_TI1:
   4831              {
   4832                /* Check whether or not the timer instance supports external clock mode 1 */
   4833                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4834          
   4835                /* Check TI1 input conditioning related parameters */
   4836                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4837                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4838          
   4839                TIM_TI1_ConfigInputStage(htim->Instance,
   4840                                         sClockSourceConfig->ClockPolarity,
   4841                                         sClockSourceConfig->ClockFilter);
   4842                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   4843                break;
   4844              }
   4845          
   4846              case TIM_CLOCKSOURCE_TI2:
   4847              {
   4848                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4849                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4850          
   4851                /* Check TI2 input conditioning related parameters */
   4852                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4853                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4854          
   4855                TIM_TI2_ConfigInputStage(htim->Instance,
   4856                                         sClockSourceConfig->ClockPolarity,
   4857                                         sClockSourceConfig->ClockFilter);
   4858                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   4859                break;
   4860              }
   4861          
   4862              case TIM_CLOCKSOURCE_TI1ED:
   4863              {
   4864                /* Check whether or not the timer instance supports external clock mode 1 */
   4865                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4866          
   4867                /* Check TI1 input conditioning related parameters */
   4868                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4869                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4870          
   4871                TIM_TI1_ConfigInputStage(htim->Instance,
   4872                                         sClockSourceConfig->ClockPolarity,
   4873                                         sClockSourceConfig->ClockFilter);
   4874                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   4875                break;
   4876              }
   4877          
   4878              case TIM_CLOCKSOURCE_ITR0:
   4879              case TIM_CLOCKSOURCE_ITR1:
   4880              case TIM_CLOCKSOURCE_ITR2:
   4881              case TIM_CLOCKSOURCE_ITR3:
   4882              {
   4883                /* Check whether or not the timer instance supports internal trigger input */
   4884                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4885          
   4886                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   4887                break;
   4888              }
   4889          
   4890              default:
   4891                break;
   4892            }
   4893            htim->State = HAL_TIM_STATE_READY;
   4894          
   4895            __HAL_UNLOCK(htim);
   4896          
   4897            return HAL_OK;
   4898          }
   4899          
   4900          /**
   4901            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4902            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4903            * @param  htim TIM handle.
   4904            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4905            *         output of a XOR gate.
   4906            *          This parameter can be one of the following values:
   4907            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4908            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4909            *            pins are connected to the TI1 input (XOR combination)
   4910            * @retval HAL status
   4911            */
   4912          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4913          {
   4914            uint32_t tmpcr2;
   4915          
   4916            /* Check the parameters */
   4917            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4918            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4919          
   4920            /* Get the TIMx CR2 register value */
   4921            tmpcr2 = htim->Instance->CR2;
   4922          
   4923            /* Reset the TI1 selection */
   4924            tmpcr2 &= ~TIM_CR2_TI1S;
   4925          
   4926            /* Set the TI1 selection */
   4927            tmpcr2 |= TI1_Selection;
   4928          
   4929            /* Write to TIMxCR2 */
   4930            htim->Instance->CR2 = tmpcr2;
   4931          
   4932            return HAL_OK;
   4933          }
   4934          
   4935          /**
   4936            * @brief  Configures the TIM in Slave mode
   4937            * @param  htim TIM handle.
   4938            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4939            *         contains the selected trigger (internal trigger input, filtered
   4940            *         timer input or external trigger input) and the Slave mode
   4941            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4942            * @retval HAL status
   4943            */
   4944          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
   4945          {
   4946            /* Check the parameters */
   4947            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4948            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4949            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4950          
   4951            __HAL_LOCK(htim);
   4952          
   4953            htim->State = HAL_TIM_STATE_BUSY;
   4954          
   4955            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   4956            {
   4957              htim->State = HAL_TIM_STATE_READY;
   4958              __HAL_UNLOCK(htim);
   4959              return HAL_ERROR;
   4960            }
   4961          
   4962            /* Disable Trigger Interrupt */
   4963            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   4964          
   4965            /* Disable Trigger DMA request */
   4966            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4967          
   4968            htim->State = HAL_TIM_STATE_READY;
   4969          
   4970            __HAL_UNLOCK(htim);
   4971          
   4972            return HAL_OK;
   4973          }
   4974          
   4975          /**
   4976            * @brief  Configures the TIM in Slave mode in interrupt mode
   4977            * @param  htim TIM handle.
   4978            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4979            *         contains the selected trigger (internal trigger input, filtered
   4980            *         timer input or external trigger input) and the Slave mode
   4981            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4982            * @retval HAL status
   4983            */
   4984          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   4985                                                          TIM_SlaveConfigTypeDef *sSlaveConfig)
   4986          {
   4987            /* Check the parameters */
   4988            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4989            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4990            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4991          
   4992            __HAL_LOCK(htim);
   4993          
   4994            htim->State = HAL_TIM_STATE_BUSY;
   4995          
   4996            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   4997            {
   4998              htim->State = HAL_TIM_STATE_READY;
   4999              __HAL_UNLOCK(htim);
   5000              return HAL_ERROR;
   5001            }
   5002          
   5003            /* Enable Trigger Interrupt */
   5004            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   5005          
   5006            /* Disable Trigger DMA request */
   5007            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   5008          
   5009            htim->State = HAL_TIM_STATE_READY;
   5010          
   5011            __HAL_UNLOCK(htim);
   5012          
   5013            return HAL_OK;
   5014          }
   5015          
   5016          /**
   5017            * @brief  Read the captured value from Capture Compare unit
   5018            * @param  htim TIM handle.
   5019            * @param  Channel TIM Channels to be enabled
   5020            *          This parameter can be one of the following values:
   5021            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   5022            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   5023            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   5024            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   5025            * @retval Captured value
   5026            */
   5027          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   5028          {
   5029            uint32_t tmpreg = 0U;
   5030          
   5031            switch (Channel)
   5032            {
   5033              case TIM_CHANNEL_1:
   5034              {
   5035                /* Check the parameters */
   5036                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5037          
   5038                /* Return the capture 1 value */
   5039                tmpreg =  htim->Instance->CCR1;
   5040          
   5041                break;
   5042              }
   5043              case TIM_CHANNEL_2:
   5044              {
   5045                /* Check the parameters */
   5046                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5047          
   5048                /* Return the capture 2 value */
   5049                tmpreg =   htim->Instance->CCR2;
   5050          
   5051                break;
   5052              }
   5053          
   5054              case TIM_CHANNEL_3:
   5055              {
   5056                /* Check the parameters */
   5057                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   5058          
   5059                /* Return the capture 3 value */
   5060                tmpreg =   htim->Instance->CCR3;
   5061          
   5062                break;
   5063              }
   5064          
   5065              case TIM_CHANNEL_4:
   5066              {
   5067                /* Check the parameters */
   5068                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   5069          
   5070                /* Return the capture 4 value */
   5071                tmpreg =   htim->Instance->CCR4;
   5072          
   5073                break;
   5074              }
   5075          
   5076              default:
   5077                break;
   5078            }
   5079          
   5080            return tmpreg;
   5081          }
   5082          
   5083          /**
   5084            * @}
   5085            */
   5086          
   5087          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   5088            *  @brief    TIM Callbacks functions
   5089            *
   5090          @verbatim
   5091            ==============================================================================
   5092                                  ##### TIM Callbacks functions #####
   5093            ==============================================================================
   5094           [..]
   5095             This section provides TIM callback functions:
   5096             (+) TIM Period elapsed callback
   5097             (+) TIM Output Compare callback
   5098             (+) TIM Input capture callback
   5099             (+) TIM Trigger callback
   5100             (+) TIM Error callback
   5101          
   5102          @endverbatim
   5103            * @{
   5104            */
   5105          
   5106          /**
   5107            * @brief  Period elapsed callback in non-blocking mode
   5108            * @param  htim TIM handle
   5109            * @retval None
   5110            */
   5111          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   5112          {
   5113            /* Prevent unused argument(s) compilation warning */
   5114            UNUSED(htim);
   5115          
   5116            /* NOTE : This function should not be modified, when the callback is needed,
   5117                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   5118             */
   5119          }
   5120          
   5121          /**
   5122            * @brief  Period elapsed half complete callback in non-blocking mode
   5123            * @param  htim TIM handle
   5124            * @retval None
   5125            */
   5126          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   5127          {
   5128            /* Prevent unused argument(s) compilation warning */
   5129            UNUSED(htim);
   5130          
   5131            /* NOTE : This function should not be modified, when the callback is needed,
   5132                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   5133             */
   5134          }
   5135          
   5136          /**
   5137            * @brief  Output Compare callback in non-blocking mode
   5138            * @param  htim TIM OC handle
   5139            * @retval None
   5140            */
   5141          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   5142          {
   5143            /* Prevent unused argument(s) compilation warning */
   5144            UNUSED(htim);
   5145          
   5146            /* NOTE : This function should not be modified, when the callback is needed,
   5147                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   5148             */
   5149          }
   5150          
   5151          /**
   5152            * @brief  Input Capture callback in non-blocking mode
   5153            * @param  htim TIM IC handle
   5154            * @retval None
   5155            */
   5156          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   5157          {
   5158            /* Prevent unused argument(s) compilation warning */
   5159            UNUSED(htim);
   5160          
   5161            /* NOTE : This function should not be modified, when the callback is needed,
   5162                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   5163             */
   5164          }
   5165          
   5166          /**
   5167            * @brief  Input Capture half complete callback in non-blocking mode
   5168            * @param  htim TIM IC handle
   5169            * @retval None
   5170            */
   5171          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   5172          {
   5173            /* Prevent unused argument(s) compilation warning */
   5174            UNUSED(htim);
   5175          
   5176            /* NOTE : This function should not be modified, when the callback is needed,
   5177                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   5178             */
   5179          }
   5180          
   5181          /**
   5182            * @brief  PWM Pulse finished callback in non-blocking mode
   5183            * @param  htim TIM handle
   5184            * @retval None
   5185            */
   5186          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   5187          {
   5188            /* Prevent unused argument(s) compilation warning */
   5189            UNUSED(htim);
   5190          
   5191            /* NOTE : This function should not be modified, when the callback is needed,
   5192                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   5193             */
   5194          }
   5195          
   5196          /**
   5197            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   5198            * @param  htim TIM handle
   5199            * @retval None
   5200            */
   5201          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   5202          {
   5203            /* Prevent unused argument(s) compilation warning */
   5204            UNUSED(htim);
   5205          
   5206            /* NOTE : This function should not be modified, when the callback is needed,
   5207                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   5208             */
   5209          }
   5210          
   5211          /**
   5212            * @brief  Hall Trigger detection callback in non-blocking mode
   5213            * @param  htim TIM handle
   5214            * @retval None
   5215            */
   5216          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   5217          {
   5218            /* Prevent unused argument(s) compilation warning */
   5219            UNUSED(htim);
   5220          
   5221            /* NOTE : This function should not be modified, when the callback is needed,
   5222                      the HAL_TIM_TriggerCallback could be implemented in the user file
   5223             */
   5224          }
   5225          
   5226          /**
   5227            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   5228            * @param  htim TIM handle
   5229            * @retval None
   5230            */
   5231          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   5232          {
   5233            /* Prevent unused argument(s) compilation warning */
   5234            UNUSED(htim);
   5235          
   5236            /* NOTE : This function should not be modified, when the callback is needed,
   5237                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   5238             */
   5239          }
   5240          
   5241          /**
   5242            * @brief  Timer error callback in non-blocking mode
   5243            * @param  htim TIM handle
   5244            * @retval None
   5245            */
   5246          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   5247          {
   5248            /* Prevent unused argument(s) compilation warning */
   5249            UNUSED(htim);
   5250          
   5251            /* NOTE : This function should not be modified, when the callback is needed,
   5252                      the HAL_TIM_ErrorCallback could be implemented in the user file
   5253             */
   5254          }
   5255          
   5256          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5257          /**
   5258            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   5259            * @param htim tim handle
   5260            * @param CallbackID ID of the callback to be registered
   5261            *        This parameter can be one of the following values:
   5262            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5263            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5264            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5265            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5266            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5267            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5268            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5269            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5270            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5271            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5272            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5273            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5274            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5275            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5276            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5277            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5278            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5279            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5280            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5281            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5282            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5283            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5284            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5285            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5286            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5287            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5288            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5289          #if defined(TIM_BDTR_BK2E)
   5290            *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
   5291          #endif
   5292            *          @param pCallback pointer to the callback function
   5293            *          @retval status
   5294            */
   5295          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,
   5296                                                     pTIM_CallbackTypeDef pCallback)
   5297          {
   5298            HAL_StatusTypeDef status = HAL_OK;
   5299          
   5300            if (pCallback == NULL)
   5301            {
   5302              return HAL_ERROR;
   5303            }
   5304            /* Process locked */
   5305            __HAL_LOCK(htim);
   5306          
   5307            if (htim->State == HAL_TIM_STATE_READY)
   5308            {
   5309              switch (CallbackID)
   5310              {
   5311                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5312                  htim->Base_MspInitCallback                 = pCallback;
   5313                  break;
   5314          
   5315                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5316                  htim->Base_MspDeInitCallback               = pCallback;
   5317                  break;
   5318          
   5319                case HAL_TIM_IC_MSPINIT_CB_ID :
   5320                  htim->IC_MspInitCallback                   = pCallback;
   5321                  break;
   5322          
   5323                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5324                  htim->IC_MspDeInitCallback                 = pCallback;
   5325                  break;
   5326          
   5327                case HAL_TIM_OC_MSPINIT_CB_ID :
   5328                  htim->OC_MspInitCallback                   = pCallback;
   5329                  break;
   5330          
   5331                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5332                  htim->OC_MspDeInitCallback                 = pCallback;
   5333                  break;
   5334          
   5335                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5336                  htim->PWM_MspInitCallback                  = pCallback;
   5337                  break;
   5338          
   5339                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5340                  htim->PWM_MspDeInitCallback                = pCallback;
   5341                  break;
   5342          
   5343                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5344                  htim->OnePulse_MspInitCallback             = pCallback;
   5345                  break;
   5346          
   5347                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5348                  htim->OnePulse_MspDeInitCallback           = pCallback;
   5349                  break;
   5350          
   5351                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5352                  htim->Encoder_MspInitCallback              = pCallback;
   5353                  break;
   5354          
   5355                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5356                  htim->Encoder_MspDeInitCallback            = pCallback;
   5357                  break;
   5358          
   5359                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5360                  htim->HallSensor_MspInitCallback           = pCallback;
   5361                  break;
   5362          
   5363                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5364                  htim->HallSensor_MspDeInitCallback         = pCallback;
   5365                  break;
   5366          
   5367                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5368                  htim->PeriodElapsedCallback                = pCallback;
   5369                  break;
   5370          
   5371                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5372                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   5373                  break;
   5374          
   5375                case HAL_TIM_TRIGGER_CB_ID :
   5376                  htim->TriggerCallback                      = pCallback;
   5377                  break;
   5378          
   5379                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5380                  htim->TriggerHalfCpltCallback              = pCallback;
   5381                  break;
   5382          
   5383                case HAL_TIM_IC_CAPTURE_CB_ID :
   5384                  htim->IC_CaptureCallback                   = pCallback;
   5385                  break;
   5386          
   5387                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5388                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   5389                  break;
   5390          
   5391                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5392                  htim->OC_DelayElapsedCallback              = pCallback;
   5393                  break;
   5394          
   5395                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5396                  htim->PWM_PulseFinishedCallback            = pCallback;
   5397                  break;
   5398          
   5399                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5400                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   5401                  break;
   5402          
   5403                case HAL_TIM_ERROR_CB_ID :
   5404                  htim->ErrorCallback                        = pCallback;
   5405                  break;
   5406          
   5407                case HAL_TIM_COMMUTATION_CB_ID :
   5408                  htim->CommutationCallback                  = pCallback;
   5409                  break;
   5410          
   5411                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5412                  htim->CommutationHalfCpltCallback          = pCallback;
   5413                  break;
   5414          
   5415                case HAL_TIM_BREAK_CB_ID :
   5416                  htim->BreakCallback                        = pCallback;
   5417                  break;
   5418          #if defined(TIM_BDTR_BK2E)
   5419          
   5420                case HAL_TIM_BREAK2_CB_ID :
   5421                  htim->Break2Callback                       = pCallback;
   5422                  break;
   5423          #endif /* TIM_BDTR_BK2E */
   5424          
   5425                default :
   5426                  /* Return error status */
   5427                  status =  HAL_ERROR;
   5428                  break;
   5429              }
   5430            }
   5431            else if (htim->State == HAL_TIM_STATE_RESET)
   5432            {
   5433              switch (CallbackID)
   5434              {
   5435                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5436                  htim->Base_MspInitCallback         = pCallback;
   5437                  break;
   5438          
   5439                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5440                  htim->Base_MspDeInitCallback       = pCallback;
   5441                  break;
   5442          
   5443                case HAL_TIM_IC_MSPINIT_CB_ID :
   5444                  htim->IC_MspInitCallback           = pCallback;
   5445                  break;
   5446          
   5447                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5448                  htim->IC_MspDeInitCallback         = pCallback;
   5449                  break;
   5450          
   5451                case HAL_TIM_OC_MSPINIT_CB_ID :
   5452                  htim->OC_MspInitCallback           = pCallback;
   5453                  break;
   5454          
   5455                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5456                  htim->OC_MspDeInitCallback         = pCallback;
   5457                  break;
   5458          
   5459                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5460                  htim->PWM_MspInitCallback          = pCallback;
   5461                  break;
   5462          
   5463                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5464                  htim->PWM_MspDeInitCallback        = pCallback;
   5465                  break;
   5466          
   5467                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5468                  htim->OnePulse_MspInitCallback     = pCallback;
   5469                  break;
   5470          
   5471                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5472                  htim->OnePulse_MspDeInitCallback   = pCallback;
   5473                  break;
   5474          
   5475                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5476                  htim->Encoder_MspInitCallback      = pCallback;
   5477                  break;
   5478          
   5479                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5480                  htim->Encoder_MspDeInitCallback    = pCallback;
   5481                  break;
   5482          
   5483                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5484                  htim->HallSensor_MspInitCallback   = pCallback;
   5485                  break;
   5486          
   5487                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5488                  htim->HallSensor_MspDeInitCallback = pCallback;
   5489                  break;
   5490          
   5491                default :
   5492                  /* Return error status */
   5493                  status =  HAL_ERROR;
   5494                  break;
   5495              }
   5496            }
   5497            else
   5498            {
   5499              /* Return error status */
   5500              status =  HAL_ERROR;
   5501            }
   5502          
   5503            /* Release Lock */
   5504            __HAL_UNLOCK(htim);
   5505          
   5506            return status;
   5507          }
   5508          
   5509          /**
   5510            * @brief  Unregister a TIM callback
   5511            *         TIM callback is redirected to the weak predefined callback
   5512            * @param htim tim handle
   5513            * @param CallbackID ID of the callback to be unregistered
   5514            *        This parameter can be one of the following values:
   5515            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5516            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5517            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5518            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5519            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5520            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5521            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5522            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5523            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5524            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5525            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5526            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5527            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5528            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5529            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5530            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5531            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5532            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5533            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5534            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5535            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5536            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5537            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5538            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5539            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5540            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5541            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5542          #if defined(TIM_BDTR_BK2E)
   5543            *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
   5544          #endif
   5545            *          @retval status
   5546            */
   5547          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   5548          {
   5549            HAL_StatusTypeDef status = HAL_OK;
   5550          
   5551            /* Process locked */
   5552            __HAL_LOCK(htim);
   5553          
   5554            if (htim->State == HAL_TIM_STATE_READY)
   5555            {
   5556              switch (CallbackID)
   5557              {
   5558                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5559                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;                      /* Legacy weak Base MspInit Callback */
   5560                  break;
   5561          
   5562                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5563                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;                    /* Legacy weak Base Msp DeInit Callback */
   5564                  break;
   5565          
   5566                case HAL_TIM_IC_MSPINIT_CB_ID :
   5567                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;                        /* Legacy weak IC Msp Init Callback */
   5568                  break;
   5569          
   5570                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5571                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;                      /* Legacy weak IC Msp DeInit Callback */
   5572                  break;
   5573          
   5574                case HAL_TIM_OC_MSPINIT_CB_ID :
   5575                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;                        /* Legacy weak OC Msp Init Callback */
   5576                  break;
   5577          
   5578                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5579                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;                      /* Legacy weak OC Msp DeInit Callback */
   5580                  break;
   5581          
   5582                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5583                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;                       /* Legacy weak PWM Msp Init Callback */
   5584                  break;
   5585          
   5586                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5587                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;                     /* Legacy weak PWM Msp DeInit Callback */
   5588                  break;
   5589          
   5590                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5591                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;                  /* Legacy weak One Pulse Msp Init Callback */
   5592                  break;
   5593          
   5594                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5595                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;                /* Legacy weak One Pulse Msp DeInit Callback */
   5596                  break;
   5597          
   5598                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5599                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;                   /* Legacy weak Encoder Msp Init Callback */
   5600                  break;
   5601          
   5602                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5603                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;                 /* Legacy weak Encoder Msp DeInit Callback */
   5604                  break;
   5605          
   5606                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5607                  htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;              /* Legacy weak Hall Sensor Msp Init Callback */
   5608                  break;
   5609          
   5610                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5611                  htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;            /* Legacy weak Hall Sensor Msp DeInit Callback */
   5612                  break;
   5613          
   5614                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5615                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak Period Elapsed Callback */
   5616                  break;
   5617          
   5618                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5619                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak Period Elapsed half complete Callback */
   5620                  break;
   5621          
   5622                case HAL_TIM_TRIGGER_CB_ID :
   5623                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak Trigger Callback */
   5624                  break;
   5625          
   5626                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5627                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak Trigger half complete Callback */
   5628                  break;
   5629          
   5630                case HAL_TIM_IC_CAPTURE_CB_ID :
   5631                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC Capture Callback */
   5632                  break;
   5633          
   5634                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5635                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC Capture half complete Callback */
   5636                  break;
   5637          
   5638                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5639                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC Delay Elapsed Callback */
   5640                  break;
   5641          
   5642                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5643                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM Pulse Finished Callback */
   5644                  break;
   5645          
   5646                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5647                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM Pulse Finished half complete Callback */
   5648                  break;
   5649          
   5650                case HAL_TIM_ERROR_CB_ID :
   5651                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak Error Callback */
   5652                  break;
   5653          
   5654                case HAL_TIM_COMMUTATION_CB_ID :
   5655                  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak Commutation Callback */
   5656                  break;
   5657          
   5658                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5659                  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak Commutation half complete Callback */
   5660                  break;
   5661          
   5662                case HAL_TIM_BREAK_CB_ID :
   5663                  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak Break Callback */
   5664                  break;
   5665          #if defined(TIM_BDTR_BK2E)
   5666          
   5667                case HAL_TIM_BREAK2_CB_ID :
   5668                  htim->Break2Callback                    = HAL_TIMEx_Break2Callback;                  /* Legacy weak Break2 Callback */
   5669                  break;
   5670          #endif /* TIM_BDTR_BK2E */
   5671          
   5672                default :
   5673                  /* Return error status */
   5674                  status =  HAL_ERROR;
   5675                  break;
   5676              }
   5677            }
   5678            else if (htim->State == HAL_TIM_STATE_RESET)
   5679            {
   5680              switch (CallbackID)
   5681              {
   5682                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5683                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;              /* Legacy weak Base MspInit Callback */
   5684                  break;
   5685          
   5686                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5687                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;            /* Legacy weak Base Msp DeInit Callback */
   5688                  break;
   5689          
   5690                case HAL_TIM_IC_MSPINIT_CB_ID :
   5691                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;                /* Legacy weak IC Msp Init Callback */
   5692                  break;
   5693          
   5694                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5695                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;              /* Legacy weak IC Msp DeInit Callback */
   5696                  break;
   5697          
   5698                case HAL_TIM_OC_MSPINIT_CB_ID :
   5699                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;                /* Legacy weak OC Msp Init Callback */
   5700                  break;
   5701          
   5702                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5703                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;              /* Legacy weak OC Msp DeInit Callback */
   5704                  break;
   5705          
   5706                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5707                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;               /* Legacy weak PWM Msp Init Callback */
   5708                  break;
   5709          
   5710                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5711                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;             /* Legacy weak PWM Msp DeInit Callback */
   5712                  break;
   5713          
   5714                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5715                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;          /* Legacy weak One Pulse Msp Init Callback */
   5716                  break;
   5717          
   5718                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5719                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;        /* Legacy weak One Pulse Msp DeInit Callback */
   5720                  break;
   5721          
   5722                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5723                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;           /* Legacy weak Encoder Msp Init Callback */
   5724                  break;
   5725          
   5726                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5727                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;         /* Legacy weak Encoder Msp DeInit Callback */
   5728                  break;
   5729          
   5730                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5731                  htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;      /* Legacy weak Hall Sensor Msp Init Callback */
   5732                  break;
   5733          
   5734                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5735                  htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;    /* Legacy weak Hall Sensor Msp DeInit Callback */
   5736                  break;
   5737          
   5738                default :
   5739                  /* Return error status */
   5740                  status =  HAL_ERROR;
   5741                  break;
   5742              }
   5743            }
   5744            else
   5745            {
   5746              /* Return error status */
   5747              status =  HAL_ERROR;
   5748            }
   5749          
   5750            /* Release Lock */
   5751            __HAL_UNLOCK(htim);
   5752          
   5753            return status;
   5754          }
   5755          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5756          
   5757          /**
   5758            * @}
   5759            */
   5760          
   5761          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   5762            *  @brief   TIM Peripheral State functions
   5763            *
   5764          @verbatim
   5765            ==============================================================================
   5766                                  ##### Peripheral State functions #####
   5767            ==============================================================================
   5768              [..]
   5769              This subsection permits to get in run-time the status of the peripheral
   5770              and the data flow.
   5771          
   5772          @endverbatim
   5773            * @{
   5774            */
   5775          
   5776          /**
   5777            * @brief  Return the TIM Base handle state.
   5778            * @param  htim TIM Base handle
   5779            * @retval HAL state
   5780            */
   5781          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   5782          {
   5783            return htim->State;
   5784          }
   5785          
   5786          /**
   5787            * @brief  Return the TIM OC handle state.
   5788            * @param  htim TIM Output Compare handle
   5789            * @retval HAL state
   5790            */
   5791          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   5792          {
   5793            return htim->State;
   5794          }
   5795          
   5796          /**
   5797            * @brief  Return the TIM PWM handle state.
   5798            * @param  htim TIM handle
   5799            * @retval HAL state
   5800            */
   5801          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   5802          {
   5803            return htim->State;
   5804          }
   5805          
   5806          /**
   5807            * @brief  Return the TIM Input Capture handle state.
   5808            * @param  htim TIM IC handle
   5809            * @retval HAL state
   5810            */
   5811          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   5812          {
   5813            return htim->State;
   5814          }
   5815          
   5816          /**
   5817            * @brief  Return the TIM One Pulse Mode handle state.
   5818            * @param  htim TIM OPM handle
   5819            * @retval HAL state
   5820            */
   5821          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   5822          {
   5823            return htim->State;
   5824          }
   5825          
   5826          /**
   5827            * @brief  Return the TIM Encoder Mode handle state.
   5828            * @param  htim TIM Encoder Interface handle
   5829            * @retval HAL state
   5830            */
   5831          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   5832          {
   5833            return htim->State;
   5834          }
   5835          
   5836          /**
   5837            * @}
   5838            */
   5839          
   5840          /**
   5841            * @}
   5842            */
   5843          
   5844          /** @defgroup TIM_Private_Functions TIM Private Functions
   5845            * @{
   5846            */
   5847          
   5848          /**
   5849            * @brief  TIM DMA error callback
   5850            * @param  hdma pointer to DMA handle.
   5851            * @retval None
   5852            */
   5853          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   5854          {
   5855            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5856          
   5857            htim->State = HAL_TIM_STATE_READY;
   5858          
   5859          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5860            htim->ErrorCallback(htim);
   5861          #else
   5862            HAL_TIM_ErrorCallback(htim);
   5863          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5864          }
   5865          
   5866          /**
   5867            * @brief  TIM DMA Delay Pulse complete callback.
   5868            * @param  hdma pointer to DMA handle.
   5869            * @retval None
   5870            */
   5871          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   5872          {
   5873            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5874          
   5875            htim->State = HAL_TIM_STATE_READY;
   5876          
   5877            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5878            {
   5879              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5880            }
   5881            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5882            {
   5883              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5884            }
   5885            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5886            {
   5887              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5888            }
   5889            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5890            {
   5891              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5892            }
   5893            else
   5894            {
   5895              /* nothing to do */
   5896            }
   5897          
   5898          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5899            htim->PWM_PulseFinishedCallback(htim);
   5900          #else
   5901            HAL_TIM_PWM_PulseFinishedCallback(htim);
   5902          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5903          
   5904            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5905          }
   5906          
   5907          /**
   5908            * @brief  TIM DMA Delay Pulse half complete callback.
   5909            * @param  hdma pointer to DMA handle.
   5910            * @retval None
   5911            */
   5912          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   5913          {
   5914            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5915          
   5916            htim->State = HAL_TIM_STATE_READY;
   5917          
   5918            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5919            {
   5920              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5921            }
   5922            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5923            {
   5924              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5925            }
   5926            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5927            {
   5928              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5929            }
   5930            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5931            {
   5932              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5933            }
   5934            else
   5935            {
   5936              /* nothing to do */
   5937            }
   5938          
   5939          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5940            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   5941          #else
   5942            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   5943          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5944          
   5945            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5946          }
   5947          
   5948          /**
   5949            * @brief  TIM DMA Capture complete callback.
   5950            * @param  hdma pointer to DMA handle.
   5951            * @retval None
   5952            */
   5953          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   5954          {
   5955            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5956          
   5957            htim->State = HAL_TIM_STATE_READY;
   5958          
   5959            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   5960            {
   5961              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   5962            }
   5963            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   5964            {
   5965              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   5966            }
   5967            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   5968            {
   5969              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   5970            }
   5971            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   5972            {
   5973              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   5974            }
   5975            else
   5976            {
   5977              /* nothing to do */
   5978            }
   5979          
   5980          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5981            htim->IC_CaptureCallback(htim);
   5982          #else
   5983            HAL_TIM_IC_CaptureCallback(htim);
   5984          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5985          
   5986            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   5987          }
   5988          
   5989          /**
   5990            * @brief  TIM DMA Capture half complete callback.
   5991            * @param  hdma pointer to DMA handle.
   5992            * @retval None
   5993            */
   5994          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   5995          {
   5996            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   5997          
   5998            htim->State = HAL_TIM_STATE_READY;
   5999          
   6000            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   6001            {
   6002              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   6003            }
   6004            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   6005            {
   6006              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   6007            }
   6008            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   6009            {
   6010              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   6011            }
   6012            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   6013            {
   6014              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   6015            }
   6016            else
   6017            {
   6018              /* nothing to do */
   6019            }
   6020          
   6021          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6022            htim->IC_CaptureHalfCpltCallback(htim);
   6023          #else
   6024            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   6025          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6026          
   6027            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   6028          }
   6029          
   6030          /**
   6031            * @brief  TIM DMA Period Elapse complete callback.
   6032            * @param  hdma pointer to DMA handle.
   6033            * @retval None
   6034            */
   6035          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   6036          {
   6037            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6038          
   6039            htim->State = HAL_TIM_STATE_READY;
   6040          
   6041          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6042            htim->PeriodElapsedCallback(htim);
   6043          #else
   6044            HAL_TIM_PeriodElapsedCallback(htim);
   6045          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6046          }
   6047          
   6048          /**
   6049            * @brief  TIM DMA Period Elapse half complete callback.
   6050            * @param  hdma pointer to DMA handle.
   6051            * @retval None
   6052            */
   6053          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   6054          {
   6055            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6056          
   6057            htim->State = HAL_TIM_STATE_READY;
   6058          
   6059          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6060            htim->PeriodElapsedHalfCpltCallback(htim);
   6061          #else
   6062            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   6063          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6064          }
   6065          
   6066          /**
   6067            * @brief  TIM DMA Trigger callback.
   6068            * @param  hdma pointer to DMA handle.
   6069            * @retval None
   6070            */
   6071          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   6072          {
   6073            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6074          
   6075            htim->State = HAL_TIM_STATE_READY;
   6076          
   6077          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6078            htim->TriggerCallback(htim);
   6079          #else
   6080            HAL_TIM_TriggerCallback(htim);
   6081          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6082          }
   6083          
   6084          /**
   6085            * @brief  TIM DMA Trigger half complete callback.
   6086            * @param  hdma pointer to DMA handle.
   6087            * @retval None
   6088            */
   6089          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   6090          {
   6091            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   6092          
   6093            htim->State = HAL_TIM_STATE_READY;
   6094          
   6095          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6096            htim->TriggerHalfCpltCallback(htim);
   6097          #else
   6098            HAL_TIM_TriggerHalfCpltCallback(htim);
   6099          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6100          }
   6101          
   6102          /**
   6103            * @brief  Time Base configuration
   6104            * @param  TIMx TIM peripheral
   6105            * @param  Structure TIM Base configuration structure
   6106            * @retval None
   6107            */
   6108          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   6109          {
   6110            uint32_t tmpcr1;
   6111            tmpcr1 = TIMx->CR1;
   6112          
   6113            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   6114            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   6115            {
   6116              /* Select the Counter Mode */
   6117              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   6118              tmpcr1 |= Structure->CounterMode;
   6119            }
   6120          
   6121            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   6122            {
   6123              /* Set the clock division */
   6124              tmpcr1 &= ~TIM_CR1_CKD;
   6125              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   6126            }
   6127          
   6128            /* Set the auto-reload preload */
   6129            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   6130          
   6131            TIMx->CR1 = tmpcr1;
   6132          
   6133            /* Set the Autoreload value */
   6134            TIMx->ARR = (uint32_t)Structure->Period ;
   6135          
   6136            /* Set the Prescaler value */
   6137            TIMx->PSC = Structure->Prescaler;
   6138          
   6139            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   6140            {
   6141              /* Set the Repetition Counter value */
   6142              TIMx->RCR = Structure->RepetitionCounter;
   6143            }
   6144          
   6145            /* Generate an update event to reload the Prescaler
   6146               and the repetition counter (only for advanced timer) value immediately */
   6147            TIMx->EGR = TIM_EGR_UG;
   6148          }
   6149          
   6150          /**
   6151            * @brief  Timer Output Compare 1 configuration
   6152            * @param  TIMx to select the TIM peripheral
   6153            * @param  OC_Config The ouput configuration structure
   6154            * @retval None
   6155            */
   6156          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6157          {
   6158            uint32_t tmpccmrx;
   6159            uint32_t tmpccer;
   6160            uint32_t tmpcr2;
   6161          
   6162            /* Disable the Channel 1: Reset the CC1E Bit */
   6163            TIMx->CCER &= ~TIM_CCER_CC1E;
   6164          
   6165            /* Get the TIMx CCER register value */
   6166            tmpccer = TIMx->CCER;
   6167            /* Get the TIMx CR2 register value */
   6168            tmpcr2 =  TIMx->CR2;
   6169          
   6170            /* Get the TIMx CCMR1 register value */
   6171            tmpccmrx = TIMx->CCMR1;
   6172          
   6173            /* Reset the Output Compare Mode Bits */
   6174            tmpccmrx &= ~TIM_CCMR1_OC1M;
   6175            tmpccmrx &= ~TIM_CCMR1_CC1S;
   6176            /* Select the Output Compare Mode */
   6177            tmpccmrx |= OC_Config->OCMode;
   6178          
   6179            /* Reset the Output Polarity level */
   6180            tmpccer &= ~TIM_CCER_CC1P;
   6181            /* Set the Output Compare Polarity */
   6182            tmpccer |= OC_Config->OCPolarity;
   6183          
   6184            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   6185            {
   6186              /* Check parameters */
   6187              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6188          
   6189              /* Reset the Output N Polarity level */
   6190              tmpccer &= ~TIM_CCER_CC1NP;
   6191              /* Set the Output N Polarity */
   6192              tmpccer |= OC_Config->OCNPolarity;
   6193              /* Reset the Output N State */
   6194              tmpccer &= ~TIM_CCER_CC1NE;
   6195            }
   6196          
   6197            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6198            {
   6199              /* Check parameters */
   6200              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6201              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6202          
   6203              /* Reset the Output Compare and Output Compare N IDLE State */
   6204              tmpcr2 &= ~TIM_CR2_OIS1;
   6205              tmpcr2 &= ~TIM_CR2_OIS1N;
   6206              /* Set the Output Idle state */
   6207              tmpcr2 |= OC_Config->OCIdleState;
   6208              /* Set the Output N Idle state */
   6209              tmpcr2 |= OC_Config->OCNIdleState;
   6210            }
   6211          
   6212            /* Write to TIMx CR2 */
   6213            TIMx->CR2 = tmpcr2;
   6214          
   6215            /* Write to TIMx CCMR1 */
   6216            TIMx->CCMR1 = tmpccmrx;
   6217          
   6218            /* Set the Capture Compare Register value */
   6219            TIMx->CCR1 = OC_Config->Pulse;
   6220          
   6221            /* Write to TIMx CCER */
   6222            TIMx->CCER = tmpccer;
   6223          }
   6224          
   6225          /**
   6226            * @brief  Timer Output Compare 2 configuration
   6227            * @param  TIMx to select the TIM peripheral
   6228            * @param  OC_Config The ouput configuration structure
   6229            * @retval None
   6230            */
   6231          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6232          {
   6233            uint32_t tmpccmrx;
   6234            uint32_t tmpccer;
   6235            uint32_t tmpcr2;
   6236          
   6237            /* Disable the Channel 2: Reset the CC2E Bit */
   6238            TIMx->CCER &= ~TIM_CCER_CC2E;
   6239          
   6240            /* Get the TIMx CCER register value */
   6241            tmpccer = TIMx->CCER;
   6242            /* Get the TIMx CR2 register value */
   6243            tmpcr2 =  TIMx->CR2;
   6244          
   6245            /* Get the TIMx CCMR1 register value */
   6246            tmpccmrx = TIMx->CCMR1;
   6247          
   6248            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6249            tmpccmrx &= ~TIM_CCMR1_OC2M;
   6250            tmpccmrx &= ~TIM_CCMR1_CC2S;
   6251          
   6252            /* Select the Output Compare Mode */
   6253            tmpccmrx |= (OC_Config->OCMode << 8U);
   6254          
   6255            /* Reset the Output Polarity level */
   6256            tmpccer &= ~TIM_CCER_CC2P;
   6257            /* Set the Output Compare Polarity */
   6258            tmpccer |= (OC_Config->OCPolarity << 4U);
   6259          
   6260            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   6261            {
   6262              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6263          
   6264              /* Reset the Output N Polarity level */
   6265              tmpccer &= ~TIM_CCER_CC2NP;
   6266              /* Set the Output N Polarity */
   6267              tmpccer |= (OC_Config->OCNPolarity << 4U);
   6268              /* Reset the Output N State */
   6269              tmpccer &= ~TIM_CCER_CC2NE;
   6270          
   6271            }
   6272          
   6273            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6274            {
   6275              /* Check parameters */
   6276              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6277              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6278          
   6279              /* Reset the Output Compare and Output Compare N IDLE State */
   6280              tmpcr2 &= ~TIM_CR2_OIS2;
   6281          #if defined(TIM_CR2_OIS2N)
   6282              tmpcr2 &= ~TIM_CR2_OIS2N;
   6283          #endif /* TIM_CR2_OIS2N */
   6284              /* Set the Output Idle state */
   6285              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   6286              /* Set the Output N Idle state */
   6287              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   6288            }
   6289          
   6290            /* Write to TIMx CR2 */
   6291            TIMx->CR2 = tmpcr2;
   6292          
   6293            /* Write to TIMx CCMR1 */
   6294            TIMx->CCMR1 = tmpccmrx;
   6295          
   6296            /* Set the Capture Compare Register value */
   6297            TIMx->CCR2 = OC_Config->Pulse;
   6298          
   6299            /* Write to TIMx CCER */
   6300            TIMx->CCER = tmpccer;
   6301          }
   6302          
   6303          /**
   6304            * @brief  Timer Output Compare 3 configuration
   6305            * @param  TIMx to select the TIM peripheral
   6306            * @param  OC_Config The ouput configuration structure
   6307            * @retval None
   6308            */
   6309          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6310          {
   6311            uint32_t tmpccmrx;
   6312            uint32_t tmpccer;
   6313            uint32_t tmpcr2;
   6314          
   6315            /* Disable the Channel 3: Reset the CC2E Bit */
   6316            TIMx->CCER &= ~TIM_CCER_CC3E;
   6317          
   6318            /* Get the TIMx CCER register value */
   6319            tmpccer = TIMx->CCER;
   6320            /* Get the TIMx CR2 register value */
   6321            tmpcr2 =  TIMx->CR2;
   6322          
   6323            /* Get the TIMx CCMR2 register value */
   6324            tmpccmrx = TIMx->CCMR2;
   6325          
   6326            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6327            tmpccmrx &= ~TIM_CCMR2_OC3M;
   6328            tmpccmrx &= ~TIM_CCMR2_CC3S;
   6329            /* Select the Output Compare Mode */
   6330            tmpccmrx |= OC_Config->OCMode;
   6331          
   6332            /* Reset the Output Polarity level */
   6333            tmpccer &= ~TIM_CCER_CC3P;
   6334            /* Set the Output Compare Polarity */
   6335            tmpccer |= (OC_Config->OCPolarity << 8U);
   6336          
   6337            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   6338            {
   6339              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6340          
   6341              /* Reset the Output N Polarity level */
   6342              tmpccer &= ~TIM_CCER_CC3NP;
   6343              /* Set the Output N Polarity */
   6344              tmpccer |= (OC_Config->OCNPolarity << 8U);
   6345              /* Reset the Output N State */
   6346              tmpccer &= ~TIM_CCER_CC3NE;
   6347            }
   6348          
   6349          #if defined(TIM_CR2_OIS3)
   6350            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6351            {
   6352              /* Check parameters */
   6353              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6354              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6355          
   6356              /* Reset the Output Compare and Output Compare N IDLE State */
   6357              tmpcr2 &= ~TIM_CR2_OIS3;
   6358              tmpcr2 &= ~TIM_CR2_OIS3N;
   6359              /* Set the Output Idle state */
   6360              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   6361              /* Set the Output N Idle state */
   6362              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   6363            }
   6364          #endif /* TIM_CR2_OIS3 */
   6365          
   6366            /* Write to TIMx CR2 */
   6367            TIMx->CR2 = tmpcr2;
   6368          
   6369            /* Write to TIMx CCMR2 */
   6370            TIMx->CCMR2 = tmpccmrx;
   6371          
   6372            /* Set the Capture Compare Register value */
   6373            TIMx->CCR3 = OC_Config->Pulse;
   6374          
   6375            /* Write to TIMx CCER */
   6376            TIMx->CCER = tmpccer;
   6377          }
   6378          
   6379          /**
   6380            * @brief  Timer Output Compare 4 configuration
   6381            * @param  TIMx to select the TIM peripheral
   6382            * @param  OC_Config The ouput configuration structure
   6383            * @retval None
   6384            */
   6385          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6386          {
   6387            uint32_t tmpccmrx;
   6388            uint32_t tmpccer;
   6389            uint32_t tmpcr2;
   6390          
   6391            /* Disable the Channel 4: Reset the CC4E Bit */
   6392            TIMx->CCER &= ~TIM_CCER_CC4E;
   6393          
   6394            /* Get the TIMx CCER register value */
   6395            tmpccer = TIMx->CCER;
   6396            /* Get the TIMx CR2 register value */
   6397            tmpcr2 =  TIMx->CR2;
   6398          
   6399            /* Get the TIMx CCMR2 register value */
   6400            tmpccmrx = TIMx->CCMR2;
   6401          
   6402            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6403            tmpccmrx &= ~TIM_CCMR2_OC4M;
   6404            tmpccmrx &= ~TIM_CCMR2_CC4S;
   6405          
   6406            /* Select the Output Compare Mode */
   6407            tmpccmrx |= (OC_Config->OCMode << 8U);
   6408          
   6409            /* Reset the Output Polarity level */
   6410            tmpccer &= ~TIM_CCER_CC4P;
   6411            /* Set the Output Compare Polarity */
   6412            tmpccer |= (OC_Config->OCPolarity << 12U);
   6413          
   6414          #if defined(TIM_CR2_OIS4)
   6415            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6416            {
   6417              /* Check parameters */
   6418              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6419          
   6420              /* Reset the Output Compare IDLE State */
   6421              tmpcr2 &= ~TIM_CR2_OIS4;
   6422          
   6423              /* Set the Output Idle state */
   6424              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   6425            }
   6426          #endif /* TIM_CR2_OIS4 */
   6427          
   6428            /* Write to TIMx CR2 */
   6429            TIMx->CR2 = tmpcr2;
   6430          
   6431            /* Write to TIMx CCMR2 */
   6432            TIMx->CCMR2 = tmpccmrx;
   6433          
   6434            /* Set the Capture Compare Register value */
   6435            TIMx->CCR4 = OC_Config->Pulse;
   6436          
   6437            /* Write to TIMx CCER */
   6438            TIMx->CCER = tmpccer;
   6439          }
   6440          
   6441          #if defined(TIM_CCER_CC5E)
   6442          /**
   6443            * @brief  Timer Output Compare 5 configuration
   6444            * @param  TIMx to select the TIM peripheral
   6445            * @param  OC_Config The ouput configuration structure
   6446            * @retval None
   6447            */
   6448          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
   6449                                        TIM_OC_InitTypeDef *OC_Config)
   6450          {
   6451            uint32_t tmpccmrx;
   6452            uint32_t tmpccer;
   6453            uint32_t tmpcr2;
   6454          
   6455            /* Disable the output: Reset the CCxE Bit */
   6456            TIMx->CCER &= ~TIM_CCER_CC5E;
   6457          
   6458            /* Get the TIMx CCER register value */
   6459            tmpccer = TIMx->CCER;
   6460            /* Get the TIMx CR2 register value */
   6461            tmpcr2 =  TIMx->CR2;
   6462            /* Get the TIMx CCMR1 register value */
   6463            tmpccmrx = TIMx->CCMR3;
   6464          
   6465            /* Reset the Output Compare Mode Bits */
   6466            tmpccmrx &= ~(TIM_CCMR3_OC5M);
   6467            /* Select the Output Compare Mode */
   6468            tmpccmrx |= OC_Config->OCMode;
   6469          
   6470            /* Reset the Output Polarity level */
   6471            tmpccer &= ~TIM_CCER_CC5P;
   6472            /* Set the Output Compare Polarity */
   6473            tmpccer |= (OC_Config->OCPolarity << 16U);
   6474          
   6475            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6476            {
   6477              /* Reset the Output Compare IDLE State */
   6478              tmpcr2 &= ~TIM_CR2_OIS5;
   6479              /* Set the Output Idle state */
   6480              tmpcr2 |= (OC_Config->OCIdleState << 8U);
   6481            }
   6482            /* Write to TIMx CR2 */
   6483            TIMx->CR2 = tmpcr2;
   6484          
   6485            /* Write to TIMx CCMR3 */
   6486            TIMx->CCMR3 = tmpccmrx;
   6487          
   6488            /* Set the Capture Compare Register value */
   6489            TIMx->CCR5 = OC_Config->Pulse;
   6490          
   6491            /* Write to TIMx CCER */
   6492            TIMx->CCER = tmpccer;
   6493          }
   6494          #endif /* TIM_CCER_CC5E */
   6495          
   6496          #if defined(TIM_CCER_CC6E)
   6497          /**
   6498            * @brief  Timer Output Compare 6 configuration
   6499            * @param  TIMx to select the TIM peripheral
   6500            * @param  OC_Config The ouput configuration structure
   6501            * @retval None
   6502            */
   6503          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
   6504                                        TIM_OC_InitTypeDef *OC_Config)
   6505          {
   6506            uint32_t tmpccmrx;
   6507            uint32_t tmpccer;
   6508            uint32_t tmpcr2;
   6509          
   6510            /* Disable the output: Reset the CCxE Bit */
   6511            TIMx->CCER &= ~TIM_CCER_CC6E;
   6512          
   6513            /* Get the TIMx CCER register value */
   6514            tmpccer = TIMx->CCER;
   6515            /* Get the TIMx CR2 register value */
   6516            tmpcr2 =  TIMx->CR2;
   6517            /* Get the TIMx CCMR1 register value */
   6518            tmpccmrx = TIMx->CCMR3;
   6519          
   6520            /* Reset the Output Compare Mode Bits */
   6521            tmpccmrx &= ~(TIM_CCMR3_OC6M);
   6522            /* Select the Output Compare Mode */
   6523            tmpccmrx |= (OC_Config->OCMode << 8U);
   6524          
   6525            /* Reset the Output Polarity level */
   6526            tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   6527            /* Set the Output Compare Polarity */
   6528            tmpccer |= (OC_Config->OCPolarity << 20U);
   6529          
   6530            if (IS_TIM_BREAK_INSTANCE(TIMx))
   6531            {
   6532              /* Reset the Output Compare IDLE State */
   6533              tmpcr2 &= ~TIM_CR2_OIS6;
   6534              /* Set the Output Idle state */
   6535              tmpcr2 |= (OC_Config->OCIdleState << 10U);
   6536            }
   6537          
   6538            /* Write to TIMx CR2 */
   6539            TIMx->CR2 = tmpcr2;
   6540          
   6541            /* Write to TIMx CCMR3 */
   6542            TIMx->CCMR3 = tmpccmrx;
   6543          
   6544            /* Set the Capture Compare Register value */
   6545            TIMx->CCR6 = OC_Config->Pulse;
   6546          
   6547            /* Write to TIMx CCER */
   6548            TIMx->CCER = tmpccer;
   6549          }
   6550          #endif /* TIM_CCER_CC6E */
   6551          
   6552          /**
   6553            * @brief  Slave Timer configuration function
   6554            * @param  htim TIM handle
   6555            * @param  sSlaveConfig Slave timer configuration
   6556            * @retval None
   6557            */
   6558          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   6559                                                            TIM_SlaveConfigTypeDef *sSlaveConfig)
   6560          {
   6561            uint32_t tmpsmcr;
   6562            uint32_t tmpccmr1;
   6563            uint32_t tmpccer;
   6564          
   6565            /* Get the TIMx SMCR register value */
   6566            tmpsmcr = htim->Instance->SMCR;
   6567          
   6568            /* Reset the Trigger Selection Bits */
   6569            tmpsmcr &= ~TIM_SMCR_TS;
   6570            /* Set the Input Trigger source */
   6571            tmpsmcr |= sSlaveConfig->InputTrigger;
   6572          
   6573            /* Reset the slave mode Bits */
   6574            tmpsmcr &= ~TIM_SMCR_SMS;
   6575            /* Set the slave mode */
   6576            tmpsmcr |= sSlaveConfig->SlaveMode;
   6577          
   6578            /* Write to TIMx SMCR */
   6579            htim->Instance->SMCR = tmpsmcr;
   6580          
   6581            /* Configure the trigger prescaler, filter, and polarity */
   6582            switch (sSlaveConfig->InputTrigger)
   6583            {
   6584              case TIM_TS_ETRF:
   6585              {
   6586                /* Check the parameters */
   6587                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   6588                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   6589                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6590                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6591                /* Configure the ETR Trigger source */
   6592                TIM_ETR_SetConfig(htim->Instance,
   6593                                  sSlaveConfig->TriggerPrescaler,
   6594                                  sSlaveConfig->TriggerPolarity,
   6595                                  sSlaveConfig->TriggerFilter);
   6596                break;
   6597              }
   6598          
   6599              case TIM_TS_TI1F_ED:
   6600              {
   6601                /* Check the parameters */
   6602                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6603                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6604          
   6605                if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   6606                {
   6607                  return HAL_ERROR;
   6608                }
   6609          
   6610                /* Disable the Channel 1: Reset the CC1E Bit */
   6611                tmpccer = htim->Instance->CCER;
   6612                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   6613                tmpccmr1 = htim->Instance->CCMR1;
   6614          
   6615                /* Set the filter */
   6616                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6617                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   6618          
   6619                /* Write to TIMx CCMR1 and CCER registers */
   6620                htim->Instance->CCMR1 = tmpccmr1;
   6621                htim->Instance->CCER = tmpccer;
   6622                break;
   6623              }
   6624          
   6625              case TIM_TS_TI1FP1:
   6626              {
   6627                /* Check the parameters */
   6628                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6629                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6630                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6631          
   6632                /* Configure TI1 Filter and Polarity */
   6633                TIM_TI1_ConfigInputStage(htim->Instance,
   6634                                         sSlaveConfig->TriggerPolarity,
   6635                                         sSlaveConfig->TriggerFilter);
   6636                break;
   6637              }
   6638          
   6639              case TIM_TS_TI2FP2:
   6640              {
   6641                /* Check the parameters */
   6642                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6643                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6644                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6645          
   6646                /* Configure TI2 Filter and Polarity */
   6647                TIM_TI2_ConfigInputStage(htim->Instance,
   6648                                         sSlaveConfig->TriggerPolarity,
   6649                                         sSlaveConfig->TriggerFilter);
   6650                break;
   6651              }
   6652          
   6653              case TIM_TS_ITR0:
   6654              case TIM_TS_ITR1:
   6655              case TIM_TS_ITR2:
   6656              case TIM_TS_ITR3:
   6657              {
   6658                /* Check the parameter */
   6659                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6660                break;
   6661              }
   6662          
   6663              default:
   6664                break;
   6665            }
   6666            return HAL_OK;
   6667          }
   6668          
   6669          /**
   6670            * @brief  Configure the TI1 as Input.
   6671            * @param  TIMx to select the TIM peripheral.
   6672            * @param  TIM_ICPolarity The Input Polarity.
   6673            *          This parameter can be one of the following values:
   6674            *            @arg TIM_ICPOLARITY_RISING
   6675            *            @arg TIM_ICPOLARITY_FALLING
   6676            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6677            * @param  TIM_ICSelection specifies the input to be used.
   6678            *          This parameter can be one of the following values:
   6679            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   6680            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   6681            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   6682            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6683            *          This parameter must be a value between 0x00 and 0x0F.
   6684            * @retval None
   6685            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   6686            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   6687            *        protected against un-initialized filter and polarity values.
   6688            */
   6689          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6690                                 uint32_t TIM_ICFilter)
   6691          {
   6692            uint32_t tmpccmr1;
   6693            uint32_t tmpccer;
   6694          
   6695            /* Disable the Channel 1: Reset the CC1E Bit */
   6696            TIMx->CCER &= ~TIM_CCER_CC1E;
   6697            tmpccmr1 = TIMx->CCMR1;
   6698            tmpccer = TIMx->CCER;
   6699          
   6700            /* Select the Input */
   6701            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   6702            {
   6703              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   6704              tmpccmr1 |= TIM_ICSelection;
   6705            }
   6706            else
   6707            {
   6708              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   6709            }
   6710          
   6711            /* Set the filter */
   6712            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6713            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   6714          
   6715            /* Select the Polarity and set the CC1E Bit */
   6716            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   6717            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   6718          
   6719            /* Write to TIMx CCMR1 and CCER registers */
   6720            TIMx->CCMR1 = tmpccmr1;
   6721            TIMx->CCER = tmpccer;
   6722          }
   6723          
   6724          /**
   6725            * @brief  Configure the Polarity and Filter for TI1.
   6726            * @param  TIMx to select the TIM peripheral.
   6727            * @param  TIM_ICPolarity The Input Polarity.
   6728            *          This parameter can be one of the following values:
   6729            *            @arg TIM_ICPOLARITY_RISING
   6730            *            @arg TIM_ICPOLARITY_FALLING
   6731            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6732            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6733            *          This parameter must be a value between 0x00 and 0x0F.
   6734            * @retval None
   6735            */
   6736          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6737          {
   6738            uint32_t tmpccmr1;
   6739            uint32_t tmpccer;
   6740          
   6741            /* Disable the Channel 1: Reset the CC1E Bit */
   6742            tmpccer = TIMx->CCER;
   6743            TIMx->CCER &= ~TIM_CCER_CC1E;
   6744            tmpccmr1 = TIMx->CCMR1;
   6745          
   6746            /* Set the filter */
   6747            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   6748            tmpccmr1 |= (TIM_ICFilter << 4U);
   6749          
   6750            /* Select the Polarity and set the CC1E Bit */
   6751            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   6752            tmpccer |= TIM_ICPolarity;
   6753          
   6754            /* Write to TIMx CCMR1 and CCER registers */
   6755            TIMx->CCMR1 = tmpccmr1;
   6756            TIMx->CCER = tmpccer;
   6757          }
   6758          
   6759          /**
   6760            * @brief  Configure the TI2 as Input.
   6761            * @param  TIMx to select the TIM peripheral
   6762            * @param  TIM_ICPolarity The Input Polarity.
   6763            *          This parameter can be one of the following values:
   6764            *            @arg TIM_ICPOLARITY_RISING
   6765            *            @arg TIM_ICPOLARITY_FALLING
   6766            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6767            * @param  TIM_ICSelection specifies the input to be used.
   6768            *          This parameter can be one of the following values:
   6769            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   6770            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   6771            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   6772            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6773            *          This parameter must be a value between 0x00 and 0x0F.
   6774            * @retval None
   6775            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   6776            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   6777            *        protected against un-initialized filter and polarity values.
   6778            */
   6779          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6780                                        uint32_t TIM_ICFilter)
   6781          {
   6782            uint32_t tmpccmr1;
   6783            uint32_t tmpccer;
   6784          
   6785            /* Disable the Channel 2: Reset the CC2E Bit */
   6786            TIMx->CCER &= ~TIM_CCER_CC2E;
   6787            tmpccmr1 = TIMx->CCMR1;
   6788            tmpccer = TIMx->CCER;
   6789          
   6790            /* Select the Input */
   6791            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   6792            tmpccmr1 |= (TIM_ICSelection << 8U);
   6793          
   6794            /* Set the filter */
   6795            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6796            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   6797          
   6798            /* Select the Polarity and set the CC2E Bit */
   6799            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6800            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   6801          
   6802            /* Write to TIMx CCMR1 and CCER registers */
   6803            TIMx->CCMR1 = tmpccmr1 ;
   6804            TIMx->CCER = tmpccer;
   6805          }
   6806          
   6807          /**
   6808            * @brief  Configure the Polarity and Filter for TI2.
   6809            * @param  TIMx to select the TIM peripheral.
   6810            * @param  TIM_ICPolarity The Input Polarity.
   6811            *          This parameter can be one of the following values:
   6812            *            @arg TIM_ICPOLARITY_RISING
   6813            *            @arg TIM_ICPOLARITY_FALLING
   6814            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6815            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6816            *          This parameter must be a value between 0x00 and 0x0F.
   6817            * @retval None
   6818            */
   6819          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6820          {
   6821            uint32_t tmpccmr1;
   6822            uint32_t tmpccer;
   6823          
   6824            /* Disable the Channel 2: Reset the CC2E Bit */
   6825            TIMx->CCER &= ~TIM_CCER_CC2E;
   6826            tmpccmr1 = TIMx->CCMR1;
   6827            tmpccer = TIMx->CCER;
   6828          
   6829            /* Set the filter */
   6830            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   6831            tmpccmr1 |= (TIM_ICFilter << 12U);
   6832          
   6833            /* Select the Polarity and set the CC2E Bit */
   6834            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   6835            tmpccer |= (TIM_ICPolarity << 4U);
   6836          
   6837            /* Write to TIMx CCMR1 and CCER registers */
   6838            TIMx->CCMR1 = tmpccmr1 ;
   6839            TIMx->CCER = tmpccer;
   6840          }
   6841          
   6842          /**
   6843            * @brief  Configure the TI3 as Input.
   6844            * @param  TIMx to select the TIM peripheral
   6845            * @param  TIM_ICPolarity The Input Polarity.
   6846            *          This parameter can be one of the following values:
   6847            *            @arg TIM_ICPOLARITY_RISING
   6848            *            @arg TIM_ICPOLARITY_FALLING
   6849            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6850            * @param  TIM_ICSelection specifies the input to be used.
   6851            *          This parameter can be one of the following values:
   6852            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   6853            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   6854            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   6855            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6856            *          This parameter must be a value between 0x00 and 0x0F.
   6857            * @retval None
   6858            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   6859            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6860            *        protected against un-initialized filter and polarity values.
   6861            */
   6862          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6863                                        uint32_t TIM_ICFilter)
   6864          {
   6865            uint32_t tmpccmr2;
   6866            uint32_t tmpccer;
   6867          
   6868            /* Disable the Channel 3: Reset the CC3E Bit */
   6869            TIMx->CCER &= ~TIM_CCER_CC3E;
   6870            tmpccmr2 = TIMx->CCMR2;
   6871            tmpccer = TIMx->CCER;
   6872          
   6873            /* Select the Input */
   6874            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   6875            tmpccmr2 |= TIM_ICSelection;
   6876          
   6877            /* Set the filter */
   6878            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   6879            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   6880          
   6881            /* Select the Polarity and set the CC3E Bit */
   6882            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   6883            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   6884          
   6885            /* Write to TIMx CCMR2 and CCER registers */
   6886            TIMx->CCMR2 = tmpccmr2;
   6887            TIMx->CCER = tmpccer;
   6888          }
   6889          
   6890          /**
   6891            * @brief  Configure the TI4 as Input.
   6892            * @param  TIMx to select the TIM peripheral
   6893            * @param  TIM_ICPolarity The Input Polarity.
   6894            *          This parameter can be one of the following values:
   6895            *            @arg TIM_ICPOLARITY_RISING
   6896            *            @arg TIM_ICPOLARITY_FALLING
   6897            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6898            * @param  TIM_ICSelection specifies the input to be used.
   6899            *          This parameter can be one of the following values:
   6900            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   6901            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   6902            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   6903            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6904            *          This parameter must be a value between 0x00 and 0x0F.
   6905            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   6906            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6907            *        protected against un-initialized filter and polarity values.
   6908            * @retval None
   6909            */
   6910          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6911                                        uint32_t TIM_ICFilter)
   6912          {
   6913            uint32_t tmpccmr2;
   6914            uint32_t tmpccer;
   6915          
   6916            /* Disable the Channel 4: Reset the CC4E Bit */
   6917            TIMx->CCER &= ~TIM_CCER_CC4E;
   6918            tmpccmr2 = TIMx->CCMR2;
   6919            tmpccer = TIMx->CCER;
   6920          
   6921            /* Select the Input */
   6922            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   6923            tmpccmr2 |= (TIM_ICSelection << 8U);
   6924          
   6925            /* Set the filter */
   6926            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   6927            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   6928          
   6929            /* Select the Polarity and set the CC4E Bit */
   6930            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   6931            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   6932          
   6933            /* Write to TIMx CCMR2 and CCER registers */
   6934            TIMx->CCMR2 = tmpccmr2;
   6935            TIMx->CCER = tmpccer ;
   6936          }
   6937          
   6938          /**
   6939            * @brief  Selects the Input Trigger source
   6940            * @param  TIMx to select the TIM peripheral
   6941            * @param  InputTriggerSource The Input Trigger source.
   6942            *          This parameter can be one of the following values:
   6943            *            @arg TIM_TS_ITR0: Internal Trigger 0
   6944            *            @arg TIM_TS_ITR1: Internal Trigger 1
   6945            *            @arg TIM_TS_ITR2: Internal Trigger 2
   6946            *            @arg TIM_TS_ITR3: Internal Trigger 3
   6947            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   6948            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   6949            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   6950            *            @arg TIM_TS_ETRF: External Trigger input
   6951            * @retval None
   6952            */
   6953          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   6954          {
   6955            uint32_t tmpsmcr;
   6956          
   6957            /* Get the TIMx SMCR register value */
   6958            tmpsmcr = TIMx->SMCR;
   6959            /* Reset the TS Bits */
   6960            tmpsmcr &= ~TIM_SMCR_TS;
   6961            /* Set the Input Trigger source and the slave mode*/
   6962            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   6963            /* Write to TIMx SMCR */
   6964            TIMx->SMCR = tmpsmcr;
   6965          }
   6966          /**
   6967            * @brief  Configures the TIMx External Trigger (ETR).
   6968            * @param  TIMx to select the TIM peripheral
   6969            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   6970            *          This parameter can be one of the following values:
   6971            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   6972            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   6973            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   6974            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   6975            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   6976            *          This parameter can be one of the following values:
   6977            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   6978            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   6979            * @param  ExtTRGFilter External Trigger Filter.
   6980            *          This parameter must be a value between 0x00 and 0x0F
   6981            * @retval None
   6982            */
   6983          void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   6984                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   6985          {
   6986            uint32_t tmpsmcr;
   6987          
   6988            tmpsmcr = TIMx->SMCR;
   6989          
   6990            /* Reset the ETR Bits */
   6991            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   6992          
   6993            /* Set the Prescaler, the Filter value and the Polarity */
   6994            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   6995          
   6996            /* Write to TIMx SMCR */
   6997            TIMx->SMCR = tmpsmcr;
   6998          }
   6999          
   7000          /**
   7001            * @brief  Enables or disables the TIM Capture Compare Channel x.
   7002            * @param  TIMx to select the TIM peripheral
   7003            * @param  Channel specifies the TIM Channel
   7004            *          This parameter can be one of the following values:
   7005            *            @arg TIM_CHANNEL_1: TIM Channel 1
   7006            *            @arg TIM_CHANNEL_2: TIM Channel 2
   7007            *            @arg TIM_CHANNEL_3: TIM Channel 3
   7008            *            @arg TIM_CHANNEL_4: TIM Channel 4
   7009            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   7010            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   7011            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   7012            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   7013            * @retval None
   7014            */
   7015          void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   7016          {
   7017            uint32_t tmp;
   7018          
   7019            /* Check the parameters */
   7020            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   7021            assert_param(IS_TIM_CHANNELS(Channel));
   7022          
   7023            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   7024          
   7025            /* Reset the CCxE Bit */
   7026            TIMx->CCER &= ~tmp;
   7027          
   7028            /* Set or reset the CCxE Bit */
   7029            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   7030          }
   7031          
   7032          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   7033          /**
   7034            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   7035            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   7036            *                the configuration information for TIM module.
   7037            * @retval None
   7038            */
   7039          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   7040          {
   7041            /* Reset the TIM callback to the legacy weak callbacks */
   7042            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
   7043            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
   7044            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
   7045            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak TriggerHalfCpltCallback           */
   7046            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC_CaptureCallback                */
   7047            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC_CaptureHalfCpltCallback        */
   7048            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC_DelayElapsedCallback           */
   7049            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM_PulseFinishedCallback         */
   7050            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM_PulseFinishedHalfCpltCallback */
   7051            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak ErrorCallback                     */
   7052            htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak CommutationCallback               */
   7053            htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak CommutationHalfCpltCallback       */
   7054            htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak BreakCallback                     */
   7055          #if defined(TIM_BDTR_BK2E)
   7056            htim->Break2Callback                    = HAL_TIMEx_Break2Callback;                  /* Legacy weak Break2Callback                    */
   7057          #endif /* TIM_BDTR_BK2E */
   7058          }
   7059          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   7060          
   7061          /**
   7062            * @}
   7063            */
   7064          
   7065          #endif /* HAL_TIM_MODULE_ENABLED */
   7066          /**
   7067            * @}
   7068            */
   7069          
   7070          /**
   7071            * @}
   7072            */
   7073          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


 
 
 0 bytes of memory

Errors: none
Warnings: none
