###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:19
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_tim.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW66E3.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_tim.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\stm32f3xx_ll_tim.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\stm32f3xx_ll_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_ll_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM LL module driver.
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          #if defined(USE_FULL_LL_DRIVER)
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f3xx_ll_tim.h"
     23          #include "stm32f3xx_ll_bus.h"
     24          
     25          #ifdef  USE_FULL_ASSERT
     26          #include "stm32_assert.h"
     27          #else
     28          #define assert_param(expr) ((void)0U)
     29          #endif /* USE_FULL_ASSERT */
     30          
     31          /** @addtogroup STM32F3xx_LL_Driver
     32            * @{
     33            */
     34          
     35          #if defined (TIM1) || defined (TIM2) || defined (TIM3) || defined (TIM4) || defined (TIM5) || defined (TIM6) || defined (TIM7) || defined (TIM8) || defined (TIM12) || defined (TIM13) || defined (TIM14) || defined (TIM15) || defined (TIM16) || defined (TIM17) || defined (TIM18) || defined (TIM19) || defined (TIM20)
     36          
     37          /** @addtogroup TIM_LL
     38            * @{
     39            */
     40          
     41          /* Private types -------------------------------------------------------------*/
     42          /* Private variables ---------------------------------------------------------*/
     43          /* Private constants ---------------------------------------------------------*/
     44          /* Private macros ------------------------------------------------------------*/
     45          /** @addtogroup TIM_LL_Private_Macros
     46            * @{
     47            */
     48          #define IS_LL_TIM_COUNTERMODE(__VALUE__) (((__VALUE__) == LL_TIM_COUNTERMODE_UP) \
     49                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_DOWN) \
     50                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP) \
     51                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_DOWN) \
     52                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP_DOWN))
     53          
     54          #define IS_LL_TIM_CLOCKDIVISION(__VALUE__) (((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV1) \
     55                                                      || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV2) \
     56                                                      || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV4))
     57          
     58          #if   defined(TIM_CCMR1_OC1M_3)
     59          #define IS_LL_TIM_OCMODE(__VALUE__) (((__VALUE__) == LL_TIM_OCMODE_FROZEN) \
     60                                               || ((__VALUE__) == LL_TIM_OCMODE_ACTIVE) \
     61                                               || ((__VALUE__) == LL_TIM_OCMODE_INACTIVE) \
     62                                               || ((__VALUE__) == LL_TIM_OCMODE_TOGGLE) \
     63                                               || ((__VALUE__) == LL_TIM_OCMODE_FORCED_INACTIVE) \
     64                                               || ((__VALUE__) == LL_TIM_OCMODE_FORCED_ACTIVE) \
     65                                               || ((__VALUE__) == LL_TIM_OCMODE_PWM1) \
     66                                               || ((__VALUE__) == LL_TIM_OCMODE_PWM2) \
     67                                               || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM1) \
     68                                               || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM2) \
     69                                               || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM1) \
     70                                               || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM2) \
     71                                               || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM1) \
     72                                               || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM2))
     73          #else
     74          #define IS_LL_TIM_OCMODE(__VALUE__) (((__VALUE__) == LL_TIM_OCMODE_FROZEN) \
     75                                               || ((__VALUE__) == LL_TIM_OCMODE_ACTIVE) \
     76                                               || ((__VALUE__) == LL_TIM_OCMODE_INACTIVE) \
     77                                               || ((__VALUE__) == LL_TIM_OCMODE_TOGGLE) \
     78                                               || ((__VALUE__) == LL_TIM_OCMODE_FORCED_INACTIVE) \
     79                                               || ((__VALUE__) == LL_TIM_OCMODE_FORCED_ACTIVE) \
     80                                               || ((__VALUE__) == LL_TIM_OCMODE_PWM1) \
     81                                               || ((__VALUE__) == LL_TIM_OCMODE_PWM2))
     82          #endif
     83          
     84          #define IS_LL_TIM_OCSTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCSTATE_DISABLE) \
     85                                                || ((__VALUE__) == LL_TIM_OCSTATE_ENABLE))
     86          
     87          #define IS_LL_TIM_OCPOLARITY(__VALUE__) (((__VALUE__) == LL_TIM_OCPOLARITY_HIGH) \
     88                                                   || ((__VALUE__) == LL_TIM_OCPOLARITY_LOW))
     89          
     90          #define IS_LL_TIM_OCIDLESTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCIDLESTATE_LOW) \
     91                                                    || ((__VALUE__) == LL_TIM_OCIDLESTATE_HIGH))
     92          
     93          #define IS_LL_TIM_ACTIVEINPUT(__VALUE__) (((__VALUE__) == LL_TIM_ACTIVEINPUT_DIRECTTI) \
     94                                                    || ((__VALUE__) == LL_TIM_ACTIVEINPUT_INDIRECTTI) \
     95                                                    || ((__VALUE__) == LL_TIM_ACTIVEINPUT_TRC))
     96          
     97          #define IS_LL_TIM_ICPSC(__VALUE__) (((__VALUE__) == LL_TIM_ICPSC_DIV1) \
     98                                              || ((__VALUE__) == LL_TIM_ICPSC_DIV2) \
     99                                              || ((__VALUE__) == LL_TIM_ICPSC_DIV4) \
    100                                              || ((__VALUE__) == LL_TIM_ICPSC_DIV8))
    101          
    102          #define IS_LL_TIM_IC_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_IC_FILTER_FDIV1) \
    103                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N2) \
    104                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N4) \
    105                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N8) \
    106                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N6) \
    107                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N8) \
    108                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N6) \
    109                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N8) \
    110                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N6) \
    111                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N8) \
    112                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N5) \
    113                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N6) \
    114                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N8) \
    115                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N5) \
    116                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N6) \
    117                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N8))
    118          
    119          #define IS_LL_TIM_IC_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \
    120                                                    || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING) \
    121                                                    || ((__VALUE__) == LL_TIM_IC_POLARITY_BOTHEDGE))
    122          
    123          #define IS_LL_TIM_ENCODERMODE(__VALUE__) (((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI1) \
    124                                                    || ((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI2) \
    125                                                    || ((__VALUE__) == LL_TIM_ENCODERMODE_X4_TI12))
    126          
    127          #define IS_LL_TIM_IC_POLARITY_ENCODER(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \
    128                                                            || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING))
    129          
    130          #define IS_LL_TIM_OSSR_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSR_DISABLE) \
    131                                                   || ((__VALUE__) == LL_TIM_OSSR_ENABLE))
    132          
    133          #define IS_LL_TIM_OSSI_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSI_DISABLE) \
    134                                                   || ((__VALUE__) == LL_TIM_OSSI_ENABLE))
    135          
    136          #define IS_LL_TIM_LOCK_LEVEL(__VALUE__) (((__VALUE__) == LL_TIM_LOCKLEVEL_OFF) \
    137                                                   || ((__VALUE__) == LL_TIM_LOCKLEVEL_1)   \
    138                                                   || ((__VALUE__) == LL_TIM_LOCKLEVEL_2)   \
    139                                                   || ((__VALUE__) == LL_TIM_LOCKLEVEL_3))
    140          
    141          #define IS_LL_TIM_BREAK_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_DISABLE) \
    142                                                    || ((__VALUE__) == LL_TIM_BREAK_ENABLE))
    143          
    144          #define IS_LL_TIM_BREAK_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_POLARITY_LOW) \
    145                                                       || ((__VALUE__) == LL_TIM_BREAK_POLARITY_HIGH))
    146          #if defined(TIM_BDTR_BKF)
    147          
    148          #define IS_LL_TIM_BREAK_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1)     \
    149                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N2)  \
    150                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N4)  \
    151                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N8)  \
    152                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N6)  \
    153                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N8)  \
    154                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N6)  \
    155                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N8)  \
    156                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N6)  \
    157                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N8)  \
    158                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N5) \
    159                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N6) \
    160                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N8) \
    161                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N5) \
    162                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N6) \
    163                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N8))
    164          #endif /* TIM_BDTR_BKF */
    165          #if defined(TIM_BDTR_BK2E)
    166          
    167          #define IS_LL_TIM_BREAK2_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_DISABLE) \
    168                                                     || ((__VALUE__) == LL_TIM_BREAK2_ENABLE))
    169          
    170          #define IS_LL_TIM_BREAK2_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_POLARITY_LOW) \
    171                                                        || ((__VALUE__) == LL_TIM_BREAK2_POLARITY_HIGH))
    172          
    173          #define IS_LL_TIM_BREAK2_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1)    \
    174                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N2)  \
    175                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N4)  \
    176                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N8)  \
    177                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N6)  \
    178                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N8)  \
    179                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N6)  \
    180                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N8)  \
    181                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N6)  \
    182                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N8)  \
    183                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N5) \
    184                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N6) \
    185                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N8) \
    186                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N5) \
    187                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N6) \
    188                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N8))
    189          #endif /* TIM_BDTR_BK2E */
    190          
    191          #define IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(__VALUE__) (((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_DISABLE) \
    192                                                               || ((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_ENABLE))
    193          /**
    194            * @}
    195            */
    196          
    197          
    198          /* Private function prototypes -----------------------------------------------*/
    199          /** @defgroup TIM_LL_Private_Functions TIM Private Functions
    200            * @{
    201            */
    202          static ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    203          static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    204          static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    205          static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    206          #if defined(TIM_CCER_CC5E)
    207          static ErrorStatus OC5Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    208          #endif /* TIM_CCER_CC5E */
    209          #if defined(TIM_CCER_CC6E)
    210          static ErrorStatus OC6Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    211          #endif /* TIM_CCER_CC6E */
    212          static ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    213          static ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    214          static ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    215          static ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    216          /**
    217            * @}
    218            */
    219          
    220          /* Exported functions --------------------------------------------------------*/
    221          /** @addtogroup TIM_LL_Exported_Functions
    222            * @{
    223            */
    224          
    225          /** @addtogroup TIM_LL_EF_Init
    226            * @{
    227            */
    228          
    229          /**
    230            * @brief  Set TIMx registers to their reset values.
    231            * @param  TIMx Timer instance
    232            * @retval An ErrorStatus enumeration value:
    233            *          - SUCCESS: TIMx registers are de-initialized
    234            *          - ERROR: invalid TIMx instance
    235            */

   \                                 In section .text, align 2, keep-with-next
    236          ErrorStatus LL_TIM_DeInit(TIM_TypeDef *TIMx)
    237          {
   \                     LL_TIM_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    238            ErrorStatus result = SUCCESS;
   \        0x2   0x2100             MOVS     R1,#+0
    239          
    240            /* Check the parameters */
    241            assert_param(IS_TIM_INSTANCE(TIMx));
    242          
    243          
    244            if (TIMx == TIM2)
   \        0x4   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \        0x8   0x....'....        LDR.W    R2,??DataTable6  ;; 0x4002100c
   \        0xC   0xD107             BNE.N    ??LL_TIM_DeInit_0
    245            {
    246              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM2);
   \        0xE   0x6850             LDR      R0,[R2, #+4]
   \       0x10   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x14   0x6050             STR      R0,[R2, #+4]
    247              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM2);
   \       0x16   0x6850             LDR      R0,[R2, #+4]
   \       0x18   0x0840             LSRS     R0,R0,#+1
   \       0x1A   0x0040             LSLS     R0,R0,#+1
   \       0x1C   0xE016             B.N      ??LL_TIM_DeInit_1
    248            }
    249          
    250          #if defined(TIM1)
    251            else if (TIMx == TIM1)
   \                     ??LL_TIM_DeInit_0: (+1)
   \       0x1E   0x....'....        LDR.W    R3,??DataTable6_1  ;; 0x40012c00
   \       0x22   0x4298             CMP      R0,R3
   \       0x24   0xD107             BNE.N    ??LL_TIM_DeInit_2
    252            {
    253              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM1);
   \       0x26   0x6810             LDR      R0,[R2, #+0]
   \       0x28   0xF440 0x6000      ORR      R0,R0,#0x800
   \       0x2C   0x6010             STR      R0,[R2, #+0]
    254              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM1);
   \       0x2E   0x6813             LDR      R3,[R2, #+0]
   \       0x30   0xF423 0x6300      BIC      R3,R3,#0x800
   \       0x34   0xE02F             B.N      ??LL_TIM_DeInit_3
    255            }
    256          #endif
    257          #if defined(TIM3)
    258            else if (TIMx == TIM3)
    259            {
    260              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM3);
    261              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM3);
    262            }
    263          #endif
    264          #if defined(TIM4)
    265            else if (TIMx == TIM4)
    266            {
    267              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM4);
    268              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM4);
    269            }
    270          #endif
    271          #if defined(TIM5)
    272            else if (TIMx == TIM5)
    273            {
    274              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM5);
    275              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM5);
    276            }
    277          #endif
    278          #if defined(TIM6)
    279            else if (TIMx == TIM6)
   \                     ??LL_TIM_DeInit_2: (+1)
   \       0x36   0x....'....        LDR.W    R4,??DataTable6_2  ;; 0x40001000
   \       0x3A   0x42A0             CMP      R0,R4
   \       0x3C   0xD108             BNE.N    ??LL_TIM_DeInit_4
    280            {
    281              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM6);
   \       0x3E   0x6850             LDR      R0,[R2, #+4]
   \       0x40   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x44   0x6050             STR      R0,[R2, #+4]
    282              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM6);
   \       0x46   0x6850             LDR      R0,[R2, #+4]
   \       0x48   0xF020 0x0010      BIC      R0,R0,#0x10
   \                     ??LL_TIM_DeInit_1: (+1)
   \       0x4C   0x6050             STR      R0,[R2, #+4]
    283            }
   \       0x4E   0xE025             B.N      ??LL_TIM_DeInit_5
    284          #endif
    285          #if defined(TIM7)
    286            else if (TIMx == TIM7)
    287            {
    288              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM7);
    289              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM7);
    290            }
    291          #endif
    292          #if defined(TIM8)
    293            else if (TIMx == TIM8)
    294            {
    295              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM8);
    296              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM8);
    297            }
    298          #endif
    299          #if defined(TIM12)
    300            else if (TIMx == TIM12)
    301            {
    302              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM12);
    303              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM12);
    304            }
    305          #endif
    306          #if defined(TIM13)
    307            else if (TIMx == TIM13)
    308            {
    309              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM13);
    310              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM13);
    311            }
    312          #endif
    313          #if defined(TIM14)
    314            else if (TIMx == TIM14)
    315            {
    316              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM14);
    317              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM14);
    318            }
    319          #endif
    320          #if defined(TIM15)
    321            else if (TIMx == TIM15)
   \                     ??LL_TIM_DeInit_4: (+1)
   \       0x50   0x....'....        LDR.W    R3,??DataTable6_3  ;; 0x40014000
   \       0x54   0x4298             CMP      R0,R3
   \       0x56   0xD107             BNE.N    ??LL_TIM_DeInit_6
    322            {
    323              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM15);
   \       0x58   0x6810             LDR      R0,[R2, #+0]
   \       0x5A   0xF440 0x3080      ORR      R0,R0,#0x10000
   \       0x5E   0x6010             STR      R0,[R2, #+0]
    324              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM15);
   \       0x60   0x6813             LDR      R3,[R2, #+0]
   \       0x62   0xF423 0x3380      BIC      R3,R3,#0x10000
   \       0x66   0xE016             B.N      ??LL_TIM_DeInit_3
    325            }
    326          #endif
    327          #if defined(TIM16)
    328            else if (TIMx == TIM16)
   \                     ??LL_TIM_DeInit_6: (+1)
   \       0x68   0x....'....        LDR.W    R4,??DataTable6_4  ;; 0x40014400
   \       0x6C   0x42A0             CMP      R0,R4
   \       0x6E   0xD107             BNE.N    ??LL_TIM_DeInit_7
    329            {
    330              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM16);
   \       0x70   0x6810             LDR      R0,[R2, #+0]
   \       0x72   0xF440 0x3000      ORR      R0,R0,#0x20000
   \       0x76   0x6010             STR      R0,[R2, #+0]
    331              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM16);
   \       0x78   0x6813             LDR      R3,[R2, #+0]
   \       0x7A   0xF423 0x3300      BIC      R3,R3,#0x20000
   \       0x7E   0xE00A             B.N      ??LL_TIM_DeInit_3
    332            }
    333          #endif
    334          #if defined(TIM17)
    335            else if (TIMx == TIM17)
   \                     ??LL_TIM_DeInit_7: (+1)
   \       0x80   0x....'....        LDR.W    R4,??DataTable6_5  ;; 0x40014800
   \       0x84   0x42A0             CMP      R0,R4
   \       0x86   0xD108             BNE.N    ??LL_TIM_DeInit_8
    336            {
    337              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM17);
   \       0x88   0x6810             LDR      R0,[R2, #+0]
   \       0x8A   0xF440 0x2080      ORR      R0,R0,#0x40000
   \       0x8E   0x6010             STR      R0,[R2, #+0]
    338              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM17);
   \       0x90   0x6813             LDR      R3,[R2, #+0]
   \       0x92   0xF423 0x2380      BIC      R3,R3,#0x40000
   \                     ??LL_TIM_DeInit_3: (+1)
   \       0x96   0x6013             STR      R3,[R2, #+0]
    339            }
   \       0x98   0xE000             B.N      ??LL_TIM_DeInit_5
    340          #endif
    341          #if defined(TIM18)
    342            else if (TIMx == TIM18)
    343            {
    344              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM18);
    345              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM18);
    346            }
    347          #endif
    348          #if defined(TIM19)
    349            else if (TIMx == TIM19)
    350            {
    351              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM19);
    352              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM19);
    353            }
    354          #endif
    355          #if defined(TIM20)
    356            else if (TIMx == TIM20)
    357            {
    358              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM20);
    359              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM20);
    360            }
    361          #endif
    362            else
    363            {
    364              result = ERROR;
   \                     ??LL_TIM_DeInit_8: (+1)
   \       0x9A   0x2101             MOVS     R1,#+1
    365            }
    366          
    367            return result;
   \                     ??LL_TIM_DeInit_5: (+1)
   \       0x9C   0x4608             MOV      R0,R1
   \       0x9E   0xBD10             POP      {R4,PC}          ;; return
    368          }
    369          
    370          /**
    371            * @brief  Set the fields of the time base unit configuration data structure
    372            *         to their default values.
    373            * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (time base unit configuration data structure)
    374            * @retval None
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          void LL_TIM_StructInit(LL_TIM_InitTypeDef *TIM_InitStruct)
    377          {
    378            /* Set the default configuration */
    379            TIM_InitStruct->Prescaler         = (uint16_t)0x0000;
   \                     LL_TIM_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    380            TIM_InitStruct->CounterMode       = LL_TIM_COUNTERMODE_UP;
    381            TIM_InitStruct->Autoreload        = 0xFFFFFFFFU;
   \        0x4   0xF04F 0x33FF      MOV      R3,#-1
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x6083             STR      R3,[R0, #+8]
    382            TIM_InitStruct->ClockDivision     = LL_TIM_CLOCKDIVISION_DIV1;
   \        0xC   0x60C1             STR      R1,[R0, #+12]
    383            TIM_InitStruct->RepetitionCounter = (uint8_t)0x00;
   \        0xE   0x7401             STRB     R1,[R0, #+16]
    384          }
   \       0x10   0x4770             BX       LR               ;; return
    385          
    386          /**
    387            * @brief  Configure the TIMx time base unit.
    388            * @param  TIMx Timer Instance
    389            * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (TIMx time base unit configuration data structure)
    390            * @retval An ErrorStatus enumeration value:
    391            *          - SUCCESS: TIMx registers are de-initialized
    392            *          - ERROR: not applicable
    393            */

   \                                 In section .text, align 2, keep-with-next
    394          ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)
    395          {
   \                     LL_TIM_Init: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    396            uint32_t tmpcr1;
    397          
    398            /* Check the parameters */
    399            assert_param(IS_TIM_INSTANCE(TIMx));
    400            assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
    401            assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
    402          
    403            tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
    404          
    405            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \        0x2   0x....'....        LDR.W    R7,??DataTable6_1  ;; 0x40012c00
   \        0x6   0x6803             LDR      R3,[R0, #+0]
   \        0x8   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xC   0x42B8             CMP      R0,R7
   \        0xE   0xBF18             IT       NE
   \       0x10   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \       0x14   0xBF01             ITTTT    EQ
   \       0x16   0xF023 0x0370      BICEQ    R3,R3,#0x70
   \       0x1A   0x684A             LDREQ    R2,[R1, #+4]
   \       0x1C   0x4313             ORREQ    R3,R2,R3
   \       0x1E   0x42B8             CMPEQ    R0,R7
    406            {
    407              /* Select the Counter Mode */
    408              MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
    409            }
    410          
    411            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \       0x20   0xD008             BEQ.N    ??LL_TIM_Init_0
   \       0x22   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x26   0xBF18             IT       NE
   \       0x28   0x42B0             CMPNE    R0,R6
   \       0x2A   0xD003             BEQ.N    ??LL_TIM_Init_0
   \       0x2C   0x42A8             CMP      R0,R5
   \       0x2E   0xBF18             IT       NE
   \       0x30   0x42A0             CMPNE    R0,R4
   \       0x32   0xD103             BNE.N    ??LL_TIM_Init_1
    412            {
    413              /* Set the clock division */
    414              MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
   \                     ??LL_TIM_Init_0: (+1)
   \       0x34   0x68CA             LDR      R2,[R1, #+12]
   \       0x36   0xF423 0x7340      BIC      R3,R3,#0x300
   \       0x3A   0x4313             ORRS     R3,R2,R3
    415            }
    416          
    417            /* Write to TIMx CR1 */
    418            LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
   \                     ??LL_TIM_Init_1: (+1)
   \       0x3C   0x6003             STR      R3,[R0, #+0]
    419          
    420            /* Set the Autoreload value */
    421            LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
    422          
    423            /* Set the Prescaler value */
    424            LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
    425          
    426            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \       0x3E   0x42B8             CMP      R0,R7
   \       0x40   0x688A             LDR      R2,[R1, #+8]
   \       0x42   0x62C2             STR      R2,[R0, #+44]
   \       0x44   0xBF18             IT       NE
   \       0x46   0x42B0             CMPNE    R0,R6
   \       0x48   0x880A             LDRH     R2,[R1, #+0]
   \       0x4A   0x6282             STR      R2,[R0, #+40]
   \       0x4C   0xD003             BEQ.N    ??LL_TIM_Init_2
   \       0x4E   0x42A8             CMP      R0,R5
   \       0x50   0xBF18             IT       NE
   \       0x52   0x42A0             CMPNE    R0,R4
   \       0x54   0xD101             BNE.N    ??LL_TIM_Init_3
    427            {
    428              /* Set the Repetition Counter value */
    429              LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
   \                     ??LL_TIM_Init_2: (+1)
   \       0x56   0x7C09             LDRB     R1,[R1, #+16]
   \       0x58   0x6301             STR      R1,[R0, #+48]
    430            }
    431          
    432            /* Generate an update event to reload the Prescaler
    433               and the repetition counter value (if applicable) immediately */
    434            LL_TIM_GenerateEvent_UPDATE(TIMx);
   \                     ??LL_TIM_Init_3: (+1)
   \       0x5A   0x6941             LDR      R1,[R0, #+20]
   \       0x5C   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x60   0x6141             STR      R1,[R0, #+20]
    435          
    436            return SUCCESS;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBDF0             POP      {R4-R7,PC}       ;; return
    437          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....             LDR.N    R4,??DataTable6_5  ;; 0x40014800
   \        0x2   0x....             LDR.N    R5,??DataTable6_4  ;; 0x40014400
   \        0x4   0x....             LDR.N    R6,??DataTable6_3  ;; 0x40014000
   \        0x6   0x4770             BX       LR
    438          
    439          /**
    440            * @brief  Set the fields of the TIMx output channel configuration data
    441            *         structure to their default values.
    442            * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (the output channel configuration data structure)
    443            * @retval None
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          void LL_TIM_OC_StructInit(LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
    446          {
    447            /* Set the default configuration */
    448            TIM_OC_InitStruct->OCMode       = LL_TIM_OCMODE_FROZEN;
   \                     LL_TIM_OC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    449            TIM_OC_InitStruct->OCState      = LL_TIM_OCSTATE_DISABLE;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    450            TIM_OC_InitStruct->OCNState     = LL_TIM_OCSTATE_DISABLE;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    451            TIM_OC_InitStruct->CompareValue = 0x00000000U;
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    452            TIM_OC_InitStruct->OCPolarity   = LL_TIM_OCPOLARITY_HIGH;
   \        0xA   0x6101             STR      R1,[R0, #+16]
    453            TIM_OC_InitStruct->OCNPolarity  = LL_TIM_OCPOLARITY_HIGH;
   \        0xC   0x6141             STR      R1,[R0, #+20]
    454            TIM_OC_InitStruct->OCIdleState  = LL_TIM_OCIDLESTATE_LOW;
   \        0xE   0x6181             STR      R1,[R0, #+24]
    455            TIM_OC_InitStruct->OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
   \       0x10   0x61C1             STR      R1,[R0, #+28]
    456          }
   \       0x12   0x4770             BX       LR               ;; return
    457          
    458          /**
    459            * @brief  Configure the TIMx output channel.
    460            * @param  TIMx Timer Instance
    461            * @param  Channel This parameter can be one of the following values:
    462            *         @arg @ref LL_TIM_CHANNEL_CH1
    463            *         @arg @ref LL_TIM_CHANNEL_CH2
    464            *         @arg @ref LL_TIM_CHANNEL_CH3
    465            *         @arg @ref LL_TIM_CHANNEL_CH4
    466            *         @arg @ref LL_TIM_CHANNEL_CH5
    467            *         @arg @ref LL_TIM_CHANNEL_CH6
    468            * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (TIMx output channel configuration data structure)
    469            * @note   OC5 and OC6 are not available for all F3 devices
    470            * @retval An ErrorStatus enumeration value:
    471            *          - SUCCESS: TIMx output channel is initialized
    472            *          - ERROR: TIMx output channel is not initialized
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          ErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
    475          {
   \                     LL_TIM_OC_Init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4603             MOV      R3,R0
    476            ErrorStatus result = ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
    477          
    478            switch (Channel)
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0x....'....        LDR.W    R12,??DataTable6_6  ;; 0xfffeff8c
   \        0xE   0x....'....        LDR.W    R7,??DataTable6_7  ;; 0xfeff8cff
   \       0x12   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x16   0x....'....        LDR.W    R8,??DataTable6_1  ;; 0x40012c00
   \       0x1A   0xD012             BEQ.N    ??LL_TIM_OC_Init_0
   \       0x1C   0x2910             CMP      R1,#+16
   \       0x1E   0xD048             BEQ.N    ??LL_TIM_OC_Init_1
   \       0x20   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x24   0xF000 0x807F      BEQ.W    ??LL_TIM_OC_Init_2
   \       0x28   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x2C   0xF000 0x80B5      BEQ.W    ??LL_TIM_OC_Init_3
   \       0x30   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0x34   0xF000 0x80DD      BEQ.W    ??LL_TIM_OC_Init_4
   \       0x38   0xF5B1 0x1F80      CMP      R1,#+1048576
   \       0x3C   0xF000 0x8104      BEQ.W    ??LL_TIM_OC_Init_5
   \       0x40   0xE12B             B.N      ??LL_TIM_OC_Init_6
    479            {
    480              case LL_TIM_CHANNEL_CH1:
    481                result = OC1Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_0: (+1)
   \       0x42   0x6A18             LDR      R0,[R3, #+32]
   \       0x44   0x0840             LSRS     R0,R0,#+1
   \       0x46   0x0040             LSLS     R0,R0,#+1
   \       0x48   0x6218             STR      R0,[R3, #+32]
   \       0x4A   0xF8D3 0xE020      LDR      LR,[R3, #+32]
   \       0x4E   0x685F             LDR      R7,[R3, #+4]
   \       0x50   0x6999             LDR      R1,[R3, #+24]
   \       0x52   0x6810             LDR      R0,[R2, #+0]
   \       0x54   0xEA0C 0x0101      AND      R1,R12,R1
   \       0x58   0xEA40 0x0C01      ORR      R12,R0,R1
   \       0x5C   0x6911             LDR      R1,[R2, #+16]
   \       0x5E   0xF02E 0x0002      BIC      R0,LR,#0x2
   \       0x62   0x4308             ORRS     R0,R1,R0
   \       0x64   0x0841             LSRS     R1,R0,#+1
   \       0x66   0x6850             LDR      R0,[R2, #+4]
   \       0x68   0x4543             CMP      R3,R8
   \       0x6A   0xBF18             IT       NE
   \       0x6C   0x42B3             CMPNE    R3,R6
   \       0x6E   0xEA40 0x0E41      ORR      LR,R0,R1, LSL #+1
   \       0x72   0xD003             BEQ.N    ??LL_TIM_OC_Init_7
   \       0x74   0x42AB             CMP      R3,R5
   \       0x76   0xBF18             IT       NE
   \       0x78   0x42A3             CMPNE    R3,R4
   \       0x7A   0xD112             BNE.N    ??LL_TIM_OC_Init_8
   \                     ??LL_TIM_OC_Init_7: (+1)
   \       0x7C   0x6950             LDR      R0,[R2, #+20]
   \       0x7E   0xF02E 0x0108      BIC      R1,LR,#0x8
   \       0x82   0xEA41 0x0080      ORR      R0,R1,R0, LSL #+2
   \       0x86   0xF020 0x0104      BIC      R1,R0,#0x4
   \       0x8A   0x6890             LDR      R0,[R2, #+8]
   \       0x8C   0xEA41 0x0E80      ORR      LR,R1,R0, LSL #+2
   \       0x90   0x6990             LDR      R0,[R2, #+24]
   \       0x92   0x69D1             LDR      R1,[R2, #+28]
   \       0x94   0xF427 0x7780      BIC      R7,R7,#0x100
   \       0x98   0x4307             ORRS     R7,R0,R7
   \       0x9A   0xF427 0x7700      BIC      R7,R7,#0x200
   \       0x9E   0xEA47 0x0741      ORR      R7,R7,R1, LSL #+1
   \                     ??LL_TIM_OC_Init_8: (+1)
   \       0xA2   0x605F             STR      R7,[R3, #+4]
   \       0xA4   0xF8C3 0xC018      STR      R12,[R3, #+24]
   \       0xA8   0x68D0             LDR      R0,[R2, #+12]
   \       0xAA   0x6358             STR      R0,[R3, #+52]
   \       0xAC   0xF8C3 0xE020      STR      LR,[R3, #+32]
   \       0xB0   0xE0F2             B.N      ??LL_TIM_OC_Init_9
    482                break;
    483              case LL_TIM_CHANNEL_CH2:
    484                result = OC2Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_1: (+1)
   \       0xB2   0x6A18             LDR      R0,[R3, #+32]
   \       0xB4   0xF020 0x0010      BIC      R0,R0,#0x10
   \       0xB8   0x6218             STR      R0,[R3, #+32]
   \       0xBA   0x4543             CMP      R3,R8
   \       0xBC   0x6A18             LDR      R0,[R3, #+32]
   \       0xBE   0x6859             LDR      R1,[R3, #+4]
   \       0xC0   0xF8D3 0xC018      LDR      R12,[R3, #+24]
   \       0xC4   0xEA07 0x0E0C      AND      LR,R7,R12
   \       0xC8   0xF8D2 0xC010      LDR      R12,[R2, #+16]
   \       0xCC   0x6817             LDR      R7,[R2, #+0]
   \       0xCE   0xF020 0x0020      BIC      R0,R0,#0x20
   \       0xD2   0xEA40 0x100C      ORR      R0,R0,R12, LSL #+4
   \       0xD6   0xF8D2 0xC004      LDR      R12,[R2, #+4]
   \       0xDA   0xF020 0x0010      BIC      R0,R0,#0x10
   \       0xDE   0xBF18             IT       NE
   \       0xE0   0x42B3             CMPNE    R3,R6
   \       0xE2   0xEA4E 0x2707      ORR      R7,LR,R7, LSL #+8
   \       0xE6   0xEA40 0x100C      ORR      R0,R0,R12, LSL #+4
   \       0xEA   0xD003             BEQ.N    ??LL_TIM_OC_Init_10
   \       0xEC   0x42AB             CMP      R3,R5
   \       0xEE   0xBF18             IT       NE
   \       0xF0   0x42A3             CMPNE    R3,R4
   \       0xF2   0xD113             BNE.N    ??LL_TIM_OC_Init_11
   \                     ??LL_TIM_OC_Init_10: (+1)
   \       0xF4   0x6954             LDR      R4,[R2, #+20]
   \       0xF6   0xF020 0x0080      BIC      R0,R0,#0x80
   \       0xFA   0xEA40 0x1084      ORR      R0,R0,R4, LSL #+6
   \       0xFE   0x6894             LDR      R4,[R2, #+8]
   \      0x100   0xF020 0x0040      BIC      R0,R0,#0x40
   \      0x104   0xEA40 0x1084      ORR      R0,R0,R4, LSL #+6
   \      0x108   0x6994             LDR      R4,[R2, #+24]
   \      0x10A   0xF421 0x6180      BIC      R1,R1,#0x400
   \      0x10E   0xEA41 0x0184      ORR      R1,R1,R4, LSL #+2
   \      0x112   0x69D4             LDR      R4,[R2, #+28]
   \      0x114   0xF421 0x6100      BIC      R1,R1,#0x800
   \      0x118   0xEA41 0x01C4      ORR      R1,R1,R4, LSL #+3
   \                     ??LL_TIM_OC_Init_11: (+1)
   \      0x11C   0x6059             STR      R1,[R3, #+4]
   \      0x11E   0x619F             STR      R7,[R3, #+24]
   \      0x120   0x68D1             LDR      R1,[R2, #+12]
   \      0x122   0x6399             STR      R1,[R3, #+56]
   \      0x124   0xE063             B.N      ??LL_TIM_OC_Init_12
    485                break;
    486              case LL_TIM_CHANNEL_CH3:
    487                result = OC3Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_2: (+1)
   \      0x126   0x6A18             LDR      R0,[R3, #+32]
   \      0x128   0xF420 0x7080      BIC      R0,R0,#0x100
   \      0x12C   0x6218             STR      R0,[R3, #+32]
   \      0x12E   0x4543             CMP      R3,R8
   \      0x130   0x6A19             LDR      R1,[R3, #+32]
   \      0x132   0xF8D3 0xE004      LDR      LR,[R3, #+4]
   \      0x136   0x69DF             LDR      R7,[R3, #+28]
   \      0x138   0x6810             LDR      R0,[R2, #+0]
   \      0x13A   0xEA0C 0x0707      AND      R7,R12,R7
   \      0x13E   0xEA40 0x0C07      ORR      R12,R0,R7
   \      0x142   0x6917             LDR      R7,[R2, #+16]
   \      0x144   0x6850             LDR      R0,[R2, #+4]
   \      0x146   0xF421 0x7100      BIC      R1,R1,#0x200
   \      0x14A   0xEA41 0x2107      ORR      R1,R1,R7, LSL #+8
   \      0x14E   0xF421 0x7180      BIC      R1,R1,#0x100
   \      0x152   0xBF18             IT       NE
   \      0x154   0x42B3             CMPNE    R3,R6
   \      0x156   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \      0x15A   0xD003             BEQ.N    ??LL_TIM_OC_Init_13
   \      0x15C   0x42AB             CMP      R3,R5
   \      0x15E   0xBF18             IT       NE
   \      0x160   0x42A3             CMPNE    R3,R4
   \      0x162   0xD113             BNE.N    ??LL_TIM_OC_Init_14
   \                     ??LL_TIM_OC_Init_13: (+1)
   \      0x164   0x6950             LDR      R0,[R2, #+20]
   \      0x166   0xF421 0x6100      BIC      R1,R1,#0x800
   \      0x16A   0xEA41 0x2180      ORR      R1,R1,R0, LSL #+10
   \      0x16E   0x6890             LDR      R0,[R2, #+8]
   \      0x170   0xF421 0x6180      BIC      R1,R1,#0x400
   \      0x174   0xEA41 0x2180      ORR      R1,R1,R0, LSL #+10
   \      0x178   0x6990             LDR      R0,[R2, #+24]
   \      0x17A   0xF42E 0x5480      BIC      R4,LR,#0x1000
   \      0x17E   0xEA44 0x1000      ORR      R0,R4,R0, LSL #+4
   \      0x182   0xF420 0x5400      BIC      R4,R0,#0x2000
   \      0x186   0x69D0             LDR      R0,[R2, #+28]
   \      0x188   0xEA44 0x1E40      ORR      LR,R4,R0, LSL #+5
   \                     ??LL_TIM_OC_Init_14: (+1)
   \      0x18C   0xF8C3 0xE004      STR      LR,[R3, #+4]
   \      0x190   0xF8C3 0xC01C      STR      R12,[R3, #+28]
   \      0x194   0x68D0             LDR      R0,[R2, #+12]
   \      0x196   0x63D8             STR      R0,[R3, #+60]
   \      0x198   0xE07D             B.N      ??LL_TIM_OC_Init_15
    488                break;
    489              case LL_TIM_CHANNEL_CH4:
    490                result = OC4Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_3: (+1)
   \      0x19A   0x6A18             LDR      R0,[R3, #+32]
   \      0x19C   0xF420 0x5080      BIC      R0,R0,#0x1000
   \      0x1A0   0x6218             STR      R0,[R3, #+32]
   \      0x1A2   0x4543             CMP      R3,R8
   \      0x1A4   0x6A18             LDR      R0,[R3, #+32]
   \      0x1A6   0x6859             LDR      R1,[R3, #+4]
   \      0x1A8   0xF8D3 0xC01C      LDR      R12,[R3, #+28]
   \      0x1AC   0xEA07 0x0E0C      AND      LR,R7,R12
   \      0x1B0   0xF8D2 0xC010      LDR      R12,[R2, #+16]
   \      0x1B4   0x6817             LDR      R7,[R2, #+0]
   \      0x1B6   0xF420 0x5000      BIC      R0,R0,#0x2000
   \      0x1BA   0xEA40 0x300C      ORR      R0,R0,R12, LSL #+12
   \      0x1BE   0xF8D2 0xC004      LDR      R12,[R2, #+4]
   \      0x1C2   0xF420 0x5080      BIC      R0,R0,#0x1000
   \      0x1C6   0xBF18             IT       NE
   \      0x1C8   0x42B3             CMPNE    R3,R6
   \      0x1CA   0xEA4E 0x2707      ORR      R7,LR,R7, LSL #+8
   \      0x1CE   0xEA40 0x300C      ORR      R0,R0,R12, LSL #+12
   \      0x1D2   0xD003             BEQ.N    ??LL_TIM_OC_Init_16
   \      0x1D4   0x42AB             CMP      R3,R5
   \      0x1D6   0xBF18             IT       NE
   \      0x1D8   0x42A3             CMPNE    R3,R4
   \      0x1DA   0xD104             BNE.N    ??LL_TIM_OC_Init_17
   \                     ??LL_TIM_OC_Init_16: (+1)
   \      0x1DC   0x6994             LDR      R4,[R2, #+24]
   \      0x1DE   0xF421 0x4180      BIC      R1,R1,#0x4000
   \      0x1E2   0xEA41 0x1184      ORR      R1,R1,R4, LSL #+6
   \                     ??LL_TIM_OC_Init_17: (+1)
   \      0x1E6   0x6059             STR      R1,[R3, #+4]
   \      0x1E8   0x61DF             STR      R7,[R3, #+28]
   \      0x1EA   0x68D1             LDR      R1,[R2, #+12]
   \      0x1EC   0x6419             STR      R1,[R3, #+64]
   \                     ??LL_TIM_OC_Init_12: (+1)
   \      0x1EE   0x6218             STR      R0,[R3, #+32]
   \      0x1F0   0xE052             B.N      ??LL_TIM_OC_Init_9
    491                break;
    492          #if defined(TIM_CCER_CC5E)
    493              case LL_TIM_CHANNEL_CH5:
    494                result = OC5Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_4: (+1)
   \      0x1F2   0x6A18             LDR      R0,[R3, #+32]
   \      0x1F4   0x....             LDR.N    R1,??DataTable6_8  ;; 0xfffeff8f
   \      0x1F6   0xF420 0x3080      BIC      R0,R0,#0x10000
   \      0x1FA   0x6218             STR      R0,[R3, #+32]
   \      0x1FC   0x6A1F             LDR      R7,[R3, #+32]
   \      0x1FE   0x6D58             LDR      R0,[R3, #+84]
   \      0x200   0x4001             ANDS     R1,R1,R0
   \      0x202   0x6810             LDR      R0,[R2, #+0]
   \      0x204   0xEA40 0x0E01      ORR      LR,R0,R1
   \      0x208   0x6911             LDR      R1,[R2, #+16]
   \      0x20A   0xF427 0x3000      BIC      R0,R7,#0x20000
   \      0x20E   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \      0x212   0xF420 0x3180      BIC      R1,R0,#0x10000
   \      0x216   0x6850             LDR      R0,[R2, #+4]
   \      0x218   0x4543             CMP      R3,R8
   \      0x21A   0xBF18             IT       NE
   \      0x21C   0x42B3             CMPNE    R3,R6
   \      0x21E   0xEA41 0x4700      ORR      R7,R1,R0, LSL #+16
   \      0x222   0xD003             BEQ.N    ??LL_TIM_OC_Init_18
   \      0x224   0x42AB             CMP      R3,R5
   \      0x226   0xBF18             IT       NE
   \      0x228   0x42A3             CMPNE    R3,R4
   \      0x22A   0xD106             BNE.N    ??LL_TIM_OC_Init_19
   \                     ??LL_TIM_OC_Init_18: (+1)
   \      0x22C   0x6858             LDR      R0,[R3, #+4]
   \      0x22E   0x6991             LDR      R1,[R2, #+24]
   \      0x230   0xF420 0x3080      BIC      R0,R0,#0x10000
   \      0x234   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \      0x238   0x6058             STR      R0,[R3, #+4]
   \                     ??LL_TIM_OC_Init_19: (+1)
   \      0x23A   0xF8C3 0xE054      STR      LR,[R3, #+84]
   \      0x23E   0x68D0             LDR      R0,[R2, #+12]
   \      0x240   0x6D99             LDR      R1,[R3, #+88]
   \      0x242   0x6598             STR      R0,[R3, #+88]
   \      0x244   0x621F             STR      R7,[R3, #+32]
   \      0x246   0xE027             B.N      ??LL_TIM_OC_Init_9
    495                break;
    496              case LL_TIM_CHANNEL_CH6:
    497                result = OC6Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_5: (+1)
   \      0x248   0x6A18             LDR      R0,[R3, #+32]
   \      0x24A   0xF420 0x1080      BIC      R0,R0,#0x100000
   \      0x24E   0x6218             STR      R0,[R3, #+32]
   \      0x250   0x6A19             LDR      R1,[R3, #+32]
   \      0x252   0x6D5F             LDR      R7,[R3, #+84]
   \      0x254   0x....             LDR.N    R0,??DataTable6_9  ;; 0xfeff8fff
   \      0x256   0x4038             ANDS     R0,R0,R7
   \      0x258   0x6817             LDR      R7,[R2, #+0]
   \      0x25A   0xEA40 0x2707      ORR      R7,R0,R7, LSL #+8
   \      0x25E   0x6910             LDR      R0,[R2, #+16]
   \      0x260   0xF421 0x1100      BIC      R1,R1,#0x200000
   \      0x264   0xEA41 0x5100      ORR      R1,R1,R0, LSL #+20
   \      0x268   0x6850             LDR      R0,[R2, #+4]
   \      0x26A   0x4543             CMP      R3,R8
   \      0x26C   0xF421 0x1180      BIC      R1,R1,#0x100000
   \      0x270   0xBF18             IT       NE
   \      0x272   0x42B3             CMPNE    R3,R6
   \      0x274   0xEA41 0x5100      ORR      R1,R1,R0, LSL #+20
   \      0x278   0xD003             BEQ.N    ??LL_TIM_OC_Init_20
   \      0x27A   0x42AB             CMP      R3,R5
   \      0x27C   0xBF18             IT       NE
   \      0x27E   0x42A3             CMPNE    R3,R4
   \      0x280   0xD106             BNE.N    ??LL_TIM_OC_Init_21
   \                     ??LL_TIM_OC_Init_20: (+1)
   \      0x282   0x6858             LDR      R0,[R3, #+4]
   \      0x284   0x6994             LDR      R4,[R2, #+24]
   \      0x286   0xF420 0x2080      BIC      R0,R0,#0x40000
   \      0x28A   0xEA40 0x2084      ORR      R0,R0,R4, LSL #+10
   \      0x28E   0x6058             STR      R0,[R3, #+4]
   \                     ??LL_TIM_OC_Init_21: (+1)
   \      0x290   0x655F             STR      R7,[R3, #+84]
   \      0x292   0x68D0             LDR      R0,[R2, #+12]
   \      0x294   0x65D8             STR      R0,[R3, #+92]
   \                     ??LL_TIM_OC_Init_15: (+1)
   \      0x296   0x6219             STR      R1,[R3, #+32]
   \                     ??LL_TIM_OC_Init_9: (+1)
   \      0x298   0x2000             MOVS     R0,#+0
    498                break;
    499          #endif /* TIM_CCER_CC5E */
    500              default:
    501                break;
    502            }
    503          
    504            return result;
   \                     ??LL_TIM_OC_Init_6: (+1)
   \      0x29A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    505          }
    506          
    507          /**
    508            * @brief  Set the fields of the TIMx input channel configuration data
    509            *         structure to their default values.
    510            * @param  TIM_ICInitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (the input channel configuration data structure)
    511            * @retval None
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          void LL_TIM_IC_StructInit(LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
    514          {
    515            /* Set the default configuration */
    516            TIM_ICInitStruct->ICPolarity    = LL_TIM_IC_POLARITY_RISING;
   \                     LL_TIM_IC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    517            TIM_ICInitStruct->ICActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
   \        0x4   0xF44F 0x3280      MOV      R2,#+65536
   \        0x8   0x6042             STR      R2,[R0, #+4]
    518            TIM_ICInitStruct->ICPrescaler   = LL_TIM_ICPSC_DIV1;
   \        0xA   0x....             B.N      ?Subroutine0
    519            TIM_ICInitStruct->ICFilter      = LL_TIM_IC_FILTER_FDIV1;
    520          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x6081             STR      R1,[R0, #+8]
   \        0x2   0x60C1             STR      R1,[R0, #+12]
   \        0x4   0x4770             BX       LR               ;; return
    521          
    522          /**
    523            * @brief  Configure the TIMx input channel.
    524            * @param  TIMx Timer Instance
    525            * @param  Channel This parameter can be one of the following values:
    526            *         @arg @ref LL_TIM_CHANNEL_CH1
    527            *         @arg @ref LL_TIM_CHANNEL_CH2
    528            *         @arg @ref LL_TIM_CHANNEL_CH3
    529            *         @arg @ref LL_TIM_CHANNEL_CH4
    530            * @param  TIM_IC_InitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (TIMx input channel configuration data structure)
    531            * @retval An ErrorStatus enumeration value:
    532            *          - SUCCESS: TIMx output channel is initialized
    533            *          - ERROR: TIMx output channel is not initialized
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          ErrorStatus LL_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef *TIM_IC_InitStruct)
    536          {
   \                     LL_TIM_IC_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    537            ErrorStatus result = ERROR;
   \        0x2   0x2301             MOVS     R3,#+1
    538          
    539            switch (Channel)
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD008             BEQ.N    ??LL_TIM_IC_Init_0
   \        0x8   0x2910             CMP      R1,#+16
   \        0xA   0xD017             BEQ.N    ??LL_TIM_IC_Init_1
   \        0xC   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x10   0xD025             BEQ.N    ??LL_TIM_IC_Init_2
   \       0x12   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x16   0xD033             BEQ.N    ??LL_TIM_IC_Init_3
   \       0x18   0xE044             B.N      ??LL_TIM_IC_Init_4
    540            {
    541              case LL_TIM_CHANNEL_CH1:
    542                result = IC1Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_0: (+1)
   \       0x1A   0x6A01             LDR      R1,[R0, #+32]
   \       0x1C   0x0849             LSRS     R1,R1,#+1
   \       0x1E   0x0049             LSLS     R1,R1,#+1
   \       0x20   0x6201             STR      R1,[R0, #+32]
   \       0x22   0x6984             LDR      R4,[R0, #+24]
   \       0x24   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x28   0x6184             STR      R4,[R0, #+24]
   \       0x2A   0x6A03             LDR      R3,[R0, #+32]
   \       0x2C   0x6811             LDR      R1,[R2, #+0]
   \       0x2E   0xF023 0x030A      BIC      R3,R3,#0xA
   \       0x32   0x430B             ORRS     R3,R1,R3
   \       0x34   0xF043 0x0301      ORR      R3,R3,#0x1
   \       0x38   0x6203             STR      R3,[R0, #+32]
   \       0x3A   0xE032             B.N      ??LL_TIM_IC_Init_5
    543                break;
    544              case LL_TIM_CHANNEL_CH2:
    545                result = IC2Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_1: (+1)
   \       0x3C   0x6A01             LDR      R1,[R0, #+32]
   \       0x3E   0xF021 0x0110      BIC      R1,R1,#0x10
   \       0x42   0x6201             STR      R1,[R0, #+32]
   \       0x44   0x6984             LDR      R4,[R0, #+24]
   \       0x46   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x4A   0x6184             STR      R4,[R0, #+24]
   \       0x4C   0x6A01             LDR      R1,[R0, #+32]
   \       0x4E   0x6812             LDR      R2,[R2, #+0]
   \       0x50   0xF021 0x01A0      BIC      R1,R1,#0xA0
   \       0x54   0xEA41 0x1102      ORR      R1,R1,R2, LSL #+4
   \       0x58   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0x5C   0xE020             B.N      ??LL_TIM_IC_Init_6
    546                break;
    547              case LL_TIM_CHANNEL_CH3:
    548                result = IC3Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_2: (+1)
   \       0x5E   0x6A01             LDR      R1,[R0, #+32]
   \       0x60   0xF421 0x7180      BIC      R1,R1,#0x100
   \       0x64   0x6201             STR      R1,[R0, #+32]
   \       0x66   0x69C4             LDR      R4,[R0, #+28]
   \       0x68   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x6C   0x61C4             STR      R4,[R0, #+28]
   \       0x6E   0x6A01             LDR      R1,[R0, #+32]
   \       0x70   0x6812             LDR      R2,[R2, #+0]
   \       0x72   0xF421 0x6120      BIC      R1,R1,#0xA00
   \       0x76   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x7A   0xF441 0x7180      ORR      R1,R1,#0x100
   \       0x7E   0xE00F             B.N      ??LL_TIM_IC_Init_6
    549                break;
    550              case LL_TIM_CHANNEL_CH4:
    551                result = IC4Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_3: (+1)
   \       0x80   0x6A01             LDR      R1,[R0, #+32]
   \       0x82   0xF421 0x5180      BIC      R1,R1,#0x1000
   \       0x86   0x6201             STR      R1,[R0, #+32]
   \       0x88   0x69C4             LDR      R4,[R0, #+28]
   \       0x8A   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x8E   0x61C4             STR      R4,[R0, #+28]
   \       0x90   0x6A01             LDR      R1,[R0, #+32]
   \       0x92   0x6812             LDR      R2,[R2, #+0]
   \       0x94   0xF421 0x4120      BIC      R1,R1,#0xA000
   \       0x98   0xEA41 0x3102      ORR      R1,R1,R2, LSL #+12
   \       0x9C   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??LL_TIM_IC_Init_6: (+1)
   \       0xA0   0x6201             STR      R1,[R0, #+32]
   \                     ??LL_TIM_IC_Init_5: (+1)
   \       0xA2   0x2300             MOVS     R3,#+0
    552                break;
    553              default:
    554                break;
    555            }
    556          
    557            return result;
   \                     ??LL_TIM_IC_Init_4: (+1)
   \       0xA4   0x4618             MOV      R0,R3
   \       0xA6   0xBD30             POP      {R4,R5,PC}       ;; return
    558          }
    559          
    560          /**
    561            * @brief  Fills each TIM_EncoderInitStruct field with its default value
    562            * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (encoder interface configuration data structure)
    563            * @retval None
    564            */

   \                                 In section .text, align 2, keep-with-next
    565          void LL_TIM_ENCODER_StructInit(LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
    566          {
    567            /* Set the default configuration */
    568            TIM_EncoderInitStruct->EncoderMode    = LL_TIM_ENCODERMODE_X2_TI1;
   \                     LL_TIM_ENCODER_StructInit: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x6001             STR      R1,[R0, #+0]
    569            TIM_EncoderInitStruct->IC1Polarity    = LL_TIM_IC_POLARITY_RISING;
   \        0x4   0x2200             MOVS     R2,#+0
    570            TIM_EncoderInitStruct->IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
   \        0x6   0xF44F 0x3180      MOV      R1,#+65536
   \        0xA   0x6042             STR      R2,[R0, #+4]
   \        0xC   0x6081             STR      R1,[R0, #+8]
    571            TIM_EncoderInitStruct->IC1Prescaler   = LL_TIM_ICPSC_DIV1;
   \        0xE   0x60C2             STR      R2,[R0, #+12]
    572            TIM_EncoderInitStruct->IC1Filter      = LL_TIM_IC_FILTER_FDIV1;
   \       0x10   0x6102             STR      R2,[R0, #+16]
    573            TIM_EncoderInitStruct->IC2Polarity    = LL_TIM_IC_POLARITY_RISING;
   \       0x12   0x6142             STR      R2,[R0, #+20]
    574            TIM_EncoderInitStruct->IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
   \       0x14   0x6181             STR      R1,[R0, #+24]
    575            TIM_EncoderInitStruct->IC2Prescaler   = LL_TIM_ICPSC_DIV1;
   \       0x16   0x61C2             STR      R2,[R0, #+28]
    576            TIM_EncoderInitStruct->IC2Filter      = LL_TIM_IC_FILTER_FDIV1;
   \       0x18   0x6202             STR      R2,[R0, #+32]
    577          }
   \       0x1A   0x4770             BX       LR               ;; return
    578          
    579          /**
    580            * @brief  Configure the encoder interface of the timer instance.
    581            * @param  TIMx Timer Instance
    582            * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (TIMx encoder interface configuration data structure)
    583            * @retval An ErrorStatus enumeration value:
    584            *          - SUCCESS: TIMx registers are de-initialized
    585            *          - ERROR: not applicable
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          ErrorStatus LL_TIM_ENCODER_Init(TIM_TypeDef *TIMx, LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
    588          {
   \                     LL_TIM_ENCODER_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    589            uint32_t tmpccmr1;
    590            uint32_t tmpccer;
    591          
    592            /* Check the parameters */
    593            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx));
    594            assert_param(IS_LL_TIM_ENCODERMODE(TIM_EncoderInitStruct->EncoderMode));
    595            assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC1Polarity));
    596            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC1ActiveInput));
    597            assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC1Prescaler));
    598            assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC1Filter));
    599            assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC2Polarity));
    600            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC2ActiveInput));
    601            assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC2Prescaler));
    602            assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC2Filter));
    603          
    604            /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
    605            TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0xF022 0x0211      BIC      R2,R2,#0x11
   \        0x8   0x6202             STR      R2,[R0, #+32]
    606          
    607            /* Get the TIMx CCMR1 register value */
    608            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
   \        0xA   0x6984             LDR      R4,[R0, #+24]
    609          
    610            /* Get the TIMx CCER register value */
    611            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
    612          
    613            /* Configure TI1 */
    614            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
    615            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1ActiveInput >> 16U);
    616            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Filter >> 16U);
    617            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Prescaler >> 16U);
    618          
    619            /* Configure TI2 */
    620            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC2S | TIM_CCMR1_IC2F  | TIM_CCMR1_IC2PSC);
    621            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2ActiveInput >> 8U);
    622            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Filter >> 8U);
    623            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Prescaler >> 8U);
   \        0xE   0x688E             LDR      R6,[R1, #+8]
   \       0x10   0x690B             LDR      R3,[R1, #+16]
   \       0x12   0x68CA             LDR      R2,[R1, #+12]
   \       0x14   0x0A24             LSRS     R4,R4,#+8
   \       0x16   0x431E             ORRS     R6,R3,R6
   \       0x18   0x6A0B             LDR      R3,[R1, #+32]
   \       0x1A   0x0224             LSLS     R4,R4,#+8
   \       0x1C   0x4316             ORRS     R6,R2,R6
   \       0x1E   0x69CA             LDR      R2,[R1, #+28]
   \       0x20   0xEA44 0x4416      ORR      R4,R4,R6, LSR #+16
   \       0x24   0x698E             LDR      R6,[R1, #+24]
   \       0x26   0x431E             ORRS     R6,R3,R6
   \       0x28   0xF424 0x447F      BIC      R4,R4,#0xFF00
   \       0x2C   0x4316             ORRS     R6,R2,R6
   \       0x2E   0xEA44 0x2416      ORR      R4,R4,R6, LSR #+8
    624          
    625            /* Set TI1 and TI2 polarity and enable TI1 and TI2 */
    626            tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
    627            tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC1Polarity);
    628            tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC2Polarity << 4U);
   \       0x32   0x684A             LDR      R2,[R1, #+4]
   \       0x34   0x694B             LDR      R3,[R1, #+20]
    629            tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
    630          
    631            /* Set encoder mode */
    632            LL_TIM_SetEncoderMode(TIMx, TIM_EncoderInitStruct->EncoderMode);
   \       0x36   0x6886             LDR      R6,[R0, #+8]
   \       0x38   0x6809             LDR      R1,[R1, #+0]
   \       0x3A   0xF025 0x05AA      BIC      R5,R5,#0xAA
   \       0x3E   0x4315             ORRS     R5,R2,R5
   \       0x40   0x....             LDR.N    R2,??DataTable6_10  ;; 0xfffefff8
   \       0x42   0x4016             ANDS     R6,R2,R6
   \       0x44   0x430E             ORRS     R6,R1,R6
   \       0x46   0xEA45 0x1503      ORR      R5,R5,R3, LSL #+4
   \       0x4A   0x6086             STR      R6,[R0, #+8]
    633          
    634            /* Write to TIMx CCMR1 */
    635            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   \       0x4C   0x6184             STR      R4,[R0, #+24]
    636          
    637            /* Write to TIMx CCER */
    638            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x4E   0xF045 0x0511      ORR      R5,R5,#0x11
   \       0x52   0x6205             STR      R5,[R0, #+32]
    639          
    640            return SUCCESS;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBD70             POP      {R4-R6,PC}       ;; return
    641          }
    642          
    643          #if defined TIM_CR2_MMS2
    644          /**
    645            * @brief  Set the fields of the TIMx Hall sensor interface configuration data
    646            *         structure to their default values.
    647            * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (HALL sensor interface configuration data structure)
    648            * @retval None
    649            */

   \                                 In section .text, align 2, keep-with-next
    650          void LL_TIM_HALLSENSOR_StructInit(LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
    651          {
    652            /* Set the default configuration */
    653            TIM_HallSensorInitStruct->IC1Polarity       = LL_TIM_IC_POLARITY_RISING;
   \                     LL_TIM_HALLSENSOR_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    654            TIM_HallSensorInitStruct->IC1Prescaler      = LL_TIM_ICPSC_DIV1;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    655            TIM_HallSensorInitStruct->IC1Filter         = LL_TIM_IC_FILTER_FDIV1;
   \        0x6                      REQUIRE ?Subroutine0
   \        0x6                      ;; // Fall through to label ?Subroutine0
    656            TIM_HallSensorInitStruct->CommutationDelay  = 0U;
    657          }
    658          
    659          /**
    660            * @brief  Configure the Hall sensor interface of the timer instance.
    661            * @note TIMx CH1, CH2 and CH3 inputs connected through a XOR
    662            *       to the TI1 input channel
    663            * @note TIMx slave mode controller is configured in reset mode.
    664                    Selected internal trigger is TI1F_ED.
    665            * @note Channel 1 is configured as input, IC1 is mapped on TRC.
    666            * @note Captured value stored in TIMx_CCR1 correspond to the time elapsed
    667            *       between 2 changes on the inputs. It gives information about motor speed.
    668            * @note Channel 2 is configured in output PWM 2 mode.
    669            * @note Compare value stored in TIMx_CCR2 corresponds to the commutation delay.
    670            * @note OC2REF is selected as trigger output on TRGO.
    671            * @note LL_TIM_IC_POLARITY_BOTHEDGE must not be used for TI1 when it is used
    672            *       when TIMx operates in Hall sensor interface mode.
    673            * @param  TIMx Timer Instance
    674            * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (TIMx HALL sensor interface configuration data structure)
    675            * @retval An ErrorStatus enumeration value:
    676            *          - SUCCESS: TIMx registers are de-initialized
    677            *          - ERROR: not applicable
    678            */

   \                                 In section .text, align 2, keep-with-next
    679          ErrorStatus LL_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
    680          {
   \                     LL_TIM_HALLSENSOR_Init: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    681            uint32_t tmpcr2;
    682            uint32_t tmpccmr1;
    683            uint32_t tmpccer;
    684            uint32_t tmpsmcr;
    685          
    686            /* Check the parameters */
    687            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(TIMx));
    688            assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_HallSensorInitStruct->IC1Polarity));
    689            assert_param(IS_LL_TIM_ICPSC(TIM_HallSensorInitStruct->IC1Prescaler));
    690            assert_param(IS_LL_TIM_IC_FILTER(TIM_HallSensorInitStruct->IC1Filter));
    691          
    692            /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
    693            TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0xF022 0x0211      BIC      R2,R2,#0x11
   \        0x8   0x6202             STR      R2,[R0, #+32]
    694          
    695            /* Get the TIMx CR2 register value */
    696            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
   \        0xA   0x6843             LDR      R3,[R0, #+4]
    697          
    698            /* Get the TIMx CCMR1 register value */
    699            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
   \        0xC   0x6984             LDR      R4,[R0, #+24]
    700          
    701            /* Get the TIMx CCER register value */
    702            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \        0xE   0x6A05             LDR      R5,[R0, #+32]
    703          
    704            /* Get the TIMx SMCR register value */
    705            tmpsmcr = LL_TIM_ReadReg(TIMx, SMCR);
   \       0x10   0x6886             LDR      R6,[R0, #+8]
    706          
    707            /* Connect TIMx_CH1, CH2 and CH3 pins to the TI1 input */
    708            tmpcr2 |= TIM_CR2_TI1S;
    709          
    710            /* OC2REF signal is used as trigger output (TRGO) */
    711            tmpcr2 |= LL_TIM_TRGO_OC2REF;
    712          
    713            /* Configure the slave mode controller */
    714            tmpsmcr &= (uint32_t)~(TIM_SMCR_TS | TIM_SMCR_SMS);
    715            tmpsmcr |= LL_TIM_TS_TI1F_ED;
    716            tmpsmcr |= LL_TIM_SLAVEMODE_RESET;
    717          
    718            /* Configure input channel 1 */
    719            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
    720            tmpccmr1 |= (uint32_t)(LL_TIM_ACTIVEINPUT_TRC >> 16U);
    721            tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Filter >> 16U);
    722            tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Prescaler >> 16U);
   \       0x12   0x688F             LDR      R7,[R1, #+8]
   \       0x14   0x684A             LDR      R2,[R1, #+4]
    723          
    724            /* Configure input channel 2 */
    725            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_OC2M | TIM_CCMR1_OC2FE  | TIM_CCMR1_OC2PE  | TIM_CCMR1_OC2CE);
    726            tmpccmr1 |= (uint32_t)(LL_TIM_OCMODE_PWM2 << 8U);
    727          
    728            /* Set Channel 1 polarity and enable Channel 1 and Channel2 */
    729            tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
    730            tmpccer |= (uint32_t)(TIM_HallSensorInitStruct->IC1Polarity);
    731            tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
    732          
    733            /* Write to TIMx CR2 */
    734            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   \       0x16   0xF043 0x03D0      ORR      R3,R3,#0xD0
   \       0x1A   0x0A24             LSRS     R4,R4,#+8
   \       0x1C   0x0224             LSLS     R4,R4,#+8
   \       0x1E   0x4317             ORRS     R7,R2,R7
   \       0x20   0x680A             LDR      R2,[R1, #+0]
   \       0x22   0x6043             STR      R3,[R0, #+4]
   \       0x24   0xF025 0x05AA      BIC      R5,R5,#0xAA
   \       0x28   0xEA44 0x4417      ORR      R4,R4,R7, LSR #+16
   \       0x2C   0x4315             ORRS     R5,R2,R5
    735          
    736            /* Write to TIMx SMCR */
    737            LL_TIM_WriteReg(TIMx, SMCR, tmpsmcr);
   \       0x2E   0x....             LDR.N    R3,??DataTable6_11  ;; 0xfffeff88
    738          
    739            /* Write to TIMx CCMR1 */
    740            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   \       0x30   0x....             LDR.N    R2,??DataTable6_12  ;; 0xfeff03ff
   \       0x32   0xF044 0x0403      ORR      R4,R4,#0x3
   \       0x36   0x401E             ANDS     R6,R3,R6
   \       0x38   0xF046 0x0644      ORR      R6,R6,#0x44
   \       0x3C   0x4014             ANDS     R4,R2,R4
   \       0x3E   0x6086             STR      R6,[R0, #+8]
   \       0x40   0xF444 0x44E0      ORR      R4,R4,#0x7000
   \       0x44   0x6184             STR      R4,[R0, #+24]
    741          
    742            /* Write to TIMx CCER */
    743            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x46   0xF045 0x0511      ORR      R5,R5,#0x11
   \       0x4A   0x6205             STR      R5,[R0, #+32]
    744          
    745            /* Write to TIMx CCR2 */
    746            LL_TIM_OC_SetCompareCH2(TIMx, TIM_HallSensorInitStruct->CommutationDelay);
   \       0x4C   0x68C9             LDR      R1,[R1, #+12]
   \       0x4E   0x6381             STR      R1,[R0, #+56]
    747          
    748            return SUCCESS;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xBDF0             POP      {R4-R7,PC}       ;; return
    749          }
    750          #endif /* TIM_CR2_MMS2 */
    751          
    752          /**
    753            * @brief  Set the fields of the Break and Dead Time configuration data structure
    754            *         to their default values.
    755            * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration data structure)
    756            * @retval None
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          void LL_TIM_BDTR_StructInit(LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
    759          {
    760            /* Set the default configuration */
    761            TIM_BDTRInitStruct->OSSRState       = LL_TIM_OSSR_DISABLE;
   \                     LL_TIM_BDTR_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    762            TIM_BDTRInitStruct->OSSIState       = LL_TIM_OSSI_DISABLE;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    763            TIM_BDTRInitStruct->LockLevel       = LL_TIM_LOCKLEVEL_OFF;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    764            TIM_BDTRInitStruct->DeadTime        = (uint8_t)0x00;
   \        0x8   0x7301             STRB     R1,[R0, #+12]
    765            TIM_BDTRInitStruct->BreakState      = LL_TIM_BREAK_DISABLE;
   \        0xA   0x81C1             STRH     R1,[R0, #+14]
    766            TIM_BDTRInitStruct->BreakPolarity   = LL_TIM_BREAK_POLARITY_LOW;
   \        0xC   0x6101             STR      R1,[R0, #+16]
    767          #if defined(TIM_BDTR_BKF)
    768            TIM_BDTRInitStruct->BreakFilter     = LL_TIM_BREAK_FILTER_FDIV1;
   \        0xE   0x6141             STR      R1,[R0, #+20]
    769          #endif /* TIM_BDTR_BKF */
    770          #if defined(TIM_BDTR_BK2E)
    771            TIM_BDTRInitStruct->Break2State     = LL_TIM_BREAK2_DISABLE;
   \       0x10   0x6181             STR      R1,[R0, #+24]
    772            TIM_BDTRInitStruct->Break2Polarity  = LL_TIM_BREAK2_POLARITY_LOW;
   \       0x12   0x61C1             STR      R1,[R0, #+28]
    773            TIM_BDTRInitStruct->Break2Filter    = LL_TIM_BREAK2_FILTER_FDIV1;
   \       0x14   0x6201             STR      R1,[R0, #+32]
    774          #endif /* TIM_BDTR_BK2E */
    775            TIM_BDTRInitStruct->AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
   \       0x16   0x6241             STR      R1,[R0, #+36]
    776          }
   \       0x18   0x4770             BX       LR               ;; return
    777          
    778          /**
    779            * @brief  Configure the Break and Dead Time feature of the timer instance.
    780            * @note As the bits BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR
    781            *  and DTG[7:0] can be write-locked depending on the LOCK configuration, it
    782            *  can be necessary to configure all of them during the first write access to
    783            *  the TIMx_BDTR register.
    784            * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
    785            *       a timer instance provides a break input.
    786            * @note Macro IS_TIM_BKIN2_INSTANCE(TIMx) can be used to check whether or not
    787            *       a timer instance provides a second break input.
    788            * @param  TIMx Timer Instance
    789            * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration data structure)
    790            * @retval An ErrorStatus enumeration value:
    791            *          - SUCCESS: Break and Dead Time is initialized
    792            *          - ERROR: not applicable
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          ErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
    795          {
   \                     LL_TIM_BDTR_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    796            uint32_t tmpbdtr = 0;
    797          
    798            /* Check the parameters */
    799            assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
    800            assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
    801            assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
    802            assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
    803            assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
    804            assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
    805            assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
    806          
    807            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
    808            the OSSI State, the dead time value and the Automatic Output Enable Bit */
    809          
    810            /* Set the BDTR bits */
    811            MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
    812            MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
    813            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
    814            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
    815            MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
    816            MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
    817            MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
    818            MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
   \        0x2   0x7B0C             LDRB     R4,[R1, #+12]
   \        0x4   0x688A             LDR      R2,[R1, #+8]
   \        0x6   0x684B             LDR      R3,[R1, #+4]
   \        0x8   0x6A4D             LDR      R5,[R1, #+36]
   \        0xA   0x4314             ORRS     R4,R2,R4
   \        0xC   0xF424 0x6480      BIC      R4,R4,#0x400
   \       0x10   0x431C             ORRS     R4,R3,R4
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0x89CB             LDRH     R3,[R1, #+14]
   \       0x16   0xF424 0x6400      BIC      R4,R4,#0x800
   \       0x1A   0x4314             ORRS     R4,R2,R4
   \       0x1C   0xF424 0x5480      BIC      R4,R4,#0x1000
   \       0x20   0x431C             ORRS     R4,R3,R4
   \       0x22   0x690A             LDR      R2,[R1, #+16]
    819          #if defined(TIM_BDTR_BKF)
    820            if (IS_TIM_ADVANCED_INSTANCE(TIMx))
   \       0x24   0x....             LDR.N    R3,??DataTable6_1  ;; 0x40012c00
   \       0x26   0xF424 0x5400      BIC      R4,R4,#0x2000
   \       0x2A   0x4314             ORRS     R4,R2,R4
   \       0x2C   0xF424 0x4480      BIC      R4,R4,#0x4000
   \       0x30   0x432C             ORRS     R4,R5,R4
   \       0x32   0xF424 0x4400      BIC      R4,R4,#0x8000
   \       0x36   0x432C             ORRS     R4,R5,R4
   \       0x38   0x4298             CMP      R0,R3
   \       0x3A   0xD10F             BNE.N    ??LL_TIM_BDTR_Init_0
    821            {
    822              assert_param(IS_LL_TIM_BREAK_FILTER(TIM_BDTRInitStruct->BreakFilter));
    823              MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, TIM_BDTRInitStruct->BreakFilter);
   \       0x3C   0x694A             LDR      R2,[R1, #+20]
    824            }
    825          #endif /* TIM_BDTR_BKF */
    826          #if defined(TIM_BDTR_BK2E)
    827          
    828            if (IS_TIM_BKIN2_INSTANCE(TIMx))
    829            {
    830              assert_param(IS_LL_TIM_BREAK2_STATE(TIM_BDTRInitStruct->Break2State));
    831              assert_param(IS_LL_TIM_BREAK2_POLARITY(TIM_BDTRInitStruct->Break2Polarity));
    832              assert_param(IS_LL_TIM_BREAK2_FILTER(TIM_BDTRInitStruct->Break2Filter));
    833          
    834              /* Set the BREAK2 input related BDTR bit-fields */
    835              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (TIM_BDTRInitStruct->Break2Filter));
    836              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, TIM_BDTRInitStruct->Break2State);
    837              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, TIM_BDTRInitStruct->Break2Polarity);
   \       0x3E   0x6A0B             LDR      R3,[R1, #+32]
   \       0x40   0xF424 0x2470      BIC      R4,R4,#0xF0000
   \       0x44   0x4314             ORRS     R4,R2,R4
   \       0x46   0xF424 0x0470      BIC      R4,R4,#0xF00000
   \       0x4A   0x431C             ORRS     R4,R3,R4
   \       0x4C   0x698A             LDR      R2,[R1, #+24]
   \       0x4E   0x69C9             LDR      R1,[R1, #+28]
   \       0x50   0xF024 0x7480      BIC      R4,R4,#0x1000000
   \       0x54   0x4314             ORRS     R4,R2,R4
   \       0x56   0xF024 0x7400      BIC      R4,R4,#0x2000000
   \       0x5A   0x430C             ORRS     R4,R1,R4
    838            }
    839          #endif /* TIM_BDTR_BK2E */
    840          
    841            /* Set TIMx_BDTR */
    842            LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
   \                     ??LL_TIM_BDTR_Init_0: (+1)
   \       0x5C   0x6444             STR      R4,[R0, #+68]
    843          
    844            return SUCCESS;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xBD30             POP      {R4,R5,PC}       ;; return
    845          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6855             LDR      R5,[R2, #+4]
   \        0x2   0x68D3             LDR      R3,[R2, #+12]
   \        0x4   0x6891             LDR      R1,[R2, #+8]
   \        0x6   0x431D             ORRS     R5,R3,R5
   \        0x8   0xF424 0x447F      BIC      R4,R4,#0xFF00
   \        0xC   0x430D             ORRS     R5,R1,R5
   \        0xE   0xEA44 0x2415      ORR      R4,R4,R5, LSR #+8
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6855             LDR      R5,[R2, #+4]
   \        0x2   0x68D3             LDR      R3,[R2, #+12]
   \        0x4   0x6891             LDR      R1,[R2, #+8]
   \        0x6   0x0A24             LSRS     R4,R4,#+8
   \        0x8   0x431D             ORRS     R5,R3,R5
   \        0xA   0x0224             LSLS     R4,R4,#+8
   \        0xC   0x430D             ORRS     R5,R1,R5
   \        0xE   0xEA44 0x4415      ORR      R4,R4,R5, LSR #+16
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x4002'100C        DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x4000'1000        DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x4001'4000        DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0xFFFE'FF8C        DC32     0xfffeff8c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0xFEFF'8CFF        DC32     0xfeff8cff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0xFFFE'FF8F        DC32     0xfffeff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \        0x0   0xFEFF'8FFF        DC32     0xfeff8fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \        0x0   0xFFFE'FFF8        DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \        0x0   0xFFFE'FF88        DC32     0xfffeff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \        0x0   0xFEFF'03FF        DC32     0xfeff03ff
    846          /**
    847            * @}
    848            */
    849          
    850          /**
    851            * @}
    852            */
    853          
    854          /** @addtogroup TIM_LL_Private_Functions TIM Private Functions
    855            *  @brief   Private functions
    856            * @{
    857            */
    858          /**
    859            * @brief  Configure the TIMx output channel 1.
    860            * @param  TIMx Timer Instance
    861            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 1 configuration data structure
    862            * @retval An ErrorStatus enumeration value:
    863            *          - SUCCESS: TIMx registers are de-initialized
    864            *          - ERROR: not applicable
    865            */
    866          static ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
    867          {
    868            uint32_t tmpccmr1;
    869            uint32_t tmpccer;
    870            uint32_t tmpcr2;
    871          
    872            /* Check the parameters */
    873            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
    874            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
    875            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
    876            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
    877            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
    878            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
    879          
    880            /* Disable the Channel 1: Reset the CC1E Bit */
    881            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
    882          
    883            /* Get the TIMx CCER register value */
    884            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
    885          
    886            /* Get the TIMx CR2 register value */
    887            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
    888          
    889            /* Get the TIMx CCMR1 register value */
    890            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
    891          
    892            /* Reset Capture/Compare selection Bits */
    893            CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
    894          
    895            /* Set the Output Compare Mode */
    896            MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
    897          
    898            /* Set the Output Compare Polarity */
    899            MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
    900          
    901            /* Set the Output State */
    902            MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
    903          
    904            if (IS_TIM_BREAK_INSTANCE(TIMx))
    905            {
    906              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    907              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
    908          
    909              /* Set the complementary output Polarity */
    910              MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
    911          
    912              /* Set the complementary output State */
    913              MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
    914          
    915              /* Set the Output Idle state */
    916              MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
    917          
    918              /* Set the complementary output Idle state */
    919              MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
    920            }
    921          
    922            /* Write to TIMx CR2 */
    923            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
    924          
    925            /* Write to TIMx CCMR1 */
    926            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
    927          
    928            /* Set the Capture Compare Register value */
    929            LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
    930          
    931            /* Write to TIMx CCER */
    932            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
    933          
    934            return SUCCESS;
    935          }
    936          
    937          /**
    938            * @brief  Configure the TIMx output channel 2.
    939            * @param  TIMx Timer Instance
    940            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
    941            * @retval An ErrorStatus enumeration value:
    942            *          - SUCCESS: TIMx registers are de-initialized
    943            *          - ERROR: not applicable
    944            */
    945          static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
    946          {
    947            uint32_t tmpccmr1;
    948            uint32_t tmpccer;
    949            uint32_t tmpcr2;
    950          
    951            /* Check the parameters */
    952            assert_param(IS_TIM_CC2_INSTANCE(TIMx));
    953            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
    954            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
    955            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
    956            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
    957            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
    958          
    959            /* Disable the Channel 2: Reset the CC2E Bit */
    960            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
    961          
    962            /* Get the TIMx CCER register value */
    963            tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
    964          
    965            /* Get the TIMx CR2 register value */
    966            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
    967          
    968            /* Get the TIMx CCMR1 register value */
    969            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
    970          
    971            /* Reset Capture/Compare selection Bits */
    972            CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
    973          
    974            /* Select the Output Compare Mode */
    975            MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
    976          
    977            /* Set the Output Compare Polarity */
    978            MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
    979          
    980            /* Set the Output State */
    981            MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
    982          
    983            if (IS_TIM_BREAK_INSTANCE(TIMx))
    984            {
    985              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    986              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
    987          
    988              /* Set the complementary output Polarity */
    989              MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
    990          
    991              /* Set the complementary output State */
    992              MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
    993          
    994              /* Set the Output Idle state */
    995              MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
    996          
    997          #if defined(STM32F373xC) || defined(STM32F378xx)
    998          #else
    999              /* Set the complementary output Idle state */
   1000              MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
   1001          #endif
   1002            }
   1003          
   1004            /* Write to TIMx CR2 */
   1005            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   1006          
   1007            /* Write to TIMx CCMR1 */
   1008            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   1009          
   1010            /* Set the Capture Compare Register value */
   1011            LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
   1012          
   1013            /* Write to TIMx CCER */
   1014            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   1015          
   1016            return SUCCESS;
   1017          }
   1018          
   1019          /**
   1020            * @brief  Configure the TIMx output channel 3.
   1021            * @param  TIMx Timer Instance
   1022            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
   1023            * @retval An ErrorStatus enumeration value:
   1024            *          - SUCCESS: TIMx registers are de-initialized
   1025            *          - ERROR: not applicable
   1026            */
   1027          static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1028          {
   1029            uint32_t tmpccmr2;
   1030            uint32_t tmpccer;
   1031            uint32_t tmpcr2;
   1032          
   1033            /* Check the parameters */
   1034            assert_param(IS_TIM_CC3_INSTANCE(TIMx));
   1035            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1036            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1037            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1038            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1039            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1040          
   1041            /* Disable the Channel 3: Reset the CC3E Bit */
   1042            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
   1043          
   1044            /* Get the TIMx CCER register value */
   1045            tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
   1046          
   1047            /* Get the TIMx CR2 register value */
   1048            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
   1049          
   1050            /* Get the TIMx CCMR2 register value */
   1051            tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
   1052          
   1053            /* Reset Capture/Compare selection Bits */
   1054            CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
   1055          
   1056            /* Select the Output Compare Mode */
   1057            MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
   1058          
   1059            /* Set the Output Compare Polarity */
   1060            MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
   1061          
   1062            /* Set the Output State */
   1063            MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
   1064          
   1065            if (IS_TIM_BREAK_INSTANCE(TIMx))
   1066            {
   1067              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1068              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1069          
   1070              /* Set the complementary output Polarity */
   1071              MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
   1072          
   1073              /* Set the complementary output State */
   1074              MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
   1075          
   1076          #if defined(STM32F373xC) || defined(STM32F378xx)
   1077          #else
   1078              /* Set the Output Idle state */
   1079              MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
   1080          
   1081              /* Set the complementary output Idle state */
   1082              MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
   1083          #endif
   1084            }
   1085          
   1086            /* Write to TIMx CR2 */
   1087            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   1088          
   1089            /* Write to TIMx CCMR2 */
   1090            LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
   1091          
   1092            /* Set the Capture Compare Register value */
   1093            LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
   1094          
   1095            /* Write to TIMx CCER */
   1096            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   1097          
   1098            return SUCCESS;
   1099          }
   1100          
   1101          /**
   1102            * @brief  Configure the TIMx output channel 4.
   1103            * @param  TIMx Timer Instance
   1104            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
   1105            * @retval An ErrorStatus enumeration value:
   1106            *          - SUCCESS: TIMx registers are de-initialized
   1107            *          - ERROR: not applicable
   1108            */
   1109          static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1110          {
   1111            uint32_t tmpccmr2;
   1112            uint32_t tmpccer;
   1113            uint32_t tmpcr2;
   1114          
   1115            /* Check the parameters */
   1116            assert_param(IS_TIM_CC4_INSTANCE(TIMx));
   1117            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1118            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1119            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1120            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1121            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1122          
   1123            /* Disable the Channel 4: Reset the CC4E Bit */
   1124            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
   1125          
   1126            /* Get the TIMx CCER register value */
   1127            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   1128          
   1129            /* Get the TIMx CR2 register value */
   1130            tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
   1131          
   1132            /* Get the TIMx CCMR2 register value */
   1133            tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
   1134          
   1135            /* Reset Capture/Compare selection Bits */
   1136            CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
   1137          
   1138            /* Select the Output Compare Mode */
   1139            MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
   1140          
   1141            /* Set the Output Compare Polarity */
   1142            MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
   1143          
   1144            /* Set the Output State */
   1145            MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
   1146          
   1147            if (IS_TIM_BREAK_INSTANCE(TIMx))
   1148            {
   1149              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1150              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1151          
   1152          #if defined(STM32F373xC) || defined(STM32F378xx)
   1153          #else
   1154              /* Set the Output Idle state */
   1155              MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
   1156          #endif
   1157            }
   1158          
   1159            /* Write to TIMx CR2 */
   1160            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   1161          
   1162            /* Write to TIMx CCMR2 */
   1163            LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
   1164          
   1165            /* Set the Capture Compare Register value */
   1166            LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
   1167          
   1168            /* Write to TIMx CCER */
   1169            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   1170          
   1171            return SUCCESS;
   1172          }
   1173          
   1174          #if defined(TIM_CCER_CC5E)
   1175          /**
   1176            * @brief  Configure the TIMx output channel 5.
   1177            * @param  TIMx Timer Instance
   1178            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 5 configuration data structure
   1179            * @note   OC5 is not available for all F3 devices
   1180            * @retval An ErrorStatus enumeration value:
   1181            *          - SUCCESS: TIMx registers are de-initialized
   1182            *          - ERROR: not applicable
   1183            */
   1184          static ErrorStatus OC5Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1185          {
   1186            uint32_t tmpccmr3;
   1187            uint32_t tmpccer;
   1188          
   1189            /* Check the parameters */
   1190            assert_param(IS_TIM_CC5_INSTANCE(TIMx));
   1191            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1192            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1193            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1194            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1195            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1196          
   1197            /* Disable the Channel 5: Reset the CC5E Bit */
   1198            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC5E);
   1199          
   1200            /* Get the TIMx CCER register value */
   1201            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   1202          
   1203            /* Get the TIMx CCMR3 register value */
   1204            tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
   1205          
   1206            /* Select the Output Compare Mode */
   1207            MODIFY_REG(tmpccmr3, TIM_CCMR3_OC5M, TIM_OCInitStruct->OCMode);
   1208          
   1209            /* Set the Output Compare Polarity */
   1210            MODIFY_REG(tmpccer, TIM_CCER_CC5P, TIM_OCInitStruct->OCPolarity << 16U);
   1211          
   1212            /* Set the Output State */
   1213            MODIFY_REG(tmpccer, TIM_CCER_CC5E, TIM_OCInitStruct->OCState << 16U);
   1214          
   1215            if (IS_TIM_BREAK_INSTANCE(TIMx))
   1216            {
   1217              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1218              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1219          
   1220              /* Set the Output Idle state */
   1221              MODIFY_REG(TIMx->CR2, TIM_CR2_OIS5, TIM_OCInitStruct->OCIdleState << 8U);
   1222          
   1223            }
   1224          
   1225            /* Write to TIMx CCMR3 */
   1226            LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
   1227          
   1228            /* Set the Capture Compare Register value */
   1229            LL_TIM_OC_SetCompareCH5(TIMx, TIM_OCInitStruct->CompareValue);
   1230          
   1231            /* Write to TIMx CCER */
   1232            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   1233          
   1234            return SUCCESS;
   1235          }
   1236          
   1237          /**
   1238            * @brief  Configure the TIMx output channel 6.
   1239            * @param  TIMx Timer Instance
   1240            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 6 configuration data structure
   1241            * @note   OC6 is not available for all F3 devices
   1242            * @retval An ErrorStatus enumeration value:
   1243            *          - SUCCESS: TIMx registers are de-initialized
   1244            *          - ERROR: not applicable
   1245            */
   1246          static ErrorStatus OC6Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1247          {
   1248            uint32_t tmpccmr3;
   1249            uint32_t tmpccer;
   1250          
   1251            /* Check the parameters */
   1252            assert_param(IS_TIM_CC6_INSTANCE(TIMx));
   1253            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1254            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1255            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1256            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1257            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1258          
   1259            /* Disable the Channel 5: Reset the CC6E Bit */
   1260            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC6E);
   1261          
   1262            /* Get the TIMx CCER register value */
   1263            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   1264          
   1265            /* Get the TIMx CCMR3 register value */
   1266            tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
   1267          
   1268            /* Select the Output Compare Mode */
   1269            MODIFY_REG(tmpccmr3, TIM_CCMR3_OC6M, TIM_OCInitStruct->OCMode << 8U);
   1270          
   1271            /* Set the Output Compare Polarity */
   1272            MODIFY_REG(tmpccer, TIM_CCER_CC6P, TIM_OCInitStruct->OCPolarity << 20U);
   1273          
   1274            /* Set the Output State */
   1275            MODIFY_REG(tmpccer, TIM_CCER_CC6E, TIM_OCInitStruct->OCState << 20U);
   1276          
   1277            if (IS_TIM_BREAK_INSTANCE(TIMx))
   1278            {
   1279              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1280              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1281          
   1282              /* Set the Output Idle state */
   1283              MODIFY_REG(TIMx->CR2, TIM_CR2_OIS6, TIM_OCInitStruct->OCIdleState << 10U);
   1284            }
   1285          
   1286            /* Write to TIMx CCMR3 */
   1287            LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
   1288          
   1289            /* Set the Capture Compare Register value */
   1290            LL_TIM_OC_SetCompareCH6(TIMx, TIM_OCInitStruct->CompareValue);
   1291          
   1292            /* Write to TIMx CCER */
   1293            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   1294          
   1295            return SUCCESS;
   1296          }
   1297          #endif /* TIM_CCER_CC5E */
   1298          
   1299          /**
   1300            * @brief  Configure the TIMx input channel 1.
   1301            * @param  TIMx Timer Instance
   1302            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 1 configuration data structure
   1303            * @retval An ErrorStatus enumeration value:
   1304            *          - SUCCESS: TIMx registers are de-initialized
   1305            *          - ERROR: not applicable
   1306            */
   1307          static ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1308          {
   1309            /* Check the parameters */
   1310            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   1311            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1312            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1313            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1314            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1315          
   1316            /* Disable the Channel 1: Reset the CC1E Bit */
   1317            TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
   1318          
   1319            /* Select the Input and set the filter and the prescaler value */
   1320            MODIFY_REG(TIMx->CCMR1,
   1321                       (TIM_CCMR1_CC1S | TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC),
   1322                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
   1323          
   1324            /* Select the Polarity and set the CC1E Bit */
   1325            MODIFY_REG(TIMx->CCER,
   1326                       (TIM_CCER_CC1P | TIM_CCER_CC1NP),
   1327                       (TIM_ICInitStruct->ICPolarity | TIM_CCER_CC1E));
   1328          
   1329            return SUCCESS;
   1330          }
   1331          
   1332          /**
   1333            * @brief  Configure the TIMx input channel 2.
   1334            * @param  TIMx Timer Instance
   1335            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 2 configuration data structure
   1336            * @retval An ErrorStatus enumeration value:
   1337            *          - SUCCESS: TIMx registers are de-initialized
   1338            *          - ERROR: not applicable
   1339            */
   1340          static ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1341          {
   1342            /* Check the parameters */
   1343            assert_param(IS_TIM_CC2_INSTANCE(TIMx));
   1344            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1345            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1346            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1347            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1348          
   1349            /* Disable the Channel 2: Reset the CC2E Bit */
   1350            TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
   1351          
   1352            /* Select the Input and set the filter and the prescaler value */
   1353            MODIFY_REG(TIMx->CCMR1,
   1354                       (TIM_CCMR1_CC2S | TIM_CCMR1_IC2F | TIM_CCMR1_IC2PSC),
   1355                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
   1356          
   1357            /* Select the Polarity and set the CC2E Bit */
   1358            MODIFY_REG(TIMx->CCER,
   1359                       (TIM_CCER_CC2P | TIM_CCER_CC2NP),
   1360                       ((TIM_ICInitStruct->ICPolarity << 4U) | TIM_CCER_CC2E));
   1361          
   1362            return SUCCESS;
   1363          }
   1364          
   1365          /**
   1366            * @brief  Configure the TIMx input channel 3.
   1367            * @param  TIMx Timer Instance
   1368            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 3 configuration data structure
   1369            * @retval An ErrorStatus enumeration value:
   1370            *          - SUCCESS: TIMx registers are de-initialized
   1371            *          - ERROR: not applicable
   1372            */
   1373          static ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1374          {
   1375            /* Check the parameters */
   1376            assert_param(IS_TIM_CC3_INSTANCE(TIMx));
   1377            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1378            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1379            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1380            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1381          
   1382            /* Disable the Channel 3: Reset the CC3E Bit */
   1383            TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
   1384          
   1385            /* Select the Input and set the filter and the prescaler value */
   1386            MODIFY_REG(TIMx->CCMR2,
   1387                       (TIM_CCMR2_CC3S | TIM_CCMR2_IC3F | TIM_CCMR2_IC3PSC),
   1388                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
   1389          
   1390            /* Select the Polarity and set the CC3E Bit */
   1391            MODIFY_REG(TIMx->CCER,
   1392                       (TIM_CCER_CC3P | TIM_CCER_CC3NP),
   1393                       ((TIM_ICInitStruct->ICPolarity << 8U) | TIM_CCER_CC3E));
   1394          
   1395            return SUCCESS;
   1396          }
   1397          
   1398          /**
   1399            * @brief  Configure the TIMx input channel 4.
   1400            * @param  TIMx Timer Instance
   1401            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 4 configuration data structure
   1402            * @retval An ErrorStatus enumeration value:
   1403            *          - SUCCESS: TIMx registers are de-initialized
   1404            *          - ERROR: not applicable
   1405            */
   1406          static ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1407          {
   1408            /* Check the parameters */
   1409            assert_param(IS_TIM_CC4_INSTANCE(TIMx));
   1410            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1411            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1412            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1413            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1414          
   1415            /* Disable the Channel 4: Reset the CC4E Bit */
   1416            TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
   1417          
   1418            /* Select the Input and set the filter and the prescaler value */
   1419            MODIFY_REG(TIMx->CCMR2,
   1420                       (TIM_CCMR2_CC4S | TIM_CCMR2_IC4F | TIM_CCMR2_IC4PSC),
   1421                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
   1422          
   1423            /* Select the Polarity and set the CC2E Bit */
   1424            MODIFY_REG(TIMx->CCER,
   1425                       (TIM_CCER_CC4P | TIM_CCER_CC4NP),
   1426                       ((TIM_ICInitStruct->ICPolarity << 12U) | TIM_CCER_CC4E));
   1427          
   1428            return SUCCESS;
   1429          }
   1430          
   1431          
   1432          /**
   1433            * @}
   1434            */
   1435          
   1436          /**
   1437            * @}
   1438            */
   1439          
   1440          #endif /* TIM1 || TIM2 || TIM3 || TIM4 || TIM5 || TIM6 || TIM7 || TIM8 || TIM12 || TIM13 || TIM14 || TIM15 || TIM16 || TIM17 || TIM18 || TIM19 || TIM20 */
   1441          
   1442          /**
   1443            * @}
   1444            */
   1445          
   1446          #endif /* USE_FULL_LL_DRIVER */
   1447          
   1448          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   LL_TIM_BDTR_Init
       0   LL_TIM_BDTR_StructInit
       8   LL_TIM_DeInit
      16   LL_TIM_ENCODER_Init
       0   LL_TIM_ENCODER_StructInit
      20   LL_TIM_HALLSENSOR_Init
       0   LL_TIM_HALLSENSOR_StructInit
      12   LL_TIM_IC_Init
       0   LL_TIM_IC_StructInit
      20   LL_TIM_Init
      24   LL_TIM_OC_Init
       0   LL_TIM_OC_StructInit
       0   LL_TIM_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       6  ?Subroutine0
       8  ?Subroutine1
      20  ?Subroutine2
      20  ?Subroutine3
      98  LL_TIM_BDTR_Init
      26  LL_TIM_BDTR_StructInit
     160  LL_TIM_DeInit
      88  LL_TIM_ENCODER_Init
      28  LL_TIM_ENCODER_StructInit
      84  LL_TIM_HALLSENSOR_Init
       6  LL_TIM_HALLSENSOR_StructInit
     168  LL_TIM_IC_Init
      12  LL_TIM_IC_StructInit
     102  LL_TIM_Init
     670  LL_TIM_OC_Init
      20  LL_TIM_OC_StructInit
      18  LL_TIM_StructInit

 
 1'586 bytes in section .text
 
 1'586 bytes of CODE memory

Errors: none
Warnings: none
