###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:07
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_pwr.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW4282.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_pwr.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\stm32f3xx_hal_pwr.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\stm32f3xx_hal_pwr.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_pwr.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_hal_pwr.c
      4            * @author  MCD Application Team
      5            * @brief   PWR HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Power Controller (PWR) peripheral:
      8            *           + Initialization/de-initialization functions
      9            *           + Peripheral Control functions
     10            *
     11            @verbatim
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     16            * All rights reserved.</center></h2>
     17            *
     18            * This software component is licensed by ST under BSD 3-Clause license,
     19            * the "License"; You may not use this file except in compliance with the
     20            * License. You may obtain a copy of the License at:
     21            *                        opensource.org/licenses/BSD-3-Clause
     22            *
     23            ******************************************************************************
     24            */
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "stm32f3xx_hal.h"
     28          
     29          /** @addtogroup STM32F3xx_HAL_Driver
     30            * @{
     31            */
     32          
     33          /** @defgroup PWR PWR
     34            * @brief PWR HAL module driver
     35            * @{
     36            */
     37          
     38          #ifdef HAL_PWR_MODULE_ENABLED
     39          
     40          /* Private typedef -----------------------------------------------------------*/
     41          /* Private define ------------------------------------------------------------*/
     42          /* Private macro -------------------------------------------------------------*/
     43          /* Private variables ---------------------------------------------------------*/
     44          /* Private function prototypes -----------------------------------------------*/
     45          /* Private functions ---------------------------------------------------------*/
     46          
     47          /** @defgroup PWR_Exported_Functions PWR Exported Functions
     48            * @{
     49            */
     50          
     51          /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
     52            *  @brief    Initialization and de-initialization functions
     53            *
     54          @verbatim
     55           ===============================================================================
     56                        ##### Initialization and de-initialization functions #####
     57           ===============================================================================
     58              [..]
     59                After reset, the backup domain (RTC registers, RTC backup data
     60                registers and backup SRAM) is protected against possible unwanted
     61                write accesses.
     62                To enable access to the RTC Domain and RTC registers, proceed as follows:
     63                  (+) Enable the Power Controller (PWR) APB1 interface clock using the
     64                      __HAL_RCC_PWR_CLK_ENABLE() macro.
     65                  (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
     66          
     67          @endverbatim
     68            * @{
     69            */
     70          
     71          /**
     72            * @brief Deinitializes the PWR peripheral registers to their default reset values.
     73            * @retval None
     74            */

   \                                 In section .text, align 2, keep-with-next
     75          void HAL_PWR_DeInit(void)
     76          {
     77            __HAL_RCC_PWR_FORCE_RESET();
   \                     HAL_PWR_DeInit: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11  ;; 0x40021010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \        0x8   0x6001             STR      R1,[R0, #+0]
     78            __HAL_RCC_PWR_RELEASE_RESET();
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   \        0xC   0xF022 0x5280      BIC      R2,R2,#0x10000000
   \       0x10   0x6002             STR      R2,[R0, #+0]
     79          }
   \       0x12   0x4770             BX       LR               ;; return
     80          
     81          /**
     82            * @brief Enables access to the backup domain (RTC registers, RTC
     83            *         backup data registers and backup SRAM).
     84            * @note  If the HSE divided by 32 is used as the RTC clock, the
     85            *         Backup Domain Access should be kept enabled.
     86            * @retval None
     87            */

   \                                 In section .text, align 2, keep-with-next
     88          void HAL_PWR_EnableBkUpAccess(void)
     89          {
     90            SET_BIT(PWR->CR, PWR_CR_DBP);  
   \                     HAL_PWR_EnableBkUpAccess: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF441 0x7180      ORR      R1,R1,#0x100
   \        0x8   0x6001             STR      R1,[R0, #+0]
     91          }
   \        0xA   0x4770             BX       LR               ;; return
     92          
     93          /**
     94            * @brief Disables access to the backup domain (RTC registers, RTC
     95            *         backup data registers and backup SRAM).
     96            * @note  If the HSE divided by 32 is used as the RTC clock, the
     97            *         Backup Domain Access should be kept enabled.
     98            * @retval None
     99            */

   \                                 In section .text, align 2, keep-with-next
    100          void HAL_PWR_DisableBkUpAccess(void)
    101          {
    102            CLEAR_BIT(PWR->CR, PWR_CR_DBP);  
   \                     HAL_PWR_DisableBkUpAccess: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF421 0x7180      BIC      R1,R1,#0x100
   \        0x8   0x6001             STR      R1,[R0, #+0]
    103          }
   \        0xA   0x4770             BX       LR               ;; return
    104          
    105          /**
    106            * @}
    107            */
    108          
    109          /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
    110            *  @brief Low Power modes configuration functions
    111            *
    112          @verbatim
    113          
    114           ===============================================================================
    115                           ##### Peripheral Control functions #####
    116           ===============================================================================
    117              
    118              *** WakeUp pin configuration ***
    119              ================================
    120              [..]
    121                (+) WakeUp pin is used to wakeup the system from Standby mode. This pin is
    122                    forced in input pull down configuration and is active on rising edges.
    123                (+) There are up to three WakeUp pins:
    124                    (++)WakeUp Pin 1 on PA.00.
    125                    (++)WakeUp Pin 2 on PC.13 (STM32F303xC, STM32F303xE only).
    126                    (++)WakeUp Pin 3 on PE.06.
    127          
    128              *** Main and Backup Regulators configuration ***
    129              ================================================
    130              [..]
    131                (+) When the backup domain is supplied by VDD (analog switch connected to VDD)
    132                    the backup SRAM is powered from VDD which replaces the VBAT power supply to
    133                    save battery life.
    134          
    135                (+) The backup SRAM is not mass erased by a tamper event. It is read
    136                    protected to prevent confidential data, such as cryptographic private
    137                    key, from being accessed. The backup SRAM can be erased only through
    138                    the Flash interface when a protection level change from level 1 to
    139                    level 0 is requested.
    140                -@- Refer to the description of Read protection (RDP) in the Flash
    141                    programming manual.
    142          
    143                  Refer to the datasheets for more details.
    144          
    145              *** Low Power modes configuration ***
    146              =====================================
    147              [..]
    148                The devices feature 3 low-power modes:
    149                (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
    150                (+) Stop mode: all clocks are stopped, regulator running, regulator
    151                    in low power mode
    152                (+) Standby mode: 1.2V domain powered off (mode not available on STM32F3x8 devices).
    153          
    154             *** Sleep mode ***
    155             ==================
    156              [..]
    157                (+) Entry:
    158                    The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFx)
    159                        functions with
    160                    (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
    161                    (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
    162               
    163                (+) Exit:
    164                  (++) Any peripheral interrupt acknowledged by the nested vectored interrupt
    165                        controller (NVIC) can wake up the device from Sleep mode.
    166          
    167             *** Stop mode ***
    168             =================
    169              [..]
    170                In Stop mode, all clocks in the 1.8V domain are stopped, the PLL, the HSI,
    171                and the HSE RC oscillators are disabled. Internal SRAM and register contents
    172                are preserved.
    173                The voltage regulator can be configured either in normal or low-power mode to minimize the consumption.
    174          
    175                (+) Entry:
    176                    The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFI )
    177                       function with:
    178                    (++) Main regulator ON or
    179                    (++) Low Power regulator ON.
    180                    (++) PWR_STOPENTRY_WFI: enter STOP mode with WFI instruction or
    181                    (++) PWR_STOPENTRY_WFE: enter STOP mode with WFE instruction
    182                (+) Exit:
    183                    (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
    184                    (++) Some specific communication peripherals (CEC, USART, I2C) interrupts, 
    185                         when programmed in wakeup mode (the peripheral must be 
    186                         programmed in wakeup mode and the corresponding interrupt vector 
    187                         must be enabled in the NVIC).
    188          
    189             *** Standby mode ***
    190             ====================
    191               [..]
    192                The Standby mode allows to achieve the lowest power consumption. It is based
    193                on the Cortex-M4 deep sleep mode, with the voltage regulator disabled.
    194                The 1.8V domain is consequently powered off. The PLL, the HSI oscillator and
    195                the HSE oscillator are also switched off. SRAM and register contents are lost
    196                except for the RTC registers, RTC backup registers, backup SRAM and Standby
    197                circuitry.
    198                The voltage regulator is OFF.
    199          
    200                (+) Entry:
    201                    (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
    202                (+) Exit:
    203                    (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
    204                         tamper event, time-stamp event, external reset in NRST pin, IWDG reset.
    205          
    206             *** Auto-wakeup (AWU) from low-power mode ***
    207             =============================================
    208              [..]
    209                The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC
    210                Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
    211                without depending on an external interrupt (Auto-wakeup mode).
    212          
    213              (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
    214          
    215                (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to
    216                      configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.
    217          
    218                (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it
    219                     is necessary to configure the RTC to detect the tamper or time stamp event using the
    220                     HAL_RTC_SetTimeStamp_IT() or HAL_RTC_SetTamper_IT() functions.
    221          
    222                (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to
    223                     configure the RTC to generate the RTC WakeUp event using the HAL_RTC_SetWakeUpTimer_IT() function.
    224          
    225              (+) Comparator auto-wakeup (AWU) from the Stop mode
    226          
    227                (++) To wake up from the Stop mode with a comparator wakeup event, it is necessary to:
    228                     (+++) Configure the EXTI Line associated with the comparator (example EXTI Line 22 for comparator 2U) 
    229                           to be sensitive to to the selected edges (falling, rising or falling 
    230                           and rising) (Interrupt or Event modes) using the EXTI_Init() function.
    231                     (+++) Configure the comparator to generate the event.      
    232          @endverbatim
    233            * @{
    234            */
    235          
    236          /**
    237            * @brief Enables the WakeUp PINx functionality.
    238            * @param WakeUpPinx Specifies the Power Wake-Up pin to enable.
    239            *         This parameter can be value of :
    240            *           @ref PWR_WakeUp_Pins
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
    244          {
    245            /* Check the parameters */
    246            assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
    247            /* Enable the EWUPx pin */
    248            SET_BIT(PWR->CSR, WakeUpPinx);
   \                     HAL_PWR_EnableWakeUpPin: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable11_2  ;; 0x40007004
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4310             ORRS     R0,R0,R2
   \        0x6   0x6008             STR      R0,[R1, #+0]
    249          }
   \        0x8   0x4770             BX       LR               ;; return
    250          
    251          /**
    252            * @brief Disables the WakeUp PINx functionality.
    253            * @param WakeUpPinx Specifies the Power Wake-Up pin to disable.
    254            *         This parameter can be values of :
    255            *           @ref PWR_WakeUp_Pins
    256            * @retval None
    257            */

   \                                 In section .text, align 2, keep-with-next
    258          void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
    259          {
    260            /* Check the parameters */
    261            assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
    262            /* Disable the EWUPx pin */
    263            CLEAR_BIT(PWR->CSR, WakeUpPinx);
   \                     HAL_PWR_DisableWakeUpPin: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable11_2  ;; 0x40007004
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xEA22 0x0000      BIC      R0,R2,R0
   \        0x8   0x6008             STR      R0,[R1, #+0]
    264          }
   \        0xA   0x4770             BX       LR               ;; return
    265          
    266          /**
    267            * @brief Enters Sleep mode.
    268            * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
    269            * @param Regulator Specifies the regulator state in SLEEP mode.
    270            *          This parameter can be one of the following values:
    271            *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
    272            *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
    273            * @note This parameter has no effect in F3 family and is just maintained to 
    274            *       offer full portability of other STM32 families softwares.
    275            * @param SLEEPEntry Specifies if SLEEP mode is entered with WFI or WFE instruction.
    276            *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
    277            *           the interrupt wake up source.
    278            *           This parameter can be one of the following values:
    279            *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
    280            *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
    281            * @retval None
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
    284          {
    285            /* Check the parameters */
    286            assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
    287          
    288            /* Clear SLEEPDEEP bit of Cortex System Control Register */
    289            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
   \                     HAL_PWR_EnterSLEEPMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0xF022 0x0204      BIC      R2,R2,#0x4
    290          
    291            /* Select SLEEP mode entry -------------------------------------------------*/
    292            if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0x6002             STR      R2,[R0, #+0]
   \        0xC   0xD101             BNE.N    ??HAL_PWR_EnterSLEEPMode_0
    293            {
    294              /* Request Wait For Interrupt */
    295              __WFI();
   \        0xE   0xBF30             WFI
   \       0x10   0x4770             BX       LR
    296            }
    297            else
    298            {
    299              /* Request Wait For Event */
    300              __SEV();
   \                     ??HAL_PWR_EnterSLEEPMode_0: (+1)
   \       0x12   0xBF40             SEV
    301              __WFE();
   \       0x14   0xBF20             WFE
    302              __WFE();
   \       0x16   0xBF20             WFE
    303            }
    304          }
   \       0x18   0x4770             BX       LR               ;; return
    305          
    306          /**
    307            * @brief Enters STOP mode.
    308            * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
    309            * @note  When exiting Stop mode by issuing an interrupt or a wakeup event,
    310            *         the HSI RC oscillator is selected as system clock.
    311            * @note  When the voltage regulator operates in low power mode, an additional
    312            *         startup delay is incurred when waking up from Stop mode.
    313            *         By keeping the internal regulator ON during Stop mode, the consumption
    314            *         is higher although the startup time is reduced.
    315            * @param Regulator Specifies the regulator state in STOP mode.
    316            *          This parameter can be one of the following values:
    317            *            @arg PWR_MAINREGULATOR_ON: STOP mode with regulator ON
    318            *            @arg PWR_LOWPOWERREGULATOR_ON: STOP mode with low power regulator ON
    319            * @param STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.
    320            *          This parameter can be one of the following values:
    321            *            @arg PWR_STOPENTRY_WFI:Enter STOP mode with WFI instruction
    322            *            @arg PWR_STOPENTRY_WFE: Enter STOP mode with WFE instruction
    323            * @retval None
    324            */

   \                                 In section .text, align 2, keep-with-next
    325          void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
    326          {
    327            uint32_t tmpreg = 0U;
    328          
    329            /* Check the parameters */
    330            assert_param(IS_PWR_REGULATOR(Regulator));
    331            assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    332          
    333            /* Select the regulator state in STOP mode ---------------------------------*/
    334            tmpreg = PWR->CR;
   \                     HAL_PWR_EnterSTOPMode: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6813             LDR      R3,[R2, #+0]
    335            
    336            /* Clear PDDS and LPDS bits */
    337            tmpreg &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS);
    338          
    339            /* Set LPDS bit according to Regulator value */
    340            tmpreg |= Regulator;
    341          
    342            /* Store the new value */
    343            PWR->CR = tmpreg;
   \        0x4   0x089B             LSRS     R3,R3,#+2
   \        0x6   0xEA40 0x0083      ORR      R0,R0,R3, LSL #+2
   \        0xA   0x6010             STR      R0,[R2, #+0]
    344          
    345            /* Set SLEEPDEEP bit of Cortex System Control Register */
    346            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    347          
    348            /* Select STOP mode entry --------------------------------------------------*/
    349            if(STOPEntry == PWR_STOPENTRY_WFI)
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \       0x10   0x6802             LDR      R2,[R0, #+0]
   \       0x12   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x16   0x6002             STR      R2,[R0, #+0]
   \       0x18   0xBF0F             ITEEE    EQ
   \       0x1A   0xBF30             WFIEQ
   \       0x1C   0xBF40             SEVNE
   \       0x1E   0xBF20             WFENE
   \       0x20   0xBF20             WFENE
    350            {
    351              /* Request Wait For Interrupt */
    352              __WFI();
    353            }
    354            else
    355            {
    356              /* Request Wait For Event */
    357              __SEV();
    358              __WFE();
    359              __WFE();
    360            }
    361          
    362            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    363            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0xF021 0x0104      BIC      R1,R1,#0x4
   \       0x28   0x6001             STR      R1,[R0, #+0]
    364          }
   \       0x2A   0x4770             BX       LR               ;; return
    365          
    366          /**
    367            * @brief Enters STANDBY mode.
    368            * @note  In Standby mode, all I/O pins are high impedance except for:
    369            *          - Reset pad (still available), 
    370            *          - RTC alternate function pins if configured for tamper, time-stamp, RTC
    371            *            Alarm out, or RTC clock calibration out, 
    372            *          - WKUP pins if enabled.
    373            * @retval None
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          void HAL_PWR_EnterSTANDBYMode(void)
    376          {
    377            /* Select STANDBY mode */
    378            PWR->CR |= PWR_CR_PDDS;
   \                     HAL_PWR_EnterSTANDBYMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_1  ;; 0x40007000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    379          
    380            /* Set SLEEPDEEP bit of Cortex System Control Register */
    381            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \        0xA   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x12   0x6002             STR      R2,[R0, #+0]
    382          
    383            /* This option is used to ensure that store operations are completed */
    384          #if defined ( __CC_ARM)
    385            __force_stores();
    386          #endif
    387            /* Request Wait For Interrupt */
    388            __WFI();
   \       0x14   0xBF30             WFI
    389          }
   \       0x16   0x4770             BX       LR               ;; return
    390          
    391          /**
    392            * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
    393            * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
    394            *       re-enters SLEEP mode when an interruption handling is over.
    395            *       Setting this bit is useful when the processor is expected to run only on
    396            *       interruptions handling.         
    397            * @retval None
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          void HAL_PWR_EnableSleepOnExit(void)
    400          {
    401            /* Set SLEEPONEXIT bit of Cortex System Control Register */
    402            SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
   \                     HAL_PWR_EnableSleepOnExit: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    403          }
   \        0xA   0x4770             BX       LR               ;; return
    404          
    405          
    406          /**
    407            * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
    408            * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
    409            *       re-enters SLEEP mode when an interruption handling is over.          
    410            * @retval None
    411            */

   \                                 In section .text, align 2, keep-with-next
    412          void HAL_PWR_DisableSleepOnExit(void)
    413          {
    414            /* Clear SLEEPONEXIT bit of Cortex System Control Register */
    415            CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
   \                     HAL_PWR_DisableSleepOnExit: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF021 0x0102      BIC      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    416          }
   \        0xA   0x4770             BX       LR               ;; return
    417          
    418          
    419          
    420          /**
    421            * @brief Enables CORTEX M4 SEVONPEND bit. 
    422            * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
    423            *       WFE to wake up when an interrupt moves from inactive to pended.
    424            * @retval None
    425            */

   \                                 In section .text, align 2, keep-with-next
    426          void HAL_PWR_EnableSEVOnPend(void)
    427          {
    428            /* Set SEVONPEND bit of Cortex System Control Register */
    429            SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
   \                     HAL_PWR_EnableSEVOnPend: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0110      ORR      R1,R1,#0x10
   \        0x8   0x6001             STR      R1,[R0, #+0]
    430          }
   \        0xA   0x4770             BX       LR               ;; return
    431          
    432          
    433          /**
    434            * @brief Disables CORTEX M4 SEVONPEND bit. 
    435            * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
    436            *       WFE to wake up when an interrupt moves from inactive to pended.         
    437            * @retval None
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          void HAL_PWR_DisableSEVOnPend(void)
    440          {
    441            /* Clear SEVONPEND bit of Cortex System Control Register */
    442            CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
   \                     HAL_PWR_DisableSEVOnPend: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_3  ;; 0xe000ed10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF021 0x0110      BIC      R1,R1,#0x10
   \        0x8   0x6001             STR      R1,[R0, #+0]
    443          }
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x4002'1010        DC32     0x40021010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x4000'7000        DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x4000'7004        DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xE000'ED10        DC32     0xe000ed10
    444          /**
    445            * @}
    446            */
    447          
    448          /**
    449            * @}
    450            */
    451          
    452          #endif /* HAL_PWR_MODULE_ENABLED */
    453          /**
    454            * @}
    455            */
    456          
    457          /**
    458            * @}
    459            */
    460          
    461          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_PWR_DeInit
       0   HAL_PWR_DisableBkUpAccess
       0   HAL_PWR_DisableSEVOnPend
       0   HAL_PWR_DisableSleepOnExit
       0   HAL_PWR_DisableWakeUpPin
       0   HAL_PWR_EnableBkUpAccess
       0   HAL_PWR_EnableSEVOnPend
       0   HAL_PWR_EnableSleepOnExit
       0   HAL_PWR_EnableWakeUpPin
       0   HAL_PWR_EnterSLEEPMode
       0   HAL_PWR_EnterSTANDBYMode
       0   HAL_PWR_EnterSTOPMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
      20  HAL_PWR_DeInit
      12  HAL_PWR_DisableBkUpAccess
      12  HAL_PWR_DisableSEVOnPend
      12  HAL_PWR_DisableSleepOnExit
      12  HAL_PWR_DisableWakeUpPin
      12  HAL_PWR_EnableBkUpAccess
      12  HAL_PWR_EnableSEVOnPend
      12  HAL_PWR_EnableSleepOnExit
      10  HAL_PWR_EnableWakeUpPin
      26  HAL_PWR_EnterSLEEPMode
      24  HAL_PWR_EnterSTANDBYMode
      44  HAL_PWR_EnterSTOPMode

 
 224 bytes in section .text
 
 224 bytes of CODE memory

Errors: none
Warnings: none
