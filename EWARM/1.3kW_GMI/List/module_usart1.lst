###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:52
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\module_usart1.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW576.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\module_usart1.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\module_usart1.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\module_usart1.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\module_usart1.c
      1          /**
      2          ********************************************************************************************************************************
      3          * @file    module_usart1.c 
      4          * @author  Pamela Lee
      5          * @brief   Main driver module for USART1 Communication.
      6          * @details This module initializes the USART1 port and attaches the pre-selected fixed memory allocation to the module.
      7          To Transmitt data in the RUN_MODULE case: put data into seqMemTX_u32, and call this function:
      8          *             USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
      9          ********************************************************************************************************************************
     10          */
     11          
     12          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     13          #include "module_usart1.h"
     14          
     15          #include "driver_usart1.h"

   \                                 In section .bss, align 4
   \   static __absolute Ring_Buf * usart1InternalSeqMem_u32
   \                     usart1InternalSeqMem_u32:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
   \       0x14                      DS8 4
   \       0x18                      DS8 4
     16          
     17          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     18          /* Uarts handle declaration */
     19          extern void Delay(__IO uint32_t nTime);
     20          
     21          extern Ram_Buf sharedMemArray[STRUCT_MEM_ARRAY_SIZE];
     22          extern ProcessInfo processInfoTable[];
     23          extern Ram_Buf *usart1StructMem_u32;
     24          
     25          //usart1_Control* usart1_Module_Control;

   \                                 In section .bss, align 4
     26          unsigned char* RxCMD ;
   \                     RxCMD:
   \        0x0                      DS8 4
     27          extern uint8_t usart1CaptureLen;
     28          extern uint8_t UniProtocolState;
     29          extern __IO uint8_t indexTx;
     30          
     31          extern Usart1_Control *usart1Control;
     32          
     33          enum {
     34            INIT_MODULE,
     35            RUN_MODULE,
     36            // additional states to be added here as necessary.
     37            IRQ_MODULE = DEFAULT_IRQ_STATE,
     38            KILL_MODULE = KILL_APP
     39          };
     40          
     41          

   \                                 In section .text, align 2, keep-with-next
     42          void assign_UART2_ModuleMem(){  
   \                     assign_UART2_ModuleMem: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
     43            usart1InternalSeqMem_u32 = SeqMem_CreateInstance(MODULE_USART1, TX_RX_BUF_SIZE, 
     44                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for this driver need to be bigger than 1 complete frame 
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x2202             MOVS     R2,#+2
   \        0xA   0x2146             MOVS     R1,#+70
   \        0xC   0x....             LDR.N    R4,??DataTable1
   \        0xE   0x....'....        BL       SeqMem_CreateInstance
     45            usart1SeqMemRXG1_2_u32 = SeqMem_CreateInstance(MODULE_USART1, TX_RX_BUF_SIZE, 
     46                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6020             STR      R0,[R4, #+0]
   \       0x16   0x9100             STR      R1,[SP, #+0]
   \       0x18   0x2300             MOVS     R3,#+0
   \       0x1A   0x2202             MOVS     R2,#+2
   \       0x1C   0x2146             MOVS     R1,#+70
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x....'....        BL       SeqMem_CreateInstance
   \       0x24   0x6060             STR      R0,[R4, #+4]
     47            usart1SeqMemRXG3_u32 = SeqMem_CreateInstance(MODULE_USART1, TX_RX_BUF_SIZE, 
     48                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
   \       0x26   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x2A   0x2146             MOVS     R1,#+70
   \       0x2C   0x....'....        BL       SeqMem_CreateInstance
   \       0x30   0x60A0             STR      R0,[R4, #+8]
     49            usart1SeqMemRXG4L_u32 = SeqMem_CreateInstance(MODULE_USART1, TX_RX_BUF_SIZE +80, 
     50                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
   \       0x32   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x36   0x60E0             STR      R0,[R4, #+12]
     51            usart1SeqMemRXG4H_u32 = SeqMem_CreateInstance(MODULE_USART1, TX_RX_BUF_SIZE +80, 
     52                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
   \       0x38   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x3C   0x6120             STR      R0,[R4, #+16]
     53            usart1SeqMemTX_u32 = SeqMem_CreateInstance(MODULE_USART1, TX_RX_BUF_SIZE +7 , 
     54                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for Tx data 
   \       0x3E   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x42   0x214D             MOVS     R1,#+77
   \       0x44   0x....'....        BL       SeqMem_CreateInstance
   \       0x48   0x6160             STR      R0,[R4, #+20]
     55            usart1StructMem_u32 =  StructMem_CreateInstance(MODULE_USART1, sizeof(Usart1_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory for this driver [should map it back to this driver local struct]
   \       0x4A   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x4E   0x2120             MOVS     R1,#+32
   \       0x50   0x....'....        BL       StructMem_CreateInstance
     56            
     57            usart1Control = (Usart1_Control*)(*usart1StructMem_u32).p_ramBuf_u8;
     58            
     59            /** assign all the new generated sequential-memory of USART1 to the structured-memory **/
     60            usart1Control->seqMemTX_u32 = usart1SeqMemTX_u32;
     61            usart1Control->seqMemTX_u32->is_OverwrittingAllowed_u8 = FALSE;
   \       0x54   0x....             LDR.N    R2,??DataTable1_1
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x6011             STR      R1,[R2, #+0]
   \       0x5A   0x6963             LDR      R3,[R4, #+20]
   \       0x5C   0x610B             STR      R3,[R1, #+16]
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x7519             STRB     R1,[R3, #+20]
     62            usart1Control->seqMemRXG1_2_u32 = usart1SeqMemRXG1_2_u32;
   \       0x62   0x6811             LDR      R1,[R2, #+0]
   \       0x64   0x6862             LDR      R2,[R4, #+4]
   \       0x66   0x600A             STR      R2,[R1, #+0]
     63            usart1Control->seqMemRXG3_u32 = usart1SeqMemRXG3_u32;
   \       0x68   0x68A3             LDR      R3,[R4, #+8]
   \       0x6A   0x604B             STR      R3,[R1, #+4]
     64            usart1Control->seqMemRXG4L_u32 = usart1SeqMemRXG4L_u32;
   \       0x6C   0x68E2             LDR      R2,[R4, #+12]
   \       0x6E   0x608A             STR      R2,[R1, #+8]
     65            usart1Control->seqMemRXG4H_u32 = usart1SeqMemRXG4H_u32;
   \       0x70   0x6923             LDR      R3,[R4, #+16]
   \       0x72   0x60CB             STR      R3,[R1, #+12]
     66            usart1Control->seqMem_InternalPipe_u32 = usart1InternalSeqMem_u32;
     67            usart1Control->errorCode_u8 = 0;
   \       0x74   0x2300             MOVS     R3,#+0
   \       0x76   0x6822             LDR      R2,[R4, #+0]
   \       0x78   0x614A             STR      R2,[R1, #+20]
   \       0x7A   0x770B             STRB     R3,[R1, #+28]
     68          }
   \       0x7C   0x61A0             STR      R0,[R4, #+24]
   \       0x7E   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x2202             MOVS     R2,#+2
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x2202             MOVS     R2,#+2
   \        0x8   0x2196             MOVS     R1,#+150
   \        0xA   0x....'....        B.W      SeqMem_CreateInstance
     69          

   \                                 In section .text, align 2, keep-with-next
     70          uint8_t moduleUsart1_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     moduleUsart1_u32: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
     71            uint8_t return_state_u8 = INIT_MODULE;
     72            switch (next_state_u8) {
   \        0x6   0x....             LDR.N    R5,??DataTable1_2
   \        0x8   0x....             LDR.N    R6,??DataTable1_1
   \        0xA   0x....'....        LDR.W    R8,??DataTable1_3
   \        0xE   0xF04F 0x0B16      MOV      R11,#+22
   \       0x12   0x24FF             MOVS     R4,#+255
   \       0x14   0xB122             CBZ.N    R2,??moduleUsart1_u32_0
   \       0x16   0x2A01             CMP      R2,#+1
   \       0x18   0xD02C             BEQ.N    ??moduleUsart1_u32_1
   \       0x1A   0x2AFF             CMP      R2,#+255
   \       0x1C   0xD044             BEQ.N    ??moduleUsart1_u32_2
   \       0x1E   0xE04C             B.N      ??moduleUsart1_u32_3
     73            case INIT_MODULE: {
     74              // Initialize UART
     75              
     76              usart1_Init();
   \                     ??moduleUsart1_u32_0: (+1)
   \       0x20   0x....'....        BL       usart1_Init
     77              assign_UART2_ModuleMem();
   \       0x24   0x....'....        BL       assign_UART2_ModuleMem
     78              
     79              // Find the structured memory for the UART2 driver module, by searching for the UART2 onwer id.
     80              Ram_Buf_Handle this_ram_buf_u32;
     81              for (uint8_t struct_mem_index_u8 = 0; struct_mem_index_u8 < TOTAL_NUM_OF_STRUCT_MEM_INSTANCES;
   \       0x28   0x2700             MOVS     R7,#+0
   \       0x2A   0x....             LDR.N    R4,??DataTable1
     82              struct_mem_index_u8++) {
     83                this_ram_buf_u32 = &sharedMemArray[struct_mem_index_u8];
     84                if (RamBuf_GetOwner(this_ram_buf_u32) == drv_id_u8) {
   \                     ??moduleUsart1_u32_4: (+1)
   \       0x2C   0x2114             MOVS     R1,#+20
   \       0x2E   0x....             LDR.N    R0,??DataTable1_4
   \       0x30   0x4379             MULS     R1,R1,R7
   \       0x32   0xEB00 0x0A01      ADD      R10,R0,R1
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0x....'....        BL       RamBuf_GetOwner
   \       0x3C   0x4548             CMP      R0,R9
   \       0x3E   0xBF08             IT       EQ
   \       0x40   0xF8C4 0xA018      STREQ    R10,[R4, #+24]
     85                  usart1StructMem_u32 = &sharedMemArray[struct_mem_index_u8];
     86                }
     87              }
   \       0x44   0x1C7F             ADDS     R7,R7,#+1
   \       0x46   0x2F09             CMP      R7,#+9
   \       0x48   0xDDF0             BLE.N    ??moduleUsart1_u32_4
     88              
     89              // Attach the structured memory to the process's master shared memory.
     90              uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \       0x4A   0x4648             MOV      R0,R9
   \       0x4C   0x....'....        BL       getProcessInfoIndex
     91              if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0x50   0xFB1B 0xFB00      SMULBB   R11,R11,R0
   \       0x54   0x28FF             CMP      R0,#+255
   \       0x56   0xEB08 0x010B      ADD      R1,R8,R11
   \       0x5A   0xD004             BEQ.N    ??moduleUsart1_u32_5
     92                processInfoTable[table_index_u8].Sched_DrvData.irqState_u8 = DEFAULT_IRQ_STATE;
   \       0x5C   0x20C8             MOVS     R0,#+200
   \       0x5E   0x7248             STRB     R0,[R1, #+9]
     93                processInfoTable[table_index_u8].Sched_DrvData.p_masterSharedMem_u32 =
     94                  usart1StructMem_u32;
   \       0x60   0x69A0             LDR      R0,[R4, #+24]
   \       0x62   0xF8C1 0x000B      STR      R0,[R1, #+11]
     95              }
     96              
     97              //Get structured memory for ADC1 data
     98              usart1Control = (Usart1_Control*)((*(processInfoTable[table_index_u8].Sched_DrvData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \                     ??moduleUsart1_u32_5: (+1)
   \       0x66   0xF8D1 0x000B      LDR      R0,[R1, #+11]
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0x6030             STR      R0,[R6, #+0]
     99              usart1CaptureLen = UniHeaderlen;                                 //pam bug without this
   \       0x6E   0x2107             MOVS     R1,#+7
   \       0x70   0x7029             STRB     R1,[R5, #+0]
    100              return_state_u8 = RUN_MODULE;
   \       0x72   0xE017             B.N      ??moduleUsart1_u32_6
    101              break;
    102            }
    103            case RUN_MODULE: {
    104              // test Uart2 transmits data
    105              // if (USART_GetITStatus(USART1, USART_IT_TXE) == RESET) {
    106              //     (*(*usart1Control).seqMemTX_u32).Write(Txbuf, &Len);
    107              //     USART_ITConfig(USART1, USART_IT_TXE, ENABLE); //  Enable when something to send
    108              // }
    109              
    110           
    111              //(*usart1Control).seqMem_InternalPipe_u32->systemInstanceIndex_u8)
    112              //if(RingBuf_GetUsedNumOfElements((Ring_Buf_Handle)((*(*usart1Control).seqMem_InternalPipe_u32).p_ringBuf_u8)) >= usart1CaptureLen )
    113              if(RingBuf_GetUsedNumOfElements((*usart1Control).seqMem_InternalPipe_u32) >= usart1CaptureLen )
   \                     ??moduleUsart1_u32_1: (+1)
   \       0x74   0x6830             LDR      R0,[R6, #+0]
   \       0x76   0x6940             LDR      R0,[R0, #+20]
   \       0x78   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x7C   0x7829             LDRB     R1,[R5, #+0]
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xBF28             IT       CS
    114              {
    115                protocolHeaderfetch();
   \       0x82   0x....'....        BLCS     protocolHeaderfetch
    116              }
    117              uint8_t TxLen = UniHeaderlen;
    118              //if((RingBuf_GetUsedNumOfElements((Ring_Buf_Handle)((*(*usart1Control).seqMemTX_u32).p_ringBuf_u8)) >= TxLen) && !indexTx)
    119              if(((RingBuf_GetUsedNumOfElements((*usart1Control).seqMemTX_u32) >= TxLen) && !indexTx) && (LL_USART_IsActiveFlag_TXE(USART1)))
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0x6900             LDR      R0,[R0, #+16]
   \       0x8A   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x8E   0x2807             CMP      R0,#+7
   \       0x90   0xDB08             BLT.N    ??moduleUsart1_u32_6
   \       0x92   0x....             LDR.N    R1,??DataTable1_5
   \       0x94   0x7808             LDRB     R0,[R1, #+0]
   \       0x96   0xB928             CBNZ.N   R0,??moduleUsart1_u32_6
   \       0x98   0x....             LDR.N    R1,??DataTable1_6  ;; 0x4001381c
   \       0x9A   0x6808             LDR      R0,[R1, #+0]
   \       0x9C   0x0600             LSLS     R0,R0,#+24
   \       0x9E   0xBF48             IT       MI
    120              {
    121                TxProcess();
   \       0xA0   0x....'....        BLMI     TxProcess
    122              }  
    123              return_state_u8 = RUN_MODULE;
   \                     ??moduleUsart1_u32_6: (+1)
   \       0xA4   0x2401             MOVS     R4,#+1
    124              break;
   \       0xA6   0xE008             B.N      ??moduleUsart1_u32_3
    125            }
    126            case KILL_MODULE: {
    127              // The USART1 driver module must only be executed once.
    128              // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    129              uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??moduleUsart1_u32_2: (+1)
   \       0xA8   0x....'....        BL       getProcessInfoIndex
    130              if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0xAC   0x28FF             CMP      R0,#+255
   \       0xAE   0xD004             BEQ.N    ??moduleUsart1_u32_3
    131                processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \       0xB0   0xFB1B 0xFB00      SMULBB   R11,R11,R0
   \       0xB4   0xEB08 0x000B      ADD      R0,R8,R11
   \       0xB8   0x7284             STRB     R4,[R0, #+10]
    132              }
    133              return_state_u8 = KILL_MODULE;
    134              break;
    135            }
    136            default: {
    137              return_state_u8 = KILL_MODULE;
    138              break;
    139            }
    140            }
    141            return return_state_u8;
   \                     ??moduleUsart1_u32_3: (+1)
   \       0xBA   0x4620             MOV      R0,R4
   \       0xBC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    142          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     usart1InternalSeqMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     usart1Control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     usart1CaptureLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     sharedMemArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     indexTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x4001'381C        DC32     0x4001381c

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   assign_UART2_ModuleMem
        16   -> SeqMem_CreateInstance
        16   -> StructMem_CreateInstance
      40   moduleUsart1_u32
        40   -> RamBuf_GetOwner
        40   -> RingBuf_GetUsedNumOfElements
        40   -> TxProcess
        40   -> assign_UART2_ModuleMem
        40   -> getProcessInfoIndex
        40   -> protocolHeaderfetch
        40   -> usart1_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
      14  ?Subroutine0
      10  ?Subroutine1
       4  RxCMD
     128  assign_UART2_ModuleMem
     192  moduleUsart1_u32
      28  usart1InternalSeqMem_u32
          usart1SeqMemRXG1_2_u32
          usart1SeqMemRXG3_u32
          usart1SeqMemRXG4L_u32
          usart1SeqMemRXG4H_u32
          usart1SeqMemTX_u32
          usart1StructMem_u32

 
  32 bytes in section .bss
 372 bytes in section .text
 
 372 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
