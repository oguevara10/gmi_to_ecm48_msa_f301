###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:44
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\revup_ctrl.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW766F.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\revup_ctrl.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\revup_ctrl.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\revup_ctrl.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\revup_ctrl.c
      1          /**
      2            ******************************************************************************
      3            * @file    revup_ctrl.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Rev-Up Control component of the Motor Control SDK:
      7            *
      8            *          * Main Rev-Up procedure to execute programmed phases
      9            *          * On the Fly (OTF)
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics International N.V.
     15            * All rights reserved.</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without
     18            * modification, are permitted, provided that the following conditions are met:
     19            *
     20            * 1. Redistribution of source code must retain the above copyright notice,
     21            *    this list of conditions and the following disclaimer.
     22            * 2. Redistributions in binary form must reproduce the above copyright notice,
     23            *    this list of conditions and the following disclaimer in the documentation
     24            *    and/or other materials provided with the distribution.
     25            * 3. Neither the name of STMicroelectronics nor the names of other
     26            *    contributors to this software may be used to endorse or promote products
     27            *    derived from this software without specific written permission.
     28            * 4. This software, including modifications and/or derivative works of this
     29            *    software, must execute solely and exclusively on microcontroller or
     30            *    microprocessor devices manufactured by or for STMicroelectronics.
     31            * 5. Redistribution and use of this software other than as permitted under
     32            *    this license is void and will automatically terminate your rights under
     33            *    this license.
     34            *
     35            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
     36            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
     37            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
     38            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     39            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
     40            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     41            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     42            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     43            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     44            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     45            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     46            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     47            *
     48            ******************************************************************************
     49            */
     50          
     51          /* Includes ------------------------------------------------------------------*/
     52          #include "revup_ctrl.h"
     53          
     54          /** @addtogroup MCSDK
     55            * @{
     56            */
     57          
     58          /** @defgroup RevUpCtrl Rev-Up Control
     59            * @brief Rev-Up Control component of the Motor Control SDK
     60            *
     61            * Used to start up the motor with a set of pre-programmed phases.
     62            *
     63            * The number of phases of the Rev up procdure can range from 0 to 5.
     64            * The Rev-Up controller must be called at speed loop frequency.
     65            *
     66            * @{
     67            */
     68          
     69          /* Private defines -----------------------------------------------------------*/
     70          
     71          /**
     72            * @brief Timeout used to reset integral term of PLL.
     73            *  It is expressed in ms.
     74            *
     75            */
     76          #define RUC_OTF_PLL_RESET_TIMEOUT 100u
     77          
     78          
     79          /**
     80            * @brief  Initialize and configure the RevUpCtrl Component
     81            * @param  pHandle: Pointer on Handle structure of RevUp controller.
     82            * @param  pSTC: Pointer on speed and torque controller structure.
     83            * @param  pVSS: Pointer on virtual speed sensor structure.
     84            * @param  pSNSL: Pointer on sensorles state observer structure.
     85            * @param  pPWM: Pointer on the PWM structure.
     86            *  @retval none
     87            */

   \                                 In section .text, align 2
     88          __weak void RUC_Init( RevUpCtrl_Handle_t * pHandle,
     89                         SpeednTorqCtrl_Handle_t * pSTC,
     90                         VirtualSpeedSensor_Handle_t * pVSS,
     91                         STO_Handle_t * pSNSL,
     92                         PWMC_Handle_t * pPWM )
     93          {
   \                     RUC_Init: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x9F05             LDR      R7,[SP, #+20]
   \        0x4   0x4604             MOV      R4,R0
     94            RevUpCtrl_PhaseParams_t * pRUCPhaseParams = &pHandle->ParamsData[0];
     95            uint8_t bPhase = 0u;
     96          
     97            pHandle->pSTC = pSTC;
   \        0x6   0xF104 0x0548      ADD      R5,R4,#+72
   \        0xA   0x2600             MOVS     R6,#+0
     98            pHandle->pVSS = pVSS;
   \        0xC   0x626A             STR      R2,[R5, #+36]
   \        0xE   0xF104 0x000C      ADD      R0,R4,#+12
     99            pHandle->pSNSL = pSNSL;
    100            pHandle->pPWM = pPWM;
    101            pHandle->OTFSCLowside = false;
    102            pHandle->EnteredZone1 = false;
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x6229             STR      R1,[R5, #+32]
   \       0x16   0x62AB             STR      R3,[R5, #+40]
   \       0x18   0x62EF             STR      R7,[R5, #+44]
   \       0x1A   0x732E             STRB     R6,[R5, #+12]
   \       0x1C   0x736A             STRB     R2,[R5, #+13]
   \       0x1E   0xE001             B.N      ??RUC_Init_0
    103          
    104            while ( ( pRUCPhaseParams != MC_NULL ) && ( bPhase < RUC_MAX_PHASE_NUMBER ) )
    105            {
    106              pRUCPhaseParams = pRUCPhaseParams->pNext;
   \                     ??RUC_Init_1: (+1)
   \       0x20   0x6880             LDR      R0,[R0, #+8]
    107              bPhase++;
   \       0x22   0x1C76             ADDS     R6,R6,#+1
    108            }
   \                     ??RUC_Init_0: (+1)
   \       0x24   0xB110             CBZ.N    R0,??RUC_Init_2
   \       0x26   0xB2F1             UXTB     R1,R6
   \       0x28   0x2905             CMP      R1,#+5
   \       0x2A   0xD3F9             BCC.N    ??RUC_Init_1
    109            pHandle->ParamsData[bPhase - 1u].pNext = MC_NULL;
   \                     ??RUC_Init_2: (+1)
   \       0x2C   0xB2F2             UXTB     R2,R6
   \       0x2E   0x200C             MOVS     R0,#+12
   \       0x30   0x4342             MULS     R2,R0,R2
   \       0x32   0x18A0             ADDS     R0,R4,R2
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6081             STR      R1,[R0, #+8]
    110          
    111            pHandle->bPhaseNbr = bPhase;
   \       0x38   0x702E             STRB     R6,[R5, #+0]
    112          
    113            pHandle->bResetPLLTh = ( uint8_t )( ( RUC_OTF_PLL_RESET_TIMEOUT * pHandle->hRUCFrequencyHz ) / 1000u );
   \       0x3A   0x2164             MOVS     R1,#+100
   \       0x3C   0x8823             LDRH     R3,[R4, #+0]
   \       0x3E   0x434B             MULS     R3,R1,R3
   \       0x40   0xF44F 0x707A      MOV      R0,#+1000
   \       0x44   0xFBB3 0xF0F0      UDIV     R0,R3,R0
   \       0x48   0x73A8             STRB     R0,[R5, #+14]
    114          
    115          }
   \       0x4A   0xBDF0             POP      {R4-R7,PC}       ;; return
    116          
    117          /**
    118            * @brief  Initialize internal RevUp controller state.
    119            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    120            * @param  hMotorDirection: rotor rotation direction.
    121            *         This parameter must be -1 or +1.
    122            *  @retval none
    123            */

   \                                 In section .text, align 2
    124          __weak void RUC_Clear( RevUpCtrl_Handle_t * pHandle, int16_t hMotorDirection )
    125          {
   \                     RUC_Clear: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
    126            VirtualSpeedSensor_Handle_t * pVSS = pHandle->pVSS;
   \        0x6   0xF104 0x0068      ADD      R0,R4,#+104
   \        0xA   0x6846             LDR      R6,[R0, #+4]
    127            SpeednTorqCtrl_Handle_t * pSTC = pHandle->pSTC;
   \        0xC   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \       0x10   0x460D             MOV      R5,R1
    128            RevUpCtrl_PhaseParams_t * pPhaseParams = pHandle->ParamsData;
    129          
    130            pHandle->hDirection = hMotorDirection;
    131            pHandle->EnteredZone1 = false;
   \       0x12   0xF104 0x0753      ADD      R7,R4,#+83
   \       0x16   0x80E5             STRH     R5,[R4, #+6]
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x70B8             STRB     R0,[R7, #+2]
    132          
    133            /*Initializes the rev up stages counter.*/
    134            pHandle->bStageCnt = 0u;
   \       0x1C   0x7178             STRB     R0,[R7, #+5]
    135            pHandle->bOTFRelCounter = 0u;
   \       0x1E   0x7038             STRB     R0,[R7, #+0]
    136            pHandle->OTFSCLowside = false;
   \       0x20   0x7078             STRB     R0,[R7, #+1]
    137          
    138            /* Calls the clear method of VSS.*/
    139            VSS_Clear( pVSS );
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x....'....        BL       VSS_Clear
    140          
    141            /* Sets the STC in torque mode.*/
    142            STC_SetControlMode( pSTC, STC_TORQUE_MODE );
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x4640             MOV      R0,R8
   \       0x2C   0x....'....        BL       STC_SetControlMode
    143          
    144            /* Sets the mechanical starting angle of VSS.*/
    145            VSS_SetMecAngle( pVSS, pHandle->hStartingMecAngle * hMotorDirection );
   \       0x30   0x8860             LDRH     R0,[R4, #+2]
   \       0x32   0xFB10 0xF105      SMULBB   R1,R0,R5
   \       0x36   0xB209             SXTH     R1,R1
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x....'....        BL       VSS_SetMecAngle
    146          
    147            /* Sets to zero the starting torque of STC */
    148            STC_ExecRamp( pSTC, 0, 0u );
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x4640             MOV      R0,R8
   \       0x44   0x....'....        BL       STC_ExecRamp
    149          
    150            /* Gives the first command to STC and VSS.*/
    151            STC_ExecRamp( pSTC, pPhaseParams->hFinalTorque * hMotorDirection,
    152                          ( uint32_t )( pPhaseParams->hDurationms ) );
   \       0x48   0x8A20             LDRH     R0,[R4, #+16]
   \       0x4A   0x89A2             LDRH     R2,[R4, #+12]
   \       0x4C   0xFB10 0xF105      SMULBB   R1,R0,R5
   \       0x50   0xB209             SXTH     R1,R1
   \       0x52   0x4640             MOV      R0,R8
   \       0x54   0x....'....        BL       STC_ExecRamp
    153          
    154            VSS_SetMecAcceleration( pVSS, pPhaseParams->hFinalMecSpeedUnit * hMotorDirection,
    155                                    pPhaseParams->hDurationms );
   \       0x58   0x89E0             LDRH     R0,[R4, #+14]
   \       0x5A   0x89A2             LDRH     R2,[R4, #+12]
   \       0x5C   0xFB10 0xF105      SMULBB   R1,R0,R5
   \       0x60   0xB209             SXTH     R1,R1
   \       0x62   0x4630             MOV      R0,R6
   \       0x64   0x....'....        BL       VSS_SetMecAcceleration
    156          
    157            /* Compute hPhaseRemainingTicks.*/
    158            pHandle->hPhaseRemainingTicks =
    159              ( uint16_t )( ( ( uint32_t )pPhaseParams->hDurationms *
    160                              ( uint32_t )pHandle->hRUCFrequencyHz ) / 1000u );
    161          
    162            pHandle->hPhaseRemainingTicks++;
   \       0x68   0x89A1             LDRH     R1,[R4, #+12]
   \       0x6A   0x8820             LDRH     R0,[R4, #+0]
   \       0x6C   0x4341             MULS     R1,R0,R1
   \       0x6E   0xF44F 0x727A      MOV      R2,#+1000
   \       0x72   0xFBB1 0xF2F2      UDIV     R2,R1,R2
    163          
    164            /*Set the next phases parameter pointer.*/
    165            pHandle->pCurrentPhaseParams = pPhaseParams->pNext;
   \       0x76   0x6960             LDR      R0,[R4, #+20]
   \       0x78   0x60A0             STR      R0,[R4, #+8]
   \       0x7A   0x1C52             ADDS     R2,R2,#+1
   \       0x7C   0x80A2             STRH     R2,[R4, #+4]
    166          
    167            /*Timeout counter for PLL reset during OTF.*/
    168            pHandle->bResetPLLCnt = 0u;
   \       0x7E   0x2100             MOVS     R1,#+0
   \       0x80   0x7139             STRB     R1,[R7, #+4]
    169          }
   \       0x82   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    170          
    171          /**
    172            * @brief  Main revup controller procedure executing overall programmed phases and
    173            *         on-the-fly startup handling.
    174            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    175            *  @retval Boolean set to false when entire revup phases have been completed.
    176            */

   \                                 In section .text, align 2
    177          __weak bool RUC_OTF_Exec( RevUpCtrl_Handle_t * pHandle )
    178          {
   \                     RUC_OTF_Exec: (+1)
   \        0x0   0xE92D 0x46F8      PUSH     {R3-R7,R9,R10,LR}
   \        0x4   0x4604             MOV      R4,R0
    179            bool IsSpeedReliable;
    180            bool retVal = true;
   \        0x6   0x2601             MOVS     R6,#+1
    181            bool condition = false;
    182          
    183            if ( pHandle->hPhaseRemainingTicks > 0u )
   \        0x8   0x88A0             LDRH     R0,[R4, #+4]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xF104 0x0748      ADD      R7,R4,#+72
   \       0x10   0xF000 0x8085      BEQ.W    ??RUC_OTF_Exec_0
    184            {
    185              /* Decrease the hPhaseRemainingTicks.*/
    186              pHandle->hPhaseRemainingTicks--;
   \       0x14   0x1E41             SUBS     R1,R0,#+1
   \       0x16   0x80A1             STRH     R1,[R4, #+4]
    187          
    188              /* OTF start-up */
    189              if ( pHandle->bStageCnt == 0u )
   \       0x18   0x7C38             LDRB     R0,[R7, #+16]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD17C             BNE.N    ??RUC_OTF_Exec_1
    190              {
    191                if ( pHandle->EnteredZone1 == false )
   \       0x1E   0x7B79             LDRB     R1,[R7, #+13]
   \       0x20   0x6AB8             LDR      R0,[R7, #+40]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xF040 0x808D      BNE.W    ??RUC_OTF_Exec_2
    192                {
    193                  if ( pHandle->pSNSL->pFctStoOtfResetPLL != MC_NULL )
   \       0x28   0x68C1             LDR      R1,[R0, #+12]
   \       0x2A   0xB161             CBZ.N    R1,??RUC_OTF_Exec_3
    194                  {
    195                    pHandle->bResetPLLCnt++;
   \       0x2C   0x7BF9             LDRB     R1,[R7, #+15]
    196                    if ( pHandle->bResetPLLCnt > pHandle->bResetPLLTh )
   \       0x2E   0x7BBA             LDRB     R2,[R7, #+14]
   \       0x30   0x1C49             ADDS     R1,R1,#+1
   \       0x32   0xB2CB             UXTB     R3,R1
   \       0x34   0x429A             CMP      R2,R3
   \       0x36   0xD205             BCS.N    ??RUC_OTF_Exec_4
    197                    {
    198                      pHandle->pSNSL->pFctStoOtfResetPLL( pHandle->pSNSL );
   \       0x38   0x73F9             STRB     R1,[R7, #+15]
   \       0x3A   0x68C1             LDR      R1,[R0, #+12]
   \       0x3C   0x4788             BLX      R1
    199                      pHandle->bOTFRelCounter = 0u;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x72F8             STRB     R0,[R7, #+11]
    200                      pHandle->bResetPLLCnt = 0u;
   \       0x42   0x2100             MOVS     R1,#+0
   \                     ??RUC_OTF_Exec_4: (+1)
   \       0x44   0x73F9             STRB     R1,[R7, #+15]
    201                    }
    202                  }
    203          
    204                  IsSpeedReliable = pHandle->pSNSL->pFctSTO_SpeedReliabilityCheck( pHandle->pSNSL );
   \                     ??RUC_OTF_Exec_3: (+1)
   \       0x46   0x6AB8             LDR      R0,[R7, #+40]
   \       0x48   0x6901             LDR      R1,[R0, #+16]
   \       0x4A   0x4788             BLX      R1
   \       0x4C   0x7AF9             LDRB     R1,[R7, #+11]
    205          
    206                  if ( IsSpeedReliable )
   \       0x4E   0xB118             CBZ.N    R0,??RUC_OTF_Exec_5
    207                  {
    208                    if ( pHandle->bOTFRelCounter < 127u )
   \       0x50   0x297F             CMP      R1,#+127
   \       0x52   0xD202             BCS.N    ??RUC_OTF_Exec_6
    209                    {
    210                      pHandle->bOTFRelCounter++;
   \       0x54   0x1C49             ADDS     R1,R1,#+1
   \       0x56   0xE000             B.N      ??RUC_OTF_Exec_6
    211                    }
    212                  }
    213                  else
    214                  {
    215                    pHandle->bOTFRelCounter = 0u;
   \                     ??RUC_OTF_Exec_5: (+1)
   \       0x58   0x2100             MOVS     R1,#+0
   \                     ??RUC_OTF_Exec_6: (+1)
   \       0x5A   0x72F9             STRB     R1,[R7, #+11]
    216                  }
    217          
    218                  if ( pHandle->pSNSL->pFctStoOtfResetPLL != MC_NULL )
   \       0x5C   0x6AB9             LDR      R1,[R7, #+40]
   \       0x5E   0x7AFA             LDRB     R2,[R7, #+11]
   \       0x60   0x68C8             LDR      R0,[R1, #+12]
   \       0x62   0xB120             CBZ.N    R0,??RUC_OTF_Exec_7
    219                  {
    220                    if ( pHandle->bOTFRelCounter == ( pHandle->bResetPLLTh >> 1 ) )
   \       0x64   0x7BB8             LDRB     R0,[R7, #+14]
   \       0x66   0xEBB2 0x0F50      CMP      R2,R0, LSR #+1
   \       0x6A   0xD155             BNE.N    ??RUC_OTF_Exec_1
   \       0x6C   0xE001             B.N      ??RUC_OTF_Exec_8
    221                    {
    222                      condition = true;
    223                    }
    224                  }
    225                  else
    226                  {
    227                    if ( pHandle->bOTFRelCounter == 127 )
   \                     ??RUC_OTF_Exec_7: (+1)
   \       0x6E   0x2A7F             CMP      R2,#+127
   \       0x70   0xD152             BNE.N    ??RUC_OTF_Exec_1
    228                    {
    229                      condition = true;
    230                    }
    231                  }
    232          
    233                  if ( condition == true )
    234                  {
    235                    bool bCollinearSpeed = false;
    236                    int16_t hObsSpeedUnit = SPD_GetAvrgMecSpeedUnit( pHandle->pSNSL->_Super );
   \                     ??RUC_OTF_Exec_8: (+1)
   \       0x72   0x6808             LDR      R0,[R1, #+0]
   \       0x74   0x....'....        BL       SPD_GetAvrgMecSpeedUnit
   \       0x78   0x4605             MOV      R5,R0
    237                    int16_t hObsSpeedUnitAbsValue =
    238                            ( hObsSpeedUnit < 0 ? ( -hObsSpeedUnit ) : ( hObsSpeedUnit ) ); /* hObsSpeedUnit absolute value */
   \       0x7A   0x2D00             CMP      R5,#+0
   \       0x7C   0x46A9             MOV      R9,R5
    239          
    240                    if ( pHandle->hDirection > 0 )
   \       0x7E   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \       0x82   0xBF44             ITT      MI
   \       0x84   0xF1C9 0x0900      RSBMI    R9,R9,#+0
   \       0x88   0xFA0F 0xF989      SXTHMI   R9,R9
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xDD04             BLE.N    ??RUC_OTF_Exec_9
    241                    {
    242                      if ( hObsSpeedUnit > 0 )
   \       0x90   0x2D00             CMP      R5,#+0
   \       0x92   0xDC04             BGT.N    ??RUC_OTF_Exec_10
    243                      {
    244                        bCollinearSpeed = true; /* actual and reference speed are collinear*/
    245                      }
    246                    }
    247                    else
    248                    {
    249                      if ( hObsSpeedUnit < 0 )
    250                      {
    251                        bCollinearSpeed = true; /* actual and reference speed are collinear*/
    252                      }
    253                    }
    254          
    255                    if ( bCollinearSpeed == false )
    256                    {
    257                      /*reverse speed management*/
    258                      pHandle->bOTFRelCounter = 0u;
   \                     ??RUC_OTF_Exec_11: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x72F8             STRB     R0,[R7, #+11]
   \       0x98   0xE03E             B.N      ??RUC_OTF_Exec_1
    259                    }
   \                     ??RUC_OTF_Exec_9: (+1)
   \       0x9A   0x2D00             CMP      R5,#+0
   \       0x9C   0xD5FA             BPL.N    ??RUC_OTF_Exec_11
    260                    else /*speeds are collinear*/
    261                    {
    262                      if ( ( uint16_t )( hObsSpeedUnitAbsValue ) > pHandle->hMinStartUpValidSpeed )
   \                     ??RUC_OTF_Exec_10: (+1)
   \       0x9E   0x8878             LDRH     R0,[R7, #+2]
   \       0xA0   0xFA1F 0xF189      UXTH     R1,R9
   \       0xA4   0x4288             CMP      R0,R1
   \       0xA6   0xD204             BCS.N    ??RUC_OTF_Exec_12
    263                      {
    264                        /* startup end, go to run */
    265                        pHandle->pSNSL->pFctForceConvergency1( pHandle->pSNSL );
   \       0xA8   0x6AB8             LDR      R0,[R7, #+40]
   \       0xAA   0x6841             LDR      R1,[R0, #+4]
   \       0xAC   0x4788             BLX      R1
    266                        pHandle->EnteredZone1 = true;
   \       0xAE   0x737E             STRB     R6,[R7, #+13]
   \       0xB0   0xE032             B.N      ??RUC_OTF_Exec_1
    267                      }
    268                      else if ( ( uint16_t )( hObsSpeedUnitAbsValue ) > pHandle->hMinStartUpFlySpeed )
   \                     ??RUC_OTF_Exec_12: (+1)
   \       0xB2   0x88B8             LDRH     R0,[R7, #+4]
   \       0xB4   0x4288             CMP      R0,R1
   \       0xB6   0xD22F             BCS.N    ??RUC_OTF_Exec_1
    269                      {
    270                        /* synch with startup*/
    271                        /* nearest phase search*/
    272                        int16_t hOldFinalMecSpeedUnit = 0;
    273                        int16_t hOldFinalTorque = 0;
    274                        int32_t wDeltaSpeedRevUp;
    275                        int32_t wDeltaTorqueRevUp;
    276                        bool bError = false;
    277                        VSS_SetCopyObserver( pHandle->pVSS );
   \       0xB8   0x6A78             LDR      R0,[R7, #+36]
   \       0xBA   0x....'....        BL       VSS_SetCopyObserver
    278                        pHandle->pSNSL->pFctForceConvergency2( pHandle->pSNSL );
   \       0xBE   0x6AB8             LDR      R0,[R7, #+40]
   \       0xC0   0x6881             LDR      R1,[R0, #+8]
   \       0xC2   0x4788             BLX      R1
   \       0xC4   0x68A3             LDR      R3,[R4, #+8]
   \       0xC6   0xF04F 0x0A00      MOV      R10,#+0
    279          
    280                        if (pHandle->pCurrentPhaseParams == MC_NULL)
   \       0xCA   0xB3BB             CBZ.N    R3,??RUC_OTF_Exec_13
   \       0xCC   0x2100             MOVS     R1,#+0
   \       0xCE   0xE008             B.N      ??RUC_OTF_Exec_14
    281                        {
    282                          bError = true;
    283                          pHandle->hPhaseRemainingTicks = 0u;
    284                        }
    285                        else
    286                        {
    287                          while ( pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit < hObsSpeedUnitAbsValue )
    288                          {
    289                            if ( pHandle->pCurrentPhaseParams->pNext == MC_NULL )
   \                     ??RUC_OTF_Exec_15: (+1)
   \       0xD0   0x6898             LDR      R0,[R3, #+8]
   \       0xD2   0xB398             CBZ.N    R0,??RUC_OTF_Exec_13
    290                            {
    291                              /* sets for Revup fail error*/
    292                              bError = true;
    293                              pHandle->hPhaseRemainingTicks = 0u;
    294                              break;
    295                            }
    296                            else
    297                            {
    298                              /* skips this phase*/
    299                              hOldFinalMecSpeedUnit = pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit;
    300                              hOldFinalTorque = pHandle->pCurrentPhaseParams->hFinalTorque;
   \       0xD4   0xF9B3 0x1004      LDRSH    R1,[R3, #+4]
    301                              pHandle->pCurrentPhaseParams = pHandle->pCurrentPhaseParams->pNext;
   \       0xD8   0x4603             MOV      R3,R0
    302                              pHandle->bStageCnt++;
   \       0xDA   0x7C38             LDRB     R0,[R7, #+16]
   \       0xDC   0x1C40             ADDS     R0,R0,#+1
   \       0xDE   0x4692             MOV      R10,R2
   \       0xE0   0x7438             STRB     R0,[R7, #+16]
    303                            }
   \                     ??RUC_OTF_Exec_14: (+1)
   \       0xE2   0xF9B3 0x2002      LDRSH    R2,[R3, #+2]
   \       0xE6   0x454A             CMP      R2,R9
   \       0xE8   0xDBF2             BLT.N    ??RUC_OTF_Exec_15
    304                          }
    305                        }
    306          
    307                        if ( bError == false )
    308                        {
    309                          /* calculation of the transition phase from OTF to standard revup */
    310                          int16_t hTorqueReference;
    311          
    312                          wDeltaSpeedRevUp = ( int32_t )( pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit ) - ( int32_t )( hOldFinalMecSpeedUnit );
    313                          wDeltaTorqueRevUp = ( int32_t )( pHandle->pCurrentPhaseParams->hFinalTorque ) - ( int32_t )( hOldFinalTorque );
    314          
    315                          hTorqueReference = ( int16_t )( ( ( ( int32_t )hObsSpeedUnit ) * wDeltaTorqueRevUp ) / wDeltaSpeedRevUp ) +
    316                                  hOldFinalTorque;
    317          
    318                          STC_ExecRamp( pHandle->pSTC, hTorqueReference, 0u );
   \       0xEA   0x60A3             STR      R3,[R4, #+8]
   \       0xEC   0x2200             MOVS     R2,#+0
   \       0xEE   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \       0xF2   0xF9B3 0x3002      LDRSH    R3,[R3, #+2]
   \       0xF6   0x1A40             SUBS     R0,R0,R1
   \       0xF8   0x4345             MULS     R5,R5,R0
   \       0xFA   0xEBA3 0x000A      SUB      R0,R3,R10
   \       0xFE   0xFB95 0xF3F0      SDIV     R3,R5,R0
   \      0x102   0x18C9             ADDS     R1,R1,R3
   \      0x104   0x6A38             LDR      R0,[R7, #+32]
   \      0x106   0xB209             SXTH     R1,R1
   \      0x108   0x....'....        BL       STC_ExecRamp
    319          
    320                          pHandle->hPhaseRemainingTicks = 1u;
   \      0x10C   0x80A6             STRH     R6,[R4, #+4]
    321          
    322                          pHandle->pCurrentPhaseParams = &pHandle->OTFPhaseParams;
    323          
    324                          pHandle->bStageCnt = 6u;
   \      0x10E   0x2106             MOVS     R1,#+6
   \      0x110   0xF104 0x035C      ADD      R3,R4,#+92
   \      0x114   0x7439             STRB     R1,[R7, #+16]
   \                     ??RUC_OTF_Exec_16: (+1)
   \      0x116   0x60A3             STR      R3,[R4, #+8]
    325                        } /* no MC_NULL error */
    326                      } /* speed > MinStartupFly */
    327                      else
    328                      {
    329                      }
    330                    } /* speeds are collinear */
    331                  } /* speed is reliable */
    332                }/*EnteredZone1 1 is false */
    333                else
    334                {
    335                  pHandle->pSNSL->pFctForceConvergency1( pHandle->pSNSL );
    336                }
    337              } /*stage 0*/
    338            } /* hPhaseRemainingTicks > 0 */
    339          
    340            if ( pHandle->hPhaseRemainingTicks == 0u )
   \                     ??RUC_OTF_Exec_1: (+1)
   \      0x118   0x88A0             LDRH     R0,[R4, #+4]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD149             BNE.N    ??RUC_OTF_Exec_17
    341            {
    342              if ( pHandle->pCurrentPhaseParams != MC_NULL )
   \                     ??RUC_OTF_Exec_0: (+1)
   \      0x11E   0x68A0             LDR      R0,[R4, #+8]
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0x7C38             LDRB     R0,[R7, #+16]
   \      0x124   0xD03B             BEQ.N    ??RUC_OTF_Exec_18
    343              {
    344                if ( pHandle->bStageCnt == 0u )
   \      0x126   0xB978             CBNZ.N   R0,??RUC_OTF_Exec_19
    345                {
    346                  /*end of OTF*/
    347                  PWMC_SwitchOffPWM( pHandle->pPWM );
   \      0x128   0x6AF8             LDR      R0,[R7, #+44]
   \      0x12A   0x....'....        BL       PWMC_SwitchOffPWM
    348                  pHandle->OTFSCLowside = true;
    349                  PWMC_TurnOnLowSides( pHandle->pPWM );
   \      0x12E   0x6AF8             LDR      R0,[R7, #+44]
   \      0x130   0x733E             STRB     R6,[R7, #+12]
   \      0x132   0x....'....        BL       PWMC_TurnOnLowSides
    350                  pHandle->bOTFRelCounter = 0u;
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0x72F8             STRB     R0,[R7, #+11]
   \      0x13A   0xE00C             B.N      ??RUC_OTF_Exec_20
    351                }
   \                     ??RUC_OTF_Exec_13: (+1)
   \      0x13C   0x2100             MOVS     R1,#+0
   \      0x13E   0x80A1             STRH     R1,[R4, #+4]
   \      0x140   0xE7E9             B.N      ??RUC_OTF_Exec_16
   \                     ??RUC_OTF_Exec_2: (+1)
   \      0x142   0x6841             LDR      R1,[R0, #+4]
   \      0x144   0x4788             BLX      R1
   \      0x146   0xE7E7             B.N      ??RUC_OTF_Exec_1
    352                else if ( ( pHandle->bStageCnt == 1u ) )
   \                     ??RUC_OTF_Exec_19: (+1)
   \      0x148   0x2801             CMP      R0,#+1
   \      0x14A   0xD104             BNE.N    ??RUC_OTF_Exec_20
    353                {
    354                  PWMC_SwitchOnPWM( pHandle->pPWM );
   \      0x14C   0x6AF8             LDR      R0,[R7, #+44]
   \      0x14E   0x....'....        BL       PWMC_SwitchOnPWM
    355                  pHandle->OTFSCLowside = false;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0x7338             STRB     R0,[R7, #+12]
    356                }
    357                else
    358                {
    359                }
    360          
    361                /* If it becomes zero the current phase has been completed.*/
    362                /* Gives the next command to STC and VSS.*/
    363                STC_ExecRamp( pHandle->pSTC, pHandle->pCurrentPhaseParams->hFinalTorque * pHandle->hDirection,
    364                              ( uint32_t )( pHandle->pCurrentPhaseParams->hDurationms ) );
   \                     ??RUC_OTF_Exec_20: (+1)
   \      0x156   0x68A0             LDR      R0,[R4, #+8]
   \      0x158   0x8802             LDRH     R2,[R0, #+0]
   \      0x15A   0x8880             LDRH     R0,[R0, #+4]
   \      0x15C   0x88E1             LDRH     R1,[R4, #+6]
   \      0x15E   0xFB10 0xF101      SMULBB   R1,R0,R1
   \      0x162   0x6A38             LDR      R0,[R7, #+32]
   \      0x164   0xB209             SXTH     R1,R1
   \      0x166   0x....'....        BL       STC_ExecRamp
    365          
    366                VSS_SetMecAcceleration( pHandle->pVSS,
    367                                        pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit * pHandle->hDirection,
    368                                        pHandle->pCurrentPhaseParams->hDurationms );
   \      0x16A   0x68A0             LDR      R0,[R4, #+8]
   \      0x16C   0x8802             LDRH     R2,[R0, #+0]
   \      0x16E   0x8840             LDRH     R0,[R0, #+2]
   \      0x170   0x88E1             LDRH     R1,[R4, #+6]
   \      0x172   0xFB10 0xF101      SMULBB   R1,R0,R1
   \      0x176   0x6A78             LDR      R0,[R7, #+36]
   \      0x178   0xB209             SXTH     R1,R1
   \      0x17A   0x....'....        BL       VSS_SetMecAcceleration
    369          
    370                /* Compute hPhaseRemainingTicks.*/
    371                pHandle->hPhaseRemainingTicks =
    372                        ( uint16_t )( ( ( uint32_t )pHandle->pCurrentPhaseParams->hDurationms *
    373                                ( uint32_t )pHandle->hRUCFrequencyHz ) / 1000u );
    374                pHandle->hPhaseRemainingTicks++;
   \      0x17E   0x68A1             LDR      R1,[R4, #+8]
   \      0x180   0x8820             LDRH     R0,[R4, #+0]
   \      0x182   0x880A             LDRH     R2,[R1, #+0]
   \      0x184   0x4342             MULS     R2,R0,R2
   \      0x186   0xF44F 0x737A      MOV      R3,#+1000
   \      0x18A   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \      0x18E   0x1C5B             ADDS     R3,R3,#+1
   \      0x190   0x80A3             STRH     R3,[R4, #+4]
    375          
    376                /*Set the next phases parameter pointer.*/
    377                pHandle->pCurrentPhaseParams = pHandle->pCurrentPhaseParams->pNext;
   \      0x192   0x6888             LDR      R0,[R1, #+8]
   \      0x194   0x60A0             STR      R0,[R4, #+8]
    378          
    379                /*Increases the rev up stages counter.*/
    380                pHandle->bStageCnt++;
   \      0x196   0x7C39             LDRB     R1,[R7, #+16]
   \      0x198   0x1C49             ADDS     R1,R1,#+1
   \      0x19A   0x7439             STRB     R1,[R7, #+16]
   \      0x19C   0xE009             B.N      ??RUC_OTF_Exec_17
    381              }
    382              else
    383              {
    384                if ( pHandle->bStageCnt == pHandle->bPhaseNbr - 1 ) /* End of user programmed revup */
   \                     ??RUC_OTF_Exec_18: (+1)
   \      0x19E   0x783A             LDRB     R2,[R7, #+0]
   \      0x1A0   0x1E52             SUBS     R2,R2,#+1
   \      0x1A2   0x4290             CMP      R0,R2
   \      0x1A4   0xBF08             IT       EQ
   \      0x1A6   0x2600             MOVEQ    R6,#+0
    385                {
    386                  retVal = false;
   \      0x1A8   0xD003             BEQ.N    ??RUC_OTF_Exec_17
    387                }
    388                else if ( pHandle->bStageCnt == 7u ) /* End of first OTF runs */
   \      0x1AA   0x2807             CMP      R0,#+7
   \      0x1AC   0xBF04             ITT      EQ
   \      0x1AE   0x2000             MOVEQ    R0,#+0
   \      0x1B0   0x7438             STRBEQ   R0,[R7, #+16]
    389                {
    390                  pHandle->bStageCnt = 0u; /* Breaking state */
    391                  pHandle->hPhaseRemainingTicks = 0u;
    392                }
    393                else
    394                {
    395                }
    396              }
    397            }
    398            return retVal;
   \                     ??RUC_OTF_Exec_17: (+1)
   \      0x1B2   0x4630             MOV      R0,R6
   \      0x1B4   0xE8BD 0x86F2      POP      {R1,R4-R7,R9,R10,PC}  ;; return
    399          }
    400          
    401          /**
    402            * @brief  Main revup controller procedure executing overall programmed phases.
    403            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    404            *  @retval Boolean set to false when entire revup phases have been completed.
    405            */

   \                                 In section .text, align 2
    406          __weak bool RUC_Exec( RevUpCtrl_Handle_t * pHandle )
    407          {
   \                     RUC_Exec: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    408            bool retVal = true;
   \        0x4   0x2501             MOVS     R5,#+1
    409          
    410            if ( pHandle->hPhaseRemainingTicks > 0u )
   \        0x6   0x88A0             LDRH     R0,[R4, #+4]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xBF1F             ITTTT    NE
   \        0xC   0x1E40             SUBNE    R0,R0,#+1
   \        0xE   0x80A0             STRHNE   R0,[R4, #+4]
   \       0x10   0xB280             UXTHNE   R0,R0
   \       0x12   0x2800             CMPNE    R0,#+0
    411            {
    412              /* Decrease the hPhaseRemainingTicks.*/
    413              pHandle->hPhaseRemainingTicks--;
    414          
    415            } /* hPhaseRemainingTicks > 0 */
    416          
    417            if ( pHandle->hPhaseRemainingTicks == 0u )
   \       0x14   0xD127             BNE.N    ??RUC_Exec_0
    418            {
    419              if ( pHandle->pCurrentPhaseParams != MC_NULL )
   \       0x16   0x68A0             LDR      R0,[R4, #+8]
   \       0x18   0xB320             CBZ.N    R0,??RUC_Exec_1
    420              {
    421          
    422                /* If it becomes zero the current phase has been completed.*/
    423                /* Gives the next command to STC and VSS.*/
    424                STC_ExecRamp( pHandle->pSTC, pHandle->pCurrentPhaseParams->hFinalTorque * pHandle->hDirection,
    425                              ( uint32_t )( pHandle->pCurrentPhaseParams->hDurationms ) );
   \       0x1A   0x8802             LDRH     R2,[R0, #+0]
   \       0x1C   0x8880             LDRH     R0,[R0, #+4]
   \       0x1E   0x88E1             LDRH     R1,[R4, #+6]
   \       0x20   0xF104 0x0658      ADD      R6,R4,#+88
   \       0x24   0xFB10 0xF101      SMULBB   R1,R0,R1
   \       0x28   0x6930             LDR      R0,[R6, #+16]
   \       0x2A   0xB209             SXTH     R1,R1
   \       0x2C   0x....'....        BL       STC_ExecRamp
    426          
    427                VSS_SetMecAcceleration( pHandle->pVSS,
    428                                        pHandle->pCurrentPhaseParams->hFinalMecSpeedUnit * pHandle->hDirection,
    429                                        pHandle->pCurrentPhaseParams->hDurationms );
   \       0x30   0x68A0             LDR      R0,[R4, #+8]
   \       0x32   0x8802             LDRH     R2,[R0, #+0]
   \       0x34   0x8840             LDRH     R0,[R0, #+2]
   \       0x36   0x88E1             LDRH     R1,[R4, #+6]
   \       0x38   0xFB10 0xF101      SMULBB   R1,R0,R1
   \       0x3C   0x6970             LDR      R0,[R6, #+20]
   \       0x3E   0xB209             SXTH     R1,R1
   \       0x40   0x....'....        BL       VSS_SetMecAcceleration
    430          
    431                /* Compute hPhaseRemainingTicks.*/
    432                pHandle->hPhaseRemainingTicks =
    433                  ( uint16_t )( ( ( uint32_t )pHandle->pCurrentPhaseParams->hDurationms *
    434                                  ( uint32_t )pHandle->hRUCFrequencyHz ) / 1000u );
    435                pHandle->hPhaseRemainingTicks++;
   \       0x44   0x68A1             LDR      R1,[R4, #+8]
   \       0x46   0x8820             LDRH     R0,[R4, #+0]
   \       0x48   0x880A             LDRH     R2,[R1, #+0]
   \       0x4A   0x4342             MULS     R2,R0,R2
   \       0x4C   0xF44F 0x737A      MOV      R3,#+1000
   \       0x50   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \       0x54   0x1C5B             ADDS     R3,R3,#+1
   \       0x56   0x80A3             STRH     R3,[R4, #+4]
    436          
    437                /*Set the next phases parameter pointer.*/
    438                pHandle->pCurrentPhaseParams = pHandle->pCurrentPhaseParams->pNext;
   \       0x58   0x6888             LDR      R0,[R1, #+8]
   \       0x5A   0x60A0             STR      R0,[R4, #+8]
    439          
    440                /*Increases the rev up stages counter.*/
    441                pHandle->bStageCnt++;
   \       0x5C   0x7831             LDRB     R1,[R6, #+0]
   \       0x5E   0x1C49             ADDS     R1,R1,#+1
   \       0x60   0x7031             STRB     R1,[R6, #+0]
   \       0x62   0xE000             B.N      ??RUC_Exec_0
    442              }
    443              else
    444              {
    445                retVal = false;
   \                     ??RUC_Exec_1: (+1)
   \       0x64   0x2500             MOVS     R5,#+0
    446              }
    447            }
    448            return retVal;
   \                     ??RUC_Exec_0: (+1)
   \       0x66   0x4628             MOV      R0,R5
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
    449          }
    450          
    451          /**
    452            * @brief  Provide current state of revup controller procedure.
    453            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    454            *  @retval Boolean set to true when entire revup phases have been completed.
    455            */

   \                                 In section .text, align 2
    456          __weak bool RUC_Completed( RevUpCtrl_Handle_t * pHandle )
    457          {
   \                     RUC_Completed: (+1)
   \        0x0   0x4601             MOV      R1,R0
    458            bool retVal = false;
   \        0x2   0x2000             MOVS     R0,#+0
    459            if ( pHandle->pCurrentPhaseParams == MC_NULL )
   \        0x4   0x6889             LDR      R1,[R1, #+8]
   \        0x6   0xB901             CBNZ.N   R1,??RUC_Completed_0
    460            {
    461              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    462            }
    463            return retVal;
   \                     ??RUC_Completed_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return
    464          }
    465          
    466          /**
    467            * @brief  Allow to exit from RevUp process at the current rotor speed.
    468            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    469            *  @retval none
    470            */

   \                                 In section .text, align 2
    471          __weak void RUC_Stop( RevUpCtrl_Handle_t * pHandle )
    472          {
   \                     RUC_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    473            VirtualSpeedSensor_Handle_t * pVSS = pHandle->pVSS;
   \        0x2   0x6EC4             LDR      R4,[R0, #+108]
    474            pHandle->pCurrentPhaseParams = MC_NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6081             STR      R1,[R0, #+8]
    475            pHandle->hPhaseRemainingTicks = 0u;
   \        0x8   0x8081             STRH     R1,[R0, #+4]
    476            VSS_SetMecAcceleration( pVSS, SPD_GetAvrgMecSpeedUnit( & pVSS->_Super ), 0u );
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x....'....        BL       SPD_GetAvrgMecSpeedUnit
   \       0x10   0x4601             MOV      R1,R0
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x....'....        B.W      VSS_SetMecAcceleration
    477          }
    478          
    479          #if defined (CCMRAM)
    480          #if defined (__ICCARM__)
    481          #pragma location = ".ccmram"
    482          #elif defined (__CC_ARM) || defined(__GNUC__)
    483          __attribute__( ( section ( ".ccmram" ) ) )
    484          #endif
    485          #endif
    486          
    487          /**
    488            * @brief  Check that alignement and first acceleration stage are completed.
    489            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    490            *  @retval Boolean set to true when first acceleration stage has been reached.
    491            */

   \                                 In section .text, align 2
    492          __weak bool RUC_FirstAccelerationStageReached( RevUpCtrl_Handle_t * pHandle )
    493          {
   \                     RUC_FirstAccelerationStageReached: (+1)
   \        0x0   0x4601             MOV      R1,R0
    494            bool retVal = false;
    495          
    496            if ( pHandle->bStageCnt >= pHandle->bFirstAccelerationStage )
   \        0x2   0x3149             ADDS     R1,R1,#+73
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7BCA             LDRB     R2,[R1, #+15]
   \        0x8   0x7809             LDRB     R1,[R1, #+0]
   \        0xA   0x428A             CMP      R2,R1
   \        0xC   0xBF28             IT       CS
   \        0xE   0x2001             MOVCS    R0,#+1
    497            {
    498              retVal = true;
    499            }
    500            return retVal;
   \       0x10   0x4770             BX       LR               ;; return
    501          }
    502          
    503          /**
    504            * @brief  Allow to modify duration of a selected phase.
    505            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    506            * @param  bPhase: RevUp phase where new duration shall be modified.
    507            *         This parameter must be a number between 0 and 6.
    508            * @param  hDurationms: new duration value required for associated phase.
    509            *         This parameter must be set in millisecond.
    510            *  @retval none
    511            */

   \                                 In section .text, align 2
    512          __weak void RUC_SetPhaseDurationms( RevUpCtrl_Handle_t * pHandle, uint8_t bPhase, uint16_t hDurationms )
    513          {
    514            pHandle->ParamsData[bPhase].hDurationms = hDurationms;
   \                     RUC_SetPhaseDurationms: (+1)
   \        0x0   0x230C             MOVS     R3,#+12
   \        0x2   0x4359             MULS     R1,R3,R1
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0x8182             STRH     R2,[R0, #+12]
    515          }
   \        0x8   0x4770             BX       LR               ;; return
    516          
    517          /**
    518            * @brief  Allow to modify targetted mechanical speed of a selected phase.
    519            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    520            * @param  bPhase: RevUp phase where new mechanical speed shall be modified.
    521            *         This parameter must be a number between 0 and 6.
    522            * @param  hFinalMecSpeedUnit: new targetted mechanical speed.
    523            *         This parameter must be expressed in 0.1Hz.
    524            *  @retval none
    525            */

   \                                 In section .text, align 2
    526          __weak void RUC_SetPhaseFinalMecSpeedUnit( RevUpCtrl_Handle_t * pHandle, uint8_t bPhase,
    527                                              int16_t hFinalMecSpeedUnit )
    528          {
    529            pHandle->ParamsData[bPhase].hFinalMecSpeedUnit = hFinalMecSpeedUnit;
   \                     RUC_SetPhaseFinalMecSpeedUnit: (+1)
   \        0x0   0x230C             MOVS     R3,#+12
   \        0x2   0x4359             MULS     R1,R3,R1
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0x81C2             STRH     R2,[R0, #+14]
    530          }
   \        0x8   0x4770             BX       LR               ;; return
    531          
    532          /**
    533            * @brief  Allow to modify targetted the motor torque of a selected phase.
    534            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    535            * @param  bPhase: RevUp phase where new the motor torque shall be modified.
    536            *         This parameter must be a number between 0 and 6.
    537            * @param  hFinalTorque: new targetted motor torque.
    538            *  @retval none
    539            */

   \                                 In section .text, align 2
    540          __weak void RUC_SetPhaseFinalTorque( RevUpCtrl_Handle_t * pHandle, uint8_t bPhase, int16_t hFinalTorque )
    541          {
    542            pHandle->ParamsData[bPhase].hFinalTorque = hFinalTorque;
   \                     RUC_SetPhaseFinalTorque: (+1)
   \        0x0   0x230C             MOVS     R3,#+12
   \        0x2   0x4359             MULS     R1,R3,R1
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0x8202             STRH     R2,[R0, #+16]
    543          }
   \        0x8   0x4770             BX       LR               ;; return
    544          
    545          /**
    546            * @brief  Allow to read duration set in selected phase.
    547            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    548            * @param  bPhase: RevUp phase from where duration is read.
    549            *         This parameter must be a number between 0 and 6.
    550            *  @retval Returns duration used in selected phase.
    551            */

   \                                 In section .text, align 2
    552          __weak uint16_t RUC_GetPhaseDurationms( RevUpCtrl_Handle_t * pHandle, uint8_t bPhase )
    553          {
    554            return ( ( uint16_t )pHandle->ParamsData[bPhase].hDurationms );
   \                     RUC_GetPhaseDurationms: (+1)
   \        0x0   0x220C             MOVS     R2,#+12
   \        0x2   0x4351             MULS     R1,R2,R1
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0x8980             LDRH     R0,[R0, #+12]
   \        0x8   0x4770             BX       LR               ;; return
    555          }
    556          
    557          /**
    558            * @brief  Allow to read targetted rotor speed set in selected phase.
    559            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    560            * @param  bPhase: RevUp phase from where targetted rotor speed is read.
    561            *         This parameter must be a number between 0 and 6.
    562            *  @retval Returns targetted rotor speed set in selected phase.
    563            */

   \                                 In section .text, align 2
    564          __weak int16_t RUC_GetPhaseFinalMecSpeedUnit( RevUpCtrl_Handle_t * pHandle, uint8_t bPhase )
    565          {
    566            return ( ( int16_t )pHandle->ParamsData[bPhase].hFinalMecSpeedUnit );
   \                     RUC_GetPhaseFinalMecSpeedUnit: (+1)
   \        0x0   0x220C             MOVS     R2,#+12
   \        0x2   0x4351             MULS     R1,R2,R1
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0xF9B0 0x000E      LDRSH    R0,[R0, #+14]
   \        0xA   0x4770             BX       LR               ;; return
    567          }
    568          
    569          /**
    570            * @brief  Allow to read targetted motor torque set in selected phase.
    571            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    572            * @param  bPhase: RevUp phase from where targetted motor torque is read.
    573            *         This parameter must be a number between 0 and 6.
    574            *  @retval Returns targetted motor torque set in selected phase.
    575            */

   \                                 In section .text, align 2
    576          __weak int16_t RUC_GetPhaseFinalTorque( RevUpCtrl_Handle_t * pHandle, uint8_t bPhase )
    577          {
    578            return ( ( int16_t )pHandle->ParamsData[bPhase].hFinalTorque );
   \                     RUC_GetPhaseFinalTorque: (+1)
   \        0x0   0x220C             MOVS     R2,#+12
   \        0x2   0x4351             MULS     R1,R2,R1
   \        0x4   0x4408             ADD      R0,R0,R1
   \        0x6   0xF9B0 0x0010      LDRSH    R0,[R0, #+16]
   \        0xA   0x4770             BX       LR               ;; return
    579          }
    580          
    581          /**
    582            * @brief  Allow to read total number of programmed phases.
    583            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    584            *  @retval Returns number of phases relative to the programmed revup.
    585            */

   \                                 In section .text, align 2
    586          __weak uint8_t RUC_GetNumberOfPhases( RevUpCtrl_Handle_t * pHandle )
    587          {
    588            return ( ( uint8_t )pHandle->bPhaseNbr );
   \                     RUC_GetNumberOfPhases: (+1)
   \        0x0   0xF890 0x0048      LDRB     R0,[R0, #+72]
   \        0x4   0x4770             BX       LR               ;; return
    589          }
    590          
    591          /**
    592            * @brief  Allow to read status of On The Fly (OTF) feature.
    593            * @param  pHandle: Pointer on Handle structure of RevUp controller.
    594            *  @retval Boolean set to true at the end of OTF precessing.
    595            */

   \                                 In section .text, align 2
    596          __weak bool RUC_Get_SCLowsideOTF_Status( RevUpCtrl_Handle_t * pHandle )
    597          {
    598            return ( pHandle->OTFSCLowside );
   \                     RUC_Get_SCLowsideOTF_Status: (+1)
   \        0x0   0xF890 0x0054      LDRB     R0,[R0, #+84]
   \        0x4   0x4770             BX       LR               ;; return
    599          }
    600          
    601          /**
    602            * @}
    603            */
    604          
    605          /**
    606            * @}
    607            */
    608          
    609          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RUC_Clear
        24   -> STC_ExecRamp
        24   -> STC_SetControlMode
        24   -> VSS_Clear
        24   -> VSS_SetMecAcceleration
        24   -> VSS_SetMecAngle
       0   RUC_Completed
      16   RUC_Exec
        16   -> STC_ExecRamp
        16   -> VSS_SetMecAcceleration
       0   RUC_FirstAccelerationStageReached
       0   RUC_GetNumberOfPhases
       0   RUC_GetPhaseDurationms
       0   RUC_GetPhaseFinalMecSpeedUnit
       0   RUC_GetPhaseFinalTorque
       0   RUC_Get_SCLowsideOTF_Status
      20   RUC_Init
      32   RUC_OTF_Exec
        32   -- Indirect call
        32   -> PWMC_SwitchOffPWM
        32   -> PWMC_SwitchOnPWM
        32   -> PWMC_TurnOnLowSides
        32   -> SPD_GetAvrgMecSpeedUnit
        32   -> STC_ExecRamp
        32   -> VSS_SetCopyObserver
        32   -> VSS_SetMecAcceleration
       0   RUC_SetPhaseDurationms
       0   RUC_SetPhaseFinalMecSpeedUnit
       0   RUC_SetPhaseFinalTorque
       8   RUC_Stop
         8   -> SPD_GetAvrgMecSpeedUnit
         0   -> VSS_SetMecAcceleration


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     134  RUC_Clear
      12  RUC_Completed
     106  RUC_Exec
      18  RUC_FirstAccelerationStageReached
       6  RUC_GetNumberOfPhases
      10  RUC_GetPhaseDurationms
      12  RUC_GetPhaseFinalMecSpeedUnit
      12  RUC_GetPhaseFinalTorque
       6  RUC_Get_SCLowsideOTF_Status
      76  RUC_Init
     440  RUC_OTF_Exec
      10  RUC_SetPhaseDurationms
      10  RUC_SetPhaseFinalMecSpeedUnit
      10  RUC_SetPhaseFinalTorque
      30  RUC_Stop

 
 892 bytes in section .text
 
 0 bytes of CODE memory (+ 892 bytes shared)

Errors: none
Warnings: none
