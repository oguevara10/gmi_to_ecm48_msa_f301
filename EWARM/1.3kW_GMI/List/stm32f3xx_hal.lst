###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:47
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW823E.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\stm32f3xx_hal.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\stm32f3xx_hal.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_hal.c
      4            * @author  MCD Application Team
      5            * @brief   HAL module driver.
      6            *          This is the common part of the HAL initialization
      7            *
      8            @verbatim
      9            ==============================================================================
     10                               ##### How to use this driver #####
     11            ==============================================================================
     12              [..]
     13              The common HAL driver contains a set of generic and common APIs that can be
     14              used by the PPP peripheral drivers and the user to start using the HAL.
     15              [..]
     16              The HAL contains two APIs categories:
     17                   (+) HAL Initialization and de-initialization functions
     18                   (+) HAL Control functions
     19          
     20            @endverbatim
     21            ******************************************************************************
     22            * @attention
     23            *
     24            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     25            * All rights reserved.</center></h2>
     26            *
     27            * This software component is licensed by ST under BSD 3-Clause license,
     28            * the "License"; You may not use this file except in compliance with the
     29            * License. You may obtain a copy of the License at:
     30            *                        opensource.org/licenses/BSD-3-Clause
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "stm32f3xx_hal.h"
     37          
     38          /** @addtogroup STM32F3xx_HAL_Driver
     39            * @{
     40            */
     41          
     42          /** @defgroup HAL HAL
     43            * @brief HAL module driver.
     44            * @{
     45            */
     46          
     47          #ifdef HAL_MODULE_ENABLED
     48          
     49          /* Private typedef -----------------------------------------------------------*/
     50          /* Private define ------------------------------------------------------------*/
     51          /** @defgroup HAL_Private Constants
     52            * @{
     53            */
     54          /**
     55           * @brief STM32F3xx HAL Driver version number V1.5.3
     56             */
     57          #define __STM32F3xx_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */
     58          #define __STM32F3xx_HAL_VERSION_SUB1   (0x05U) /*!< [23:16] sub1 version */
     59          #define __STM32F3xx_HAL_VERSION_SUB2   (0x03U) /*!< [15:8]  sub2 version */
     60          #define __STM32F3xx_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
     61          #define __STM32F3xx_HAL_VERSION         ((__STM32F3xx_HAL_VERSION_MAIN << 24U)\
     62                                                  |(__STM32F3xx_HAL_VERSION_SUB1 << 16U)\
     63                                                  |(__STM32F3xx_HAL_VERSION_SUB2 << 8U )\
     64                                                  |(__STM32F3xx_HAL_VERSION_RC))
     65          
     66          #define IDCODE_DEVID_MASK    (0x00000FFFU)
     67          /**
     68            * @}
     69            */
     70            
     71          /* Private macro -------------------------------------------------------------*/
     72          /* Exported variables --------------------------------------------------------*/
     73          /** @defgroup HAL_Exported_Variables HAL Exported Variables
     74            * @{
     75            */

   \                                 In section .data, align 4
     76          __IO uint32_t uwTick;
     77          uint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */
     78          HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */
   \                     uwTickFreq:
   \        0x0   0x01               DC8 1
   \        0x1   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \                     uwTick:
   \        0x4                      DS8 4
   \                     uwTickPrio:
   \        0x8   0x0000'0010        DC32 16
     79          /**
     80            * @}
     81            */
     82          /* Private function prototypes -----------------------------------------------*/
     83          /* Exported functions ---------------------------------------------------------*/
     84          
     85          /** @defgroup HAL_Exported_Functions HAL Exported Functions
     86            * @{
     87            */
     88          
     89          /** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions 
     90           *  @brief    Initialization and de-initialization functions
     91           *
     92          @verbatim
     93           ===============================================================================
     94                        ##### Initialization and de-initialization functions #####
     95           ===============================================================================
     96              [..]  This section provides functions allowing to:
     97                (+) Initializes the Flash interface, the NVIC allocation and initial clock 
     98                    configuration. It initializes the systick also when timeout is needed
     99                    and the backup domain when enabled.
    100                (+) de-Initializes common part of the HAL.
    101                (+) Configure The time base source to have 1ms time base with a dedicated 
    102                    Tick interrupt priority. 
    103                  (++) SysTick timer is used by default as source of time base, but user 
    104                       can eventually implement his proper time base source (a general purpose 
    105                       timer for example or other time source), keeping in mind that Time base 
    106                       duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
    107                       handled in milliseconds basis.
    108                  (++) Time base configuration function (HAL_InitTick ()) is called automatically 
    109                       at the beginning of the program after reset by HAL_Init() or at any time 
    110                       when clock is configured, by HAL_RCC_ClockConfig(). 
    111                  (++) Source of time base is configured  to generate interrupts at regular 
    112                       time intervals. Care must be taken if HAL_Delay() is called from a 
    113                       peripheral ISR process, the Tick interrupt line must have higher priority 
    114                      (numerically lower) than the peripheral interrupt. Otherwise the caller 
    115                      ISR process will be blocked. 
    116                 (++) functions affecting time base configurations are declared as __Weak  
    117                       to make  override possible  in case of other  implementations in user file.
    118          
    119          @endverbatim
    120            * @{
    121            */
    122          
    123          /**
    124            * @brief  This function configures the Flash prefetch, 
    125            *         Configures time base source, NVIC and Low level hardware
    126            * @note   This function is called at the beginning of program after reset and before 
    127            *         the clock configuration
    128            *             
    129            * @note   The Systick configuration is based on HSI clock, as HSI is the clock
    130            *         used after a system Reset and the NVIC configuration is set to Priority group 4 
    131            *            
    132            * @note   The time base configuration is based on MSI clock when exting from Reset.
    133            *         Once done, time base tick start incrementing.
    134            *         In the default implementation,Systick is used as source of time base.
    135            *       The tick variable is incremented each 1ms in its ISR.
    136            * @retval HAL status
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef HAL_Init(void)
    139          {
   \                     HAL_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    140            /* Configure Flash prefetch */
    141          #if (PREFETCH_ENABLE != 0U)
    142            __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
   \        0x2   0x....             LDR.N    R0,??DataTable16  ;; 0x40022000
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF041 0x0110      ORR      R1,R1,#0x10
   \        0xA   0x6001             STR      R1,[R0, #+0]
    143          #endif /* PREFETCH_ENABLE */
    144          
    145            /* Set Interrupt Group Priority */
    146            HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0x....'....        BL       HAL_NVIC_SetPriorityGrouping
    147          
    148            /* Enable systick and configure 1ms tick (default clock after Reset is HSI) */
    149            HAL_InitTick(TICK_INT_PRIORITY);
   \       0x12   0x2004             MOVS     R0,#+4
   \       0x14   0x....'....        BL       HAL_InitTick
    150          
    151            /* Init the low level hardware */
    152            HAL_MspInit();
   \       0x18   0x....'....        BL       HAL_MspInit
    153          
    154            /* Return function status */
    155            return HAL_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD02             POP      {R1,PC}          ;; return
    156          }
    157          
    158          /**
    159            * @brief  This function de-Initializes common part of the HAL and stops the systick.
    160            * @note This function is optional.
    161            * @retval HAL status
    162            */

   \                                 In section .text, align 2, keep-with-next
    163          HAL_StatusTypeDef HAL_DeInit(void)
    164          {
   \                     HAL_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    165            /* Reset of all peripherals */
    166            __HAL_RCC_APB1_FORCE_RESET();
   \        0x2   0x....             LDR.N    R0,??DataTable16_1  ;; 0x4002100c
   \        0x4   0xF04F 0x31FF      MOV      R1,#-1
   \        0x8   0x6041             STR      R1,[R0, #+4]
    167            __HAL_RCC_APB1_RELEASE_RESET();
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6042             STR      R2,[R0, #+4]
    168          
    169            __HAL_RCC_APB2_FORCE_RESET();
   \        0xE   0x6001             STR      R1,[R0, #+0]
    170            __HAL_RCC_APB2_RELEASE_RESET();
   \       0x10   0x6002             STR      R2,[R0, #+0]
    171          
    172            __HAL_RCC_AHB_FORCE_RESET();
   \       0x12   0x61C1             STR      R1,[R0, #+28]
    173            __HAL_RCC_AHB_RELEASE_RESET();
   \       0x14   0x61C2             STR      R2,[R0, #+28]
    174          
    175            /* De-Init the low level hardware */
    176            HAL_MspDeInit();
   \       0x16   0x....'....        BL       HAL_MspDeInit
    177          
    178            /* Return function status */
    179            return HAL_OK;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD02             POP      {R1,PC}          ;; return
    180          }
    181          
    182          /**
    183            * @brief  Initialize the MSP.
    184            * @retval None
    185            */

   \                                 In section .text, align 2
    186          __weak void HAL_MspInit(void)
    187          {
    188            /* NOTE : This function should not be modified, when the callback is needed,
    189                      the HAL_MspInit could be implemented in the user file
    190             */
    191          }
   \                     HAL_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    192          
    193          /**
    194            * @brief  DeInitialize the MSP.
    195            * @retval None
    196            */

   \                                 In section .text, align 2
    197          __weak void HAL_MspDeInit(void)
    198          {
    199            /* NOTE : This function should not be modified, when the callback is needed,
    200                      the HAL_MspDeInit could be implemented in the user file
    201             */
    202          }
   \                     HAL_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    203          
    204          /**
    205            * @brief  This function configures the source of the time base. 
    206            *         The time source is configured  to have 1ms time base with a dedicated 
    207            *         Tick interrupt priority. 
    208            * @note   This function is called  automatically at the beginning of program after
    209            *         reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig(). 
    210            * @note   In the default implementation , SysTick timer is the source of time base. 
    211            *         It is used to generate interrupts at regular time intervals. 
    212            *         Care must be taken if HAL_Delay() is called from a peripheral ISR process, 
    213            *         The SysTick interrupt must have higher priority (numerically lower) 
    214            *         than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
    215            *         The function is declared as __Weak  to be overwritten  in case of other
    216            *         implementation  in user file.
    217            * @param TickPriority Tick interrupt priority.
    218            * @retval HAL status
    219            */

   \                                 In section .text, align 4
    220          __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
    221          {
   \                     HAL_InitTick: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    222            /* Configure the SysTick to have interrupt in 1ms time basis*/
    223            if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
   \        0x2   0x4D0D             LDR.N    R5,??HAL_InitTick_0
   \        0x4   0x4B0D             LDR.N    R3,??HAL_InitTick_0+0x4
   \        0x6   0x782A             LDRB     R2,[R5, #+0]
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0xF44F 0x717A      MOV      R1,#+1000
   \        0xE   0x6818             LDR      R0,[R3, #+0]
   \       0x10   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \       0x14   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x18   0x....'....        BL       HAL_SYSTICK_Config
   \       0x1C   0xB950             CBNZ.N   R0,??HAL_InitTick_1
    224            {
    225              return HAL_ERROR;
    226            }
    227          
    228            /* Configure the SysTick IRQ priority */
    229            if (TickPriority < (1UL << __NVIC_PRIO_BITS))
   \       0x1E   0x2C10             CMP      R4,#+16
   \       0x20   0xD208             BCS.N    ??HAL_InitTick_1
    230            {
    231              HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x4621             MOV      R1,R4
   \       0x26   0xF04F 0x30FF      MOV      R0,#-1
   \       0x2A   0x....'....        BL       HAL_NVIC_SetPriority
    232              uwTickPrio = TickPriority;
   \       0x2E   0x60AC             STR      R4,[R5, #+8]
    233            }
    234            else
    235            {
    236              return HAL_ERROR;
    237            }
    238             /* Return function status */
    239            return HAL_OK;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_InitTick_1: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??HAL_InitTick_0:
   \       0x38   0x....'....        DC32     uwTickFreq
   \       0x3C   0x....'....        DC32     SystemCoreClock
    240          }
    241          
    242          /**
    243            * @}
    244            */
    245          
    246          /** @defgroup HAL_Exported_Functions_Group2 HAL Control functions 
    247           *  @brief    HAL Control functions
    248           *
    249          @verbatim
    250           ===============================================================================
    251                                ##### HAL Control functions #####
    252           ===============================================================================
    253              [..]  This section provides functions allowing to:
    254                (+) Provide a tick value in millisecond
    255                (+) Provide a blocking delay in millisecond
    256                (+) Suspend the time base source interrupt
    257                (+) Resume the time base source interrupt
    258                (+) Get the HAL API driver version
    259                (+) Get the device identifier
    260                (+) Get the device revision identifier
    261                (+) Enable/Disable Debug module during Sleep mode
    262                (+) Enable/Disable Debug module during STOP mode
    263                (+) Enable/Disable Debug module during STANDBY mode
    264                
    265          @endverbatim
    266            * @{
    267            */
    268          
    269          /**
    270            * @brief  This function is called to increment  a global variable "uwTick"
    271            *         used as application time base.
    272            * @note In the default implementation, this variable is incremented each 1ms
    273            *         in SysTick ISR.
    274            * @note This function is declared as __weak to be overwritten in case of other 
    275            *         implementations  in user file.
    276            * @retval None
    277            */

   \                                 In section .text, align 4
    278          __weak void HAL_IncTick(void)
    279          {
    280            uwTick += uwTickFreq;
   \                     HAL_IncTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_IncTick_0
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0x7802             LDRB     R2,[R0, #+0]
   \        0x6   0x188A             ADDS     R2,R1,R2
   \        0x8   0x6042             STR      R2,[R0, #+4]
    281          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_IncTick_0:
   \        0xC   0x....'....        DC32     uwTickFreq
    282          
    283          /**
    284            * @brief  Povides a tick value in millisecond.
    285            * @note   The function is declared as __Weak  to be overwritten  in case of other 
    286            *         implementations  in user file.
    287            * @retval tick value
    288            */

   \                                 In section .text, align 4
    289          __weak uint32_t HAL_GetTick(void)
    290          {
    291            return uwTick;  
   \                     HAL_GetTick: (+1)
   \        0x0   0x4801             LDR.N    R0,??HAL_GetTick_0
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??HAL_GetTick_0:
   \        0x8   0x....'....        DC32     uwTickFreq
    292          }
    293          
    294          /**
    295            * @brief This function returns a tick priority.
    296            * @retval tick priority
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          uint32_t HAL_GetTickPrio(void)
    299          {
    300            return uwTickPrio;
   \                     HAL_GetTickPrio: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_2
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0x4770             BX       LR               ;; return
    301          }
    302          
    303          /**
    304            * @brief Set new tick Freq.
    305            * @retval status
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
    308          {
   \                     HAL_SetTickFreq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    309            HAL_StatusTypeDef status  = HAL_OK;
    310            HAL_TickFreqTypeDef prevTickFreq;
    311          
    312            assert_param(IS_TICKFREQ(Freq));
    313          
    314            if (uwTickFreq != Freq)
   \        0x2   0x....             LDR.N    R4,??DataTable16_2
   \        0x4   0x7825             LDRB     R5,[R4, #+0]
   \        0x6   0x4601             MOV      R1,R0
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x428D             CMP      R5,R1
   \        0xC   0xD006             BEQ.N    ??HAL_SetTickFreq_0
    315            {
    316              /* Back up uwTickFreq frequency */
    317              prevTickFreq = uwTickFreq;
    318          
    319              /* Update uwTickFreq global variable used by HAL_InitTick() */
    320              uwTickFreq = Freq;
   \        0xE   0x7021             STRB     R1,[R4, #+0]
    321          
    322              /* Apply the new tick Freq */
    323              status = HAL_InitTick(uwTickPrio);
   \       0x10   0x68A0             LDR      R0,[R4, #+8]
   \       0x12   0x....'....        BL       HAL_InitTick
    324          
    325              if (status != HAL_OK)
   \       0x16   0x0001             MOVS     R1,R0
   \       0x18   0xBF18             IT       NE
   \       0x1A   0x7025             STRBNE   R5,[R4, #+0]
    326              {
    327                /* Restore previous tick frequency */
    328                uwTickFreq = prevTickFreq;
    329              }
    330            }
    331          
    332            return status;
   \                     ??HAL_SetTickFreq_0: (+1)
   \       0x1C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    333          }
    334          
    335          /**
    336            * @brief Return tick frequency.
    337            * @retval tick period in Hz
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          HAL_TickFreqTypeDef HAL_GetTickFreq(void)
    340          {
    341            return uwTickFreq;
   \                     HAL_GetTickFreq: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_2
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    342          }
    343          
    344          /**
    345            * @brief  This function provides accurate delay (in milliseconds) based 
    346            *         on variable incremented.
    347            * @note   In the default implementation , SysTick timer is the source of time base. 
    348            *         It is used to generate interrupts at regular time intervals where uwTick
    349            *         is incremented.
    350            *         The function is declared as __Weak  to be overwritten  in case of other
    351            *         implementations  in user file.
    352            * @param  Delay specifies the delay time length, in milliseconds.
    353            * @retval None
    354            */

   \                                 In section .text, align 4
    355          __weak void HAL_Delay(uint32_t Delay)
    356          {
   \                     HAL_Delay: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    357            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x....'....        BL       HAL_GetTick
    358            uint32_t wait = Delay;
    359            
    360            /* Add freq to guarantee minimum wait */
    361            if (wait < HAL_MAX_DELAY)
   \        0x8   0xF114 0x0F01      CMN      R4,#+1
   \        0xC   0x4605             MOV      R5,R0
   \        0xE   0xD002             BEQ.N    ??HAL_Delay_1
    362            {
    363              wait += (uint32_t)(uwTickFreq);
   \       0x10   0x4804             LDR.N    R0,??HAL_Delay_0
   \       0x12   0x7801             LDRB     R1,[R0, #+0]
   \       0x14   0x1864             ADDS     R4,R4,R1
    364            }
    365            
    366            while((HAL_GetTick() - tickstart) < wait)
   \                     ??HAL_Delay_1: (+1)
   \       0x16   0x....'....        BL       HAL_GetTick
   \       0x1A   0x1B40             SUBS     R0,R0,R5
   \       0x1C   0x42A0             CMP      R0,R4
   \       0x1E   0xD3FA             BCC.N    ??HAL_Delay_1
    367            {
    368            }
    369          }
   \       0x20   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x22   0xBF00             Nop
   \                     ??HAL_Delay_0:
   \       0x24   0x....'....        DC32     uwTickFreq
    370          
    371          /**
    372            * @brief  Suspend Tick increment.
    373            * @note   In the default implementation , SysTick timer is the source of time base. It is  
    374            *         used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
    375            *         is called, the the SysTick interrupt will be disabled and so Tick increment 
    376            *         is suspended.
    377            * @note This function is declared as __weak to be overwritten in case of other
    378            *         implementations  in user file.
    379            * @retval None
    380            */

   \                                 In section .text, align 4
    381          __weak void HAL_SuspendTick(void)
    382          
    383          {
    384            /* Disable SysTick Interrupt */
    385            SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
   \                     HAL_SuspendTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_SuspendTick_0  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF021 0x0102      BIC      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    386                                                             
    387          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_SuspendTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    388          
    389          /**
    390            * @brief  Resume Tick increment.
    391            * @note   In the default implementation , SysTick timer is the source of time base. It is  
    392            *         used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
    393            *         is called, the the SysTick interrupt will be enabled and so Tick increment 
    394            *         is resumed.
    395            *         The function is declared as __Weak  to be overwritten  in case of other
    396            *         implementations  in user file.
    397            * @retval None
    398            */

   \                                 In section .text, align 4
    399          __weak void HAL_ResumeTick(void)
    400          {
    401            /* Enable SysTick Interrupt */
    402            SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
   \                     HAL_ResumeTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_ResumeTick_0  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    403            
    404          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_ResumeTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    405          
    406          /**
    407            * @brief  This function returns the HAL revision
    408            * @retval version 0xXYZR (8bits for each decimal, R for RC)
    409            */

   \                                 In section .text, align 2, keep-with-next
    410          uint32_t HAL_GetHalVersion(void)
    411          {
    412           return __STM32F3xx_HAL_VERSION;
   \                     HAL_GetHalVersion: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_3  ;; 0x1050300
   \        0x2   0x4770             BX       LR               ;; return
    413          }
    414          
    415          /**
    416            * @brief  Returns the device revision identifier.
    417            * @retval Device revision identifier
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          uint32_t HAL_GetREVID(void)
    420          {
    421            return((DBGMCU->IDCODE) >> 16U);
   \                     HAL_GetREVID: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_4  ;; 0xe0042000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0C00             LSRS     R0,R0,#+16
   \        0x6   0x4770             BX       LR               ;; return
    422          }
    423          
    424          /**
    425            * @brief  Returns the device identifier.
    426            * @retval Device identifier
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          uint32_t HAL_GetDEVID(void)
    429          {
    430            return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
   \                     HAL_GetDEVID: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_4  ;; 0xe0042000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x000B      UBFX     R0,R0,#+0,#+12
   \        0x8   0x4770             BX       LR               ;; return
    431          }
    432          
    433          /**
    434            * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
    435            * @retval Device identifier
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          uint32_t HAL_GetUIDw0(void)
    438          {
    439             return(READ_REG(*((uint32_t *)UID_BASE)));
   \                     HAL_GetUIDw0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_5  ;; 0x1ffff7ac
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    440          }
    441          
    442          /**
    443            * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
    444            * @retval Device identifier
    445            */

   \                                 In section .text, align 2, keep-with-next
    446          uint32_t HAL_GetUIDw1(void)
    447          {
    448             return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
   \                     HAL_GetUIDw1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_6  ;; 0x1ffff7b0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    449          }
    450          
    451          /**
    452            * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
    453            * @retval Device identifier
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          uint32_t HAL_GetUIDw2(void)
    456          {
    457             return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
   \                     HAL_GetUIDw2: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_7  ;; 0x1ffff7b4
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    458          }
    459          
    460          /**
    461            * @brief  Enable the Debug Module during SLEEP mode
    462            * @retval None
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          void HAL_DBGMCU_EnableDBGSleepMode(void)
    465          {
    466            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_EnableDBGSleepMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_8  ;; 0xe0042004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    467          }
   \        0xA   0x4770             BX       LR               ;; return
    468          
    469          /**
    470            * @brief  Disable the Debug Module during SLEEP mode
    471            * @retval None
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          void HAL_DBGMCU_DisableDBGSleepMode(void)
    474          {
    475            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_DisableDBGSleepMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_8  ;; 0xe0042004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    476          }
   \        0xA   0x4770             BX       LR               ;; return
    477          
    478          /**
    479            * @brief  Enable the Debug Module during STOP mode
    480            * @retval None
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          void HAL_DBGMCU_EnableDBGStopMode(void)
    483          {
    484            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_EnableDBGStopMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_8  ;; 0xe0042004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    485          }
   \        0xA   0x4770             BX       LR               ;; return
    486          
    487          /**
    488            * @brief  Disable the Debug Module during STOP mode
    489            * @retval None
    490            */

   \                                 In section .text, align 2, keep-with-next
    491          void HAL_DBGMCU_DisableDBGStopMode(void)
    492          {
    493            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_DisableDBGStopMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_8  ;; 0xe0042004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF021 0x0102      BIC      R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    494          }
   \        0xA   0x4770             BX       LR               ;; return
    495          
    496          /**
    497            * @brief  Enable the Debug Module during STANDBY mode
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void HAL_DBGMCU_EnableDBGStandbyMode(void)
    501          {
    502            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_EnableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_8  ;; 0xe0042004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x0104      ORR      R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    503          }
   \        0xA   0x4770             BX       LR               ;; return
    504          
    505          /**
    506            * @brief  Disable the Debug Module during STANDBY mode
    507            * @retval None
    508            */

   \                                 In section .text, align 2, keep-with-next
    509          void HAL_DBGMCU_DisableDBGStandbyMode(void)
    510          {
    511            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_DisableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_8  ;; 0xe0042004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF021 0x0104      BIC      R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    512          }
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x4002'100C        DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     uwTickFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x0105'0300        DC32     0x1050300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0xE004'2000        DC32     0xe0042000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x1FFF'F7AC        DC32     0x1ffff7ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x1FFF'F7B0        DC32     0x1ffff7b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x1FFF'F7B4        DC32     0x1ffff7b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0xE004'2004        DC32     0xe0042004
    513          
    514          /**
    515            * @}
    516            */
    517          
    518          /**
    519            * @}
    520            */
    521          
    522          #endif /* HAL_MODULE_ENABLED */
    523          /**
    524            * @}
    525            */
    526          
    527          /**
    528            * @}
    529            */
    530          
    531          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_DBGMCU_DisableDBGSleepMode
       0   HAL_DBGMCU_DisableDBGStandbyMode
       0   HAL_DBGMCU_DisableDBGStopMode
       0   HAL_DBGMCU_EnableDBGSleepMode
       0   HAL_DBGMCU_EnableDBGStandbyMode
       0   HAL_DBGMCU_EnableDBGStopMode
       8   HAL_DeInit
         8   -> HAL_MspDeInit
      16   HAL_Delay
        16   -> HAL_GetTick
       0   HAL_GetDEVID
       0   HAL_GetHalVersion
       0   HAL_GetREVID
       0   HAL_GetTick
       0   HAL_GetTickFreq
       0   HAL_GetTickPrio
       0   HAL_GetUIDw0
       0   HAL_GetUIDw1
       0   HAL_GetUIDw2
       0   HAL_IncTick
       8   HAL_Init
         8   -> HAL_InitTick
         8   -> HAL_MspInit
         8   -> HAL_NVIC_SetPriorityGrouping
      16   HAL_InitTick
        16   -> HAL_NVIC_SetPriority
        16   -> HAL_SYSTICK_Config
       0   HAL_MspDeInit
       0   HAL_MspInit
       0   HAL_ResumeTick
      16   HAL_SetTickFreq
        16   -> HAL_InitTick
       0   HAL_SuspendTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
      12  HAL_DBGMCU_DisableDBGSleepMode
      12  HAL_DBGMCU_DisableDBGStandbyMode
      12  HAL_DBGMCU_DisableDBGStopMode
      12  HAL_DBGMCU_EnableDBGSleepMode
      12  HAL_DBGMCU_EnableDBGStandbyMode
      12  HAL_DBGMCU_EnableDBGStopMode
      30  HAL_DeInit
      40  HAL_Delay
      10  HAL_GetDEVID
       4  HAL_GetHalVersion
       8  HAL_GetREVID
      12  HAL_GetTick
       6  HAL_GetTickFreq
       6  HAL_GetTickPrio
       6  HAL_GetUIDw0
       6  HAL_GetUIDw1
       6  HAL_GetUIDw2
      16  HAL_IncTick
      32  HAL_Init
      64  HAL_InitTick
       2  HAL_MspDeInit
       2  HAL_MspInit
      16  HAL_ResumeTick
      30  HAL_SetTickFreq
      16  HAL_SuspendTick
      12  uwTickFreq
          uwTick
          uwTickPrio

 
  12 bytes in section .data
 420 bytes in section .text
 
 252 bytes of CODE memory (+ 168 bytes shared)
  12 bytes of DATA memory

Errors: none
Warnings: none
