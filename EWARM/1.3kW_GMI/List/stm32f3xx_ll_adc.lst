###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:16
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_adc.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW597F.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_adc.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\stm32f3xx_ll_adc.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\stm32f3xx_ll_adc.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_ll_adc.c
      4            * @author  MCD Application Team
      5            * @brief   ADC LL module driver
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          #if defined(USE_FULL_LL_DRIVER)
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f3xx_ll_adc.h"
     23          #include "stm32f3xx_ll_bus.h"
     24          
     25          #ifdef  USE_FULL_ASSERT
     26            #include "stm32_assert.h"
     27          #else
     28            #define assert_param(expr) ((void)0U)
     29          #endif
     30          
     31          /** @addtogroup STM32F3xx_LL_Driver
     32            * @{
     33            */
     34          
     35          /* Note: Devices of STM32F3 serie embed 1 out of 2 different ADC IP.   b      */
     36          /*       - STM32F30x, STM32F31x, STM32F32x, STM32F33x, STM32F35x, STM32F39x:  */
     37          /*         ADC IP 5Msamples/sec, from 1 to 4 ADC instances and other specific */
     38          /*         features (refer to reference manual).                              */
     39          /*       - STM32F37x:                                                         */
     40          /*         ADC IP 1Msamples/sec, 1 ADC instance                               */
     41          /*       This file contains the drivers of these ADC IP, located in 2 area    */
     42          /*       delimited by compilation switches.                                   */
     43          
     44          #if defined(ADC5_V1_1)
     45          
     46          #if defined (ADC1) || defined (ADC2) || defined (ADC3) || defined (ADC4)
     47          
     48          /** @addtogroup ADC_LL ADC
     49            * @{
     50            */
     51          
     52          /* Private types -------------------------------------------------------------*/
     53          /* Private variables ---------------------------------------------------------*/
     54          /* Private constants ---------------------------------------------------------*/
     55          /** @addtogroup ADC_LL_Private_Constants
     56            * @{
     57            */
     58          
     59          /* Definitions of ADC hardware constraints delays */
     60          /* Note: Only ADC IP HW delays are defined in ADC LL driver driver,           */
     61          /*       not timeout values:                                                  */
     62          /*       Timeout values for ADC operations are dependent to device clock      */
     63          /*       configuration (system clock versus ADC clock),                       */
     64          /*       and therefore must be defined in user application.                   */
     65          /*       Refer to @ref ADC_LL_EC_HW_DELAYS for description of ADC timeout     */
     66          /*       values definition.                                                   */
     67          /* Note: ADC timeout values are defined here in CPU cycles to be independent  */
     68          /*       of device clock setting.                                             */
     69          /*       In user application, ADC timeout values should be defined with       */
     70          /*       temporal values, in function of device clock settings.               */
     71          /*       Highest ratio CPU clock frequency vs ADC clock frequency:            */
     72          /*        - ADC clock from synchronous clock with AHB prescaler 512,          */
     73          /*          APB prescaler 16, ADC prescaler 4.                                */
     74          /*        - ADC clock from asynchronous clock (PLL) with prescaler 1,         */
     75          /*          with highest ratio CPU clock frequency vs HSI clock frequency:    */
     76          /*          CPU clock frequency max 72MHz, PLL frequency 72MHz: ratio 1.      */
     77          /* Unit: CPU cycles.                                                          */
     78          #define ADC_CLOCK_RATIO_VS_CPU_HIGHEST          ((uint32_t) 512U * 16U * 4U)
     79          #define ADC_TIMEOUT_DISABLE_CPU_CYCLES          (ADC_CLOCK_RATIO_VS_CPU_HIGHEST * 1U)
     80          #define ADC_TIMEOUT_STOP_CONVERSION_CPU_CYCLES  (ADC_CLOCK_RATIO_VS_CPU_HIGHEST * 1U)
     81          
     82          /**
     83            * @}
     84            */
     85          
     86          /* Private macros ------------------------------------------------------------*/
     87          
     88          /** @addtogroup ADC_LL_Private_Macros
     89            * @{
     90            */
     91          
     92          /* Check of parameters for configuration of ADC hierarchical scope:           */
     93          /* common to several ADC instances.                                           */
     94          #define IS_LL_ADC_COMMON_CLOCK(__CLOCK__)                                      \
     95            (   ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV1)                             \
     96             || ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV2)                             \
     97             || ((__CLOCK__) == LL_ADC_CLOCK_SYNC_PCLK_DIV4)                             \
     98             || ((__CLOCK__) == LL_ADC_CLOCK_ASYNC_DIV1)                                 \
     99            )
    100          
    101          /* Check of parameters for configuration of ADC hierarchical scope:           */
    102          /* ADC instance.                                                              */
    103          #define IS_LL_ADC_RESOLUTION(__RESOLUTION__)                                   \
    104            (   ((__RESOLUTION__) == LL_ADC_RESOLUTION_12B)                              \
    105             || ((__RESOLUTION__) == LL_ADC_RESOLUTION_10B)                              \
    106             || ((__RESOLUTION__) == LL_ADC_RESOLUTION_8B)                               \
    107             || ((__RESOLUTION__) == LL_ADC_RESOLUTION_6B)                               \
    108            )
    109          
    110          #define IS_LL_ADC_DATA_ALIGN(__DATA_ALIGN__)                                   \
    111            (   ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_RIGHT)                            \
    112             || ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_LEFT)                             \
    113            )
    114          
    115          #define IS_LL_ADC_LOW_POWER(__LOW_POWER__)                                     \
    116            (   ((__LOW_POWER__) == LL_ADC_LP_MODE_NONE)                                 \
    117             || ((__LOW_POWER__) == LL_ADC_LP_AUTOWAIT)                                  \
    118            )
    119          
    120          /* Check of parameters for configuration of ADC hierarchical scope:           */
    121          /* ADC group regular                                                          */
    122          #if defined(STM32F303xE) || defined(STM32F398xx)
    123          #define IS_LL_ADC_REG_TRIG_SOURCE(__ADC_INSTANCE__, __REG_TRIG_SOURCE__)       \
    124            ((((__ADC_INSTANCE__) == ADC1) || ((__ADC_INSTANCE__) == ADC2))              \
    125              ? (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    126                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1_ADC12)        \
    127                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2_ADC12)        \
    128                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)              \
    129                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2_ADC12)        \
    130                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO_ADC12)       \
    131                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4_ADC12)        \
    132                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11_ADC12)     \
    133                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO_ADC12)       \
    134                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO2)            \
    135                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)             \
    136                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)            \
    137                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO_ADC12)       \
    138                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_TRGO)             \
    139                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM6_TRGO_ADC12)       \
    140                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)            \
    141                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH4_ADC12)        \
    142                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_TRG0_ADC12)      \
    143                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_TRG02_ADC12)     \
    144                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_CH1_ADC12)       \
    145                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_CH2_ADC12)       \
    146                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_CH3_ADC12)       \
    147                )                                                                        \
    148                :                                                                        \
    149                (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    150                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH1_ADC34)        \
    151                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH3_ADC34)        \
    152                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)              \
    153                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_CH1_ADC34)        \
    154                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO__ADC34)      \
    155                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE2_ADC34)      \
    156                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH1_ADC34)        \
    157                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO__ADC34)      \
    158                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO2)            \
    159                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)             \
    160                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)            \
    161                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO__ADC34)      \
    162                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_TRGO)             \
    163                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM7_TRGO_ADC34)       \
    164                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)            \
    165                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH1_ADC34)        \
    166                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_TRG0_ADC34)      \
    167                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_TRG02_ADC34)     \
    168                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM20_CH1_ADC34)       \
    169                )                                                                        \
    170            )
    171          #elif defined(STM32F303xC) || defined(STM32F358xx)
    172          #define IS_LL_ADC_REG_TRIG_SOURCE(__ADC_INSTANCE__, __REG_TRIG_SOURCE__)       \
    173            ((((__ADC_INSTANCE__) == ADC1) || ((__ADC_INSTANCE__) == ADC2))              \
    174              ? (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    175                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1_ADC12)        \
    176                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2_ADC12)        \
    177                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)              \
    178                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2_ADC12)        \
    179                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO_ADC12)       \
    180                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4_ADC12)        \
    181                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11_ADC12)     \
    182                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO_ADC12)       \
    183                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO2)            \
    184                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)             \
    185                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)            \
    186                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO_ADC12)       \
    187                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_TRGO)             \
    188                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM6_TRGO_ADC12)       \
    189                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)            \
    190                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH4_ADC12)        \
    191                )                                                                        \
    192                :                                                                        \
    193                (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    194                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH1_ADC34)        \
    195                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH3_ADC34)        \
    196                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)              \
    197                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_CH1_ADC34)        \
    198                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO__ADC34)      \
    199                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE2_ADC34)      \
    200                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH1_ADC34)        \
    201                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO__ADC34)      \
    202                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO2)            \
    203                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)             \
    204                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)            \
    205                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO__ADC34)      \
    206                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_TRGO)             \
    207                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM7_TRGO_ADC34)       \
    208                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)            \
    209                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH1_ADC34)        \
    210                )                                                                        \
    211            )
    212          #elif defined(STM32F303x8) || defined(STM32F328xx)
    213          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
    214            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
    215             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \
    216             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \
    217             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \
    218             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \
    219             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \
    220             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4)                  \
    221             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \
    222             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO)                 \
    223             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)                 \
    224             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)                \
    225             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO)                 \
    226             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_TRGO)                 \
    227             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM6_TRGO)                 \
    228             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)                \
    229             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH4)                  \
    230            )
    231          #elif defined(STM32F334x8)
    232          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
    233            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
    234             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \
    235             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \
    236             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \
    237             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \
    238             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \
    239             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \
    240             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_HRTIM_TRG1)                \
    241             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_HRTIM_TRG3)                \
    242             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)                 \
    243             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)                \
    244             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO)                 \
    245             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM6_TRGO)                 \
    246             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)                \
    247             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH4)                  \
    248            )
    249          #elif defined(STM32F302xC) || defined(STM32F302xE)
    250          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
    251            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
    252             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \
    253             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \
    254             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \
    255             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \
    256             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \
    257             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4)                  \
    258             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \
    259             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)                 \
    260             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)                \
    261             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO)                 \
    262             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_TRGO)                 \
    263             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM6_TRGO)                 \
    264             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)                \
    265             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH4)                  \
    266            )
    267          #elif defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)
    268          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
    269            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
    270             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \
    271             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \
    272             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \
    273             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \
    274             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO)                 \
    275             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_TRGO2)                \
    276             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_TRGO)                 \
    277             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM6_TRGO)                 \
    278             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM15_TRGO)                \
    279            )
    280          #endif
    281          
    282          #define IS_LL_ADC_REG_CONTINUOUS_MODE(__REG_CONTINUOUS_MODE__)                 \
    283            (   ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_SINGLE)                    \
    284             || ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_CONTINUOUS)                \
    285            )
    286          
    287          #define IS_LL_ADC_REG_DMA_TRANSFER(__REG_DMA_TRANSFER__)                       \
    288            (   ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_NONE)                 \
    289             || ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_LIMITED)              \
    290             || ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_UNLIMITED)            \
    291            )
    292          
    293          #define IS_LL_ADC_REG_OVR_DATA_BEHAVIOR(__REG_OVR_DATA_BEHAVIOR__)             \
    294            (   ((__REG_OVR_DATA_BEHAVIOR__) == LL_ADC_REG_OVR_DATA_PRESERVED)           \
    295             || ((__REG_OVR_DATA_BEHAVIOR__) == LL_ADC_REG_OVR_DATA_OVERWRITTEN)         \
    296            )
    297          
    298          #define IS_LL_ADC_REG_SEQ_SCAN_LENGTH(__REG_SEQ_SCAN_LENGTH__)                 \
    299            (   ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_DISABLE)               \
    300             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS)         \
    301             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS)         \
    302             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS)         \
    303             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS)         \
    304             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS)         \
    305             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS)         \
    306             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS)         \
    307             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS)         \
    308             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS)        \
    309             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS)        \
    310             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS)        \
    311             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS)        \
    312             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS)        \
    313             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS)        \
    314             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS)        \
    315            )
    316          
    317          #define IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(__REG_SEQ_DISCONT_MODE__)          \
    318            (   ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_DISABLE)           \
    319             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_1RANK)             \
    320             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_2RANKS)            \
    321             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_3RANKS)            \
    322             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_4RANKS)            \
    323             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_5RANKS)            \
    324             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_6RANKS)            \
    325             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_7RANKS)            \
    326             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_8RANKS)            \
    327            )
    328          
    329          /* Check of parameters for configuration of ADC hierarchical scope:           */
    330          /* ADC group injected                                                         */
    331          #if defined(STM32F303xE) || defined(STM32F398xx)
    332          #define IS_LL_ADC_INJ_TRIG_SOURCE(__ADC_INSTANCE__, __INJ_TRIG_SOURCE__)       \
    333            ((((__ADC_INSTANCE__) == ADC1) || ((__ADC_INSTANCE__) == ADC2))              \
    334              ? (   ((__INJ_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    335                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)             \
    336                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)              \
    337                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO_ADC12)       \
    338                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1_ADC12)        \
    339                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4_ADC12)        \
    340                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO_ADC12)       \
    341                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15_ADC12)     \
    342                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4_ADC12)        \
    343                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)            \
    344                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO)             \
    345                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2)            \
    346                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH3_ADC12)        \
    347                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)             \
    348                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH1_ADC12)        \
    349                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM6_TRGO_ADC12)       \
    350                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)            \
    351                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM20_TRGO_ADC12)      \
    352                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM20_TRGO2_ADC12)     \
    353                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM20_CH4_ADC12)       \
    354                )                                                                        \
    355                :                                                                        \
    356                (   ((__INJ_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    357                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)             \
    358                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)              \
    359                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH3_ADC34)        \
    360                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH2_ADC34)        \
    361                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4__ADC34)       \
    362                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH4_ADC34)        \
    363                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO__ADC34)      \
    364                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)            \
    365                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO)             \
    366                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2)            \
    367                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH3_ADC34)        \
    368                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)             \
    369                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO__ADC34)      \
    370                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM7_TRGO_ADC34)       \
    371                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)            \
    372                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM20_TRG_ADC34)       \
    373                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM20_TRG2_ADC34)      \
    374                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM20_CH2)             \
    375                )                                                                        \
    376            )
    377          #elif defined(STM32F303xC) || defined(STM32F358xx)
    378          #define IS_LL_ADC_INJ_TRIG_SOURCE(__ADC_INSTANCE__, __INJ_TRIG_SOURCE__)       \
    379            ((((__ADC_INSTANCE__) == ADC1) || ((__ADC_INSTANCE__) == ADC2))              \
    380              ? (   ((__INJ_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    381                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)             \
    382                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)              \
    383                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO_ADC12)       \
    384                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1_ADC12)        \
    385                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4_ADC12)        \
    386                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO_ADC12)       \
    387                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15_ADC12)     \
    388                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4_ADC12)        \
    389                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)            \
    390                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO)             \
    391                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2)            \
    392                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH3_ADC12)        \
    393                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)             \
    394                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH1_ADC12)        \
    395                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM6_TRGO_ADC12)       \
    396                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)            \
    397                )                                                                        \
    398                :                                                                        \
    399                (   ((__INJ_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    400                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)             \
    401                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)              \
    402                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH3_ADC34)        \
    403                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH2_ADC34)        \
    404                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4__ADC34)       \
    405                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH4_ADC34)        \
    406                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO__ADC34)      \
    407                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)            \
    408                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO)             \
    409                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2)            \
    410                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH3_ADC34)        \
    411                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)             \
    412                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO__ADC34)      \
    413                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM7_TRGO_ADC34)       \
    414                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)            \
    415                )                                                                        \
    416            )
    417          
    418          #elif defined(STM32F303x8) || defined(STM32F328xx)
    419          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
    420            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
    421             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \
    422             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \
    423             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \
    424             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \
    425             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \
    426             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)                 \
    427             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \
    428             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4)                  \
    429             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)                \
    430             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO)                 \
    431             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_TRGO2)                \
    432             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH3)                  \
    433             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)                 \
    434             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH1)                  \
    435             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM6_TRGO)                 \
    436             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)                \
    437            )
    438          #elif defined(STM32F334x8)
    439          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
    440            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
    441             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \
    442             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \
    443             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \
    444             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \
    445             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \
    446             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \
    447             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)                \
    448             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_HRTIM_TRG2)                \
    449             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_HRTIM_TRG4)                \
    450             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH3)                  \
    451             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)                 \
    452             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH1)                  \
    453             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM6_TRGO)                 \
    454             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)                \
    455            )
    456          #elif defined(STM32F302xC) || defined(STM32F302xE)
    457          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
    458            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
    459             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \
    460             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \
    461             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \
    462             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \
    463             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \
    464             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)                 \
    465             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \
    466             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)                \
    467             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH3)                  \
    468             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_TRGO)                 \
    469             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH1)                  \
    470             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM6_TRGO)                 \
    471             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)                \
    472            )
    473          #elif defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)
    474          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
    475            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
    476             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \
    477             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \
    478             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \
    479             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO2)                \
    480             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM6_TRGO)                 \
    481             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM15_TRGO)                \
    482            )
    483          #endif
    484          
    485          #define IS_LL_ADC_INJ_TRIG_EXT_EDGE(__INJ_TRIG_EXT_EDGE__)                     \
    486            (   ((__INJ_TRIG_EXT_EDGE__) == LL_ADC_INJ_TRIG_EXT_RISING)                  \
    487             || ((__INJ_TRIG_EXT_EDGE__) == LL_ADC_INJ_TRIG_EXT_FALLING)                 \
    488             || ((__INJ_TRIG_EXT_EDGE__) == LL_ADC_INJ_TRIG_EXT_RISINGFALLING)           \
    489            )
    490          
    491          #define IS_LL_ADC_INJ_TRIG_AUTO(__INJ_TRIG_AUTO__)                             \
    492            (   ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_INDEPENDENT)                     \
    493             || ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_FROM_GRP_REGULAR)                \
    494            )
    495          
    496          #define IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(__INJ_SEQ_SCAN_LENGTH__)                 \
    497            (   ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_DISABLE)               \
    498             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS)         \
    499             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS)         \
    500             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS)         \
    501            )
    502          
    503          #define IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(__INJ_SEQ_DISCONT_MODE__)          \
    504            (   ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_DISABLE)           \
    505             || ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_1RANK)             \
    506            )
    507          
    508          #if defined(ADC_MULTIMODE_SUPPORT)
    509          /* Check of parameters for configuration of ADC hierarchical scope:           */
    510          /* multimode.                                                                 */
    511          #define IS_LL_ADC_MULTI_MODE(__MULTI_MODE__)                                   \
    512            (   ((__MULTI_MODE__) == LL_ADC_MULTI_INDEPENDENT)                           \
    513             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIMULT)                       \
    514             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTERL)                       \
    515             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_SIMULT)                       \
    516             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_ALTERN)                       \
    517             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM)                  \
    518             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT)                  \
    519             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM)                  \
    520            )
    521          
    522          #define IS_LL_ADC_MULTI_DMA_TRANSFER(__MULTI_DMA_TRANSFER__)                   \
    523            (   ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_EACH_ADC)              \
    524             || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_LIMIT_RES12_10B)       \
    525             || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_LIMIT_RES8_6B)         \
    526             || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_UNLMT_RES12_10B)       \
    527             || ((__MULTI_DMA_TRANSFER__) == LL_ADC_MULTI_REG_DMA_UNLMT_RES8_6B)         \
    528            )
    529          
    530          #define IS_LL_ADC_MULTI_TWOSMP_DELAY(__MULTI_TWOSMP_DELAY__)                   \
    531            (   ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE)           \
    532             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_2CYCLES)          \
    533             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_3CYCLES)          \
    534             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_4CYCLES)          \
    535             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES)          \
    536             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_6CYCLES)          \
    537             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_7CYCLES)          \
    538             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_8CYCLES)          \
    539             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_9CYCLES)          \
    540             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_10CYCLES)         \
    541             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_11CYCLES)         \
    542             || ((__MULTI_TWOSMP_DELAY__) == LL_ADC_MULTI_TWOSMP_DELAY_12CYCLES)         \
    543            )
    544          
    545          #define IS_LL_ADC_MULTI_MASTER_SLAVE(__MULTI_MASTER_SLAVE__)                   \
    546            (   ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_MASTER)                        \
    547             || ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_SLAVE)                         \
    548             || ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_MASTER_SLAVE)                  \
    549            )
    550          
    551          #endif /* ADC_MULTIMODE_SUPPORT */
    552          /**
    553            * @}
    554            */
    555          
    556          
    557          /* Private function prototypes -----------------------------------------------*/
    558          
    559          /* Exported functions --------------------------------------------------------*/
    560          /** @addtogroup ADC_LL_Exported_Functions
    561            * @{
    562            */
    563          
    564          /** @addtogroup ADC_LL_EF_Init
    565            * @{
    566            */
    567          
    568          /**
    569            * @brief  De-initialize registers of all ADC instances belonging to
    570            *         the same ADC common instance to their default reset values.
    571            * @note   This function is performing a hard reset, using high level
    572            *         clock source RCC ADC reset.
    573            *         Caution: On this STM32 serie, if several ADC instances are available
    574            *         on the selected device, RCC ADC reset will reset
    575            *         all ADC instances belonging to the common ADC instance.
    576            *         To de-initialize only 1 ADC instance, use
    577            *         function @ref LL_ADC_DeInit().
    578            * @param  ADCxy_COMMON ADC common instance
    579            *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
    580            * @retval An ErrorStatus enumeration value:
    581            *          - SUCCESS: ADC common registers are de-initialized
    582            *          - ERROR: not applicable
    583            */

   \                                 In section .text, align 2, keep-with-next
    584          ErrorStatus LL_ADC_CommonDeInit(ADC_Common_TypeDef *ADCxy_COMMON)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
    588            
    589            /* Force reset of ADC clock (core clock) */
    590            #if defined(ADC1) && defined(ADC2) && defined(ADC3) && defined(ADC4)
    591            if(ADCxy_COMMON == ADC12_COMMON)
    592            {
    593              LL_AHB1_GRP1_ForceReset  (LL_AHB1_GRP1_PERIPH_ADC12);
    594            }
    595            else
    596            {
    597              LL_AHB1_GRP1_ForceReset  (LL_AHB1_GRP1_PERIPH_ADC34);
    598            }
    599            #elif defined(ADC1) && defined(ADC2)
    600            LL_AHB1_GRP1_ForceReset  (LL_AHB1_GRP1_PERIPH_ADC12);
    601            #elif defined(ADC1)
    602            LL_AHB1_GRP1_ForceReset  (LL_AHB1_GRP1_PERIPH_ADC1);
   \                     LL_ADC_CommonDeInit: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable4  ;; 0x40021028
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \        0x8   0x6001             STR      R1,[R0, #+0]
    603            #endif
    604            
    605            /* Release reset of ADC clock (core clock) */
    606            #if defined(ADC1) && defined(ADC2) && defined(ADC3) && defined(ADC4)
    607            if(ADCxy_COMMON == ADC12_COMMON)
    608            {
    609              LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_ADC12);
    610            }
    611            else
    612            {
    613              LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_ADC34);
    614            }
    615            #elif defined(ADC1) && defined(ADC2)
    616            LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_ADC12);
    617            #elif defined(ADC1)
    618            LL_AHB1_GRP1_ReleaseReset(LL_AHB1_GRP1_PERIPH_ADC1);
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   \        0xC   0xF022 0x5280      BIC      R2,R2,#0x10000000
   \       0x10   0x6002             STR      R2,[R0, #+0]
    619            #endif
    620            
    621            return SUCCESS;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
    622          }
    623          
    624          /**
    625            * @brief  Initialize some features of ADC common parameters
    626            *         (all ADC instances belonging to the same ADC common instance)
    627            *         and multimode (for devices with several ADC instances available).
    628            * @note   The setting of ADC common parameters is conditioned to
    629            *         ADC instances state:
    630            *         All ADC instances belonging to the same ADC common instance
    631            *         must be disabled.
    632            * @param  ADCxy_COMMON ADC common instance
    633            *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
    634            * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure
    635            * @retval An ErrorStatus enumeration value:
    636            *          - SUCCESS: ADC common registers are initialized
    637            *          - ERROR: ADC common registers are not initialized
    638            */

   \                                 In section .text, align 2, keep-with-next
    639          ErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
    640          {
   \                     LL_ADC_CommonInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    641            ErrorStatus status = SUCCESS;
    642            
    643            /* Check the parameters */
    644            assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
    645            assert_param(IS_LL_ADC_COMMON_CLOCK(ADC_CommonInitStruct->CommonClock));
    646            
    647          #if defined(ADC_MULTIMODE_SUPPORT)
    648            assert_param(IS_LL_ADC_MULTI_MODE(ADC_CommonInitStruct->Multimode));
    649            if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
    650            {
    651              assert_param(IS_LL_ADC_MULTI_DMA_TRANSFER(ADC_CommonInitStruct->MultiDMATransfer));
    652              assert_param(IS_LL_ADC_MULTI_TWOSMP_DELAY(ADC_CommonInitStruct->MultiTwoSamplingDelay));
    653            }
    654          #endif /* ADC_MULTIMODE_SUPPORT */
    655          
    656            /* Note: Hardware constraint (refer to description of functions             */
    657            /*       "LL_ADC_SetCommonXXX()" and "LL_ADC_SetMultiXXX()"):               */
    658            /*       On this STM32 serie, setting of these features is conditioned to   */
    659            /*       ADC state:                                                         */
    660            /*       All ADC instances of the ADC common group must be disabled.        */
    661            if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(ADCxy_COMMON) == 0U)
   \        0x2   0x....             LDR.N    R3,??DataTable4_1  ;; 0x50000008
   \        0x4   0x681B             LDR      R3,[R3, #+0]
   \        0x6   0x4602             MOV      R2,R0
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x07DC             LSLS     R4,R3,#+31
   \        0xC   0xD406             BMI.N    ??LL_ADC_CommonInit_0
    662            {
    663              /* Configuration of ADC hierarchical scope:                               */
    664              /*  - common to several ADC                                               */
    665              /*    (all ADC instances belonging to the same ADC common instance)       */
    666              /*    - Set ADC clock (conversion clock)                                  */
    667              /*  - multimode (if several ADC instances available on the                */
    668              /*    selected device)                                                    */
    669              /*    - Set ADC multimode configuration                                   */
    670              /*    - Set ADC multimode DMA transfer                                    */
    671              /*    - Set ADC multimode: delay between 2 sampling phases                */
    672          #if defined(ADC_MULTIMODE_SUPPORT)
    673              if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
    674              {
    675                MODIFY_REG(ADCxy_COMMON->CCR,
    676                             ADC_CCR_CKMODE
    677                           | ADC_CCR_DUAL
    678                           | ADC_CCR_MDMA
    679                           | ADC_CCR_DELAY
    680                          ,
    681                             ADC_CommonInitStruct->CommonClock
    682                           | ADC_CommonInitStruct->Multimode
    683                           | ADC_CommonInitStruct->MultiDMATransfer
    684                           | ADC_CommonInitStruct->MultiTwoSamplingDelay
    685                          );
    686              }
    687              else
    688              {
    689                MODIFY_REG(ADCxy_COMMON->CCR,
    690                             ADC_CCR_CKMODE
    691                           | ADC_CCR_DUAL
    692                           | ADC_CCR_MDMA
    693                           | ADC_CCR_DELAY
    694                          ,
    695                             ADC_CommonInitStruct->CommonClock
    696                           | LL_ADC_MULTI_INDEPENDENT
    697                          );
    698              }
    699          #else
    700              LL_ADC_SetCommonClock(ADCxy_COMMON, ADC_CommonInitStruct->CommonClock);
   \        0xE   0x6893             LDR      R3,[R2, #+8]
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0xF423 0x3340      BIC      R3,R3,#0x30000
   \       0x16   0x430B             ORRS     R3,R1,R3
   \       0x18   0x6093             STR      R3,[R2, #+8]
    701          #endif
    702            }
   \       0x1A   0xBD10             POP      {R4,PC}
    703            else
    704            {
    705              /* Initialization error: One or several ADC instances belonging to        */
    706              /* the same ADC common instance are not disabled.                         */
    707              status = ERROR;
   \                     ??LL_ADC_CommonInit_0: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
    708            }
    709            
    710            return status;
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    711          }
    712          
    713          /**
    714            * @brief  Set each @ref LL_ADC_CommonInitTypeDef field to default value.
    715            * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure
    716            *                              whose fields will be set to default values.
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          void LL_ADC_CommonStructInit(LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
    720          {
    721            /* Set ADC_CommonInitStruct fields to default values */
    722            /* Set fields of ADC common */
    723            /* (all ADC instances belonging to the same ADC common instance) */
    724            ADC_CommonInitStruct->CommonClock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;
   \                     LL_ADC_CommonStructInit: (+1)
   \        0x0   0xF44F 0x3100      MOV      R1,#+131072
   \        0x4   0x6001             STR      R1,[R0, #+0]
    725            
    726          #if defined(ADC_MULTIMODE_SUPPORT)
    727            /* Set fields of ADC multimode */
    728            ADC_CommonInitStruct->Multimode             = LL_ADC_MULTI_INDEPENDENT;
    729            ADC_CommonInitStruct->MultiDMATransfer      = LL_ADC_MULTI_REG_DMA_EACH_ADC;
    730            ADC_CommonInitStruct->MultiTwoSamplingDelay = LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE;
    731          #endif /* ADC_MULTIMODE_SUPPORT */
    732          }
   \        0x6   0x4770             BX       LR               ;; return
    733          
    734          /**
    735            * @brief  De-initialize registers of the selected ADC instance
    736            *         to their default reset values.
    737            * @note   To reset all ADC instances quickly (perform a hard reset),
    738            *         use function @ref LL_ADC_CommonDeInit().
    739            * @note   If this functions returns error status, it means that ADC instance
    740            *         is in an unknown state.
    741            *         In this case, perform a hard reset using high level
    742            *         clock source RCC ADC reset.
    743            *         Caution: On this STM32 serie, if several ADC instances are available
    744            *         on the selected device, RCC ADC reset will reset
    745            *         all ADC instances belonging to the common ADC instance.
    746            *         Refer to function @ref LL_ADC_CommonDeInit().
    747            * @param  ADCx ADC instance
    748            * @retval An ErrorStatus enumeration value:
    749            *          - SUCCESS: ADC registers are de-initialized
    750            *          - ERROR: ADC registers are not de-initialized
    751            */

   \                                 In section .text, align 2, keep-with-next
    752          ErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx)
    753          {
   \                     LL_ADC_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4601             MOV      R1,R0
    754            ErrorStatus status = SUCCESS;
   \        0x4   0x2200             MOVS     R2,#+0
    755            
    756            __IO uint32_t timeout_cpu_cycles = 0U;
   \        0x6   0x9200             STR      R2,[SP, #+0]
    757            
    758            /* Check the parameters */
    759            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
    760            
    761            /* Disable ADC instance if not already disabled.                            */
    762            if(LL_ADC_IsEnabled(ADCx) == 1U)
   \        0x8   0x688B             LDR      R3,[R1, #+8]
   \        0xA   0x07D8             LSLS     R0,R3,#+31
   \        0xC   0xD547             BPL.N    ??LL_ADC_DeInit_0
    763            {
    764              /* Set ADC group regular trigger source to SW start to ensure to not      */
    765              /* have an external trigger event occurring during the conversion stop    */
    766              /* ADC disable process.                                                   */
    767              LL_ADC_REG_SetTriggerSource(ADCx, LL_ADC_REG_TRIG_SOFTWARE);
   \        0xE   0x68CB             LDR      R3,[R1, #+12]
   \       0x10   0xF423 0x637C      BIC      R3,R3,#0xFC0
   \       0x14   0x60CB             STR      R3,[R1, #+12]
    768              
    769              /* Stop potential ADC conversion on going on ADC group regular.           */
    770              if(LL_ADC_REG_IsConversionOngoing(ADCx) != 0U)
   \       0x16   0x6888             LDR      R0,[R1, #+8]
   \       0x18   0x....             LDR.N    R3,??DataTable4_2  ;; 0x7fffffc0
   \       0x1A   0x0744             LSLS     R4,R0,#+29
   \       0x1C   0xD507             BPL.N    ??LL_ADC_DeInit_1
    771              {
    772                if(LL_ADC_REG_IsStopConversionOngoing(ADCx) == 0U)
   \       0x1E   0x6888             LDR      R0,[R1, #+8]
   \       0x20   0x06C4             LSLS     R4,R0,#+27
   \       0x22   0xD404             BMI.N    ??LL_ADC_DeInit_1
    773                {
    774                  LL_ADC_REG_StopConversion(ADCx);
   \       0x24   0x6888             LDR      R0,[R1, #+8]
   \       0x26   0x4018             ANDS     R0,R3,R0
   \       0x28   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x2C   0x6088             STR      R0,[R1, #+8]
    775                }
    776              }
    777              
    778              /* Set ADC group injected trigger source to SW start to ensure to not     */
    779              /* have an external trigger event occurring during the conversion stop    */
    780              /* ADC disable process.                                                   */
    781              LL_ADC_INJ_SetTriggerSource(ADCx, LL_ADC_INJ_TRIG_SOFTWARE);
   \                     ??LL_ADC_DeInit_1: (+1)
   \       0x2E   0x6CC8             LDR      R0,[R1, #+76]
   \       0x30   0xF020 0x00FC      BIC      R0,R0,#0xFC
   \       0x34   0x64C8             STR      R0,[R1, #+76]
    782              
    783              /* Stop potential ADC conversion on going on ADC group injected.          */
    784              if(LL_ADC_INJ_IsConversionOngoing(ADCx) != 0U)
   \       0x36   0x6888             LDR      R0,[R1, #+8]
   \       0x38   0x0704             LSLS     R4,R0,#+28
   \       0x3A   0xD507             BPL.N    ??LL_ADC_DeInit_2
    785              {
    786                if(LL_ADC_INJ_IsStopConversionOngoing(ADCx) == 0U)
   \       0x3C   0x6888             LDR      R0,[R1, #+8]
   \       0x3E   0x0684             LSLS     R4,R0,#+26
   \       0x40   0xD404             BMI.N    ??LL_ADC_DeInit_2
    787                {
    788                  LL_ADC_INJ_StopConversion(ADCx);
   \       0x42   0x6888             LDR      R0,[R1, #+8]
   \       0x44   0x4018             ANDS     R0,R3,R0
   \       0x46   0xF040 0x0020      ORR      R0,R0,#0x20
   \       0x4A   0x6088             STR      R0,[R1, #+8]
    789                }
    790              }
    791              
    792              /* Wait for ADC conversions are effectively stopped                       */
    793              timeout_cpu_cycles = ADC_TIMEOUT_STOP_CONVERSION_CPU_CYCLES;
   \                     ??LL_ADC_DeInit_2: (+1)
   \       0x4C   0xF44F 0x4400      MOV      R4,#+32768
   \       0x50   0x9400             STR      R4,[SP, #+0]
   \       0x52   0xE004             B.N      ??LL_ADC_DeInit_3
    794              while ((  LL_ADC_REG_IsStopConversionOngoing(ADCx) 
    795                      | LL_ADC_INJ_IsStopConversionOngoing(ADCx)) == 1U)
    796              {
    797                if(timeout_cpu_cycles-- == 0U)
   \                     ??LL_ADC_DeInit_4: (+1)
   \       0x54   0x9800             LDR      R0,[SP, #+0]
   \       0x56   0x1E45             SUBS     R5,R0,#+1
   \       0x58   0x9500             STR      R5,[SP, #+0]
   \       0x5A   0xB900             CBNZ.N   R0,??LL_ADC_DeInit_3
    798                {
    799                  /* Time-out error */
    800                  status = ERROR;
   \       0x5C   0x2201             MOVS     R2,#+1
    801                }
    802              }
   \                     ??LL_ADC_DeInit_3: (+1)
   \       0x5E   0x6888             LDR      R0,[R1, #+8]
   \       0x60   0x688D             LDR      R5,[R1, #+8]
   \       0x62   0x0900             LSRS     R0,R0,#+4
   \       0x64   0x096D             LSRS     R5,R5,#+5
   \       0x66   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x6A   0xF005 0x0501      AND      R5,R5,#0x1
   \       0x6E   0x4328             ORRS     R0,R5,R0
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xD0EF             BEQ.N    ??LL_ADC_DeInit_4
    803              
    804              /* Flush group injected contexts queue (register JSQR):                   */
    805              /* Note: Bit JQM must be set to empty the contexts queue (otherwise       */
    806              /*       contexts queue is maintained with the last active context).      */
    807              LL_ADC_INJ_SetQueueMode(ADCx, LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY);
   \       0x74   0x68C8             LDR      R0,[R1, #+12]
   \       0x76   0xF440 0x1000      ORR      R0,R0,#0x200000
   \       0x7A   0x60C8             STR      R0,[R1, #+12]
    808              
    809              /* Disable the ADC instance */
    810              LL_ADC_Disable(ADCx);
   \       0x7C   0x6888             LDR      R0,[R1, #+8]
   \       0x7E   0x4003             ANDS     R3,R3,R0
   \       0x80   0xF043 0x0302      ORR      R3,R3,#0x2
   \       0x84   0x608B             STR      R3,[R1, #+8]
    811              
    812              /* Wait for ADC instance is effectively disabled */
    813              timeout_cpu_cycles = ADC_TIMEOUT_DISABLE_CPU_CYCLES;
   \       0x86   0x9400             STR      R4,[SP, #+0]
   \       0x88   0xE004             B.N      ??LL_ADC_DeInit_5
    814              while (LL_ADC_IsDisableOngoing(ADCx) == 1U)
    815              {
    816                if(timeout_cpu_cycles-- == 0U)
   \                     ??LL_ADC_DeInit_6: (+1)
   \       0x8A   0x9800             LDR      R0,[SP, #+0]
   \       0x8C   0x1E43             SUBS     R3,R0,#+1
   \       0x8E   0x9300             STR      R3,[SP, #+0]
   \       0x90   0xB900             CBNZ.N   R0,??LL_ADC_DeInit_5
    817                {
    818                  /* Time-out error */
    819                  status = ERROR;
   \       0x92   0x2201             MOVS     R2,#+1
    820                }
    821              }
   \                     ??LL_ADC_DeInit_5: (+1)
   \       0x94   0x6888             LDR      R0,[R1, #+8]
   \       0x96   0x0840             LSRS     R0,R0,#+1
   \       0x98   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x9C   0xD1F5             BNE.N    ??LL_ADC_DeInit_6
    822            }
    823            
    824            /* Check whether ADC state is compliant with expected state */
    825            if(READ_BIT(ADCx->CR,
    826                        (  ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART
    827                         | ADC_CR_ADDIS | ADC_CR_ADEN                                     )
    828                       )
    829               == 0U)
   \                     ??LL_ADC_DeInit_0: (+1)
   \       0x9E   0x6888             LDR      R0,[R1, #+8]
   \       0xA0   0xF010 0x0F3F      TST      R0,#0x3F
   \       0xA4   0xD16B             BNE.N    ??LL_ADC_DeInit_7
    830            {
    831              /* ========== Reset ADC registers ========== */
    832              /* Reset register IER */
    833              CLEAR_BIT(ADCx->IER,
    834                        (  LL_ADC_IT_ADRDY
    835                         | LL_ADC_IT_EOC
    836                         | LL_ADC_IT_EOS
    837                         | LL_ADC_IT_OVR
    838                         | LL_ADC_IT_EOSMP
    839                         | LL_ADC_IT_JEOC
    840                         | LL_ADC_IT_JEOS
    841                         | LL_ADC_IT_JQOVF
    842                         | LL_ADC_IT_AWD1
    843                         | LL_ADC_IT_AWD2
    844                         | LL_ADC_IT_AWD3 )
    845                       );
   \       0xA6   0x6848             LDR      R0,[R1, #+4]
   \       0xA8   0x0AC0             LSRS     R0,R0,#+11
   \       0xAA   0x02C0             LSLS     R0,R0,#+11
   \       0xAC   0x6048             STR      R0,[R1, #+4]
    846              
    847              /* Reset register ISR */
    848              SET_BIT(ADCx->ISR,
    849                      (  LL_ADC_FLAG_ADRDY
    850                       | LL_ADC_FLAG_EOC
    851                       | LL_ADC_FLAG_EOS
    852                       | LL_ADC_FLAG_OVR
    853                       | LL_ADC_FLAG_EOSMP
    854                       | LL_ADC_FLAG_JEOC
    855                       | LL_ADC_FLAG_JEOS
    856                       | LL_ADC_FLAG_JQOVF
    857                       | LL_ADC_FLAG_AWD1
    858                       | LL_ADC_FLAG_AWD2
    859                       | LL_ADC_FLAG_AWD3 )
    860                     );
   \       0xAE   0xF240 0x70FF      MOVW     R0,#+2047
   \       0xB2   0x680B             LDR      R3,[R1, #+0]
   \       0xB4   0x4303             ORRS     R3,R0,R3
   \       0xB6   0x600B             STR      R3,[R1, #+0]
    861              
    862              /* Reset register CR */
    863              /*  - Bits ADC_CR_JADSTP, ADC_CR_ADSTP, ADC_CR_JADSTART, ADC_CR_ADSTART,  */
    864              /*    ADC_CR_ADCAL, ADC_CR_ADDIS, ADC_CR_ADEN are in                      */
    865              /*    access mode "read-set": no direct reset applicable.                 */
    866              /*  - Reset Calibration mode to default setting (single ended).           */
    867              /*  - Disable ADC internal voltage regulator.                             */
    868              /*    Note: ADC internal voltage regulator disable is conditioned to      */
    869              /*          ADC state disabled: already done above.                       */
    870              /* Sequence to disable voltage regulator:                                 */
    871              /* 1. Set the intermediate state before moving the ADC voltage regulator  */
    872              /*    to disable state.                                                   */
    873              CLEAR_BIT(ADCx->CR, ADC_CR_ADVREGEN_1 | ADC_CR_ADVREGEN_0 | ADC_CR_ADCALDIF);
   \       0xB8   0x688C             LDR      R4,[R1, #+8]
   \       0xBA   0xF024 0x44E0      BIC      R4,R4,#0x70000000
   \       0xBE   0x608C             STR      R4,[R1, #+8]
    874              /* 2. Set ADVREGEN bits to 0x10 */
    875              SET_BIT(ADCx->CR, ADC_CR_ADVREGEN_1);
   \       0xC0   0x6888             LDR      R0,[R1, #+8]
   \       0xC2   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \       0xC6   0x6088             STR      R0,[R1, #+8]
    876              
    877              /* Reset register CFGR */
    878              CLEAR_BIT(ADCx->CFGR,
    879                        (  ADC_CFGR_AWD1CH  | ADC_CFGR_JAUTO   | ADC_CFGR_JAWD1EN
    880                         | ADC_CFGR_AWD1EN  | ADC_CFGR_AWD1SGL | ADC_CFGR_JQM
    881                         | ADC_CFGR_JDISCEN | ADC_CFGR_DISCNUM | ADC_CFGR_DISCEN
    882                         | ADC_CFGR_AUTDLY  | ADC_CFGR_CONT    | ADC_CFGR_OVRMOD
    883                         | ADC_CFGR_EXTEN   | ADC_CFGR_EXTSEL  | ADC_CFGR_ALIGN
    884                         | ADC_CFGR_RES     | ADC_CFGR_DMACFG  | ADC_CFGR_DMAEN  )
    885                       );
   \       0xC8   0x68CB             LDR      R3,[R1, #+12]
   \       0xCA   0x....             LDR.N    R0,??DataTable4_3  ;; 0x80008004
   \       0xCC   0x4003             ANDS     R3,R0,R3
   \       0xCE   0x60CB             STR      R3,[R1, #+12]
    886              
    887              /* Reset register SMPR1 */
    888              CLEAR_BIT(ADCx->SMPR1,
    889                        (  ADC_SMPR1_SMP9 | ADC_SMPR1_SMP8 | ADC_SMPR1_SMP7
    890                         | ADC_SMPR1_SMP6 | ADC_SMPR1_SMP5 | ADC_SMPR1_SMP4
    891                         | ADC_SMPR1_SMP3 | ADC_SMPR1_SMP2 | ADC_SMPR1_SMP1)
    892                       );
   \       0xD0   0x694B             LDR      R3,[R1, #+20]
   \       0xD2   0xF36F 0x03DD      BFC      R3,#+3,#+27
   \       0xD6   0x614B             STR      R3,[R1, #+20]
    893              
    894              /* Reset register SMPR2 */
    895              CLEAR_BIT(ADCx->SMPR2,
    896                        (  ADC_SMPR2_SMP18 | ADC_SMPR2_SMP17 | ADC_SMPR2_SMP16
    897                         | ADC_SMPR2_SMP15 | ADC_SMPR2_SMP14 | ADC_SMPR2_SMP13
    898                         | ADC_SMPR2_SMP12 | ADC_SMPR2_SMP11 | ADC_SMPR2_SMP10)
    899                       );
   \       0xD8   0x6988             LDR      R0,[R1, #+24]
   \       0xDA   0xF000 0x4078      AND      R0,R0,#0xF8000000
   \       0xDE   0x6188             STR      R0,[R1, #+24]
    900              
    901              /* Reset register TR1 */
    902              MODIFY_REG(ADCx->TR1, ADC_TR1_HT1 | ADC_TR1_LT1, ADC_TR1_HT1);
   \       0xE0   0x6A0B             LDR      R3,[R1, #+32]
   \       0xE2   0x....             LDR.N    R0,??DataTable4_4  ;; 0xfff0000
   \       0xE4   0xF003 0x23F0      AND      R3,R3,#0xF000F000
   \       0xE8   0x4303             ORRS     R3,R0,R3
   \       0xEA   0x620B             STR      R3,[R1, #+32]
    903              
    904              /* Reset register TR2 */
    905              MODIFY_REG(ADCx->TR2, ADC_TR2_HT2 | ADC_TR2_LT2, ADC_TR2_HT2);
   \       0xEC   0x6A4B             LDR      R3,[R1, #+36]
   \       0xEE   0xF023 0x13FF      BIC      R3,R3,#0xFF00FF
   \       0xF2   0xF443 0x037F      ORR      R3,R3,#0xFF0000
   \       0xF6   0x624B             STR      R3,[R1, #+36]
    906              
    907              /* Reset register TR3 */
    908              MODIFY_REG(ADCx->TR3, ADC_TR3_HT3 | ADC_TR3_LT3, ADC_TR3_HT3);
   \       0xF8   0x6A88             LDR      R0,[R1, #+40]
   \       0xFA   0xF020 0x10FF      BIC      R0,R0,#0xFF00FF
   \       0xFE   0xF440 0x007F      ORR      R0,R0,#0xFF0000
   \      0x102   0x6288             STR      R0,[R1, #+40]
    909              
    910              /* Reset register SQR1 */
    911              CLEAR_BIT(ADCx->SQR1,
    912                        (  ADC_SQR1_SQ4 | ADC_SQR1_SQ3 | ADC_SQR1_SQ2
    913                         | ADC_SQR1_SQ1 | ADC_SQR1_L)
    914                       );
   \      0x104   0x6B0B             LDR      R3,[R1, #+48]
   \      0x106   0x....             LDR.N    R0,??DataTable4_5  ;; 0xe0820830
   \      0x108   0x4003             ANDS     R3,R0,R3
   \      0x10A   0x630B             STR      R3,[R1, #+48]
    915              
    916              /* Reset register SQR2 */
    917              CLEAR_BIT(ADCx->SQR2,
    918                        (  ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7
    919                         | ADC_SQR2_SQ6 | ADC_SQR2_SQ5)
    920                       );
   \      0x10C   0x....             LDR.N    R0,??DataTable4_6  ;; 0xe0820820
   \      0x10E   0x6B4B             LDR      R3,[R1, #+52]
   \      0x110   0x4003             ANDS     R3,R0,R3
   \      0x112   0x634B             STR      R3,[R1, #+52]
    921              
    922              /* Reset register SQR3 */
    923              CLEAR_BIT(ADCx->SQR3,
    924                        (  ADC_SQR3_SQ14 | ADC_SQR3_SQ13 | ADC_SQR3_SQ12
    925                         | ADC_SQR3_SQ11 | ADC_SQR3_SQ10)
    926                       );
   \      0x114   0x6B8C             LDR      R4,[R1, #+56]
   \      0x116   0x4020             ANDS     R0,R0,R4
   \      0x118   0x6388             STR      R0,[R1, #+56]
    927              
    928              /* Reset register SQR4 */
    929              CLEAR_BIT(ADCx->SQR4, ADC_SQR4_SQ16 | ADC_SQR4_SQ15);
   \      0x11A   0x6BCB             LDR      R3,[R1, #+60]
   \      0x11C   0x....             LDR.N    R0,??DataTable4_7  ;; 0xfffff820
   \      0x11E   0x4003             ANDS     R3,R0,R3
   \      0x120   0x63CB             STR      R3,[R1, #+60]
    930              
    931              /* Reset register JSQR */
    932              CLEAR_BIT(ADCx->JSQR,
    933                        (  ADC_JSQR_JL
    934                         | ADC_JSQR_JEXTSEL | ADC_JSQR_JEXTEN
    935                         | ADC_JSQR_JSQ4    | ADC_JSQR_JSQ3
    936                         | ADC_JSQR_JSQ2    | ADC_JSQR_JSQ1  )
    937                       );
   \      0x122   0x....             LDR.N    R0,??DataTable4_8  ;; 0x82082000
   \      0x124   0x6CCB             LDR      R3,[R1, #+76]
   \      0x126   0x4003             ANDS     R3,R0,R3
   \      0x128   0x64CB             STR      R3,[R1, #+76]
    938              
    939              /* Flush ADC group injected contexts queue */
    940              SET_BIT(ADCx->CFGR, ADC_CFGR_JQM);
   \      0x12A   0x68CB             LDR      R3,[R1, #+12]
   \      0x12C   0xF443 0x1300      ORR      R3,R3,#0x200000
   \      0x130   0x60CB             STR      R3,[R1, #+12]
    941              CLEAR_BIT(ADCx->CFGR, ADC_CFGR_JQM);
   \      0x132   0x68C8             LDR      R0,[R1, #+12]
   \      0x134   0xF420 0x1000      BIC      R0,R0,#0x200000
   \      0x138   0x60C8             STR      R0,[R1, #+12]
    942              /* Reset register ISR bit JQOVF (set by previous operation on JSQR) */
    943              SET_BIT(ADCx->ISR, LL_ADC_FLAG_JQOVF);
   \      0x13A   0x680B             LDR      R3,[R1, #+0]
    944              
    945              /* Reset register DR */
    946              /* Note: bits in access mode read only, no direct reset applicable */
    947              
    948              /* Reset register OFR1 */
    949              CLEAR_BIT(ADCx->OFR1, ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1);
   \      0x13C   0x....             LDR.N    R0,??DataTable4_9  ;; 0x3fff000
   \      0x13E   0xF443 0x6380      ORR      R3,R3,#0x400
   \      0x142   0x600B             STR      R3,[R1, #+0]
   \      0x144   0x6E0B             LDR      R3,[R1, #+96]
   \      0x146   0x4003             ANDS     R3,R0,R3
   \      0x148   0x660B             STR      R3,[R1, #+96]
    950              /* Reset register OFR2 */
    951              CLEAR_BIT(ADCx->OFR2, ADC_OFR2_OFFSET2_EN | ADC_OFR2_OFFSET2_CH | ADC_OFR2_OFFSET2);
   \      0x14A   0x6E4C             LDR      R4,[R1, #+100]
   \      0x14C   0x4004             ANDS     R4,R0,R4
   \      0x14E   0x664C             STR      R4,[R1, #+100]
    952              /* Reset register OFR3 */
    953              CLEAR_BIT(ADCx->OFR3, ADC_OFR3_OFFSET3_EN | ADC_OFR3_OFFSET3_CH | ADC_OFR3_OFFSET3);
   \      0x150   0x6E8B             LDR      R3,[R1, #+104]
   \      0x152   0x4003             ANDS     R3,R0,R3
   \      0x154   0x668B             STR      R3,[R1, #+104]
    954              /* Reset register OFR4 */
    955              CLEAR_BIT(ADCx->OFR4, ADC_OFR4_OFFSET4_EN | ADC_OFR4_OFFSET4_CH | ADC_OFR4_OFFSET4);
   \      0x156   0x6ECC             LDR      R4,[R1, #+108]
   \      0x158   0x4020             ANDS     R0,R0,R4
   \      0x15A   0x66C8             STR      R0,[R1, #+108]
    956              
    957              /* Reset registers JDR1, JDR2, JDR3, JDR4 */
    958              /* Note: bits in access mode read only, no direct reset applicable */
    959              
    960              /* Reset register AWD2CR */
    961              CLEAR_BIT(ADCx->AWD2CR, ADC_AWD2CR_AWD2CH);
   \      0x15C   0xF101 0x00A0      ADD      R0,R1,#+160
   \      0x160   0x....             LDR.N    R1,??DataTable4_10  ;; 0xfff80001
   \      0x162   0x6803             LDR      R3,[R0, #+0]
   \      0x164   0x400B             ANDS     R3,R1,R3
   \      0x166   0x6003             STR      R3,[R0, #+0]
    962              
    963              /* Reset register AWD3CR */
    964              CLEAR_BIT(ADCx->AWD3CR, ADC_AWD3CR_AWD3CH);
   \      0x168   0x6844             LDR      R4,[R0, #+4]
   \      0x16A   0x400C             ANDS     R4,R1,R4
   \      0x16C   0x6044             STR      R4,[R0, #+4]
    965              
    966              /* Reset register DIFSEL */
    967              CLEAR_BIT(ADCx->DIFSEL, ADC_DIFSEL_DIFSEL);
   \      0x16E   0x6903             LDR      R3,[R0, #+16]
   \      0x170   0x4019             ANDS     R1,R1,R3
   \      0x172   0x6101             STR      R1,[R0, #+16]
    968              
    969              /* Reset register CALFACT */
    970              CLEAR_BIT(ADCx->CALFACT, ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S);
   \      0x174   0x6941             LDR      R1,[R0, #+20]
   \      0x176   0xF021 0x117F      BIC      R1,R1,#0x7F007F
   \      0x17A   0x6141             STR      R1,[R0, #+20]
   \      0x17C   0xE000             B.N      ??LL_ADC_DeInit_8
    971            }
    972            else
    973            {
    974              /* ADC instance is in an unknown state */
    975              /* Need to performing a hard reset of ADC instance, using high level      */
    976              /* clock source RCC ADC reset.                                            */
    977              /* Caution: On this STM32 serie, if several ADC instances are available   */
    978              /*          on the selected device, RCC ADC reset will reset              */
    979              /*          all ADC instances belonging to the common ADC instance.       */
    980              /* Caution: On this STM32 serie, if several ADC instances are available   */
    981              /*          on the selected device, RCC ADC reset will reset              */
    982              /*          all ADC instances belonging to the common ADC instance.       */
    983              status = ERROR;
   \                     ??LL_ADC_DeInit_7: (+1)
   \      0x17E   0x2201             MOVS     R2,#+1
    984            }
    985            
    986            return status;
   \                     ??LL_ADC_DeInit_8: (+1)
   \      0x180   0x4610             MOV      R0,R2
   \      0x182   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    987          }
    988          
    989          /**
    990            * @brief  Initialize some features of ADC instance.
    991            * @note   These parameters have an impact on ADC scope: ADC instance.
    992            *         Affects both group regular and group injected (availability
    993            *         of ADC group injected depends on STM32 families).
    994            *         Refer to corresponding unitary functions into
    995            *         @ref ADC_LL_EF_Configuration_ADC_Instance .
    996            * @note   The setting of these parameters by function @ref LL_ADC_Init()
    997            *         is conditioned to ADC state:
    998            *         ADC instance must be disabled.
    999            *         This condition is applied to all ADC features, for efficiency
   1000            *         and compatibility over all STM32 families. However, the different
   1001            *         features can be set under different ADC state conditions
   1002            *         (setting possible with ADC enabled without conversion on going,
   1003            *         ADC enabled with conversion on going, ...)
   1004            *         Each feature can be updated afterwards with a unitary function
   1005            *         and potentially with ADC in a different state than disabled,
   1006            *         refer to description of each function for setting
   1007            *         conditioned to ADC state.
   1008            * @note   After using this function, some other features must be configured
   1009            *         using LL unitary functions.
   1010            *         The minimum configuration remaining to be done is:
   1011            *          - Set ADC group regular or group injected sequencer:
   1012            *            map channel on the selected sequencer rank.
   1013            *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().
   1014            *          - Set ADC channel sampling time
   1015            *            Refer to function LL_ADC_SetChannelSamplingTime();
   1016            * @param  ADCx ADC instance
   1017            * @param  ADC_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
   1018            * @retval An ErrorStatus enumeration value:
   1019            *          - SUCCESS: ADC registers are initialized
   1020            *          - ERROR: ADC registers are not initialized
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          ErrorStatus LL_ADC_Init(ADC_TypeDef *ADCx, LL_ADC_InitTypeDef *ADC_InitStruct)
   1023          {
   \                     LL_ADC_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4602             MOV      R2,R0
   1024            ErrorStatus status = SUCCESS;
   \        0x4   0x2000             MOVS     R0,#+0
   1025            
   1026            /* Check the parameters */
   1027            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1028            
   1029            assert_param(IS_LL_ADC_RESOLUTION(ADC_InitStruct->Resolution));
   1030            assert_param(IS_LL_ADC_DATA_ALIGN(ADC_InitStruct->DataAlignment));
   1031            assert_param(IS_LL_ADC_LOW_POWER(ADC_InitStruct->LowPowerMode));
   1032            
   1033            /* Note: Hardware constraint (refer to description of this function):       */
   1034            /*       ADC instance must be disabled.                                     */
   1035            if(LL_ADC_IsEnabled(ADCx) == 0U)
   \        0x6   0x6893             LDR      R3,[R2, #+8]
   \        0x8   0x07DB             LSLS     R3,R3,#+31
   \        0xA   0xD40A             BMI.N    ??LL_ADC_Init_0
   1036            {
   1037              /* Configuration of ADC hierarchical scope:                               */
   1038              /*  - ADC instance                                                        */
   1039              /*    - Set ADC data resolution                                           */
   1040              /*    - Set ADC conversion data alignment                                 */
   1041              /*    - Set ADC low power mode                                            */
   1042              MODIFY_REG(ADCx->CFGR,
   1043                           ADC_CFGR_RES
   1044                         | ADC_CFGR_ALIGN
   1045                         | ADC_CFGR_AUTDLY
   1046                        ,
   1047                           ADC_InitStruct->Resolution
   1048                         | ADC_InitStruct->DataAlignment
   1049                         | ADC_InitStruct->LowPowerMode
   1050                        );
   \        0xC   0x68D6             LDR      R6,[R2, #+12]
   \        0xE   0x....             LDR.N    R5,??DataTable4_11  ;; 0xffffbfc7
   \       0x10   0x680C             LDR      R4,[R1, #+0]
   \       0x12   0x684B             LDR      R3,[R1, #+4]
   \       0x14   0x6889             LDR      R1,[R1, #+8]
   \       0x16   0x402E             ANDS     R6,R5,R6
   \       0x18   0x4326             ORRS     R6,R4,R6
   \       0x1A   0x431E             ORRS     R6,R3,R6
   \       0x1C   0x430E             ORRS     R6,R1,R6
   \       0x1E   0x60D6             STR      R6,[R2, #+12]
   \       0x20   0xBD70             POP      {R4-R6,PC}
   1051              
   1052            }
   1053            else
   1054            {
   1055              /* Initialization error: ADC instance is not disabled. */
   1056              status = ERROR;
   \                     ??LL_ADC_Init_0: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   1057            }
   1058            return status;
   \       0x24   0xBD70             POP      {R4-R6,PC}       ;; return
   1059          }
   1060          
   1061          /**
   1062            * @brief  Set each @ref LL_ADC_InitTypeDef field to default value.
   1063            * @param  ADC_InitStruct Pointer to a @ref LL_ADC_InitTypeDef structure
   1064            *                        whose fields will be set to default values.
   1065            * @retval None
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          void LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct)
   1068          {
   1069            /* Set ADC_InitStruct fields to default values */
   1070            /* Set fields of ADC instance */
   1071            ADC_InitStruct->Resolution    = LL_ADC_RESOLUTION_12B;
   \                     LL_ADC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1072            ADC_InitStruct->DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
   \        0x4   0x6041             STR      R1,[R0, #+4]
   1073            ADC_InitStruct->LowPowerMode  = LL_ADC_LP_MODE_NONE;
   \        0x6   0x6081             STR      R1,[R0, #+8]
   1074            
   1075          }
   \        0x8   0x4770             BX       LR               ;; return
   1076          
   1077          /**
   1078            * @brief  Initialize some features of ADC group regular.
   1079            * @note   These parameters have an impact on ADC scope: ADC group regular.
   1080            *         Refer to corresponding unitary functions into
   1081            *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
   1082            *         (functions with prefix "REG").
   1083            * @note   The setting of these parameters by function @ref LL_ADC_Init()
   1084            *         is conditioned to ADC state:
   1085            *         ADC instance must be disabled.
   1086            *         This condition is applied to all ADC features, for efficiency
   1087            *         and compatibility over all STM32 families. However, the different
   1088            *         features can be set under different ADC state conditions
   1089            *         (setting possible with ADC enabled without conversion on going,
   1090            *         ADC enabled with conversion on going, ...)
   1091            *         Each feature can be updated afterwards with a unitary function
   1092            *         and potentially with ADC in a different state than disabled,
   1093            *         refer to description of each function for setting
   1094            *         conditioned to ADC state.
   1095            * @note   After using this function, other features must be configured
   1096            *         using LL unitary functions.
   1097            *         The minimum configuration remaining to be done is:
   1098            *          - Set ADC group regular or group injected sequencer:
   1099            *            map channel on the selected sequencer rank.
   1100            *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().
   1101            *          - Set ADC channel sampling time
   1102            *            Refer to function LL_ADC_SetChannelSamplingTime();
   1103            * @param  ADCx ADC instance
   1104            * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
   1105            * @retval An ErrorStatus enumeration value:
   1106            *          - SUCCESS: ADC registers are initialized
   1107            *          - ERROR: ADC registers are not initialized
   1108            */

   \                                 In section .text, align 2, keep-with-next
   1109          ErrorStatus LL_ADC_REG_Init(ADC_TypeDef *ADCx, LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
   1110          {
   \                     LL_ADC_REG_Init: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   1111            ErrorStatus status = SUCCESS;
   1112            
   1113            /* Check the parameters */
   1114            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1115          #if defined(ADC1) && defined(ADC2) && defined(ADC3) && defined(ADC4)
   1116            assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADCx, ADC_REG_InitStruct->TriggerSource));
   1117          #else
   1118            assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADC_REG_InitStruct->TriggerSource));
   1119          #endif
   1120            assert_param(IS_LL_ADC_REG_SEQ_SCAN_LENGTH(ADC_REG_InitStruct->SequencerLength));
   1121            if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   1122            {
   1123              assert_param(IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(ADC_REG_InitStruct->SequencerDiscont));
   1124            }
   1125            assert_param(IS_LL_ADC_REG_CONTINUOUS_MODE(ADC_REG_InitStruct->ContinuousMode));
   1126            assert_param(IS_LL_ADC_REG_DMA_TRANSFER(ADC_REG_InitStruct->DMATransfer));
   1127            assert_param(IS_LL_ADC_REG_OVR_DATA_BEHAVIOR(ADC_REG_InitStruct->Overrun));
   1128            
   1129            /* Note: Hardware constraint (refer to description of this function):       */
   1130            /*       ADC instance must be disabled.                                     */
   1131            if(LL_ADC_IsEnabled(ADCx) == 0U)
   \        0x2   0x6883             LDR      R3,[R0, #+8]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x07DC             LSLS     R4,R3,#+31
   \        0x8   0xD41D             BMI.N    ??LL_ADC_REG_Init_0
   1132            {
   1133              /* Configuration of ADC hierarchical scope:                               */
   1134              /*  - ADC group regular                                                   */
   1135              /*    - Set ADC group regular trigger source                              */
   1136              /*    - Set ADC group regular sequencer length                            */
   1137              /*    - Set ADC group regular sequencer discontinuous mode                */
   1138              /*    - Set ADC group regular continuous mode                             */
   1139              /*    - Set ADC group regular conversion data transfer: no transfer or    */
   1140              /*      transfer by DMA, and DMA requests mode                            */
   1141              /*    - Set ADC group regular overrun behavior                            */
   1142              /* Note: On this STM32 serie, ADC trigger edge is set to value 0x0 by     */
   1143              /*       setting of trigger source to SW start.                           */
   1144              if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   \        0xA   0x694C             LDR      R4,[R1, #+20]
   \        0xC   0x690D             LDR      R5,[R1, #+16]
   \        0xE   0x68CE             LDR      R6,[R1, #+12]
   \       0x10   0x680F             LDR      R7,[R1, #+0]
   \       0x12   0x684B             LDR      R3,[R1, #+4]
   \       0x14   0x....'....        LDR.W    R12,??DataTable4_12  ;; 0xfff0c03c
   \       0x18   0xB133             CBZ.N    R3,??LL_ADC_REG_Init_1
   1145              {
   1146                MODIFY_REG(ADCx->CFGR,
   1147                             ADC_CFGR_EXTSEL
   1148                           | ADC_CFGR_EXTEN
   1149                           | ADC_CFGR_DISCEN
   1150                           | ADC_CFGR_DISCNUM
   1151                           | ADC_CFGR_CONT
   1152                           | ADC_CFGR_DMAEN
   1153                           | ADC_CFGR_DMACFG
   1154                           | ADC_CFGR_OVRMOD
   1155                          ,
   1156                             ADC_REG_InitStruct->TriggerSource
   1157                           | ADC_REG_InitStruct->SequencerDiscont
   1158                           | ADC_REG_InitStruct->ContinuousMode
   1159                           | ADC_REG_InitStruct->DMATransfer
   1160                           | ADC_REG_InitStruct->Overrun
   1161                          );
   \       0x1A   0x68C3             LDR      R3,[R0, #+12]
   \       0x1C   0xEA0C 0x0303      AND      R3,R12,R3
   \       0x20   0x431F             ORRS     R7,R7,R3
   \       0x22   0x688B             LDR      R3,[R1, #+8]
   \       0x24   0x431F             ORRS     R7,R3,R7
   \       0x26   0xE003             B.N      ??LL_ADC_REG_Init_2
   1162              }
   1163              else
   1164              {
   1165                MODIFY_REG(ADCx->CFGR,
   1166                             ADC_CFGR_EXTSEL
   1167                           | ADC_CFGR_EXTEN
   1168                           | ADC_CFGR_DISCEN
   1169                           | ADC_CFGR_DISCNUM
   1170                           | ADC_CFGR_CONT
   1171                           | ADC_CFGR_DMAEN
   1172                           | ADC_CFGR_DMACFG
   1173                           | ADC_CFGR_OVRMOD
   1174                          ,
   1175                             ADC_REG_InitStruct->TriggerSource
   1176                           | LL_ADC_REG_SEQ_DISCONT_DISABLE
   1177                           | ADC_REG_InitStruct->ContinuousMode
   1178                           | ADC_REG_InitStruct->DMATransfer
   1179                           | ADC_REG_InitStruct->Overrun
   1180                          );
   \                     ??LL_ADC_REG_Init_1: (+1)
   \       0x28   0x68C3             LDR      R3,[R0, #+12]
   \       0x2A   0xEA0C 0x0303      AND      R3,R12,R3
   \       0x2E   0x431F             ORRS     R7,R7,R3
   \                     ??LL_ADC_REG_Init_2: (+1)
   \       0x30   0x433E             ORRS     R6,R6,R7
   \       0x32   0x4335             ORRS     R5,R5,R6
   \       0x34   0x432C             ORRS     R4,R4,R5
   \       0x36   0x60C4             STR      R4,[R0, #+12]
   1181              }
   1182              
   1183              /* Set ADC group regular sequencer length and scan direction */
   1184              LL_ADC_REG_SetSequencerLength(ADCx, ADC_REG_InitStruct->SequencerLength);
   \       0x38   0x6B03             LDR      R3,[R0, #+48]
   \       0x3A   0x6849             LDR      R1,[R1, #+4]
   \       0x3C   0x091B             LSRS     R3,R3,#+4
   \       0x3E   0xEA41 0x1303      ORR      R3,R1,R3, LSL #+4
   \       0x42   0x6303             STR      R3,[R0, #+48]
   1185            }
   \       0x44   0xE000             B.N      ??LL_ADC_REG_Init_3
   1186            else
   1187            {
   1188              /* Initialization error: ADC instance is not disabled. */
   1189              status = ERROR;
   \                     ??LL_ADC_REG_Init_0: (+1)
   \       0x46   0x2201             MOVS     R2,#+1
   1190            }
   1191            return status;
   \                     ??LL_ADC_REG_Init_3: (+1)
   \       0x48   0x4610             MOV      R0,R2
   \       0x4A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1192          }
   1193          
   1194          /**
   1195            * @brief  Set each @ref LL_ADC_REG_InitTypeDef field to default value.
   1196            * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
   1197            *                            whose fields will be set to default values.
   1198            * @retval None
   1199            */

   \                                 In section .text, align 2, keep-with-next
   1200          void LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
   1201          {
   1202            /* Set ADC_REG_InitStruct fields to default values */
   1203            /* Set fields of ADC group regular */
   1204            /* Note: On this STM32 serie, ADC trigger edge is set to value 0x0 by       */
   1205            /*       setting of trigger source to SW start.                             */
   1206            ADC_REG_InitStruct->TriggerSource    = LL_ADC_REG_TRIG_SOFTWARE;
   \                     LL_ADC_REG_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1207            ADC_REG_InitStruct->SequencerLength  = LL_ADC_REG_SEQ_SCAN_DISABLE;
   \        0x4   0x6041             STR      R1,[R0, #+4]
   1208            ADC_REG_InitStruct->SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
   \        0x6   0x6081             STR      R1,[R0, #+8]
   1209            ADC_REG_InitStruct->ContinuousMode   = LL_ADC_REG_CONV_SINGLE;
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   1210            ADC_REG_InitStruct->DMATransfer      = LL_ADC_REG_DMA_TRANSFER_NONE;
   \        0xA   0x6101             STR      R1,[R0, #+16]
   1211            ADC_REG_InitStruct->Overrun          = LL_ADC_REG_OVR_DATA_OVERWRITTEN;
   \        0xC   0xF44F 0x5180      MOV      R1,#+4096
   \       0x10   0x6141             STR      R1,[R0, #+20]
   1212          }
   \       0x12   0x4770             BX       LR               ;; return
   1213          
   1214          /**
   1215            * @brief  Initialize some features of ADC group injected.
   1216            * @note   These parameters have an impact on ADC scope: ADC group injected.
   1217            *         Refer to corresponding unitary functions into
   1218            *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
   1219            *         (functions with prefix "INJ").
   1220            * @note   The setting of these parameters by function @ref LL_ADC_Init()
   1221            *         is conditioned to ADC state:
   1222            *         ADC instance must be disabled.
   1223            *         This condition is applied to all ADC features, for efficiency
   1224            *         and compatibility over all STM32 families. However, the different
   1225            *         features can be set under different ADC state conditions
   1226            *         (setting possible with ADC enabled without conversion on going,
   1227            *         ADC enabled with conversion on going, ...)
   1228            *         Each feature can be updated afterwards with a unitary function
   1229            *         and potentially with ADC in a different state than disabled,
   1230            *         refer to description of each function for setting
   1231            *         conditioned to ADC state.
   1232            * @note   After using this function, other features must be configured
   1233            *         using LL unitary functions.
   1234            *         The minimum configuration remaining to be done is:
   1235            *          - Set ADC group injected sequencer:
   1236            *            map channel on the selected sequencer rank.
   1237            *            Refer to function @ref LL_ADC_INJ_SetSequencerRanks().
   1238            *          - Set ADC channel sampling time
   1239            *            Refer to function LL_ADC_SetChannelSamplingTime();
   1240            * @note   Caution to ADC group injected contexts queue: On this STM32 serie, 
   1241            *         using successively several times this function will appear has
   1242            *         having no effect.
   1243            *         This is due to ADC group injected contexts queue (this feature
   1244            *         cannot be disabled on this STM32 serie).
   1245            *         To set several features of ADC group injected, use
   1246            *         function @ref LL_ADC_INJ_ConfigQueueContext().
   1247            * @param  ADCx ADC instance
   1248            * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure
   1249            * @retval An ErrorStatus enumeration value:
   1250            *          - SUCCESS: ADC registers are initialized
   1251            *          - ERROR: ADC registers are not initialized
   1252            */

   \                                 In section .text, align 2, keep-with-next
   1253          ErrorStatus LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
   1254          {
   \                     LL_ADC_INJ_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1255            ErrorStatus status = SUCCESS;
   1256            
   1257            /* Check the parameters */
   1258            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1259          #if defined(ADC1) && defined(ADC2) && defined(ADC3) && defined(ADC4)
   1260            assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADCx, ADC_INJ_InitStruct->TriggerSource));
   1261          #else
   1262            assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADC_INJ_InitStruct->TriggerSource));
   1263          #endif
   1264            assert_param(IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(ADC_INJ_InitStruct->SequencerLength));
   1265            if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_INJ_SEQ_SCAN_DISABLE)
   1266            {
   1267              assert_param(IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(ADC_INJ_InitStruct->SequencerDiscont));
   1268            }
   1269            assert_param(IS_LL_ADC_INJ_TRIG_AUTO(ADC_INJ_InitStruct->TrigAuto));
   1270            
   1271            /* Note: Hardware constraint (refer to description of this function):       */
   1272            /*       ADC instance must be disabled.                                     */
   1273            if(LL_ADC_IsEnabled(ADCx) == 0U)
   \        0x2   0x6882             LDR      R2,[R0, #+8]
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x07D2             LSLS     R2,R2,#+31
   \        0x8   0xD417             BMI.N    ??LL_ADC_INJ_Init_0
   1274            {
   1275              /* Configuration of ADC hierarchical scope:                               */
   1276              /*  - ADC group injected                                                  */
   1277              /*    - Set ADC group injected trigger source                             */
   1278              /*    - Set ADC group injected sequencer length                           */
   1279              /*    - Set ADC group injected sequencer discontinuous mode               */
   1280              /*    - Set ADC group injected conversion trigger: independent or         */
   1281              /*      from ADC group regular                                            */
   1282              /* Note: On this STM32 serie, ADC trigger edge is set to value 0x0 by     */
   1283              /*       setting of trigger source to SW start.                           */
   1284              if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   \        0xA   0x68CC             LDR      R4,[R1, #+12]
   \        0xC   0x684A             LDR      R2,[R1, #+4]
   \        0xE   0xB132             CBZ.N    R2,??LL_ADC_INJ_Init_1
   1285              {
   1286                MODIFY_REG(ADCx->CFGR,
   1287                             ADC_CFGR_JDISCEN
   1288                           | ADC_CFGR_JAUTO
   1289                          ,
   1290                             ADC_INJ_InitStruct->SequencerDiscont
   1291                           | ADC_INJ_InitStruct->TrigAuto
   1292                          );
   \       0x10   0x68C5             LDR      R5,[R0, #+12]
   \       0x12   0x688A             LDR      R2,[R1, #+8]
   \       0x14   0xF025 0x7504      BIC      R5,R5,#0x2100000
   \       0x18   0x4315             ORRS     R5,R2,R5
   \       0x1A   0x432C             ORRS     R4,R4,R5
   \       0x1C   0xE003             B.N      ??LL_ADC_INJ_Init_2
   1293              }
   1294              else
   1295              {
   1296                MODIFY_REG(ADCx->CFGR,
   1297                             ADC_CFGR_JDISCEN
   1298                           | ADC_CFGR_JAUTO
   1299                          ,
   1300                             LL_ADC_REG_SEQ_DISCONT_DISABLE
   1301                           | ADC_INJ_InitStruct->TrigAuto
   1302                          );
   \                     ??LL_ADC_INJ_Init_1: (+1)
   \       0x1E   0x68C2             LDR      R2,[R0, #+12]
   \       0x20   0xF022 0x7204      BIC      R2,R2,#0x2100000
   \       0x24   0x4314             ORRS     R4,R4,R2
   \                     ??LL_ADC_INJ_Init_2: (+1)
   \       0x26   0x60C4             STR      R4,[R0, #+12]
   1303              }
   1304              
   1305              MODIFY_REG(ADCx->JSQR,
   1306                           ADC_JSQR_JEXTSEL
   1307                         | ADC_JSQR_JEXTEN
   1308                         | ADC_JSQR_JL
   1309                        ,
   1310                           ADC_INJ_InitStruct->TriggerSource
   1311                         | ADC_INJ_InitStruct->SequencerLength
   1312                        );
   \       0x28   0x6CC2             LDR      R2,[R0, #+76]
   \       0x2A   0x684C             LDR      R4,[R1, #+4]
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0x0A12             LSRS     R2,R2,#+8
   \       0x30   0x430C             ORRS     R4,R1,R4
   \       0x32   0xEA44 0x2202      ORR      R2,R4,R2, LSL #+8
   \       0x36   0x64C2             STR      R2,[R0, #+76]
   \       0x38   0xE000             B.N      ??LL_ADC_INJ_Init_3
   1313            }
   1314            else
   1315            {
   1316              /* Initialization error: ADC instance is not disabled. */
   1317              status = ERROR;
   \                     ??LL_ADC_INJ_Init_0: (+1)
   \       0x3A   0x2301             MOVS     R3,#+1
   1318            }
   1319            return status;
   \                     ??LL_ADC_INJ_Init_3: (+1)
   \       0x3C   0x4618             MOV      R0,R3
   \       0x3E   0xBD30             POP      {R4,R5,PC}       ;; return
   1320          }
   1321          
   1322          /**
   1323            * @brief  Set each @ref LL_ADC_INJ_InitTypeDef field to default value.
   1324            * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure
   1325            *                            whose fields will be set to default values.
   1326            * @retval None
   1327            */

   \                                 In section .text, align 2, keep-with-next
   1328          void LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
   1329          {
   1330            /* Set ADC_INJ_InitStruct fields to default values */
   1331            /* Set fields of ADC group injected */
   1332            ADC_INJ_InitStruct->TriggerSource    = LL_ADC_INJ_TRIG_SOFTWARE;
   \                     LL_ADC_INJ_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1333            ADC_INJ_InitStruct->SequencerLength  = LL_ADC_INJ_SEQ_SCAN_DISABLE;
   \        0x4   0x6041             STR      R1,[R0, #+4]
   1334            ADC_INJ_InitStruct->SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;
   \        0x6   0x6081             STR      R1,[R0, #+8]
   1335            ADC_INJ_InitStruct->TrigAuto         = LL_ADC_INJ_TRIG_INDEPENDENT;
   \        0x8   0x60C1             STR      R1,[R0, #+12]
   1336          }
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x4002'1028        DC32     0x40021028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x5000'0008        DC32     0x50000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x7FFF'FFC0        DC32     0x7fffffc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x8000'8004        DC32     0x80008004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x0FFF'0000        DC32     0xfff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0xE082'0830        DC32     0xe0820830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0xE082'0820        DC32     0xe0820820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0xFFFF'F820        DC32     0xfffff820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x8208'2000        DC32     0x82082000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x03FF'F000        DC32     0x3fff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0xFFF8'0001        DC32     0xfff80001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0xFFFF'BFC7        DC32     0xffffbfc7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0xFFF0'C03C        DC32     0xfff0c03c
   1337          
   1338          /**
   1339            * @}
   1340            */
   1341          
   1342          /**
   1343            * @}
   1344            */
   1345          
   1346          /**
   1347            * @}
   1348            */
   1349          
   1350          #endif /* ADC1 || ADC2 || ADC3 || ADC4 */
   1351          
   1352          
   1353          #endif /* STM32F301x8 || STM32F302x8 || STM32F302xC || STM32F302xE || STM32F303x8 || STM32F303xC || STM32F303xE || STM32F318xx || STM32F328xx || STM32F334x8 || STM32F358xx || STM32F398xx */
   1354          
   1355          #if defined (ADC1_V2_5)
   1356          
   1357          #if defined (ADC1)
   1358          
   1359          /** @addtogroup ADC_LL ADC
   1360            * @{
   1361            */
   1362          
   1363          /* Private types -------------------------------------------------------------*/
   1364          /* Private variables ---------------------------------------------------------*/
   1365          /* Private constants ---------------------------------------------------------*/
   1366          /* Private macros ------------------------------------------------------------*/
   1367          
   1368          /** @addtogroup ADC_LL_Private_Macros
   1369            * @{
   1370            */
   1371          
   1372          /* Check of parameters for configuration of ADC hierarchical scope:           */
   1373          /* common to several ADC instances.                                           */
   1374          /* Check of parameters for configuration of ADC hierarchical scope:           */
   1375          /* ADC instance.                                                              */
   1376          #define IS_LL_ADC_DATA_ALIGN(__DATA_ALIGN__)                                   \
   1377            (   ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_RIGHT)                            \
   1378             || ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_LEFT) )
   1379          
   1380          #define IS_LL_ADC_SCAN_SELECTION(__SCAN_SELECTION__)                           \
   1381            (   ((__SCAN_SELECTION__) == LL_ADC_SEQ_SCAN_DISABLE)                        \
   1382             || ((__SCAN_SELECTION__) == LL_ADC_SEQ_SCAN_ENABLE) )
   1383          
   1384          #define IS_LL_ADC_SEQ_SCAN_MODE(__SEQ_SCAN_MODE__)                             \
   1385            (   ((__SCAN_MODE__) == LL_ADC_SEQ_SCAN_DISABLE)                             \
   1386             || ((__SCAN_MODE__) == LL_ADC_SEQ_SCAN_ENABLE) )
   1387          
   1388          /* Check of parameters for configuration of ADC hierarchical scope:           */
   1389          /* ADC group regular                                                          */
   1390          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
   1391            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
   1392             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \
   1393             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \
   1394             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH2)                  \
   1395             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM19_TRGO)                \
   1396             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM19_CH3)                 \
   1397             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM19_CH4)                 \
   1398             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11))
   1399          
   1400          #define IS_LL_ADC_REG_CONTINUOUS_MODE(__REG_CONTINUOUS_MODE__)                 \
   1401            (   ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_SINGLE)                    \
   1402             || ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_CONTINUOUS))
   1403          
   1404          #define IS_LL_ADC_REG_DMA_TRANSFER(__REG_DMA_TRANSFER__)                       \
   1405            (   ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_NONE)                 \
   1406             || ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_UNLIMITED))
   1407          
   1408          #define IS_LL_ADC_REG_SEQ_SCAN_LENGTH(__REG_SEQ_SCAN_LENGTH__)                 \
   1409            (   ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_DISABLE)               \
   1410             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS)         \
   1411             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS)         \
   1412             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS)         \
   1413             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS)         \
   1414             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS)         \
   1415             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS)         \
   1416             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS)         \
   1417             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS)         \
   1418             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS)        \
   1419             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS)        \
   1420             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS)        \
   1421             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS)        \
   1422             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS)        \
   1423             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS)        \
   1424             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS))
   1425          
   1426          #define IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(__REG_SEQ_DISCONT_MODE__)          \
   1427            (   ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_DISABLE)           \
   1428             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_1RANK)             \
   1429             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_2RANKS)            \
   1430             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_3RANKS)            \
   1431             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_4RANKS)            \
   1432             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_5RANKS)            \
   1433             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_6RANKS)            \
   1434             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_7RANKS)            \
   1435             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_8RANKS) )
   1436          
   1437          /* Check of parameters for configuration of ADC hierarchical scope:           */
   1438          /* ADC group injected                                                         */
   1439          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
   1440            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
   1441             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \
   1442             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \
   1443             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \
   1444             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)                  \
   1445             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM19_CH1)                 \
   1446             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM19_CH2)                 \
   1447             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15))
   1448          
   1449          #define IS_LL_ADC_INJ_TRIG_AUTO(__INJ_TRIG_AUTO__)                             \
   1450            (   ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_INDEPENDENT)                     \
   1451             || ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_FROM_GRP_REGULAR))
   1452          
   1453          #define IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(__INJ_SEQ_SCAN_LENGTH__)                 \
   1454            (   ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_DISABLE)               \
   1455             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS)         \
   1456             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS)         \
   1457             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS))
   1458          
   1459          #define IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(__INJ_SEQ_DISCONT_MODE__)          \
   1460            (   ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_DISABLE)           \
   1461             || ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_1RANK)  )
   1462          
   1463          /**
   1464            * @}
   1465            */
   1466          
   1467          
   1468          /* Private function prototypes -----------------------------------------------*/
   1469          
   1470          /* Exported functions --------------------------------------------------------*/
   1471          /** @addtogroup ADC_LL_Exported_Functions
   1472            * @{
   1473            */
   1474          
   1475          /** @addtogroup ADC_LL_EF_Init
   1476            * @{
   1477            */
   1478          
   1479          /**
   1480            * @brief  De-initialize registers of all ADC instances belonging to
   1481            *         the same ADC common instance to their default reset values.
   1482            * @param  ADCxy_COMMON ADC common instance
   1483            *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
   1484            * @retval An ErrorStatus enumeration value:
   1485            *          - SUCCESS: ADC common registers are de-initialized
   1486            *          - ERROR: not applicable
   1487            */
   1488          ErrorStatus LL_ADC_CommonDeInit(ADC_Common_TypeDef *ADCxy_COMMON)
   1489          {
   1490            /* Check the parameters */
   1491            assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
   1492            
   1493            /* Force reset of ADC clock (core clock) */
   1494            LL_APB2_GRP1_ForceReset  (LL_APB2_GRP1_PERIPH_ADC1);
   1495            
   1496            /* Release reset of ADC clock (core clock) */
   1497            LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_ADC1);
   1498          
   1499            return SUCCESS;
   1500          }
   1501          
   1502          /**
   1503            * @brief  De-initialize registers of the selected ADC instance
   1504            *         to their default reset values.
   1505            * @note   To reset all ADC instances quickly (perform a hard reset),
   1506            *         use function @ref LL_ADC_CommonDeInit().
   1507            * @param  ADCx ADC instance
   1508            * @retval An ErrorStatus enumeration value:
   1509            *          - SUCCESS: ADC registers are de-initialized
   1510            *          - ERROR: ADC registers are not de-initialized
   1511            */
   1512          ErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx)
   1513          {
   1514            ErrorStatus status = SUCCESS;
   1515            
   1516            /* Check the parameters */
   1517            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1518            
   1519            /* Disable ADC instance if not already disabled.                            */
   1520            if(LL_ADC_IsEnabled(ADCx) == 1U)
   1521            {
   1522              /* Set ADC group regular trigger source to SW start to ensure to not      */
   1523              /* have an external trigger event occurring during the conversion stop    */
   1524              /* ADC disable process.                                                   */
   1525              LL_ADC_REG_SetTriggerSource(ADCx, LL_ADC_REG_TRIG_SOFTWARE);
   1526              
   1527              /* Set ADC group injected trigger source to SW start to ensure to not     */
   1528              /* have an external trigger event occurring during the conversion stop    */
   1529              /* ADC disable process.                                                   */
   1530              LL_ADC_INJ_SetTriggerSource(ADCx, LL_ADC_INJ_TRIG_SOFTWARE);
   1531              
   1532              /* Disable the ADC instance */
   1533              LL_ADC_Disable(ADCx);
   1534            }
   1535            
   1536            /* Check whether ADC state is compliant with expected state */
   1537            /* (hardware requirements of bits state to reset registers below) */
   1538            if(READ_BIT(ADCx->CR2, ADC_CR2_ADON) == 0U)
   1539            {
   1540              /* ========== Reset ADC registers ========== */
   1541              /* Reset register SR */
   1542              CLEAR_BIT(ADCx->SR,
   1543                        (  LL_ADC_FLAG_STRT
   1544                         | LL_ADC_FLAG_JSTRT
   1545                         | LL_ADC_FLAG_EOS
   1546                         | LL_ADC_FLAG_JEOS
   1547                         | LL_ADC_FLAG_AWD1 )
   1548                       );
   1549              
   1550              /* Reset register CR1 */
   1551              CLEAR_BIT(ADCx->CR1,
   1552                        (  ADC_CR1_AWDEN   | ADC_CR1_JAWDEN
   1553                         | ADC_CR1_DISCNUM | ADC_CR1_JDISCEN | ADC_CR1_DISCEN
   1554                         | ADC_CR1_JAUTO   | ADC_CR1_AWDSGL  | ADC_CR1_SCAN
   1555                         | ADC_CR1_JEOCIE  | ADC_CR1_AWDIE   | ADC_CR1_EOCIE
   1556                         | ADC_CR1_AWDCH                                     )
   1557                       );
   1558              
   1559              /* Reset register CR2 */
   1560              CLEAR_BIT(ADCx->CR2,
   1561                        (  ADC_CR2_TSVREFE
   1562                         | ADC_CR2_SWSTART  | ADC_CR2_EXTTRIG  | ADC_CR2_EXTSEL
   1563                         | ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL
   1564                         | ADC_CR2_ALIGN    | ADC_CR2_DMA
   1565                         | ADC_CR2_RSTCAL   | ADC_CR2_CAL
   1566                         | ADC_CR2_CONT     | ADC_CR2_ADON                      )
   1567                       );
   1568              
   1569              /* Reset register SMPR1 */
   1570              CLEAR_BIT(ADCx->SMPR1,
   1571                        (  ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16
   1572                         | ADC_SMPR1_SMP15 | ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13
   1573                         | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10)
   1574                       );
   1575              
   1576              /* Reset register SMPR2 */
   1577              CLEAR_BIT(ADCx->SMPR2,
   1578                        (  ADC_SMPR2_SMP9
   1579                         | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | ADC_SMPR2_SMP6
   1580                         | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | ADC_SMPR2_SMP3
   1581                         | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | ADC_SMPR2_SMP0)
   1582                       );
   1583              
   1584              /* Reset register JOFR1 */
   1585              CLEAR_BIT(ADCx->JOFR1, ADC_JOFR1_JOFFSET1);
   1586              /* Reset register JOFR2 */
   1587              CLEAR_BIT(ADCx->JOFR2, ADC_JOFR2_JOFFSET2);
   1588              /* Reset register JOFR3 */
   1589              CLEAR_BIT(ADCx->JOFR3, ADC_JOFR3_JOFFSET3);
   1590              /* Reset register JOFR4 */
   1591              CLEAR_BIT(ADCx->JOFR4, ADC_JOFR4_JOFFSET4);
   1592              
   1593              /* Reset register HTR */
   1594              SET_BIT(ADCx->HTR, ADC_HTR_HT);
   1595              /* Reset register LTR */
   1596              CLEAR_BIT(ADCx->LTR, ADC_LTR_LT);
   1597              
   1598              /* Reset register SQR1 */
   1599              CLEAR_BIT(ADCx->SQR1,
   1600                        (  ADC_SQR1_L
   1601                         | ADC_SQR1_SQ16
   1602                         | ADC_SQR1_SQ15 | ADC_SQR1_SQ14 | ADC_SQR1_SQ13)
   1603                       );
   1604                       
   1605              /* Reset register SQR2 */
   1606              CLEAR_BIT(ADCx->SQR2,
   1607                        (  ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10
   1608                         | ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7)
   1609                       );
   1610              
   1611              
   1612              /* Reset register JSQR */
   1613              CLEAR_BIT(ADCx->JSQR,
   1614                        (  ADC_JSQR_JL
   1615                         | ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3
   1616                         | ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  )
   1617                       );
   1618              
   1619              /* Reset register DR */
   1620              /* bits in access mode read only, no direct reset applicable */
   1621              
   1622              /* Reset registers JDR1, JDR2, JDR3, JDR4 */
   1623              /* bits in access mode read only, no direct reset applicable */
   1624              
   1625            }
   1626            
   1627            return status;
   1628          }
   1629          
   1630          /**
   1631            * @brief  Initialize some features of ADC instance.
   1632            * @note   These parameters have an impact on ADC scope: ADC instance.
   1633            *         Affects both group regular and group injected (availability
   1634            *         of ADC group injected depends on STM32 families).
   1635            *         Refer to corresponding unitary functions into
   1636            *         @ref ADC_LL_EF_Configuration_ADC_Instance .
   1637            * @note   The setting of these parameters by function @ref LL_ADC_Init()
   1638            *         is conditioned to ADC state:
   1639            *         ADC instance must be disabled.
   1640            *         This condition is applied to all ADC features, for efficiency
   1641            *         and compatibility over all STM32 families. However, the different
   1642            *         features can be set under different ADC state conditions
   1643            *         (setting possible with ADC enabled without conversion on going,
   1644            *         ADC enabled with conversion on going, ...)
   1645            *         Each feature can be updated afterwards with a unitary function
   1646            *         and potentially with ADC in a different state than disabled,
   1647            *         refer to description of each function for setting
   1648            *         conditioned to ADC state.
   1649            * @note   After using this function, some other features must be configured
   1650            *         using LL unitary functions.
   1651            *         The minimum configuration remaining to be done is:
   1652            *          - Set ADC group regular or group injected sequencer:
   1653            *            map channel on the selected sequencer rank.
   1654            *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().
   1655            *          - Set ADC channel sampling time
   1656            *            Refer to function LL_ADC_SetChannelSamplingTime();
   1657            * @param  ADCx ADC instance
   1658            * @param  ADC_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
   1659            * @retval An ErrorStatus enumeration value:
   1660            *          - SUCCESS: ADC registers are initialized
   1661            *          - ERROR: ADC registers are not initialized
   1662            */
   1663          ErrorStatus LL_ADC_Init(ADC_TypeDef *ADCx, LL_ADC_InitTypeDef *ADC_InitStruct)
   1664          {
   1665            ErrorStatus status = SUCCESS;
   1666            
   1667            /* Check the parameters */
   1668            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1669            
   1670            assert_param(IS_LL_ADC_DATA_ALIGN(ADC_InitStruct->DataAlignment));
   1671            assert_param(IS_LL_ADC_SCAN_SELECTION(ADC_InitStruct->SequencersScanMode));
   1672            
   1673            /* Note: Hardware constraint (refer to description of this function):       */
   1674            /*       ADC instance must be disabled.                                     */
   1675            if(LL_ADC_IsEnabled(ADCx) == 0U)
   1676            {
   1677              /* Configuration of ADC hierarchical scope:                               */
   1678              /*  - ADC instance                                                        */
   1679              /*    - Set ADC conversion data alignment                                 */
   1680              MODIFY_REG(ADCx->CR1,
   1681                           ADC_CR1_SCAN
   1682                        ,
   1683                           ADC_InitStruct->SequencersScanMode
   1684                        );
   1685              
   1686              MODIFY_REG(ADCx->CR2,
   1687                           ADC_CR2_ALIGN
   1688                        ,
   1689                           ADC_InitStruct->DataAlignment
   1690                        );
   1691          
   1692            }
   1693            else
   1694            {
   1695              /* Initialization error: ADC instance is not disabled. */
   1696              status = ERROR;
   1697            }
   1698            return status;
   1699          }
   1700          
   1701          /**
   1702            * @brief  Set each @ref LL_ADC_InitTypeDef field to default value.
   1703            * @param  ADC_InitStruct Pointer to a @ref LL_ADC_InitTypeDef structure
   1704            *                        whose fields will be set to default values.
   1705            * @retval None
   1706            */
   1707          void LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct)
   1708          {
   1709            /* Set ADC_InitStruct fields to default values */
   1710            /* Set fields of ADC instance */
   1711            ADC_InitStruct->DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
   1712            
   1713            /* Enable scan mode to have a generic behavior with ADC of other            */
   1714            /* STM32 families, without this setting available:                          */
   1715            /* ADC group regular sequencer and ADC group injected sequencer depend      */
   1716            /* only of their own configuration.                                         */
   1717            ADC_InitStruct->SequencersScanMode      = LL_ADC_SEQ_SCAN_ENABLE;
   1718            
   1719          }
   1720          
   1721          /**
   1722            * @brief  Initialize some features of ADC group regular.
   1723            * @note   These parameters have an impact on ADC scope: ADC group regular.
   1724            *         Refer to corresponding unitary functions into
   1725            *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
   1726            *         (functions with prefix "REG").
   1727            * @note   The setting of these parameters by function @ref LL_ADC_Init()
   1728            *         is conditioned to ADC state:
   1729            *         ADC instance must be disabled.
   1730            *         This condition is applied to all ADC features, for efficiency
   1731            *         and compatibility over all STM32 families. However, the different
   1732            *         features can be set under different ADC state conditions
   1733            *         (setting possible with ADC enabled without conversion on going,
   1734            *         ADC enabled with conversion on going, ...)
   1735            *         Each feature can be updated afterwards with a unitary function
   1736            *         and potentially with ADC in a different state than disabled,
   1737            *         refer to description of each function for setting
   1738            *         conditioned to ADC state.
   1739            * @note   After using this function, other features must be configured
   1740            *         using LL unitary functions.
   1741            *         The minimum configuration remaining to be done is:
   1742            *          - Set ADC group regular or group injected sequencer:
   1743            *            map channel on the selected sequencer rank.
   1744            *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().
   1745            *          - Set ADC channel sampling time
   1746            *            Refer to function LL_ADC_SetChannelSamplingTime();
   1747            * @param  ADCx ADC instance
   1748            * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
   1749            * @retval An ErrorStatus enumeration value:
   1750            *          - SUCCESS: ADC registers are initialized
   1751            *          - ERROR: ADC registers are not initialized
   1752            */
   1753          ErrorStatus LL_ADC_REG_Init(ADC_TypeDef *ADCx, LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
   1754          {
   1755            ErrorStatus status = SUCCESS;
   1756            
   1757            /* Check the parameters */
   1758            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1759            assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADC_REG_InitStruct->TriggerSource));
   1760            assert_param(IS_LL_ADC_REG_SEQ_SCAN_LENGTH(ADC_REG_InitStruct->SequencerLength));
   1761            if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   1762            {
   1763              assert_param(IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(ADC_REG_InitStruct->SequencerDiscont));
   1764            }
   1765            assert_param(IS_LL_ADC_REG_CONTINUOUS_MODE(ADC_REG_InitStruct->ContinuousMode));
   1766            assert_param(IS_LL_ADC_REG_DMA_TRANSFER(ADC_REG_InitStruct->DMATransfer));
   1767            
   1768            /* Note: Hardware constraint (refer to description of this function):       */
   1769            /*       ADC instance must be disabled.                                     */
   1770            if(LL_ADC_IsEnabled(ADCx) == 0U)
   1771            {
   1772              /* Configuration of ADC hierarchical scope:                               */
   1773              /*  - ADC group regular                                                   */
   1774              /*    - Set ADC group regular trigger source                              */
   1775              /*    - Set ADC group regular sequencer length                            */
   1776              /*    - Set ADC group regular sequencer discontinuous mode                */
   1777              /*    - Set ADC group regular continuous mode                             */
   1778              /*    - Set ADC group regular conversion data transfer: no transfer or    */
   1779              /*      transfer by DMA, and DMA requests mode                            */
   1780              /* Note: On this STM32 serie, ADC trigger edge is set when starting        */
   1781              /*       ADC conversion.                                                  */
   1782              /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().      */
   1783              if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   1784              {
   1785                MODIFY_REG(ADCx->CR1,
   1786                             ADC_CR1_DISCEN
   1787                           | ADC_CR1_DISCNUM
   1788                          ,
   1789                             ADC_REG_InitStruct->SequencerLength
   1790                           | ADC_REG_InitStruct->SequencerDiscont
   1791                          );
   1792              }
   1793              else
   1794              {
   1795                MODIFY_REG(ADCx->CR1,
   1796                             ADC_CR1_DISCEN
   1797                           | ADC_CR1_DISCNUM
   1798                          ,
   1799                             ADC_REG_InitStruct->SequencerLength
   1800                           | LL_ADC_REG_SEQ_DISCONT_DISABLE
   1801                          );
   1802              }
   1803              
   1804              MODIFY_REG(ADCx->CR2,
   1805                           ADC_CR2_EXTSEL
   1806                         | ADC_CR2_CONT
   1807                         | ADC_CR2_DMA
   1808                        ,
   1809                           ADC_REG_InitStruct->TriggerSource
   1810                         | ADC_REG_InitStruct->ContinuousMode
   1811                         | ADC_REG_InitStruct->DMATransfer
   1812                        );
   1813          
   1814              /* Set ADC group regular sequencer length and scan direction */
   1815              /* Note: Hardware constraint (refer to description of this function):     */
   1816              /* Note: If ADC instance feature scan mode is disabled                    */
   1817              /*       (refer to  ADC instance initialization structure                 */
   1818              /*       parameter @ref SequencersScanMode                                */
   1819              /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */
   1820              /*       this parameter is discarded.                                     */
   1821              LL_ADC_REG_SetSequencerLength(ADCx, ADC_REG_InitStruct->SequencerLength);
   1822            }
   1823            else
   1824            {
   1825              /* Initialization error: ADC instance is not disabled. */
   1826              status = ERROR;
   1827            }
   1828            return status;
   1829          }
   1830          
   1831          /**
   1832            * @brief  Set each @ref LL_ADC_REG_InitTypeDef field to default value.
   1833            * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
   1834            *                            whose fields will be set to default values.
   1835            * @retval None
   1836            */
   1837          void LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
   1838          {
   1839            /* Set ADC_REG_InitStruct fields to default values */
   1840            /* Set fields of ADC group regular */
   1841            /* Note: On this STM32 serie, ADC trigger edge is set when starting         */
   1842            /*       ADC conversion.                                                    */
   1843            /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().        */
   1844            ADC_REG_InitStruct->TriggerSource    = LL_ADC_REG_TRIG_SOFTWARE;
   1845            ADC_REG_InitStruct->SequencerLength  = LL_ADC_REG_SEQ_SCAN_DISABLE;
   1846            ADC_REG_InitStruct->SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
   1847            ADC_REG_InitStruct->ContinuousMode   = LL_ADC_REG_CONV_SINGLE;
   1848            ADC_REG_InitStruct->DMATransfer      = LL_ADC_REG_DMA_TRANSFER_NONE;
   1849          }
   1850          
   1851          /**
   1852            * @brief  Initialize some features of ADC group injected.
   1853            * @note   These parameters have an impact on ADC scope: ADC group injected.
   1854            *         Refer to corresponding unitary functions into
   1855            *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
   1856            *         (functions with prefix "INJ").
   1857            * @note   The setting of these parameters by function @ref LL_ADC_Init()
   1858            *         is conditioned to ADC state:
   1859            *         ADC instance must be disabled.
   1860            *         This condition is applied to all ADC features, for efficiency
   1861            *         and compatibility over all STM32 families. However, the different
   1862            *         features can be set under different ADC state conditions
   1863            *         (setting possible with ADC enabled without conversion on going,
   1864            *         ADC enabled with conversion on going, ...)
   1865            *         Each feature can be updated afterwards with a unitary function
   1866            *         and potentially with ADC in a different state than disabled,
   1867            *         refer to description of each function for setting
   1868            *         conditioned to ADC state.
   1869            * @note   After using this function, other features must be configured
   1870            *         using LL unitary functions.
   1871            *         The minimum configuration remaining to be done is:
   1872            *          - Set ADC group injected sequencer:
   1873            *            map channel on the selected sequencer rank.
   1874            *            Refer to function @ref LL_ADC_INJ_SetSequencerRanks().
   1875            *          - Set ADC channel sampling time
   1876            *            Refer to function LL_ADC_SetChannelSamplingTime();
   1877            * @param  ADCx ADC instance
   1878            * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure
   1879            * @retval An ErrorStatus enumeration value:
   1880            *          - SUCCESS: ADC registers are initialized
   1881            *          - ERROR: ADC registers are not initialized
   1882            */
   1883          ErrorStatus LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
   1884          {
   1885            ErrorStatus status = SUCCESS;
   1886            
   1887            /* Check the parameters */
   1888            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
   1889            assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADC_INJ_InitStruct->TriggerSource));
   1890            assert_param(IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(ADC_INJ_InitStruct->SequencerLength));
   1891            if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_INJ_SEQ_SCAN_DISABLE)
   1892            {
   1893              assert_param(IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(ADC_INJ_InitStruct->SequencerDiscont));
   1894            }
   1895            assert_param(IS_LL_ADC_INJ_TRIG_AUTO(ADC_INJ_InitStruct->TrigAuto));
   1896            
   1897            /* Note: Hardware constraint (refer to description of this function):       */
   1898            /*       ADC instance must be disabled.                                     */
   1899            if(LL_ADC_IsEnabled(ADCx) == 0U)
   1900            {
   1901              /* Configuration of ADC hierarchical scope:                               */
   1902              /*  - ADC group injected                                                  */
   1903              /*    - Set ADC group injected trigger source                             */
   1904              /*    - Set ADC group injected sequencer length                           */
   1905              /*    - Set ADC group injected sequencer discontinuous mode               */
   1906              /*    - Set ADC group injected conversion trigger: independent or         */
   1907              /*      from ADC group regular                                            */
   1908              /* Note: On this STM32 serie, ADC trigger edge is set when starting       */
   1909              /*       ADC conversion.                                                  */
   1910              /*       Refer to function @ref LL_ADC_INJ_StartConversionExtTrig().      */
   1911              if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   1912              {
   1913                MODIFY_REG(ADCx->CR1,
   1914                             ADC_CR1_JDISCEN
   1915                           | ADC_CR1_JAUTO
   1916                          ,
   1917                             ADC_INJ_InitStruct->SequencerDiscont
   1918                           | ADC_INJ_InitStruct->TrigAuto
   1919                          );
   1920              }
   1921              else
   1922              {
   1923                MODIFY_REG(ADCx->CR1,
   1924                             ADC_CR1_JDISCEN
   1925                           | ADC_CR1_JAUTO
   1926                          ,
   1927                             LL_ADC_REG_SEQ_DISCONT_DISABLE
   1928                           | ADC_INJ_InitStruct->TrigAuto
   1929                          );
   1930              }
   1931              
   1932              MODIFY_REG(ADCx->CR2,
   1933                         ADC_CR2_JEXTSEL
   1934                        ,
   1935                         ADC_INJ_InitStruct->TriggerSource
   1936                        );
   1937              
   1938              /* Note: Hardware constraint (refer to description of this function):     */
   1939              /* Note: If ADC instance feature scan mode is disabled                    */
   1940              /*       (refer to  ADC instance initialization structure                 */
   1941              /*       parameter @ref SequencersScanMode                                */
   1942              /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */
   1943              /*       this parameter is discarded.                                     */
   1944              LL_ADC_INJ_SetSequencerLength(ADCx, ADC_INJ_InitStruct->SequencerLength);
   1945            }
   1946            else
   1947            {
   1948              /* Initialization error: ADC instance is not disabled. */
   1949              status = ERROR;
   1950            }
   1951            return status;
   1952          }
   1953          
   1954          /**
   1955            * @brief  Set each @ref LL_ADC_INJ_InitTypeDef field to default value.
   1956            * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure
   1957            *                            whose fields will be set to default values.
   1958            * @retval None
   1959            */
   1960          void LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
   1961          {
   1962            /* Set ADC_INJ_InitStruct fields to default values */
   1963            /* Set fields of ADC group injected */
   1964            ADC_INJ_InitStruct->TriggerSource    = LL_ADC_INJ_TRIG_SOFTWARE;
   1965            ADC_INJ_InitStruct->SequencerLength  = LL_ADC_INJ_SEQ_SCAN_DISABLE;
   1966            ADC_INJ_InitStruct->SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;
   1967            ADC_INJ_InitStruct->TrigAuto         = LL_ADC_INJ_TRIG_INDEPENDENT;
   1968          }
   1969          
   1970          /**
   1971            * @}
   1972            */
   1973          
   1974          /**
   1975            * @}
   1976            */
   1977          
   1978          /**
   1979            * @}
   1980            */
   1981          
   1982          #endif /* ADC1 */
   1983          
   1984          
   1985          #endif /* STM32F373xC || STM32F378xx */
   1986          
   1987          /**
   1988            * @}
   1989            */
   1990          
   1991          #endif /* USE_FULL_LL_DRIVER */
   1992          
   1993          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LL_ADC_CommonDeInit
       8   LL_ADC_CommonInit
       0   LL_ADC_CommonStructInit
      16   LL_ADC_DeInit
      12   LL_ADC_INJ_Init
       0   LL_ADC_INJ_StructInit
      16   LL_ADC_Init
      20   LL_ADC_REG_Init
       0   LL_ADC_REG_StructInit
       0   LL_ADC_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      22  LL_ADC_CommonDeInit
      32  LL_ADC_CommonInit
       8  LL_ADC_CommonStructInit
     388  LL_ADC_DeInit
      64  LL_ADC_INJ_Init
      12  LL_ADC_INJ_StructInit
      38  LL_ADC_Init
      76  LL_ADC_REG_Init
      20  LL_ADC_REG_StructInit
      10  LL_ADC_StructInit

 
 722 bytes in section .text
 
 722 bytes of CODE memory

Errors: none
Warnings: none
