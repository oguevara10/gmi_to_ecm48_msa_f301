###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:45
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\speed_pos_fdbk.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW7C4E.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\speed_pos_fdbk.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\speed_pos_fdbk.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\speed_pos_fdbk.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\speed_pos_fdbk.c
      1          /**
      2            ******************************************************************************
      3            * @file    speed_pos_fdbk.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the  features
      6            *          of the Speed & Position Feedback component of the Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "speed_pos_fdbk.h"
     24          
     25          /** @addtogroup MCSDK
     26            * @{
     27            */
     28          
     29          /** @defgroup SpeednPosFdbk Speed & Position Feedback
     30           *
     31            * @brief Speed & Position Feedback components of the Motor Control SDK
     32            *
     33            * These components provide the speed and the angular position of the rotor of a motor (both
     34            * electrical and mechanical).
     35            *
     36            * Several implementations of the Speed and Position Feedback feature are provided by the Motor
     37            * to account for the specificities of the motor used on the application:
     38            *
     39            * - @ref hall_speed_pos_fdbk "Hall Speed & Position Feedback" for motors with Hall effect sensors
     40            * - @ref Encoder  "Encoder Speed & Position Feedback" for motors with a quadrature encoder
     41            * - two general purpose sensorless implementations are provided:
     42            *   @ref SpeednPosFdbk_STO "State Observer with PLL" and
     43            *   @ref STO_CORDIC_SpeednPosFdbk "State Observer with CORDIC"
     44            * - "High Frequency Injection" for anisotropic I-PMSM motors (Not included in this release).
     45            *
     46            * @{
     47            */
     48          
     49          /**
     50            * @brief  It returns the last computed rotor electrical angle, expressed in
     51            *         s16degrees. 1 s16degree = 360ï¿½/65536
     52            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
     53            * @retval int16_t rotor electrical angle (s16degrees)
     54            */

   \                                 In section .text, align 2
     55          __weak int16_t SPD_GetElAngle( SpeednPosFdbk_Handle_t * pHandle )
     56          {
     57            return ( pHandle->hElAngle );
   \                     SPD_GetElAngle: (+1)
   \        0x0   0xF9B0 0x0004      LDRSH    R0,[R0, #+4]
   \        0x4   0x4770             BX       LR               ;; return
     58          }
     59          
     60          /**
     61            * @brief  It returns the last computed rotor mechanical angle, expressed in
     62            *         s16degrees. Mechanical angle frame is based on parameter bElToMecRatio
     63            *         and, if occasionally provided - through function SPD_SetMecAngle -
     64            *         of a measured mechanical angle, on information computed thereof.
     65            * @note   both Hall sensor and Sensor-less do not implement either
     66            *         mechanical angle computation or acceleration computation.
     67            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
     68            * @retval int16_t rotor mechanical angle (s16degrees)
     69            */

   \                                 In section .text, align 2
     70          __weak int32_t SPD_GetMecAngle( SpeednPosFdbk_Handle_t * pHandle )
     71          {
     72            return ( pHandle->wMecAngle );
   \                     SPD_GetMecAngle: (+1)
   \        0x0   0x6880             LDR      R0,[R0, #+8]
   \        0x2   0x4770             BX       LR               ;; return
     73          }
     74          
     75          /**
     76            * @brief  Returns the last computed average mechanical speed, expressed in
     77            *         the unit defined by #SPEED_UNIT.
     78            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
     79            */

   \                                 In section .text, align 2
     80          __weak int16_t SPD_GetAvrgMecSpeedUnit( SpeednPosFdbk_Handle_t * pHandle )
     81          {
     82            return ( pHandle->hAvrMecSpeedUnit );
   \                     SPD_GetAvrgMecSpeedUnit: (+1)
   \        0x0   0xF9B0 0x000C      LDRSH    R0,[R0, #+12]
   \        0x4   0x4770             BX       LR               ;; return
     83          }
     84          
     85          /**
     86            * @brief  It returns the last computed electrical speed, expressed in Dpp.
     87            *         1 Dpp = 1 s16Degree/control Period. The control period is the period
     88            *         on which the rotor electrical angle is computed (through function
     89            *         SPD_CalcElectricalAngle).
     90            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
     91            * @retval int16_t rotor electrical speed (Dpp)
     92            */

   \                                 In section .text, align 2
     93          __weak int16_t SPD_GetElSpeedDpp( SpeednPosFdbk_Handle_t * pHandle )
     94          {
     95            return ( pHandle->hElSpeedDpp );
   \                     SPD_GetElSpeedDpp: (+1)
   \        0x0   0xF9B0 0x000E      LDRSH    R0,[R0, #+14]
   \        0x4   0x4770             BX       LR               ;; return
     96          }
     97          
     98          /**
     99            * @brief  It returns the last instantaneous computed electrical speed, expressed in Dpp.
    100            *         1 Dpp = 1 s16Degree/control Period. The control period is the period
    101            *         on which the rotor electrical angle is computed (through function
    102            *         SPD_CalcElectricalAngle).
    103            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
    104            * @retval int16_t rotor instantaneous electrical speed (Dpp)
    105            */

   \                                 In section .text, align 2
    106          __weak int16_t SPD_GetInstElSpeedDpp( SpeednPosFdbk_Handle_t * pHandle )
    107          {
    108            return ( pHandle->InstantaneousElSpeedDpp );
   \                     SPD_GetInstElSpeedDpp: (+1)
   \        0x0   0xF9B0 0x0010      LDRSH    R0,[R0, #+16]
   \        0x4   0x4770             BX       LR               ;; return
    109          }
    110          
    111          /**
    112            * @brief  It returns the result of the last reliability check performed.
    113            *         Reliability is measured with reference to parameters
    114            *         hMaxReliableElSpeedUnit, hMinReliableElSpeedUnit,
    115            *         bMaximumSpeedErrorsNumber and/or specific parameters of the derived
    116            *         true = sensor information is reliable
    117            *         false = sensor information is not reliable
    118            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
    119            * @retval bool sensor reliability state
    120            */

   \                                 In section .text, align 2
    121          __weak bool SPD_Check( SpeednPosFdbk_Handle_t * pHandle )
    122          {
   \                     SPD_Check: (+1)
   \        0x0   0x4601             MOV      R1,R0
    123            bool SpeedSensorReliability = true;
   \        0x2   0x2001             MOVS     R0,#+1
    124            if ( pHandle->bSpeedErrorNumber ==
    125                 pHandle->bMaximumSpeedErrorsNumber )
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
   \        0x6   0x78C9             LDRB     R1,[R1, #+3]
   \        0x8   0x428A             CMP      R2,R1
   \        0xA   0xBF08             IT       EQ
   \        0xC   0x2000             MOVEQ    R0,#+0
    126            {
    127              SpeedSensorReliability = false;
    128            }
    129            return ( SpeedSensorReliability );
   \        0xE   0x4770             BX       LR               ;; return
    130          }
    131          
    132          #if defined (CCMRAM)
    133          #if defined (__ICCARM__)
    134          #pragma location = ".ccmram"
    135          #elif defined (__CC_ARM) || defined(__GNUC__)
    136          __attribute__( ( section ( ".ccmram" ) ) )
    137          #endif
    138          #endif
    139          
    140          /**
    141            * @brief  This method must be called - at least - with the same periodicity
    142            *         on which speed control is executed. It computes and returns - through
    143            *         parameter pMecSpeedUnit - the rotor average mechanical speed,
    144            *         expressed in the unit defined by #SPEED_UNIT. It computes and returns
    145            *         the reliability state of the sensor; reliability is measured with
    146            *         reference to parameters hMaxReliableElSpeedUnit, hMinReliableElSpeedUnit,
    147            *         bMaximumSpeedErrorsNumber and/or specific parameters of the derived
    148            *         true = sensor information is reliable
    149            *         false = sensor information is not reliable
    150            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
    151            * @param  pMecSpeedUnit pointer to int16_t, used to return the rotor average
    152            *         mechanical speed (expressed in the unit defined by #SPEED_UNIT)
    153            * @retval none
    154            */

   \                                 In section .text, align 2
    155          __weak bool SPD_IsMecSpeedReliable( SpeednPosFdbk_Handle_t * pHandle, int16_t * pMecSpeedUnit )
    156          {
    157            bool SpeedSensorReliability = true;
   \                     SPD_IsMecSpeedReliable: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xB5F0             PUSH     {R4-R7,LR}
    158            uint8_t bSpeedErrorNumber;
    159            uint8_t bMaximumSpeedErrorsNumber = pHandle->bMaximumSpeedErrorsNumber;
    160          
    161            bool SpeedError = false;
   \        0x4   0x2500             MOVS     R5,#+0
    162            uint16_t hAbsMecSpeedUnit, hAbsMecAccelUnitP;
    163            int16_t hAux;
    164          
    165            bSpeedErrorNumber = pHandle->bSpeedErrorNumber;
    166          
    167            /* Compute absoulte value of mechanical speed */
    168            if ( *pMecSpeedUnit < 0 )
   \        0x6   0x5F49             LDRSH    R1,[R1, R5]
   \        0x8   0x78C3             LDRB     R3,[R0, #+3]
   \        0xA   0x7804             LDRB     R4,[R0, #+0]
   \        0xC   0x000E             MOVS     R6,R1
   \        0xE   0xBF48             IT       MI
   \       0x10   0x4249             RSBMI    R1,R1,#+0
    169            {
    170              hAux = -( *pMecSpeedUnit );
    171              hAbsMecSpeedUnit = ( uint16_t )( hAux );
    172            }
    173            else
    174            {
    175              hAbsMecSpeedUnit = ( uint16_t )( *pMecSpeedUnit );
    176            }
    177          
    178            if ( hAbsMecSpeedUnit > pHandle->hMaxReliableMecSpeedUnit )
   \       0x12   0x8A86             LDRH     R6,[R0, #+20]
   \       0x14   0xB28F             UXTH     R7,R1
   \       0x16   0x42BE             CMP      R6,R7
    179            {
    180              SpeedError = true;
    181            }
    182          
    183            if ( hAbsMecSpeedUnit < pHandle->hMinReliableMecSpeedUnit )
   \       0x18   0x8AC6             LDRH     R6,[R0, #+22]
   \       0x1A   0xBF38             IT       CC
   \       0x1C   0x2501             MOVCC    R5,#+1
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0x42B1             CMP      R1,R6
    184            {
    185              SpeedError = true;
    186            }
    187          
    188            /* Compute absoulte value of mechanical acceleration */
    189            if ( pHandle->hMecAccelUnitP < 0 )
   \       0x22   0xF9B0 0x1012      LDRSH    R1,[R0, #+18]
    190            {
    191              hAux = -( pHandle->hMecAccelUnitP );
    192              hAbsMecAccelUnitP = ( uint16_t )( hAux );
    193            }
    194            else
    195            {
    196              hAbsMecAccelUnitP = ( uint16_t )( pHandle->hMecAccelUnitP );
    197            }
    198          
    199            if ( hAbsMecAccelUnitP > pHandle->hMaxReliableMecAccelUnitP )
   \       0x26   0x8B07             LDRH     R7,[R0, #+24]
   \       0x28   0xBF38             IT       CC
   \       0x2A   0x2501             MOVCC    R5,#+1
   \       0x2C   0x000E             MOVS     R6,R1
   \       0x2E   0xBF48             IT       MI
   \       0x30   0x4249             RSBMI    R1,R1,#+0
   \       0x32   0xB289             UXTH     R1,R1
   \       0x34   0x428F             CMP      R7,R1
   \       0x36   0xD300             BCC.N    ??SPD_IsMecSpeedReliable_0
    200            {
    201              SpeedError = true;
    202            }
    203          
    204            if ( SpeedError == true )
   \       0x38   0xB11D             CBZ.N    R5,??SPD_IsMecSpeedReliable_1
    205            {
    206              if ( bSpeedErrorNumber < bMaximumSpeedErrorsNumber )
   \                     ??SPD_IsMecSpeedReliable_0: (+1)
   \       0x3A   0x429C             CMP      R4,R3
   \       0x3C   0xDA04             BGE.N    ??SPD_IsMecSpeedReliable_2
    207              {
    208                bSpeedErrorNumber++;
   \       0x3E   0x1C64             ADDS     R4,R4,#+1
   \       0x40   0xE002             B.N      ??SPD_IsMecSpeedReliable_2
    209              }
    210            }
    211            else
    212            {
    213              if ( bSpeedErrorNumber < bMaximumSpeedErrorsNumber )
   \                     ??SPD_IsMecSpeedReliable_1: (+1)
   \       0x42   0x429C             CMP      R4,R3
   \       0x44   0xBFB8             IT       LT
   \       0x46   0x2400             MOVLT    R4,#+0
    214              {
    215                bSpeedErrorNumber = 0u;
    216              }
    217            }
    218          
    219            if ( bSpeedErrorNumber == bMaximumSpeedErrorsNumber )
   \                     ??SPD_IsMecSpeedReliable_2: (+1)
   \       0x48   0xB2E1             UXTB     R1,R4
   \       0x4A   0x4299             CMP      R1,R3
   \       0x4C   0xBF08             IT       EQ
   \       0x4E   0x2200             MOVEQ    R2,#+0
    220            {
    221              SpeedSensorReliability = false;
    222            }
    223          
    224            pHandle->bSpeedErrorNumber = bSpeedErrorNumber;
   \       0x50   0x7004             STRB     R4,[R0, #+0]
    225          
    226            return ( SpeedSensorReliability );
   \       0x52   0x4610             MOV      R0,R2
   \       0x54   0xBDF0             POP      {R4-R7,PC}       ;; return
    227          }
    228          
    229          /**
    230            * @brief  This method returns the average mechanical rotor speed expressed in
    231            *         "S16Speed". It means that:\n
    232            *         - it is zero for zero speed,\n
    233            *         - it become INT16_MAX when the average mechanical speed is equal to
    234            *           hMaxReliableMecSpeedUnit,\n
    235            *         - it becomes -INT16_MAX when the average mechanical speed is equal to
    236            *         -hMaxReliableMecSpeedUnit.
    237            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
    238            * @retval int16_t The average mechanical rotor speed expressed in "S16Speed".
    239            */

   \                                 In section .text, align 2
    240          __weak int16_t SPD_GetS16Speed( SpeednPosFdbk_Handle_t * pHandle )
    241          {
    242            int32_t wAux = ( int32_t ) pHandle->hAvrMecSpeedUnit;
    243            wAux *= INT16_MAX;
    244            wAux /= ( int16_t ) pHandle->hMaxReliableMecSpeedUnit;
    245            return ( int16_t )wAux;
   \                     SPD_GetS16Speed: (+1)
   \        0x0   0xF9B0 0x100C      LDRSH    R1,[R0, #+12]
   \        0x4   0xF9B0 0x0014      LDRSH    R0,[R0, #+20]
   \        0x8   0xEBC1 0x31C1      RSB      R1,R1,R1, LSL #+15
   \        0xC   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \       0x10   0xB200             SXTH     R0,R0
   \       0x12   0x4770             BX       LR               ;; return
    246          }
    247          
    248          /**
    249            * @brief  This method returns the coefficient used to transform electrical to
    250            *         mechanical quantities and viceversa. It usually coincides with motor
    251            *         pole pairs number.
    252            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
    253            * @retval uint8_t The motor pole pairs number.
    254            */

   \                                 In section .text, align 2
    255          __weak uint8_t SPD_GetElToMecRatio( SpeednPosFdbk_Handle_t * pHandle )
    256          {
    257            return ( pHandle->bElToMecRatio );
   \                     SPD_GetElToMecRatio: (+1)
   \        0x0   0x7840             LDRB     R0,[R0, #+1]
   \        0x2   0x4770             BX       LR               ;; return
    258          }
    259          
    260          /**
    261            * @brief  This method sets the coefficient used to transform electrical to
    262            *         mechanical quantities and viceversa. It usually coincides with motor
    263            *         pole pairs number.
    264            * @param  pHandle: handler of the current instance of the SpeednPosFdbk component
    265            * @param  bPP The motor pole pairs number to be set.
    266            */

   \                                 In section .text, align 2
    267          __weak void SPD_SetElToMecRatio( SpeednPosFdbk_Handle_t * pHandle, uint8_t bPP )
    268          {
    269            pHandle->bElToMecRatio = bPP;
   \                     SPD_SetElToMecRatio: (+1)
   \        0x0   0x7041             STRB     R1,[R0, #+1]
    270          }
   \        0x2   0x4770             BX       LR               ;; return
    271          
    272          
    273          /**
    274            * @}
    275            */
    276          
    277          /**
    278            * @}
    279            */
    280          
    281          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SPD_Check
       0   SPD_GetAvrgMecSpeedUnit
       0   SPD_GetElAngle
       0   SPD_GetElSpeedDpp
       0   SPD_GetElToMecRatio
       0   SPD_GetInstElSpeedDpp
       0   SPD_GetMecAngle
       0   SPD_GetS16Speed
      20   SPD_IsMecSpeedReliable
       0   SPD_SetElToMecRatio


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  SPD_Check
       6  SPD_GetAvrgMecSpeedUnit
       6  SPD_GetElAngle
       6  SPD_GetElSpeedDpp
       4  SPD_GetElToMecRatio
       6  SPD_GetInstElSpeedDpp
       4  SPD_GetMecAngle
      20  SPD_GetS16Speed
      86  SPD_IsMecSpeedReliable
       4  SPD_SetElToMecRatio

 
 158 bytes in section .text
 
 0 bytes of CODE memory (+ 158 bytes shared)

Errors: none
Warnings: none
