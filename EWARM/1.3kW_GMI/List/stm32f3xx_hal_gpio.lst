###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:06
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_gpio.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW3A7F.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_gpio.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\stm32f3xx_hal_gpio.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\stm32f3xx_hal_gpio.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                              ##### GPIO Peripheral features #####
     14            ==============================================================================
     15            [..]
     16              (+) Each port bit of the general-purpose I/O (GPIO) ports can be individually
     17                  configured by software in several modes:
     18                  (++) Input mode
     19                  (++) Analog mode
     20                  (++) Output mode
     21                  (++) Alternate function mode
     22                  (++) External interrupt/event lines
     23          
     24              (+) During and just after reset, the alternate functions and external interrupt
     25                  lines are not active and the I/O ports are configured in input floating mode.
     26          
     27              (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be
     28                  activated or not.
     29          
     30              (+) In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     31                  type and the IO speed can be selected depending on the VDD value.
     32          
     33              (+) The microcontroller IO pins are connected to onboard peripherals/modules through a
     34                  multiplexer that allows only one peripheral alternate function (AF) connected
     35                 to an IO pin at a time. In this way, there can be no conflict between peripherals
     36                 sharing the same IO pin.
     37          
     38              (+) All ports have external interrupt/event capability. To use external interrupt
     39                  lines, the port must be configured in input mode. All available GPIO pins are
     40                  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     41          
     42              (+) The external interrupt/event controller consists of up to 23 edge detectors
     43                  (16 lines are connected to GPIO) for generating event/interrupt requests (each
     44                  input line can be independently configured to select the type (interrupt or event)
     45                  and the corresponding trigger event (rising or falling or both). Each line can
     46                  also be masked independently.
     47          
     48                               ##### How to use this driver #####
     49            ==============================================================================
     50            [..]
     51              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE().
     52          
     53              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     54                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     55                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
     56                       structure.
     57                  (++) In case of Output or alternate function mode selection: the speed is
     58                       configured through "Speed" member from GPIO_InitTypeDef structure.
     59                  (++) In alternate mode is selection, the alternate function connected to the IO
     60                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     61                  (++) Analog mode is required when a pin is to be used as ADC channel
     62                       or DAC output.
     63                  (++) In case of external interrupt/event selection the "Mode" member from
     64                       GPIO_InitTypeDef structure select the type (interrupt or event) and
     65                       the corresponding trigger event (rising or falling or both).
     66          
     67              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
     68                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     69                  HAL_NVIC_EnableIRQ().
     70          
     71              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     72          
     73              (#) To set/reset the level of a pin configured in output mode use
     74                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     75          
     76             (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     77            
     78              (#) During and just after reset, the alternate functions are not
     79                  active and the GPIO pins are configured in input floating mode (except JTAG
     80                  pins).
     81          
     82              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
     83                  (PC14 and PC15U, respectively) when the LSE oscillator is off. The LSE has
     84                  priority over the GPIO function.
     85          
     86              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
     87                  general purpose PF0 and PF1, respectively, when the HSE oscillator is off.
     88                  The HSE has priority over the GPIO function.
     89          
     90            @endverbatim
     91            ******************************************************************************
     92            * @attention
     93            *
     94            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     95            * All rights reserved.</center></h2>
     96            *
     97            * This software component is licensed by ST under BSD 3-Clause license,
     98            * the "License"; You may not use this file except in compliance with the
     99            * License. You may obtain a copy of the License at:
    100            *                        opensource.org/licenses/BSD-3-Clause
    101            *
    102            ******************************************************************************
    103            */
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32f3xx_hal.h"
    107          
    108          /** @addtogroup STM32F3xx_HAL_Driver
    109            * @{
    110            */
    111          
    112          /** @defgroup GPIO GPIO
    113            * @brief GPIO HAL module driver
    114            * @{
    115            */
    116          
    117          /** MISRA C:2012 deviation rule has been granted for following rules:
    118            * Rule-18.1_d - Medium: Array pointer `GPIOx' is accessed with index [..,..]
    119            * which may be out of array bounds [..,UNKNOWN] in following APIs:
    120            * HAL_GPIO_Init
    121            * HAL_GPIO_DeInit
    122            */
    123          
    124          #ifdef HAL_GPIO_MODULE_ENABLED
    125          
    126          /* Private typedef -----------------------------------------------------------*/
    127          /* Private defines -----------------------------------------------------------*/
    128          /** @defgroup GPIO_Private_Defines GPIO Private Defines
    129            * @{
    130            */
    131          #define GPIO_MODE             (0x00000003U)
    132          #define EXTI_MODE             (0x10000000U)
    133          #define GPIO_MODE_IT          (0x00010000U)
    134          #define GPIO_MODE_EVT         (0x00020000U)
    135          #define RISING_EDGE           (0x00100000U)
    136          #define FALLING_EDGE          (0x00200000U)
    137          #define GPIO_OUTPUT_TYPE      (0x00000010U)
    138          
    139          #define GPIO_NUMBER           (16U)
    140          /**
    141            * @}
    142            */
    143            
    144          /* Private macros ------------------------------------------------------------*/
    145          /* Private macros ------------------------------------------------------------*/
    146          /** @defgroup GPIO_Private_Macros GPIO Private Macros
    147            * @{
    148            */
    149          /**
    150            * @}
    151            */
    152          /* Private variables ---------------------------------------------------------*/
    153          /* Private function prototypes -----------------------------------------------*/
    154          /* Exported functions --------------------------------------------------------*/
    155          
    156          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    157            * @{
    158            */
    159          
    160          /** @defgroup GPIO_Exported_Functions_Group1 Initialization/de-initialization functions 
    161           *  @brief    Initialization and Configuration functions
    162           *
    163          @verbatim
    164           ===============================================================================
    165                        ##### Initialization and de-initialization functions #####
    166           ===============================================================================
    167          
    168          @endverbatim
    169            * @{
    170            */
    171          
    172          /**
    173            * @brief  Initialize the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    174            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F3 family devices
    175            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    176            *         the configuration information for the specified GPIO peripheral.
    177            * @retval None
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    180          {
   \                     HAL_GPIO_Init: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    181            uint32_t position = 0x00u;
   \        0x4   0xF04F 0x0E00      MOV      LR,#+0
    182            uint32_t iocurrent;
    183            uint32_t temp;
    184          
    185            /* Check the parameters */
    186            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    187            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    188            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    189            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
   \        0x8   0x....             LDR.N    R2,??DataTable2  ;; 0x40010400
   \        0xA   0x....             LDR.N    R3,??DataTable2_1  ;; 0x40010008
   \        0xC   0x....'....        LDR.W    R8,??DataTable2_2  ;; 0x40021018
   \       0x10   0xF04F 0x090F      MOV      R9,#+15
   \       0x14   0x4682             MOV      R10,R0
   \       0x16   0x460F             MOV      R7,R1
   \       0x18   0xE033             B.N      ??HAL_GPIO_Init_0
    190          
    191            /* Configure the port pins */
    192            while (((GPIO_Init->Pin) >> position) != 0x00u)
    193            {
    194              /* Get current io position */
    195              iocurrent = (GPIO_Init->Pin) & (1uL << position);
    196          
    197              if (iocurrent != 0x00u)
    198              {
    199                /*--------------------- GPIO Mode Configuration ------------------------*/
    200                /* In case of Alternate function mode selection */
    201                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    202                {
    203                  /* Check the Alternate function parameters */
    204                  assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    205                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    206          
    207                  /* Configure Alternate function mapped with the current IO */
    208                  temp = GPIOx->AFR[position >> 3u];
    209                  temp &= ~(0xFu << ((position & 0x07u) * 4u));
    210                  temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
    211                  GPIOx->AFR[position >> 3u] = temp;
    212                }
    213          
    214                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    215                temp = GPIOx->MODER;
    216                temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
    217                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
    218                GPIOx->MODER = temp;
    219          
    220                /* In case of Output or Alternate function mode selection */
    221                if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    222                   (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
    223                {
    224                  /* Check the Speed parameter */
    225                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    226                  /* Configure the IO Speed */
    227                  temp = GPIOx->OSPEEDR;
    228                  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
    229                  temp |= (GPIO_Init->Speed << (position * 2u));
    230                  GPIOx->OSPEEDR = temp;
    231          
    232                  /* Configure the IO Output Type */
    233                  temp = GPIOx->OTYPER;
    234                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
    235                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
    236                  GPIOx->OTYPER = temp;
    237                }
    238          
    239                /* Activate the Pull-up or Pull down resistor for the current IO */
    240                temp = GPIOx->PUPDR;
    241                temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
    242                temp |= ((GPIO_Init->Pull) << (position * 2u));
    243                GPIOx->PUPDR = temp;
    244          
    245                /*--------------------- EXTI Mode Configuration ------------------------*/
    246                /* Configure the External Interrupt or event for the current IO */
    247                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
    248                {
    249                  /* Enable SYSCFG Clock */
    250                  __HAL_RCC_SYSCFG_CLK_ENABLE();
    251          
    252                  temp = SYSCFG->EXTICR[position >> 2u];
    253                  temp &= ~(0x0FuL << (4u * (position & 0x03u)));
    254                  temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
   \                     ??HAL_GPIO_Init_1: (+1)
   \       0x1A   0x....             LDR.N    R5,??DataTable2_3  ;; 0x48000c00
   \       0x1C   0x45AA             CMP      R10,R5
   \       0x1E   0xBF14             ITE      NE
   \       0x20   0x2505             MOVNE    R5,#+5
   \       0x22   0x2503             MOVEQ    R5,#+3
    255                  SYSCFG->EXTICR[position >> 2u] = temp;
   \                     ??HAL_GPIO_Init_2: (+1)
   \       0x24   0x408D             LSLS     R5,R5,R1
   \       0x26   0x4325             ORRS     R5,R5,R4
   \       0x28   0xF843 0x502C      STR      R5,[R3, R12, LSL #+2]
    256          
    257                  /* Clear EXTI line configuration */
    258                  temp = EXTI->IMR;
    259                  temp &= ~(iocurrent);
   \       0x2C   0x43C1             MVNS     R1,R0
   \       0x2E   0x6814             LDR      R4,[R2, #+0]
   \       0x30   0xEA01 0x0C04      AND      R12,R1,R4
    260                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \       0x34   0x687C             LDR      R4,[R7, #+4]
   \       0x36   0x03E5             LSLS     R5,R4,#+15
   \       0x38   0xBF48             IT       MI
   \       0x3A   0xEA40 0x0C0C      ORRMI    R12,R0,R12
    261                  {
    262                    temp |= iocurrent;
    263                  }
    264                  EXTI->IMR = temp;
   \       0x3E   0xF8C2 0xC000      STR      R12,[R2, #+0]
    265          
    266                  temp = EXTI->EMR;
   \       0x42   0x6854             LDR      R4,[R2, #+4]
    267                  temp &= ~(iocurrent);
   \       0x44   0xEA01 0x0C04      AND      R12,R1,R4
    268                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \       0x48   0x687C             LDR      R4,[R7, #+4]
   \       0x4A   0x03A5             LSLS     R5,R4,#+14
   \       0x4C   0xBF48             IT       MI
   \       0x4E   0xEA40 0x0C0C      ORRMI    R12,R0,R12
    269                  {
    270                    temp |= iocurrent;
    271                  }
    272                  EXTI->EMR = temp;
   \       0x52   0xF8C2 0xC004      STR      R12,[R2, #+4]
    273          
    274                  /* Clear Rising Falling edge configuration */
    275                  temp = EXTI->RTSR;
   \       0x56   0x6894             LDR      R4,[R2, #+8]
    276                  temp &= ~(iocurrent);
   \       0x58   0xEA01 0x0C04      AND      R12,R1,R4
    277                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \       0x5C   0x687C             LDR      R4,[R7, #+4]
   \       0x5E   0x02E5             LSLS     R5,R4,#+11
   \       0x60   0xBF48             IT       MI
   \       0x62   0xEA40 0x0C0C      ORRMI    R12,R0,R12
    278                  {
    279                    temp |= iocurrent;
    280                  }
    281                  EXTI->RTSR = temp;
   \       0x66   0xF8C2 0xC008      STR      R12,[R2, #+8]
    282          
    283                  temp = EXTI->FTSR;
   \       0x6A   0x68D4             LDR      R4,[R2, #+12]
    284                  temp &= ~(iocurrent);
   \       0x6C   0xEA01 0x0C04      AND      R12,R1,R4
    285                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \       0x70   0x6879             LDR      R1,[R7, #+4]
   \       0x72   0x028C             LSLS     R4,R1,#+10
   \       0x74   0xBF48             IT       MI
   \       0x76   0xEA40 0x0C0C      ORRMI    R12,R0,R12
    286                  {
    287                    temp |= iocurrent;
    288                  }
    289                  EXTI->FTSR = temp;
   \       0x7A   0xF8C2 0xC00C      STR      R12,[R2, #+12]
    290                }
    291              }
    292          
    293              position++;
   \                     ??HAL_GPIO_Init_3: (+1)
   \       0x7E   0xF10E 0x0E01      ADD      LR,LR,#+1
   \                     ??HAL_GPIO_Init_0: (+1)
   \       0x82   0x6839             LDR      R1,[R7, #+0]
   \       0x84   0xFA31 0xF00E      LSRS     R0,R1,LR
   \       0x88   0xF000 0x8083      BEQ.W    ??HAL_GPIO_Init_4
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xFA00 0xFC0E      LSL      R12,R0,LR
   \       0x92   0xEA1C 0x0001      ANDS     R0,R12,R1
   \       0x96   0xD0F2             BEQ.N    ??HAL_GPIO_Init_3
   \       0x98   0x687C             LDR      R4,[R7, #+4]
   \       0x9A   0x2C02             CMP      R4,#+2
   \       0x9C   0xBF18             IT       NE
   \       0x9E   0x2C12             CMPNE    R4,#+18
   \       0xA0   0xEA4F 0x018E      LSL      R1,LR,#+2
   \       0xA4   0xD110             BNE.N    ??HAL_GPIO_Init_5
   \       0xA6   0xEA4F 0x04DE      LSR      R4,LR,#+3
   \       0xAA   0xEB0A 0x0484      ADD      R4,R10,R4, LSL #+2
   \       0xAE   0xF001 0x051C      AND      R5,R1,#0x1C
   \       0xB2   0x6A26             LDR      R6,[R4, #+32]
   \       0xB4   0xFA09 0xFB05      LSL      R11,R9,R5
   \       0xB8   0xEA26 0x060B      BIC      R6,R6,R11
   \       0xBC   0xF8D7 0xB010      LDR      R11,[R7, #+16]
   \       0xC0   0xFA0B 0xF505      LSL      R5,R11,R5
   \       0xC4   0x4335             ORRS     R5,R5,R6
   \       0xC6   0x6225             STR      R5,[R4, #+32]
   \                     ??HAL_GPIO_Init_5: (+1)
   \       0xC8   0xEA4F 0x044E      LSL      R4,LR,#+1
   \       0xCC   0x2503             MOVS     R5,#+3
   \       0xCE   0xF8DA 0x6000      LDR      R6,[R10, #+0]
   \       0xD2   0xF897 0xB004      LDRB     R11,[R7, #+4]
   \       0xD6   0x40A5             LSLS     R5,R5,R4
   \       0xD8   0x43ED             MVNS     R5,R5
   \       0xDA   0xF00B 0x0B03      AND      R11,R11,#0x3
   \       0xDE   0x402E             ANDS     R6,R5,R6
   \       0xE0   0xFA0B 0xFB04      LSL      R11,R11,R4
   \       0xE4   0xEA4B 0x0606      ORR      R6,R11,R6
   \       0xE8   0xF8CA 0x6000      STR      R6,[R10, #+0]
   \       0xEC   0x687E             LDR      R6,[R7, #+4]
   \       0xEE   0x2E01             CMP      R6,#+1
   \       0xF0   0xBF18             IT       NE
   \       0xF2   0x2E02             CMPNE    R6,#+2
   \       0xF4   0xD003             BEQ.N    ??HAL_GPIO_Init_6
   \       0xF6   0x2E11             CMP      R6,#+17
   \       0xF8   0xBF18             IT       NE
   \       0xFA   0x2E12             CMPNE    R6,#+18
   \       0xFC   0xD117             BNE.N    ??HAL_GPIO_Init_7
   \                     ??HAL_GPIO_Init_6: (+1)
   \       0xFE   0xF8DA 0x6008      LDR      R6,[R10, #+8]
   \      0x102   0xF8D7 0xB00C      LDR      R11,[R7, #+12]
   \      0x106   0x402E             ANDS     R6,R5,R6
   \      0x108   0xFA0B 0xFB04      LSL      R11,R11,R4
   \      0x10C   0xEA4B 0x0606      ORR      R6,R11,R6
   \      0x110   0xF8CA 0x6008      STR      R6,[R10, #+8]
   \      0x114   0xF8DA 0x6004      LDR      R6,[R10, #+4]
   \      0x118   0xEA26 0x0C0C      BIC      R12,R6,R12
   \      0x11C   0x687E             LDR      R6,[R7, #+4]
   \      0x11E   0xF3C6 0x1600      UBFX     R6,R6,#+4,#+1
   \      0x122   0xFA06 0xF60E      LSL      R6,R6,LR
   \      0x126   0xEA46 0x060C      ORR      R6,R6,R12
   \      0x12A   0xF8CA 0x6004      STR      R6,[R10, #+4]
   \                     ??HAL_GPIO_Init_7: (+1)
   \      0x12E   0xF8DA 0x600C      LDR      R6,[R10, #+12]
   \      0x132   0x4035             ANDS     R5,R5,R6
   \      0x134   0x68BE             LDR      R6,[R7, #+8]
   \      0x136   0xFA06 0xF404      LSL      R4,R6,R4
   \      0x13A   0x432C             ORRS     R4,R4,R5
   \      0x13C   0xF8CA 0x400C      STR      R4,[R10, #+12]
   \      0x140   0x687C             LDR      R4,[R7, #+4]
   \      0x142   0x00E4             LSLS     R4,R4,#+3
   \      0x144   0xD59B             BPL.N    ??HAL_GPIO_Init_3
   \      0x146   0xF8D8 0x4000      LDR      R4,[R8, #+0]
   \      0x14A   0xF044 0x0401      ORR      R4,R4,#0x1
   \      0x14E   0xF8C8 0x4000      STR      R4,[R8, #+0]
   \      0x152   0xEA4F 0x0C9E      LSR      R12,LR,#+2
   \      0x156   0xF8D8 0x5000      LDR      R5,[R8, #+0]
   \      0x15A   0xF005 0x0501      AND      R5,R5,#0x1
   \      0x15E   0x9500             STR      R5,[SP, #+0]
   \      0x160   0xF001 0x010C      AND      R1,R1,#0xC
   \      0x164   0x9C00             LDR      R4,[SP, #+0]
   \      0x166   0xF853 0x502C      LDR      R5,[R3, R12, LSL #+2]
   \      0x16A   0xFA09 0xF401      LSL      R4,R9,R1
   \      0x16E   0xEA25 0x0404      BIC      R4,R5,R4
   \      0x172   0xF1BA 0x4F90      CMP      R10,#+1207959552
   \      0x176   0xBF08             IT       EQ
   \      0x178   0x2500             MOVEQ    R5,#+0
   \      0x17A   0xD009             BEQ.N    ??HAL_GPIO_Init_8
   \      0x17C   0x....             LDR.N    R5,??DataTable2_4  ;; 0x48000400
   \      0x17E   0x45AA             CMP      R10,R5
   \      0x180   0xBF08             IT       EQ
   \      0x182   0x2501             MOVEQ    R5,#+1
   \      0x184   0xD004             BEQ.N    ??HAL_GPIO_Init_8
   \      0x186   0x....             LDR.N    R5,??DataTable2_5  ;; 0x48000800
   \      0x188   0x45AA             CMP      R10,R5
   \      0x18A   0xF47F 0xAF46      BNE.W    ??HAL_GPIO_Init_1
   \      0x18E   0x2502             MOVS     R5,#+2
   \                     ??HAL_GPIO_Init_8: (+1)
   \      0x190   0xE748             B.N      ??HAL_GPIO_Init_2
    294            }
    295          }
   \                     ??HAL_GPIO_Init_4: (+1)
   \      0x192   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    296          
    297          /**
    298            * @brief  De-initialize the GPIOx peripheral registers to their default reset values.
    299            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F30X device or STM32F37X device
    300            * @param  GPIO_Pin specifies the port bit to be written.
    301            *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
    302            * @retval None
    303            */

   \                                 In section .text, align 2, keep-with-next
    304          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    305          {
   \                     HAL_GPIO_DeInit: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x468A             MOV      R10,R1
    306            uint32_t position = 0x00u;
   \        0x6   0xF04F 0x0B00      MOV      R11,#+0
    307            uint32_t iocurrent;
    308            uint32_t tmp;
    309          
    310            /* Check the parameters */
    311            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    312            assert_param(IS_GPIO_PIN(GPIO_Pin));
   \        0xA   0x....             LDR.N    R1,??DataTable2  ;; 0x40010400
   \        0xC   0x....             LDR.N    R3,??DataTable2_1  ;; 0x40010008
   \        0xE   0x220F             MOVS     R2,#+15
   \       0x10   0x4604             MOV      R4,R0
   \       0x12   0xE03C             B.N      ??HAL_GPIO_DeInit_0
    313          
    314            /* Configure the port pins */
    315            while ((GPIO_Pin >> position) != 0x00u)
    316            {
    317              /* Get current io position */
    318              iocurrent = (GPIO_Pin) & (1uL << position);
    319          
    320              if (iocurrent != 0x00u)
    321              {
    322                /*------------------------- EXTI Mode Configuration --------------------*/
    323                /* Clear the External Interrupt or Event for the current IO */
    324          
    325                tmp = SYSCFG->EXTICR[position >> 2u];
    326                tmp &= (0x0FuL << (4u * (position & 0x03u)));
    327                if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \       0x14   0x....             LDR.N    R6,??DataTable2_3  ;; 0x48000c00
   \       0x16   0x42B4             CMP      R4,R6
   \       0x18   0xBF14             ITE      NE
   \       0x1A   0x2605             MOVNE    R6,#+5
   \       0x1C   0x2603             MOVEQ    R6,#+3
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \       0x1E   0xFA06 0xF60E      LSL      R6,R6,LR
   \       0x22   0x42B5             CMP      R5,R6
   \       0x24   0xD112             BNE.N    ??HAL_GPIO_DeInit_3
    328                {
    329                  /* Clear EXTI line configuration */
    330                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \       0x26   0x680D             LDR      R5,[R1, #+0]
   \       0x28   0x43C0             MVNS     R0,R0
   \       0x2A   0x4005             ANDS     R5,R0,R5
   \       0x2C   0x600D             STR      R5,[R1, #+0]
    331                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \       0x2E   0x684D             LDR      R5,[R1, #+4]
   \       0x30   0x4005             ANDS     R5,R0,R5
   \       0x32   0x604D             STR      R5,[R1, #+4]
    332                  
    333                  /* Clear Rising Falling edge configuration */
    334                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \       0x34   0x688D             LDR      R5,[R1, #+8]
   \       0x36   0x4005             ANDS     R5,R0,R5
   \       0x38   0x608D             STR      R5,[R1, #+8]
    335                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \       0x3A   0x68CD             LDR      R5,[R1, #+12]
   \       0x3C   0x4028             ANDS     R0,R0,R5
   \       0x3E   0x60C8             STR      R0,[R1, #+12]
    336          
    337                  /* Configure the External Interrupt or event for the current IO */
    338                  tmp = 0x0FuL << (4u * (position & 0x03u));
    339                  SYSCFG->EXTICR[position >> 2u] &= ~tmp;
   \       0x40   0xF853 0x0028      LDR      R0,[R3, R8, LSL #+2]
   \       0x44   0xEA20 0x0009      BIC      R0,R0,R9
   \       0x48   0xF843 0x0028      STR      R0,[R3, R8, LSL #+2]
    340                }
    341          
    342                /*------------------------- GPIO Mode Configuration --------------------*/
    343                /* Configure IO Direction in Input Floating Mode */
    344                GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2u));
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \       0x4C   0x2503             MOVS     R5,#+3
   \       0x4E   0xEA4F 0x004B      LSL      R0,R11,#+1
   \       0x52   0xFA05 0xF000      LSL      R0,R5,R0
   \       0x56   0x6825             LDR      R5,[R4, #+0]
   \       0x58   0x43C0             MVNS     R0,R0
   \       0x5A   0x4005             ANDS     R5,R0,R5
   \       0x5C   0x6025             STR      R5,[R4, #+0]
    345          
    346                /* Configure the default Alternate Function in current IO */
    347                GPIOx->AFR[position >> 3u] &= ~(0xFu << ((uint32_t)(position & 0x07u) * 4u)) ;
   \       0x5E   0xF007 0x071C      AND      R7,R7,#0x1C
   \       0x62   0xEA4F 0x05DB      LSR      R5,R11,#+3
   \       0x66   0xEB04 0x0585      ADD      R5,R4,R5, LSL #+2
   \       0x6A   0xFA02 0xF707      LSL      R7,R2,R7
   \       0x6E   0x6A2E             LDR      R6,[R5, #+32]
   \       0x70   0xEA26 0x0707      BIC      R7,R6,R7
   \       0x74   0x622F             STR      R7,[R5, #+32]
    348          
    349                /* Configure the default value for IO Speed */
    350                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
   \       0x76   0x68A7             LDR      R7,[R4, #+8]
   \       0x78   0x4007             ANDS     R7,R0,R7
   \       0x7A   0x60A7             STR      R7,[R4, #+8]
    351          
    352                /* Configure the default value IO Output Type */
    353                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
   \       0x7C   0x6865             LDR      R5,[R4, #+4]
   \       0x7E   0xEA25 0x050C      BIC      R5,R5,R12
   \       0x82   0x6065             STR      R5,[R4, #+4]
    354          
    355                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    356                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
   \       0x84   0x68E7             LDR      R7,[R4, #+12]
   \       0x86   0x4038             ANDS     R0,R0,R7
   \       0x88   0x60E0             STR      R0,[R4, #+12]
    357              }
    358          
    359              position++;
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \       0x8A   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \       0x8E   0xFA3A 0xF00B      LSRS     R0,R10,R11
   \       0x92   0xD020             BEQ.N    ??HAL_GPIO_DeInit_5
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xFA00 0xFC0B      LSL      R12,R0,R11
   \       0x9A   0xEA1C 0x000A      ANDS     R0,R12,R10
   \       0x9E   0xD0F4             BEQ.N    ??HAL_GPIO_DeInit_4
   \       0xA0   0xEA4F 0x089B      LSR      R8,R11,#+2
   \       0xA4   0xEA4F 0x078B      LSL      R7,R11,#+2
   \       0xA8   0xF853 0x5028      LDR      R5,[R3, R8, LSL #+2]
   \       0xAC   0xF007 0x0E0C      AND      LR,R7,#0xC
   \       0xB0   0xFA02 0xF90E      LSL      R9,R2,LR
   \       0xB4   0xF1B4 0x4F90      CMP      R4,#+1207959552
   \       0xB8   0xEA09 0x0505      AND      R5,R9,R5
   \       0xBC   0xBF08             IT       EQ
   \       0xBE   0x2600             MOVEQ    R6,#+0
   \       0xC0   0xD0AD             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0xC2   0x....             LDR.N    R6,??DataTable2_4  ;; 0x48000400
   \       0xC4   0x42B4             CMP      R4,R6
   \       0xC6   0xBF08             IT       EQ
   \       0xC8   0x2601             MOVEQ    R6,#+1
   \       0xCA   0xD0A8             BEQ.N    ??HAL_GPIO_DeInit_2
   \       0xCC   0x....             LDR.N    R6,??DataTable2_5  ;; 0x48000800
   \       0xCE   0x42B4             CMP      R4,R6
   \       0xD0   0xD1A0             BNE.N    ??HAL_GPIO_DeInit_1
   \       0xD2   0x2602             MOVS     R6,#+2
   \       0xD4   0xE7A3             B.N      ??HAL_GPIO_DeInit_2
    360            }
    361          }
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \       0xD6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    362          
    363          /**
    364            * @}
    365            */
    366          
    367          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions 
    368           *  @brief GPIO Read, Write, Toggle, Lock and EXTI management functions.
    369           *
    370          @verbatim
    371           ===============================================================================
    372                                 ##### IO operation functions #####
    373           ===============================================================================
    374          
    375          @endverbatim
    376            * @{
    377            */
    378          
    379          /**
    380            * @brief  Read the specified input port pin.
    381            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F3 family
    382            * @param  GPIO_Pin specifies the port bit to read.
    383            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    384            * @retval The input port pin value.
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    387          {
    388            GPIO_PinState bitstatus;
    389          
    390            /* Check the parameters */
    391            assert_param(IS_GPIO_PIN(GPIO_Pin));
    392          
    393            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0x4008             ANDS     R0,R1,R0
   \        0x4   0xBF18             IT       NE
   \        0x6   0x2001             MOVNE    R0,#+1
    394            {
    395              bitstatus = GPIO_PIN_SET;
    396            }
    397            else
    398            {
    399              bitstatus = GPIO_PIN_RESET;
    400            }
    401            return bitstatus;
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x4770             BX       LR               ;; return
    402          }
    403          
    404          /**
    405            * @brief  Set or clear the selected data port bit.
    406            *
    407            * @note   This function uses GPIOx_BSRR and GPIOx_BRR registers to allow atomic read/modify
    408            *         accesses. In this way, there is no risk of an IRQ occurring between
    409            *         the read and the modify access.
    410            *
    411            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F3 family
    412            * @param  GPIO_Pin specifies the port bit to be written.
    413            *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
    414            * @param  PinState specifies the value to be written to the selected bit.
    415            *         This parameter can be one of the GPIO_PinState enum values:
    416            *            @arg GPIO_PIN_RESET: to clear the port pin
    417            *            @arg GPIO_PIN_SET: to set the port pin
    418            * @retval None
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_GPIO_PIN(GPIO_Pin));
    424            assert_param(IS_GPIO_PIN_ACTION(PinState));
    425          
    426            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \        0x0   0xB10A             CBZ.N    R2,??HAL_GPIO_WritePin_0
    427            {
    428              GPIOx->BSRR = (uint32_t)GPIO_Pin;
   \        0x2   0x6181             STR      R1,[R0, #+24]
   \        0x4   0x4770             BX       LR
    429            }
    430            else
    431            {
    432              GPIOx->BRR = (uint32_t)GPIO_Pin;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \        0x6   0x6281             STR      R1,[R0, #+40]
    433            }
    434          }
   \        0x8   0x4770             BX       LR               ;; return
    435          
    436          /**
    437            * @brief  Toggle the specified GPIO pin.
    438            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F3 family
    439            * @param  GPIO_Pin specifies the pin to be toggled.
    440            * @retval None
    441            */

   \                                 In section .text, align 2, keep-with-next
    442          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_GPIO_PIN(GPIO_Pin));
    446          
    447            if ((GPIOx->ODR & GPIO_Pin) != 0X00u)
   \                     HAL_GPIO_TogglePin: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x420A             TST      R2,R1
   \        0x4   0xBF18             IT       NE
   \        0x6   0x0409             LSLNE    R1,R1,#+16
    448            {
    449              GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
    450            }
    451            else
    452            {
    453              GPIOx->BSRR = (uint32_t)GPIO_Pin;
   \        0x8   0x6181             STR      R1,[R0, #+24]
    454            }
    455          }
   \        0xA   0x4770             BX       LR               ;; return
    456          
    457          /**
    458          * @brief  Lock GPIO Pins configuration registers.
    459            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    460            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    461            * @note   The configuration of the locked GPIO pins can no longer be modified
    462            *         until the next reset.
    463            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F3 family
    464            * @param  GPIO_Pin specifies the port bits to be locked.
    465            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    469          {
   \                     HAL_GPIO_LockPin: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
    470            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \        0x2   0xF44F 0x3380      MOV      R3,#+65536
   \        0x6   0x9300             STR      R3,[SP, #+0]
    471          
    472            /* Check the parameters */
    473            assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
    474            assert_param(IS_GPIO_PIN(GPIO_Pin));
    475          
    476            /* Apply lock key write sequence */
    477            tmp |= GPIO_Pin;
   \        0x8   0x9C00             LDR      R4,[SP, #+0]
   \        0xA   0x430C             ORRS     R4,R1,R4
   \        0xC   0x9400             STR      R4,[SP, #+0]
    478            /* Set LCKx bit(s): LCKK='1' + LCK[15U-0] */
    479            GPIOx->LCKR = tmp;
   \        0xE   0x9A00             LDR      R2,[SP, #+0]
   \       0x10   0x61C2             STR      R2,[R0, #+28]
    480            /* Reset LCKx bit(s): LCKK='0' + LCK[15U-0] */
    481            GPIOx->LCKR = GPIO_Pin;
   \       0x12   0x61C1             STR      R1,[R0, #+28]
    482            /* Set LCKx bit(s): LCKK='1' + LCK[15U-0] */
    483            GPIOx->LCKR = tmp;
   \       0x14   0x9900             LDR      R1,[SP, #+0]
   \       0x16   0x61C1             STR      R1,[R0, #+28]
    484            /* Read LCKK register. This read is mandatory to complete key lock sequence */
    485            tmp = GPIOx->LCKR;
   \       0x18   0x69C2             LDR      R2,[R0, #+28]
   \       0x1A   0x9200             STR      R2,[SP, #+0]
    486          
    487            /* read again in order to confirm lock is active */
    488           if((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00u)
   \       0x1C   0x69C0             LDR      R0,[R0, #+28]
   \       0x1E   0xF400 0x3080      AND      R0,R0,#0x10000
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x4180             SBCS     R0,R0,R0
   \       0x26   0x0FC0             LSRS     R0,R0,#+31
    489            {
    490              return HAL_OK;
    491            }
    492            else
    493            {
    494              return HAL_ERROR;
   \       0x28   0xBD12             POP      {R1,R4,PC}       ;; return
    495            }
    496          }
    497          
    498          /**
    499            * @brief  Handle EXTI interrupt request.
    500            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    504          {
    505            /* EXTI line interrupt detected */
    506            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable2_6  ;; 0x40010414
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0x4203             TST      R3,R0
   \        0x6   0xBF1C             ITT      NE
    507            {
    508              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \        0x8   0x6010             STRNE    R0,[R2, #+0]
    509              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \        0xA   0x....'....        BNE.W    HAL_GPIO_EXTI_Callback
    510            }
    511          }
   \        0xE   0x4770             BX       LR               ;; return
    512          
    513          /**
    514            * @brief  EXTI line detection callback.
    515            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    516            * @retval None
    517            */

   \                                 In section .text, align 2
    518          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    519          {
    520            /* Prevent unused argument(s) compilation warning */
    521            UNUSED(GPIO_Pin);
    522          
    523            /* NOTE: This function should not be modified, when the callback is needed,
    524                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    525             */
    526          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4001'0008        DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4002'1018        DC32     0x40021018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4800'0C00        DC32     0x48000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x4800'0400        DC32     0x48000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x4800'0800        DC32     0x48000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x4001'0414        DC32     0x40010414
    527          
    528          /**
    529            * @}
    530            */
    531          
    532          
    533          /**
    534            * @}
    535            */
    536          
    537          #endif /* HAL_GPIO_MODULE_ENABLED */
    538          /**
    539            * @}
    540            */
    541          
    542          /**
    543            * @}
    544            */
    545          
    546          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      36   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       0   HAL_GPIO_EXTI_IRQHandler
         0   -> HAL_GPIO_EXTI_Callback
      40   HAL_GPIO_Init
      12   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
     218  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      16  HAL_GPIO_EXTI_IRQHandler
     406  HAL_GPIO_Init
      42  HAL_GPIO_LockPin
      12  HAL_GPIO_ReadPin
      12  HAL_GPIO_TogglePin
      10  HAL_GPIO_WritePin

 
 746 bytes in section .text
 
 744 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
