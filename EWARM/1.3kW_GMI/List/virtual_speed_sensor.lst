###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:17
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\virtual_speed_sensor.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW67B5.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\virtual_speed_sensor.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\virtual_speed_sensor.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\virtual_speed_sensor.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\virtual_speed_sensor.c
      1          /**
      2            ******************************************************************************
      3            * @file    virtual_speed_sensor.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Virtual Speed Sensor component of the Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "virtual_speed_sensor.h"
     24          
     25          
     26          /** @addtogroup MCSDK
     27            * @{
     28            */
     29          
     30          /** @addtogroup SpeednPosFdbk
     31            * @{
     32            */
     33          
     34          /** @defgroup VirtualSpeedSensor Virtual Speed & Position Feedback
     35            * @brief Virtual Speed Speed & Position Feedback implementation
     36            *
     37            * This component provides a "virtual" implementation of the speed and position feedback features.
     38            * This implementation provides a theoretical estimation of the speed and position of the rotor of
     39            * the motor based on a mechanical acceleration and an initial angle set by the application.
     40            *
     41            * This component is used during the revup phases of the motor in a sensorless subsystem.
     42            *
     43            * @todo Document the Virtual Speed Sensor "module".
     44            *
     45            * @{
     46            */
     47          
     48          /**
     49          * @brief  Software initialization of VirtualSpeedSensor component
     50          * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
     51          * @retval none
     52          */

   \                                 In section .text, align 2
     53          __weak void VSS_Init( VirtualSpeedSensor_Handle_t * pHandle )
     54          {
     55          #ifdef FASTDIV
     56            FD_Init( &( pHandle->fd ) );
     57          #endif
     58          
     59            VSS_Clear( pHandle );
   \                     VSS_Init: (+1)
   \        0x0   0x....'....        B.W      VSS_Clear
     60          }
     61          
     62          /**
     63          * @brief  Software initialization of VSS object to be performed at each restart
     64          *         of the motor.
     65          * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
     66          * @retval none
     67          */

   \                                 In section .text, align 2
     68          __weak void VSS_Clear( VirtualSpeedSensor_Handle_t * pHandle )
     69          {
     70          
     71            pHandle->_Super.bSpeedErrorNumber = 0u;
   \                     VSS_Clear: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7001             STRB     R1,[R0, #+0]
     72            pHandle->_Super.hElAngle = 0;
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x8082             STRH     R2,[R0, #+4]
     73            pHandle->_Super.hMecAngle = 0;
   \        0x8   0x80C1             STRH     R1,[R0, #+6]
     74            pHandle->_Super.hAvrMecSpeedUnit = 0;
   \        0xA   0x8181             STRH     R1,[R0, #+12]
     75            pHandle->_Super.hElSpeedDpp = 0;
   \        0xC   0x81C2             STRH     R2,[R0, #+14]
     76            pHandle->_Super.hMecAccelUnitP = 0;
   \        0xE   0x8241             STRH     R1,[R0, #+18]
     77            pHandle->_Super.bSpeedErrorNumber = 0u;
   \       0x10   0x7002             STRB     R2,[R0, #+0]
     78          
     79            pHandle->wElAccDppP32 = 0;
   \       0x12   0x6201             STR      R1,[R0, #+32]
     80            pHandle->wElSpeedDpp32 = 0;
   \       0x14   0x6241             STR      R1,[R0, #+36]
     81            pHandle->hRemainingStep = 0u;
   \       0x16   0x8502             STRH     R2,[R0, #+40]
     82            pHandle->hElAngleAccu = 0;
   \       0x18   0x302C             ADDS     R0,R0,#+44
   \       0x1A   0x8081             STRH     R1,[R0, #+4]
     83          
     84            pHandle->bTransitionStarted = false;
     85            pHandle->bTransitionEnded = false;
   \       0x1C   0x7041             STRB     R1,[R0, #+1]
   \       0x1E   0x7002             STRB     R2,[R0, #+0]
     86            pHandle->hTransitionRemainingSteps = pHandle->hTransitionSteps;
     87            pHandle->bTransitionLocked = false;
   \       0x20   0x7182             STRB     R2,[R0, #+6]
     88          
     89            pHandle->bCopyObserver = false;
   \       0x22   0x71C2             STRB     R2,[R0, #+7]
   \       0x24   0x8941             LDRH     R1,[R0, #+10]
   \       0x26   0x8041             STRH     R1,[R0, #+2]
     90          
     91          #ifdef FASTDIV
     92            /* (Fast division optimization for cortex-M0 micros)*/
     93            /* Dummy division to speed up next executions */
     94            FD_FastDiv( &( pHandle->fd ), 1, ( int32_t )( pHandle->_Super.bElToMecRatio ) );
     95            FD_FastDiv( &( pHandle->fd ), 1, ( int32_t )( pHandle->hTransitionSteps ) );
     96          #endif
     97          }
   \       0x28   0x4770             BX       LR               ;; return
     98          
     99          #if defined (CCMRAM)
    100          #if defined (__ICCARM__)
    101          #pragma location = ".ccmram"
    102          #elif defined (__CC_ARM) || defined(__GNUC__)
    103          __attribute__( ( section ( ".ccmram" ) ) )
    104          #endif
    105          #endif
    106          /**
    107          * @brief  Update the rotor electrical angle integrating the last setled
    108          *         instantaneous electrical speed express in dpp.
    109          * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    110          * @retval int16_t Measured electrical angle in s16degree format.
    111          */

   \                                 In section .text, align 2
    112          __weak int16_t VSS_CalcElAngle( VirtualSpeedSensor_Handle_t * pHandle, void * pInputVars_str )
    113          {
   \                     VSS_CalcElAngle: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    114          
    115            int16_t hRetAngle;
    116            int16_t hAngleDiff;
    117            int16_t hAngleCorr;
    118            int32_t wAux;
    119            int16_t hSignCorr = 1;
    120          
    121            if ( pHandle->bCopyObserver == true )
   \        0x2   0xF100 0x042C      ADD      R4,R0,#+44
   \        0x6   0x2501             MOVS     R5,#+1
   \        0x8   0x79E2             LDRB     R2,[R4, #+7]
   \        0xA   0x2A01             CMP      R2,#+1
   \        0xC   0xBF08             IT       EQ
   \        0xE   0xF9B1 0x2000      LDRSHEQ  R2,[R1, #+0]
    122            {
    123              hRetAngle = *( int16_t * )pInputVars_str;
   \       0x12   0xD032             BEQ.N    ??VSS_CalcElAngle_0
    124            }
    125            else
    126            {
    127              pHandle->hElAngleAccu += pHandle->_Super.hElSpeedDpp;
   \       0x14   0xF9B0 0x600E      LDRSH    R6,[R0, #+14]
   \       0x18   0x88A2             LDRH     R2,[R4, #+4]
   \       0x1A   0x18B2             ADDS     R2,R6,R2
   \       0x1C   0x80A2             STRH     R2,[R4, #+4]
    128          
    129          #ifdef FASTDIV
    130              pHandle->_Super.hMecAngle += ( int16_t )( FD_FastDiv( &( pHandle->fd ),
    131                                           ( int32_t )pHandle->_Super.hElSpeedDpp,
    132                                           ( int32_t )pHandle->_Super.bElToMecRatio ) );
    133          #else
    134              pHandle->_Super.hMecAngle += pHandle->_Super.hElSpeedDpp /
    135                                           ( int16_t )pHandle->_Super.bElToMecRatio;
   \       0x1E   0x7843             LDRB     R3,[R0, #+1]
   \       0x20   0x88C7             LDRH     R7,[R0, #+6]
   \       0x22   0xFB96 0xF3F3      SDIV     R3,R6,R3
   \       0x26   0x19DF             ADDS     R7,R3,R7
   \       0x28   0x80C7             STRH     R7,[R0, #+6]
    136          #endif
    137          
    138              if ( pHandle->bTransitionStarted == true )
   \       0x2A   0x7827             LDRB     R7,[R4, #+0]
   \       0x2C   0x2F01             CMP      R7,#+1
   \       0x2E   0xD124             BNE.N    ??VSS_CalcElAngle_0
    139              {
    140                if ( pHandle->hTransitionRemainingSteps == 0 )
   \       0x30   0xF9B4 0x3002      LDRSH    R3,[R4, #+2]
   \       0x34   0xB91B             CBNZ.N   R3,??VSS_CalcElAngle_1
    141                {
    142                  hRetAngle = *( int16_t * )pInputVars_str;
   \       0x36   0x5ECA             LDRSH    R2,[R1, R3]
    143                  pHandle->bTransitionEnded = true;
   \       0x38   0x7065             STRB     R5,[R4, #+1]
    144                  pHandle->_Super.bSpeedErrorNumber = 0u;
   \       0x3A   0x7003             STRB     R3,[R0, #+0]
   \       0x3C   0xE01D             B.N      ??VSS_CalcElAngle_0
    145                }
    146                else
    147                {
    148                  pHandle->hTransitionRemainingSteps--;
   \                     ??VSS_CalcElAngle_1: (+1)
   \       0x3E   0x1E5B             SUBS     R3,R3,#+1
   \       0x40   0x8063             STRH     R3,[R4, #+2]
    149          
    150                  if ( pHandle->_Super.hElSpeedDpp >= 0 )
   \       0x42   0x2E00             CMP      R6,#+0
   \       0x44   0xF9B1 0x7000      LDRSH    R7,[R1, #+0]
    151                  {
    152                    hAngleDiff = *( int16_t * )pInputVars_str - pHandle->hElAngleAccu;
    153                  }
    154                  else
    155                  {
    156                    hAngleDiff = pHandle->hElAngleAccu - *( int16_t * )pInputVars_str;
    157                    hSignCorr = -1;
    158                  }
    159          
    160                  wAux = ( int32_t )hAngleDiff * pHandle->hTransitionRemainingSteps;
    161          
    162          #ifdef FASTDIV
    163                  hAngleCorr = ( int16_t )( FD_FastDiv( &( pHandle->fd ),
    164                                                        wAux,
    165                                                        ( int32_t )( pHandle->hTransitionSteps ) ) );
    166          #else
    167                  hAngleCorr = ( int16_t )( wAux / pHandle->hTransitionSteps );
    168          #endif
    169          
    170                  hAngleCorr *= hSignCorr;
   \       0x48   0xF9B4 0xC00A      LDRSH    R12,[R4, #+10]
   \       0x4C   0xBF52             ITEE     PL
   \       0x4E   0x1ABE             SUBPL    R6,R7,R2
   \       0x50   0x1BD6             SUBMI    R6,R2,R7
   \       0x52   0xF04F 0x35FF      MOVMI    R5,#-1
   \       0x56   0xB236             SXTH     R6,R6
   \       0x58   0xFB16 0xF303      SMULBB   R3,R6,R3
   \       0x5C   0xFB93 0xF3FC      SDIV     R3,R3,R12
   \       0x60   0xFB13 0xF305      SMULBB   R3,R3,R5
    171          
    172                  if ( hAngleDiff >= 0 )
   \       0x64   0x2E00             CMP      R6,#+0
   \       0x66   0xB21B             SXTH     R3,R3
   \       0x68   0xD404             BMI.N    ??VSS_CalcElAngle_2
    173                  {
    174                    pHandle->bTransitionLocked = true;
   \       0x6A   0x2201             MOVS     R2,#+1
   \       0x6C   0x71A2             STRB     R2,[R4, #+6]
    175                    hRetAngle = *( int16_t * )pInputVars_str - hAngleCorr;
   \       0x6E   0x880C             LDRH     R4,[R1, #+0]
   \       0x70   0x1AE2             SUBS     R2,R4,R3
   \       0x72   0xE002             B.N      ??VSS_CalcElAngle_0
    176                  }
    177                  else
    178                  {
    179                    if ( pHandle->bTransitionLocked == false )
   \                     ??VSS_CalcElAngle_2: (+1)
   \       0x74   0x79A1             LDRB     R1,[R4, #+6]
   \       0x76   0xB101             CBZ.N    R1,??VSS_CalcElAngle_0
    180                    {
    181                      hRetAngle = pHandle->hElAngleAccu;
    182                    }
    183                    else
    184                    {
    185                      hRetAngle = *( int16_t * )pInputVars_str + hAngleCorr;
   \       0x78   0x19DA             ADDS     R2,R3,R7
    186                    }
    187                  }
    188                }
    189              }
    190              else
    191              {
    192                hRetAngle = pHandle->hElAngleAccu;
    193              }
    194            }
    195          
    196            pHandle->_Super.hElAngle = hRetAngle;
   \                     ??VSS_CalcElAngle_0: (+1)
   \       0x7A   0x8082             STRH     R2,[R0, #+4]
    197            return hRetAngle;
   \       0x7C   0xB210             SXTH     R0,R2
   \       0x7E   0xBDF0             POP      {R4-R7,PC}       ;; return
    198          }
    199          
    200          /**
    201            * @brief  This method must be called with the same periodicity
    202            *         on which speed control is executed.
    203            *         This method computes and stores rotor instantaneous el speed (express
    204            *         in dpp considering the measurement frequency) in order to provide it
    205            *         to SPD_CalcElAngle function and SPD_GetElAngle.
    206            *         Then compute store and return - through parameter
    207            *         hMecSpeedUnit - the rotor average mech speed, expressed in the unit
    208            *         defined by #SPEED_UNIT. Then return the reliability state of the
    209            *         sensor (always true).
    210            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    211            * @param  hMecSpeedUnit pointer to int16_t, used to return the rotor average
    212            *         mechanical speed (SPED_UNIT)
    213            * @retval true = sensor information is reliable
    214            *         false = sensor information is not reliable
    215            */

   \                                 In section .text, align 2
    216          __weak bool VSS_CalcAvrgMecSpeedUnit( VirtualSpeedSensor_Handle_t * pHandle, int16_t * hMecSpeedUnit )
    217          {
   \                     VSS_CalcAvrgMecSpeedUnit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    218            bool SpeedSensorReliability = false;
    219          
    220            if ( pHandle->hRemainingStep > 1u )
   \        0x2   0x8D03             LDRH     R3,[R0, #+40]
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x240A             MOVS     R4,#+10
   \        0x8   0x2B02             CMP      R3,#+2
   \        0xA   0xD319             BCC.N    ??VSS_CalcAvrgMecSpeedUnit_0
    221            {
    222              pHandle->wElSpeedDpp32 += pHandle->wElAccDppP32;
   \        0xC   0x6A45             LDR      R5,[R0, #+36]
   \        0xE   0x6A03             LDR      R3,[R0, #+32]
   \       0x10   0x195D             ADDS     R5,R3,R5
   \       0x12   0x6245             STR      R5,[R0, #+36]
    223              pHandle->_Super.hElSpeedDpp = ( int16_t )( pHandle->wElSpeedDpp32 / 65536 );
    224          
    225              /* Convert dpp into MecUnit */
    226              *hMecSpeedUnit = ( int16_t )( ( ( int32_t )pHandle->_Super.hElSpeedDpp *
    227                                              ( int32_t )pHandle->_Super.hMeasurementFrequency * SPEED_UNIT ) /
    228                                            ( ( int32_t )pHandle->_Super.DPPConvFactor * ( int32_t )pHandle->_Super.bElToMecRatio ) );
   \       0x14   0x13EE             ASRS     R6,R5,#+15
   \       0x16   0xEB05 0x4516      ADD      R5,R5,R6, LSR #+16
   \       0x1A   0x142D             ASRS     R5,R5,#+16
   \       0x1C   0x81C5             STRH     R5,[R0, #+14]
    229          
    230              pHandle->_Super.hAvrMecSpeedUnit = *hMecSpeedUnit;
   \       0x1E   0x8B43             LDRH     R3,[R0, #+26]
   \       0x20   0xF9B0 0x500E      LDRSH    R5,[R0, #+14]
   \       0x24   0x435D             MULS     R5,R3,R5
   \       0x26   0x436C             MULS     R4,R4,R5
   \       0x28   0x69C5             LDR      R5,[R0, #+28]
   \       0x2A   0x7843             LDRB     R3,[R0, #+1]
   \       0x2C   0x435D             MULS     R5,R3,R5
   \       0x2E   0xFB94 0xF3F5      SDIV     R3,R4,R5
   \       0x32   0x800B             STRH     R3,[R1, #+0]
   \       0x34   0x880C             LDRH     R4,[R1, #+0]
    231          
    232              pHandle->hRemainingStep--;
   \       0x36   0x8D03             LDRH     R3,[R0, #+40]
   \       0x38   0x8184             STRH     R4,[R0, #+12]
   \       0x3A   0x1E5C             SUBS     R4,R3,#+1
   \       0x3C   0x8504             STRH     R4,[R0, #+40]
   \       0x3E   0xE014             B.N      ??VSS_CalcAvrgMecSpeedUnit_1
    233            }
    234            else if ( pHandle->hRemainingStep == 1u )
   \                     ??VSS_CalcAvrgMecSpeedUnit_0: (+1)
   \       0x40   0x2B01             CMP      R3,#+1
   \       0x42   0xD110             BNE.N    ??VSS_CalcAvrgMecSpeedUnit_2
    235            {
    236              *hMecSpeedUnit = pHandle->hFinalMecSpeedUnit;
    237          
    238              pHandle->_Super.hAvrMecSpeedUnit = *hMecSpeedUnit;
   \       0x44   0xF9B0 0x302A      LDRSH    R3,[R0, #+42]
   \       0x48   0x800B             STRH     R3,[R1, #+0]
   \       0x4A   0x8183             STRH     R3,[R0, #+12]
    239          
    240              pHandle->_Super.hElSpeedDpp = ( int16_t )( ( ( int32_t )( *hMecSpeedUnit ) *
    241                                            ( int32_t ) ( pHandle->_Super.DPPConvFactor) ) /
    242                                            ( ( int32_t )SPEED_UNIT * ( int32_t )pHandle->_Super.hMeasurementFrequency ) );
    243          
    244              pHandle->_Super.hElSpeedDpp *= ( int16_t )( pHandle->_Super.bElToMecRatio );
   \       0x4C   0x5E8D             LDRSH    R5,[R1, R2]
   \       0x4E   0x69C3             LDR      R3,[R0, #+28]
   \       0x50   0x8B46             LDRH     R6,[R0, #+26]
   \       0x52   0x435D             MULS     R5,R3,R5
   \       0x54   0x4374             MULS     R4,R4,R6
   \       0x56   0x7843             LDRB     R3,[R0, #+1]
    245          
    246              pHandle->hRemainingStep = 0u;
   \       0x58   0x8502             STRH     R2,[R0, #+40]
   \       0x5A   0xFB95 0xF4F4      SDIV     R4,R5,R4
   \       0x5E   0xFB14 0xF303      SMULBB   R3,R4,R3
   \       0x62   0x81C3             STRH     R3,[R0, #+14]
   \       0x64   0xE001             B.N      ??VSS_CalcAvrgMecSpeedUnit_1
    247            }
    248            else
    249            {
    250              *hMecSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
   \                     ??VSS_CalcAvrgMecSpeedUnit_2: (+1)
   \       0x66   0x8984             LDRH     R4,[R0, #+12]
   \       0x68   0x800C             STRH     R4,[R1, #+0]
    251            }
    252            /* If the transition is not done yet, we already know that speed is not reliable */
    253            if ( pHandle->bTransitionEnded == false )
   \                     ??VSS_CalcAvrgMecSpeedUnit_1: (+1)
   \       0x6A   0xF890 0x302D      LDRB     R3,[R0, #+45]
   \       0x6E   0xB913             CBNZ.N   R3,??VSS_CalcAvrgMecSpeedUnit_3
    254            {
    255              pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
   \       0x70   0x78C1             LDRB     R1,[R0, #+3]
   \       0x72   0x7001             STRB     R1,[R0, #+0]
    256              SpeedSensorReliability = false;
   \       0x74   0xE002             B.N      ??VSS_CalcAvrgMecSpeedUnit_4
    257            }
    258            else
    259            {
    260              SpeedSensorReliability = SPD_IsMecSpeedReliable ( &pHandle->_Super, hMecSpeedUnit );
   \                     ??VSS_CalcAvrgMecSpeedUnit_3: (+1)
   \       0x76   0x....'....        BL       SPD_IsMecSpeedReliable
   \       0x7A   0x4602             MOV      R2,R0
    261            }
    262          
    263            return ( SpeedSensorReliability );
   \                     ??VSS_CalcAvrgMecSpeedUnit_4: (+1)
   \       0x7C   0x4610             MOV      R0,R2
   \       0x7E   0xBD70             POP      {R4-R6,PC}       ;; return
    264          }
    265          
    266          /**
    267            * @brief  It is used to set istantaneous information on VSS mechanical and
    268            *         electrical angle.
    269            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    270            * @param  hMecAngle istantaneous measure of rotor mechanical angle
    271            * @retval none
    272            */

   \                                 In section .text, align 2
    273          __weak void VSS_SetMecAngle( VirtualSpeedSensor_Handle_t * pHandle, int16_t hMecAngle )
    274          {
    275          
    276            pHandle->hElAngleAccu = hMecAngle;
    277            pHandle->_Super.hMecAngle = pHandle->hElAngleAccu / ( int16_t )pHandle->_Super.bElToMecRatio;
   \                     VSS_SetMecAngle: (+1)
   \        0x0   0x7843             LDRB     R3,[R0, #+1]
   \        0x2   0x8601             STRH     R1,[R0, #+48]
   \        0x4   0xFB91 0xF3F3      SDIV     R3,R1,R3
   \        0x8   0x80C3             STRH     R3,[R0, #+6]
    278            pHandle->_Super.hElAngle = hMecAngle;
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    279          }
   \        0xC   0x4770             BX       LR               ;; return
    280          
    281          /**
    282            * @brief  Set the mechanical acceleration of virtual sensor. This acceleration
    283                      is defined starting from current mechanical speed, final mechanical
    284                      speed expressed in 0.1Hz and duration expressed in milliseconds.
    285            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    286            * @param  hFinalMecSpeedUnit mechanical speed  assumed by
    287                      the virtual sensor at the end of the duration. Expressed in the unit defined
    288                      by #SPEED_UNIT.
    289            * @param  hDurationms Duration expressed in ms. It can be 0 to apply
    290                      instantaneous the final speed.
    291            * @retval none
    292            */

   \                                 In section .text, align 2
    293          __weak void  VSS_SetMecAcceleration( VirtualSpeedSensor_Handle_t * pHandle, int16_t  hFinalMecSpeedUnit,
    294                                        uint16_t hDurationms )
    295          {
   \                     VSS_SetMecAcceleration: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    296          
    297            uint16_t hNbrStep;
    298            int16_t hCurrentMecSpeedDpp;
    299            int32_t wMecAccDppP32;
    300            int16_t hFinalMecSpeedDpp;
    301          
    302            if ( pHandle->bTransitionStarted == false )
   \        0x2   0xF100 0x052C      ADD      R5,R0,#+44
   \        0x6   0x4613             MOV      R3,R2
   \        0x8   0x782A             LDRB     R2,[R5, #+0]
   \        0xA   0xBB92             CBNZ.N   R2,??VSS_SetMecAcceleration_0
    303            {
    304              if ( hDurationms == 0u )
   \        0xC   0x240A             MOVS     R4,#+10
   \        0xE   0x001E             MOVS     R6,R3
   \       0x10   0xD10F             BNE.N    ??VSS_SetMecAcceleration_1
    305              {
    306                pHandle->_Super.hAvrMecSpeedUnit = hFinalMecSpeedUnit;
    307          
    308                pHandle->_Super.hElSpeedDpp = ( int16_t )( ( ( int32_t )( hFinalMecSpeedUnit ) *
    309                                              ( int32_t )( pHandle->_Super.DPPConvFactor) ) /
    310                                              ( ( int32_t )SPEED_UNIT * ( int32_t )pHandle->_Super.hMeasurementFrequency ) );
    311          
    312                pHandle->_Super.hElSpeedDpp *= ( int16_t )( pHandle->_Super.bElToMecRatio );
   \       0x12   0x69C2             LDR      R2,[R0, #+28]
   \       0x14   0x8B45             LDRH     R5,[R0, #+26]
   \       0x16   0x8181             STRH     R1,[R0, #+12]
   \       0x18   0x460B             MOV      R3,R1
   \       0x1A   0x4353             MULS     R3,R2,R3
   \       0x1C   0x436C             MULS     R4,R4,R5
   \       0x1E   0x7842             LDRB     R2,[R0, #+1]
    313          
    314                pHandle->hRemainingStep = 0u;
    315          
    316                pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
   \       0x20   0x8541             STRH     R1,[R0, #+42]
   \       0x22   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \       0x26   0xFB13 0xF202      SMULBB   R2,R3,R2
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x81C2             STRH     R2,[R0, #+14]
   \       0x2E   0x8503             STRH     R3,[R0, #+40]
   \       0x30   0xBDF0             POP      {R4-R7,PC}
    317              }
    318              else
    319              {
    320                hNbrStep = ( uint16_t )( ( ( uint32_t )hDurationms *
    321                                           ( uint32_t )pHandle->hSpeedSamplingFreqHz ) /
    322                                         1000u );
    323          
    324                hNbrStep++;
   \                     ??VSS_SetMecAcceleration_1: (+1)
   \       0x32   0x892A             LDRH     R2,[R5, #+8]
   \       0x34   0x4353             MULS     R3,R2,R3
   \       0x36   0xF44F 0x757A      MOV      R5,#+1000
   \       0x3A   0xFBB3 0xF5F5      UDIV     R5,R3,R5
    325          
    326                pHandle->hRemainingStep = hNbrStep;
    327          
    328                hCurrentMecSpeedDpp = pHandle->_Super.hElSpeedDpp /
    329                                      ( int16_t )pHandle->_Super.bElToMecRatio;
    330          
    331                hFinalMecSpeedDpp = ( int16_t )( ( ( int32_t )hFinalMecSpeedUnit * ( int32_t )( pHandle->_Super.DPPConvFactor) ) /
    332                                                 ( ( int32_t )SPEED_UNIT * ( int32_t )pHandle->_Super.hMeasurementFrequency ) );
    333          
    334                wMecAccDppP32 = ( ( ( int32_t )hFinalMecSpeedDpp - ( int32_t )hCurrentMecSpeedDpp ) *
    335                                  ( int32_t )65536 ) / ( int32_t )hNbrStep;
    336          
    337                pHandle->wElAccDppP32 = wMecAccDppP32 * ( int16_t )pHandle->_Super.bElToMecRatio;
   \       0x3E   0x69C3             LDR      R3,[R0, #+28]
   \       0x40   0x1C6D             ADDS     R5,R5,#+1
   \       0x42   0x460A             MOV      R2,R1
   \       0x44   0x8505             STRH     R5,[R0, #+40]
   \       0x46   0x435A             MULS     R2,R3,R2
   \       0x48   0x8B43             LDRH     R3,[R0, #+26]
   \       0x4A   0x7846             LDRB     R6,[R0, #+1]
   \       0x4C   0xF9B0 0x700E      LDRSH    R7,[R0, #+14]
    338          
    339                pHandle->hFinalMecSpeedUnit = hFinalMecSpeedUnit;
   \       0x50   0x8541             STRH     R1,[R0, #+42]
   \       0x52   0x435C             MULS     R4,R4,R3
   \       0x54   0xFB92 0xF4F4      SDIV     R4,R2,R4
   \       0x58   0xFB97 0xF2F6      SDIV     R2,R7,R6
   \       0x5C   0xB224             SXTH     R4,R4
   \       0x5E   0xB212             SXTH     R2,R2
   \       0x60   0x1AA4             SUBS     R4,R4,R2
   \       0x62   0x0424             LSLS     R4,R4,#+16
   \       0x64   0xB2AD             UXTH     R5,R5
   \       0x66   0xFB94 0xF5F5      SDIV     R5,R4,R5
   \       0x6A   0x436E             MULS     R6,R6,R5
    340          
    341                pHandle->wElSpeedDpp32 = ( int32_t )pHandle->_Super.hElSpeedDpp * ( int32_t )65536;
   \       0x6C   0x043F             LSLS     R7,R7,#+16
   \       0x6E   0x6206             STR      R6,[R0, #+32]
   \       0x70   0x6247             STR      R7,[R0, #+36]
    342              }
    343            }
    344          }
   \                     ??VSS_SetMecAcceleration_0: (+1)
   \       0x72   0xBDF0             POP      {R4-R7,PC}       ;; return
    345          
    346          /**
    347            * @brief  Checks if the ramp executed after a VSPD_SetMecAcceleration command
    348            *         has been completed.
    349            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    350            * @retval bool true if the ramp is completed, otherwise false.
    351            */

   \                                 In section .text, align 2
    352          __weak bool VSS_RampCompleted( VirtualSpeedSensor_Handle_t * pHandle )
    353          {
   \                     VSS_RampCompleted: (+1)
   \        0x0   0x4601             MOV      R1,R0
    354            bool retVal = false;
   \        0x2   0x2000             MOVS     R0,#+0
    355            if ( pHandle->hRemainingStep == 0u )
   \        0x4   0x8D09             LDRH     R1,[R1, #+40]
   \        0x6   0xB901             CBNZ.N   R1,??VSS_RampCompleted_0
    356            {
    357              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    358            }
    359            return retVal;
   \                     ??VSS_RampCompleted_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return
    360          }
    361          
    362          /**
    363            * @brief  Get the final speed of last setled ramp of virtual sensor expressed
    364                      in 0.1Hz.
    365            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    366            * @retval none
    367            */

   \                                 In section .text, align 2
    368          __weak int16_t  VSS_GetLastRampFinalSpeed( VirtualSpeedSensor_Handle_t * pHandle )
    369          {
    370            return pHandle->hFinalMecSpeedUnit;
   \                     VSS_GetLastRampFinalSpeed: (+1)
   \        0x0   0xF9B0 0x002A      LDRSH    R0,[R0, #+42]
   \        0x4   0x4770             BX       LR               ;; return
    371          }
    372          
    373          /**
    374            * @brief  Set the command to Start the transition phase from VirtualSpeedSensor
    375                      to other SpeedSensor.
    376                      Transition is to be considered ended when Sensor information is
    377                      declared 'Reliable' or if function returned value is false
    378            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    379            * @param  bool true to Start the transition phase, false has no effect
    380            * @retval bool true if Transition phase is enabled (started or not), false if
    381                      transition has been triggered but it's actually disabled
    382                      (parameter hTransitionSteps = 0)
    383            */

   \                                 In section .text, align 2
    384          __weak bool VSS_SetStartTransition( VirtualSpeedSensor_Handle_t * pHandle, bool bCommand )
    385          {
   \                     VSS_SetStartTransition: (+1)
   \        0x0   0x4602             MOV      R2,R0
    386            bool bAux = true;
   \        0x2   0x2001             MOVS     R0,#+1
    387            if ( bCommand == true )
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xBF01             ITTTT    EQ
   \        0x8   0xF102 0x032C      ADDEQ    R3,R2,#+44
   \        0xC   0x7018             STRBEQ   R0,[R3, #+0]
   \        0xE   0xF9B3 0x100A      LDRSHEQ  R1,[R3, #+10]
   \       0x12   0x2900             CMPEQ    R1,#+0
    388            {
    389              pHandle->bTransitionStarted = true;
    390          
    391              if ( pHandle->hTransitionSteps == 0 )
   \       0x14   0xD102             BNE.N    ??VSS_SetStartTransition_0
    392              {
    393                pHandle->bTransitionEnded = true;
   \       0x16   0x7058             STRB     R0,[R3, #+1]
    394                pHandle->_Super.bSpeedErrorNumber = 0u;
   \       0x18   0x7011             STRB     R1,[R2, #+0]
    395                bAux = false;
   \       0x1A   0x2000             MOVS     R0,#+0
    396              }
    397            }
    398            return bAux;
   \                     ??VSS_SetStartTransition_0: (+1)
   \       0x1C   0x4770             BX       LR               ;; return
    399          }
    400          
    401          /**
    402            * @brief  Return the status of the transition phase.
    403            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    404            * @retval bool true if Transition phase is ongoing, false otherwise.
    405            */

   \                                 In section .text, align 2
    406          __weak bool VSS_IsTransitionOngoing( VirtualSpeedSensor_Handle_t * pHandle )
    407          {
   \                     VSS_IsTransitionOngoing: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4601             MOV      R1,R0
    408            uint16_t hTS = 0u, hTE = 0u, hAux;
   \        0x4   0x2200             MOVS     R2,#+0
    409            bool retVal = false;
    410            if ( pHandle->bTransitionStarted == true )
   \        0x6   0xF811 0x4F2C      LDRB     R4,[R1, #+44]!
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x2C01             CMP      R4,#+1
    411            {
    412              hTS = 1u;
    413            }
    414            if ( pHandle->bTransitionEnded == true )
   \       0x10   0x7849             LDRB     R1,[R1, #+1]
   \       0x12   0xBF08             IT       EQ
   \       0x14   0x2201             MOVEQ    R2,#+1
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xBF08             IT       EQ
   \       0x1A   0x2301             MOVEQ    R3,#+1
    415            {
    416              hTE = 1u;
    417            }
    418            hAux = hTS ^ hTE;
    419            if ( hAux != 0u )
   \       0x1C   0x405A             EORS     R2,R3,R2
   \       0x1E   0xBF18             IT       NE
   \       0x20   0x2001             MOVNE    R0,#+1
    420            {
    421              retVal = true;
    422            }
    423            return ( retVal );
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    424          }
    425          

   \                                 In section .text, align 2
    426          __weak bool VSS_TransitionEnded( VirtualSpeedSensor_Handle_t * pHandle )
    427          {
    428              return pHandle->bTransitionEnded;
   \                     VSS_TransitionEnded: (+1)
   \        0x0   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \        0x4   0x4770             BX       LR               ;; return
    429          }
    430          
    431          /**
    432            * @brief  It set istantaneous information on rotor electrical angle copied by state observer;
    433            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    434            * @retval none
    435            */

   \                                 In section .text, align 2
    436          __weak void VSS_SetCopyObserver( VirtualSpeedSensor_Handle_t * pHandle )
    437          {
    438            pHandle->bCopyObserver = true;
   \                     VSS_SetCopyObserver: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0xF880 0x1033      STRB     R1,[R0, #+51]
    439          }
   \        0x6   0x4770             BX       LR               ;; return
    440          
    441          /**
    442            * @brief  It  set istantaneous information on rotor electrical angle.
    443            * @param  pHandle: handler of the current instance of the VirtualSpeedSensor component
    444            * @param  hElAngle istantaneous measure of rotor electrical angle (s16degrees)
    445            * @retval none
    446            */

   \                                 In section .text, align 2
    447          __weak void VSS_SetElAngle( VirtualSpeedSensor_Handle_t * pHandle, int16_t hElAngle )
    448          {
    449            pHandle->hElAngleAccu = hElAngle;
   \                     VSS_SetElAngle: (+1)
   \        0x0   0x8601             STRH     R1,[R0, #+48]
    450            pHandle->_Super.hElAngle = hElAngle;
   \        0x2   0x8081             STRH     R1,[R0, #+4]
    451          }
   \        0x4   0x4770             BX       LR               ;; return
    452          
    453          /**
    454            * @}
    455            */
    456          
    457          /**
    458            * @}
    459            */
    460          
    461          /**
    462            * @}
    463            */
    464          
    465          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   VSS_CalcAvrgMecSpeedUnit
        16   -> SPD_IsMecSpeedReliable
      20   VSS_CalcElAngle
       0   VSS_Clear
       0   VSS_GetLastRampFinalSpeed
       0   VSS_Init
         0   -> VSS_Clear
       8   VSS_IsTransitionOngoing
       0   VSS_RampCompleted
       0   VSS_SetCopyObserver
       0   VSS_SetElAngle
      20   VSS_SetMecAcceleration
       0   VSS_SetMecAngle
       0   VSS_SetStartTransition
       0   VSS_TransitionEnded


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     128  VSS_CalcAvrgMecSpeedUnit
     128  VSS_CalcElAngle
      42  VSS_Clear
       6  VSS_GetLastRampFinalSpeed
       4  VSS_Init
      36  VSS_IsTransitionOngoing
      12  VSS_RampCompleted
       8  VSS_SetCopyObserver
       6  VSS_SetElAngle
     116  VSS_SetMecAcceleration
      14  VSS_SetMecAngle
      30  VSS_SetStartTransition
       6  VSS_TransitionEnded

 
 536 bytes in section .text
 
 0 bytes of CODE memory (+ 536 bytes shared)

Errors: none
Warnings: none
