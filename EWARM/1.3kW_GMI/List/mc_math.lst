###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:13:51
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Src\mc_math.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EWFACF.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Src\mc_math.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\mc_math.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\mc_math.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Src\mc_math.c
      1          /**
      2            ******************************************************************************
      3            * @file    mc_math.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides mathematics functions useful for and specific to
      6            *          Motor Control.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "mc_math.h"
     23          #include "mc_type.h"
     24          
     25          /** @addtogroup MCSDK
     26            * @{
     27            */
     28          
     29          /** @defgroup MC_Math Motor Control Math functions
     30            * @brief Motor Control Mathematic functions of the Motor Control SDK
     31            *
     32            * @todo Document the Motor Control Math "module".
     33            *
     34            * @{
     35            */
     36          
     37          /* Private macro -------------------------------------------------------------*/
     38          
     39          #define SIN_COS_TABLE {\
     40              0x0000,0x00C9,0x0192,0x025B,0x0324,0x03ED,0x04B6,0x057F,\
     41              0x0648,0x0711,0x07D9,0x08A2,0x096A,0x0A33,0x0AFB,0x0BC4,\
     42              0x0C8C,0x0D54,0x0E1C,0x0EE3,0x0FAB,0x1072,0x113A,0x1201,\
     43              0x12C8,0x138F,0x1455,0x151C,0x15E2,0x16A8,0x176E,0x1833,\
     44              0x18F9,0x19BE,0x1A82,0x1B47,0x1C0B,0x1CCF,0x1D93,0x1E57,\
     45              0x1F1A,0x1FDD,0x209F,0x2161,0x2223,0x22E5,0x23A6,0x2467,\
     46              0x2528,0x25E8,0x26A8,0x2767,0x2826,0x28E5,0x29A3,0x2A61,\
     47              0x2B1F,0x2BDC,0x2C99,0x2D55,0x2E11,0x2ECC,0x2F87,0x3041,\
     48              0x30FB,0x31B5,0x326E,0x3326,0x33DF,0x3496,0x354D,0x3604,\
     49              0x36BA,0x376F,0x3824,0x38D9,0x398C,0x3A40,0x3AF2,0x3BA5,\
     50              0x3C56,0x3D07,0x3DB8,0x3E68,0x3F17,0x3FC5,0x4073,0x4121,\
     51              0x41CE,0x427A,0x4325,0x43D0,0x447A,0x4524,0x45CD,0x4675,\
     52              0x471C,0x47C3,0x4869,0x490F,0x49B4,0x4A58,0x4AFB,0x4B9D,\
     53              0x4C3F,0x4CE0,0x4D81,0x4E20,0x4EBF,0x4F5D,0x4FFB,0x5097,\
     54              0x5133,0x51CE,0x5268,0x5302,0x539B,0x5432,0x54C9,0x5560,\
     55              0x55F5,0x568A,0x571D,0x57B0,0x5842,0x58D3,0x5964,0x59F3,\
     56              0x5A82,0x5B0F,0x5B9C,0x5C28,0x5CB3,0x5D3E,0x5DC7,0x5E4F,\
     57              0x5ED7,0x5F5D,0x5FE3,0x6068,0x60EB,0x616E,0x61F0,0x6271,\
     58              0x62F1,0x6370,0x63EE,0x646C,0x64E8,0x6563,0x65DD,0x6656,\
     59              0x66CF,0x6746,0x67BC,0x6832,0x68A6,0x6919,0x698B,0x69FD,\
     60              0x6A6D,0x6ADC,0x6B4A,0x6BB7,0x6C23,0x6C8E,0x6CF8,0x6D61,\
     61              0x6DC9,0x6E30,0x6E96,0x6EFB,0x6F5E,0x6FC1,0x7022,0x7083,\
     62              0x70E2,0x7140,0x719D,0x71F9,0x7254,0x72AE,0x7307,0x735E,\
     63              0x73B5,0x740A,0x745F,0x74B2,0x7504,0x7555,0x75A5,0x75F3,\
     64              0x7641,0x768D,0x76D8,0x7722,0x776B,0x77B3,0x77FA,0x783F,\
     65              0x7884,0x78C7,0x7909,0x794A,0x7989,0x79C8,0x7A05,0x7A41,\
     66              0x7A7C,0x7AB6,0x7AEE,0x7B26,0x7B5C,0x7B91,0x7BC5,0x7BF8,\
     67              0x7C29,0x7C59,0x7C88,0x7CB6,0x7CE3,0x7D0E,0x7D39,0x7D62,\
     68              0x7D89,0x7DB0,0x7DD5,0x7DFA,0x7E1D,0x7E3E,0x7E5F,0x7E7E,\
     69              0x7E9C,0x7EB9,0x7ED5,0x7EEF,0x7F09,0x7F21,0x7F37,0x7F4D,\
     70              0x7F61,0x7F74,0x7F86,0x7F97,0x7FA6,0x7FB4,0x7FC1,0x7FCD,\
     71              0x7FD8,0x7FE1,0x7FE9,0x7FF0,0x7FF5,0x7FF9,0x7FFD,0x7FFE}
     72          
     73          #define ATAN1DIV1     (int16_t)8192
     74          #define ATAN1DIV2     (int16_t)4836
     75          #define ATAN1DIV4     (int16_t)2555
     76          #define ATAN1DIV8     (int16_t)1297
     77          #define ATAN1DIV16    (int16_t)651
     78          #define ATAN1DIV32    (int16_t)326
     79          #define ATAN1DIV64    (int16_t)163
     80          #define ATAN1DIV128   (int16_t)81
     81          #define ATAN1DIV256   (int16_t)41
     82          #define ATAN1DIV512   (int16_t)20
     83          #define ATAN1DIV1024  (int16_t)10
     84          #define ATAN1DIV2048  (int16_t)5
     85          #define ATAN1DIV4096  (int16_t)3
     86          #define ATAN1DIV8192  (int16_t)1
     87          
     88          #define SIN_MASK        0x0300u
     89          #define U0_90           0x0200u
     90          #define U90_180         0x0300u
     91          #define U180_270        0x0000u
     92          #define U270_360        0x0100u
     93          
     94          /* Private variables ---------------------------------------------------------*/

   \                                 In section .rodata, align 4
     95          const int16_t hSin_Cos_Table[256] = SIN_COS_TABLE;
   \                     hSin_Cos_Table:
   \        0x0   0x0000 0x00C9      DC16 0, 201, 402, 603, 804, 1'005, 1'206, 1'407, 1'608, 1'809, 2'009

   \               0x0192 0x025

   \              B 0x0324 0x03

   \              ED 0x04B6 0x0

   \              57F 0x0648 0x

   \              0711 0x07D9
   \       0x16   0x08A2 0x096A      DC16 2'210, 2'410, 2'611, 2'811, 3'012, 3'212, 3'412, 3'612, 3'811

   \               0x0A33 0x0AF

   \              B 0x0BC4 0x0C

   \              8C 0x0D54 0x0

   \              E1C 0x0EE3
   \       0x28   0x0FAB 0x1072      DC16 4'011, 4'210, 4'410, 4'609, 4'808, 5'007, 5'205, 5'404, 5'602

   \               0x113A 0x120

   \              1 0x12C8 0x13

   \              8F 0x1455 0x1

   \              51C 0x15E2
   \       0x3A   0x16A8 0x176E      DC16 5'800, 5'998, 6'195, 6'393, 6'590, 6'786, 6'983, 7'179, 7'375

   \               0x1833 0x18F

   \              9 0x19BE 0x1A

   \              82 0x1B47 0x1

   \              C0B 0x1CCF
   \       0x4C   0x1D93 0x1E57      DC16 7'571, 7'767, 7'962, 8'157, 8'351, 8'545, 8'739, 8'933, 9'126

   \               0x1F1A 0x1FD

   \              D 0x209F 0x21

   \              61 0x2223 0x2

   \              2E5 0x23A6
   \       0x5E   0x2467 0x2528      DC16 9'319, 9'512, 9'704, 9'896, 10'087, 10'278, 10'469, 10'659, 10'849

   \               0x25E8 0x26A

   \              8 0x2767 0x28

   \              26 0x28E5 0x2

   \              9A3 0x2A61
   \       0x70   0x2B1F 0x2BDC      DC16 11'039, 11'228, 11'417, 11'605, 11'793, 11'980, 12'167, 12'353

   \               0x2C99 0x2D5

   \              5 0x2E11 0x2E

   \              CC 0x2F87 0x3

   \              041
   \       0x80   0x30FB 0x31B5      DC16 12'539, 12'725, 12'910, 13'094, 13'279, 13'462, 13'645, 13'828

   \               0x326E 0x332

   \              6 0x33DF 0x34

   \              96 0x354D 0x3

   \              604
   \       0x90   0x36BA 0x376F      DC16 14'010, 14'191, 14'372, 14'553, 14'732, 14'912, 15'090, 15'269

   \               0x3824 0x38D

   \              9 0x398C 0x3A

   \              40 0x3AF2 0x3

   \              BA5
   \       0xA0   0x3C56 0x3D07      DC16 15'446, 15'623, 15'800, 15'976, 16'151, 16'325, 16'499, 16'673

   \               0x3DB8 0x3E6

   \              8 0x3F17 0x3F

   \              C5 0x4073 0x4

   \              121
   \       0xB0   0x41CE 0x427A      DC16 16'846, 17'018, 17'189, 17'360, 17'530, 17'700, 17'869, 18'037

   \               0x4325 0x43D

   \              0 0x447A 0x45

   \              24 0x45CD 0x4

   \              675
   \       0xC0   0x471C 0x47C3      DC16 18'204, 18'371, 18'537, 18'703, 18'868, 19'032, 19'195, 19'357

   \               0x4869 0x490

   \              F 0x49B4 0x4A

   \              58 0x4AFB 0x4

   \              B9D
   \       0xD0   0x4C3F 0x4CE0      DC16 19'519, 19'680, 19'841, 20'000, 20'159, 20'317, 20'475, 20'631

   \               0x4D81 0x4E2

   \              0 0x4EBF 0x4F

   \              5D 0x4FFB 0x5

   \              097
   \       0xE0   0x5133 0x51CE      DC16 20'787, 20'942, 21'096, 21'250, 21'403, 21'554, 21'705, 21'856

   \               0x5268 0x530

   \              2 0x539B 0x54

   \              32 0x54C9 0x5

   \              560
   \       0xF0   0x55F5 0x568A      DC16 22'005, 22'154, 22'301, 22'448, 22'594, 22'739, 22'884, 23'027

   \               0x571D 0x57B

   \              0 0x5842 0x58

   \              D3 0x5964 0x5

   \              9F3
   \      0x100   0x5A82 0x5B0F      DC16 23'170, 23'311, 23'452, 23'592, 23'731, 23'870, 24'007, 24'143

   \               0x5B9C 0x5C2

   \              8 0x5CB3 0x5D

   \              3E 0x5DC7 0x5

   \              E4F
   \      0x110   0x5ED7 0x5F5D      DC16 24'279, 24'413, 24'547, 24'680, 24'811, 24'942, 25'072, 25'201

   \               0x5FE3 0x606

   \              8 0x60EB 0x61

   \              6E 0x61F0 0x6

   \              271
   \      0x120   0x62F1 0x6370      DC16 25'329, 25'456, 25'582, 25'708, 25'832, 25'955, 26'077, 26'198

   \               0x63EE 0x646

   \              C 0x64E8 0x65

   \              63 0x65DD 0x6

   \              656
   \      0x130   0x66CF 0x6746      DC16 26'319, 26'438, 26'556, 26'674, 26'790, 26'905, 27'019, 27'133

   \               0x67BC 0x683

   \              2 0x68A6 0x69

   \              19 0x698B 0x6

   \              9FD
   \      0x140   0x6A6D 0x6ADC      DC16 27'245, 27'356, 27'466, 27'575, 27'683, 27'790, 27'896, 28'001

   \               0x6B4A 0x6BB

   \              7 0x6C23 0x6C

   \              8E 0x6CF8 0x6

   \              D61
   \      0x150   0x6DC9 0x6E30      DC16 28'105, 28'208, 28'310, 28'411, 28'510, 28'609, 28'706, 28'803

   \               0x6E96 0x6EF

   \              B 0x6F5E 0x6F

   \              C1 0x7022 0x7

   \              083
   \      0x160   0x70E2 0x7140      DC16 28'898, 28'992, 29'085, 29'177, 29'268, 29'358, 29'447, 29'534

   \               0x719D 0x71F

   \              9 0x7254 0x72

   \              AE 0x7307 0x7

   \              35E
   \      0x170   0x73B5 0x740A      DC16 29'621, 29'706, 29'791, 29'874, 29'956, 30'037, 30'117, 30'195

   \               0x745F 0x74B

   \              2 0x7504 0x75

   \              55 0x75A5 0x7

   \              5F3
   \      0x180   0x7641 0x768D      DC16 30'273, 30'349, 30'424, 30'498, 30'571, 30'643, 30'714, 30'783

   \               0x76D8 0x772

   \              2 0x776B 0x77

   \              B3 0x77FA 0x7

   \              83F
   \      0x190   0x7884 0x78C7      DC16 30'852, 30'919, 30'985, 31'050, 31'113, 31'176, 31'237, 31'297

   \               0x7909 0x794

   \              A 0x7989 0x79

   \              C8 0x7A05 0x7

   \              A41
   \      0x1A0   0x7A7C 0x7AB6      DC16 31'356, 31'414, 31'470, 31'526, 31'580, 31'633, 31'685, 31'736

   \               0x7AEE 0x7B2

   \              6 0x7B5C 0x7B

   \              91 0x7BC5 0x7

   \              BF8
   \      0x1B0   0x7C29 0x7C59      DC16 31'785, 31'833, 31'880, 31'926, 31'971, 32'014, 32'057, 32'098

   \               0x7C88 0x7CB

   \              6 0x7CE3 0x7D

   \              0E 0x7D39 0x7

   \              D62
   \      0x1C0   0x7D89 0x7DB0      DC16 32'137, 32'176, 32'213, 32'250, 32'285, 32'318, 32'351, 32'382

   \               0x7DD5 0x7DF

   \              A 0x7E1D 0x7E

   \              3E 0x7E5F 0x7

   \              E7E
   \      0x1D0   0x7E9C 0x7EB9      DC16 32'412, 32'441, 32'469, 32'495, 32'521, 32'545, 32'567, 32'589

   \               0x7ED5 0x7EE

   \              F 0x7F09 0x7F

   \              21 0x7F37 0x7

   \              F4D
   \      0x1E0   0x7F61 0x7F74      DC16 32'609, 32'628, 32'646, 32'663, 32'678, 32'692, 32'705, 32'717

   \               0x7F86 0x7F9

   \              7 0x7FA6 0x7F

   \              B4 0x7FC1 0x7

   \              FCD
   \      0x1F0   0x7FD8 0x7FE1      DC16 32'728, 32'737, 32'745, 32'752, 32'757, 32'761, 32'765, 32'766

   \               0x7FE9 0x7FF

   \              0 0x7FF5 0x7F

   \              F9 0x7FFD 0x7

   \              FFE
     96          
     97          #define divSQRT_3 (int32_t)0x49E6    /* 1/sqrt(3) in q1.15 format=0.5773315*/
     98          
     99          #if defined (CCMRAM)
    100          #if defined (__ICCARM__)
    101          #pragma location = ".ccmram"
    102          #elif defined (__CC_ARM) || defined(__GNUC__)
    103          __attribute__( ( section ( ".ccmram" ) ) )
    104          #endif
    105          #endif
    106          /**
    107            * @brief  This function transforms stator values a and b (which are
    108            *         directed along axes each displaced by 120 degrees) into values
    109            *         alpha and beta in a stationary qd reference frame.
    110            *                               alpha = a
    111            *                       beta = -(2*b+a)/sqrt(3)
    112            * @param  Input: stator values a and b in ab_t format
    113            * @retval Stator values alpha and beta in alphabeta_t format
    114            */

   \                                 In section .text, align 4
    115          __weak alphabeta_t MCM_Clarke( ab_t Input  )
    116          {
   \                     MCM_Clarke: (+1)
   \        0x0   0xB401             PUSH     {R0}
   \        0x2   0xB081             SUB      SP,SP,#+4
    117            alphabeta_t Output;
    118          
    119            int32_t a_divSQRT3_tmp, b_divSQRT3_tmp ;
    120            int32_t wbeta_tmp;
    121            int16_t hbeta_tmp;
    122          
    123            /* qIalpha = qIas*/
    124            Output.alpha = Input.a;
    125          
    126            a_divSQRT3_tmp = divSQRT_3 * ( int32_t )Input.a;
    127          
    128            b_divSQRT3_tmp = divSQRT_3 * ( int32_t )Input.b;
    129          
    130            /*qIbeta = -(2*qIbs+qIas)/sqrt(3)*/
    131          #ifdef FULL_MISRA_C_COMPLIANCY
    132            wbeta_tmp = ( -( a_divSQRT3_tmp ) - ( b_divSQRT3_tmp ) -
    133                           ( b_divSQRT3_tmp ) ) / 32768;
    134          #else
    135            /* WARNING: the below instruction is not MISRA compliant, user should verify
    136              that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    137              the compiler to perform the shift (instead of LSR logical shift right) */
    138          
    139            wbeta_tmp = ( -( a_divSQRT3_tmp ) - ( b_divSQRT3_tmp ) -
    140                           ( b_divSQRT3_tmp ) ) >> 15;
   \        0x4   0xF644 0x12E6      MOVW     R2,#+18918
   \        0x8   0xF9BD 0x0004      LDRSH    R0,[SP, #+4]
   \        0xC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x10   0x4601             MOV      R1,R0
   \       0x12   0x480B             LDR.N    R0,??MCM_Clarke_0  ;; 0xffffb61a
   \       0x14   0xFB11 0xF000      SMULBB   R0,R1,R0
   \       0x18   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \       0x1C   0xFB11 0xF202      SMULBB   R2,R1,R2
   \       0x20   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   \       0x24   0x13C0             ASRS     R0,R0,#+15
    141          #endif
    142          
    143            /* Check saturation of Ibeta */
    144            if ( wbeta_tmp > INT16_MAX )
   \       0x26   0xF300 0x000F      SSAT     R0,#+16,R0
    145            {
    146              hbeta_tmp = INT16_MAX;
    147            }
    148            else if ( wbeta_tmp < ( -32768 ) )
    149            {
    150              hbeta_tmp = ( -32768 );
    151            }
    152            else
    153            {
    154              hbeta_tmp = ( int16_t )( wbeta_tmp );
    155            }
    156          
    157            Output.beta = hbeta_tmp;
   \       0x2A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    158          
    159            if ( Output.beta == ( int16_t )( -32768 ) )
   \       0x2E   0xF510 0x4F00      CMN      R0,#+32768
   \       0x32   0xBF04             ITT      EQ
   \       0x34   0x4903             LDREQ.N  R1,??MCM_Clarke_0+0x4  ;; 0xffff8001
   \       0x36   0xF8AD 0x1002      STRHEQ   R1,[SP, #+2]
    160            {
    161              Output.beta = -32767;
    162            }
    163          
    164            return ( Output );
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0xB002             ADD      SP,SP,#+8
   \       0x3E   0x4770             BX       LR               ;; return
   \                     ??MCM_Clarke_0:
   \       0x40   0xFFFF'B61A        DC32     0xffffb61a
   \       0x44   0xFFFF'8001        DC32     0xffff8001
    165          }
    166          
    167          #if defined (CCMRAM)
    168          #if defined (__ICCARM__)
    169          #pragma location = ".ccmram"
    170          #elif defined (__CC_ARM) || defined(__GNUC__)
    171          __attribute__( ( section ( ".ccmram" ) ) )
    172          #endif
    173          #endif
    174          /**
    175            * @brief  This function transforms stator values alpha and beta, which
    176            *         belong to a stationary qd reference frame, to a rotor flux
    177            *         synchronous reference frame (properly oriented), so as q and d.
    178            *                   d= alpha *sin(theta)+ beta *cos(Theta)
    179            *                   q= alpha *cos(Theta)- beta *sin(Theta)
    180            * @param  Input: stator values alpha and beta in alphabeta_t format
    181            * @param  Theta: rotating frame angular position in q1.15 format
    182            * @retval Stator values q and d in qd_t format
    183            */

   \                                 In section .text, align 4
    184          __weak qd_t MCM_Park( alphabeta_t Input, int16_t Theta )
    185          {
   \                     MCM_Park: (+1)
   \        0x0   0xB571             PUSH     {R0,R4-R6,LR}
   \        0x2   0xB083             SUB      SP,SP,#+12
    186            qd_t Output;
    187            int32_t d_tmp_1, d_tmp_2, q_tmp_1, q_tmp_2;
    188            Trig_Components Local_Vector_Components;
    189            int32_t wqd_tmp;
    190            int16_t hqd_tmp;
    191          
    192            Local_Vector_Components = MCM_Trig_Functions( Theta );
   \        0x4   0xB208             SXTH     R0,R1
   \        0x6   0x....'....        BL       MCM_Trig_Functions
   \        0xA   0x9001             STR      R0,[SP, #+4]
    193          
    194            /*No overflow guaranteed*/
    195            q_tmp_1 = Input.alpha * ( int32_t )Local_Vector_Components.hCos;
    196          
    197            /*No overflow guaranteed*/
    198            q_tmp_2 = Input.beta * ( int32_t )Local_Vector_Components.hSin;
    199          
    200            /*Iq component in Q1.15 Format */
    201          #ifdef FULL_MISRA_C_COMPLIANCY
    202            wqd_tmp = ( q_tmp_1 - q_tmp_2 ) / 32768;
    203          #else
    204            /* WARNING: the below instruction is not MISRA compliant, user should verify
    205              that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    206              the compiler to perform the shift (instead of LSR logical shift right) */
    207            wqd_tmp = ( q_tmp_1 - q_tmp_2 ) >> 15;
   \        0xC   0xF9BD 0x2004      LDRSH    R2,[SP, #+4]
   \       0x10   0xF9BD 0x300C      LDRSH    R3,[SP, #+12]
   \       0x14   0xF9BD 0x0006      LDRSH    R0,[SP, #+6]
   \       0x18   0xF9BD 0x100E      LDRSH    R1,[SP, #+14]
    208          #endif
    209          
    210            /* Check saturation of Iq */
    211            if ( wqd_tmp > INT16_MAX )
    212            {
    213              hqd_tmp = INT16_MAX;
    214            }
    215            else if ( wqd_tmp < ( -32768 ) )
    216            {
    217              hqd_tmp = ( -32768 );
    218            }
    219            else
    220            {
    221              hqd_tmp = ( int16_t )( wqd_tmp );
    222            }
    223          
    224            Output.q = hqd_tmp;
    225          
    226            if ( Output.q == ( int16_t )( -32768 ) )
   \       0x1C   0x4D10             LDR.N    R5,??MCM_Park_0  ;; 0xffff8000
   \       0x1E   0xFB13 0xF402      SMULBB   R4,R3,R2
   \       0x22   0xFB00 0x4411      MLS      R4,R0,R1,R4
   \       0x26   0x13E4             ASRS     R4,R4,#+15
   \       0x28   0xF304 0x040F      SSAT     R4,#+16,R4
   \       0x2C   0xF8AD 0x4000      STRH     R4,[SP, #+0]
    227            {
    228              Output.q = -32767;
    229            }
    230          
    231            /*No overflow guaranteed*/
    232            d_tmp_1 = Input.alpha * ( int32_t )Local_Vector_Components.hSin;
    233          
    234            /*No overflow guaranteed*/
    235            d_tmp_2 = Input.beta * ( int32_t )Local_Vector_Components.hCos;
    236          
    237            /*Id component in Q1.15 Format */
    238          #ifdef FULL_MISRA_C_COMPLIANCY
    239            wqd_tmp = ( d_tmp_1 + d_tmp_2 ) / 32768;
    240          #else
    241            /* WARNING: the below instruction is not MISRA compliant, user should verify
    242              that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    243              the compiler to perform the shift (instead of LSR logical shift right) */
    244            wqd_tmp = ( d_tmp_1 + d_tmp_2 ) >> 15;
   \       0x30   0xFB13 0xF000      SMULBB   R0,R3,R0
   \       0x34   0xF9BD 0x6000      LDRSH    R6,[SP, #+0]
   \       0x38   0x4C0A             LDR.N    R4,??MCM_Park_0+0x4  ;; 0xffff8001
   \       0x3A   0x42AE             CMP      R6,R5
   \       0x3C   0xBF08             IT       EQ
   \       0x3E   0xF8AD 0x4000      STRHEQ   R4,[SP, #+0]
   \       0x42   0xFB11 0x0002      SMLABB   R0,R1,R2,R0
   \       0x46   0x13C0             ASRS     R0,R0,#+15
    245          #endif
    246          
    247            /* Check saturation of Id */
    248            if ( wqd_tmp > INT16_MAX )
   \       0x48   0xF300 0x000F      SSAT     R0,#+16,R0
    249            {
    250              hqd_tmp = INT16_MAX;
    251            }
    252            else if ( wqd_tmp < ( -32768 ) )
    253            {
    254              hqd_tmp = ( -32768 );
    255            }
    256            else
    257            {
    258              hqd_tmp = ( int16_t )( wqd_tmp );
    259            }
    260          
    261            Output.d = hqd_tmp;
   \       0x4C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    262          
    263            if ( Output.d == ( int16_t )( -32768 ) )
   \       0x50   0x42A8             CMP      R0,R5
   \       0x52   0xBF08             IT       EQ
   \       0x54   0xF8AD 0x4002      STRHEQ   R4,[SP, #+2]
    264            {
    265              Output.d = -32767;
    266            }
    267          
    268            return ( Output );
   \       0x58   0x9800             LDR      R0,[SP, #+0]
   \       0x5A   0xB004             ADD      SP,SP,#+16
   \       0x5C   0xBD70             POP      {R4-R6,PC}       ;; return
   \       0x5E   0xBF00             Nop
   \                     ??MCM_Park_0:
   \       0x60   0xFFFF'8000        DC32     0xffff8000
   \       0x64   0xFFFF'8001        DC32     0xffff8001
    269          }
    270          
    271          #if defined (CCMRAM)
    272          #if defined (__ICCARM__)
    273          #pragma location = ".ccmram"
    274          #elif defined (__CC_ARM) || defined(__GNUC__)
    275          __attribute__( ( section ( ".ccmram" ) ) )
    276          #endif
    277          #endif
    278          /**
    279            * @brief  This function transforms stator voltage qVq and qVd, that belong to
    280            *         a rotor flux synchronous rotating frame, to a stationary reference
    281            *         frame, so as to obtain qValpha and qVbeta:
    282            *                  Valfa= Vq*Cos(theta)+ Vd*Sin(theta)
    283            *                  Vbeta=-Vq*Sin(theta)+ Vd*Cos(theta)
    284            * @param  Input: stator voltage Vq and Vd in qd_t format
    285            * @param  Theta: rotating frame angular position in q1.15 format
    286            * @retval Stator voltage Valpha and Vbeta in qd_t format
    287            */

   \                                 In section .text, align 2
    288          __weak alphabeta_t MCM_Rev_Park( qd_t Input, int16_t Theta )
    289          {
   \                     MCM_Rev_Park: (+1)
   \        0x0   0xB531             PUSH     {R0,R4,R5,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    290            int32_t alpha_tmp1, alpha_tmp2, beta_tmp1, beta_tmp2;
    291            Trig_Components Local_Vector_Components;
    292            alphabeta_t Output;
    293          
    294            Local_Vector_Components = MCM_Trig_Functions( Theta );
   \        0x4   0xB208             SXTH     R0,R1
   \        0x6   0x....'....        BL       MCM_Trig_Functions
   \        0xA   0x9001             STR      R0,[SP, #+4]
    295          
    296            /*No overflow guaranteed*/
    297            alpha_tmp1 = Input.q * ( int32_t )Local_Vector_Components.hCos;
    298            alpha_tmp2 = Input.d * ( int32_t )Local_Vector_Components.hSin;
    299          
    300          #ifdef FULL_MISRA_C_COMPLIANCY
    301            Output.alpha = ( int16_t )( ( ( alpha_tmp1 ) + ( alpha_tmp2 ) ) / 32768 );
    302          #else
    303            /* WARNING: the below instruction is not MISRA compliant, user should verify
    304              that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    305              the compiler to perform the shift (instead of LSR logical shift right) */
    306            Output.alpha = ( int16_t )( ( ( alpha_tmp1 ) + ( alpha_tmp2 ) ) >> 15 );
   \        0xC   0xF9BD 0x3004      LDRSH    R3,[SP, #+4]
   \       0x10   0xF9BD 0x4008      LDRSH    R4,[SP, #+8]
   \       0x14   0xF9BD 0x1006      LDRSH    R1,[SP, #+6]
   \       0x18   0xF9BD 0x200A      LDRSH    R2,[SP, #+10]
   \       0x1C   0xFB14 0xF503      SMULBB   R5,R4,R3
    307          #endif
    308          
    309            beta_tmp1 = Input.q * ( int32_t )Local_Vector_Components.hSin;
    310            beta_tmp2 = Input.d * ( int32_t )Local_Vector_Components.hCos;
    311          
    312          #ifdef FULL_MISRA_C_COMPLIANCY
    313            Output.beta = ( int16_t )( ( beta_tmp2 - beta_tmp1 ) / 32768 );
    314          #else
    315            /* WARNING: the below instruction is not MISRA compliant, user should verify
    316            that Cortex-M3 assembly instruction ASR (arithmetic shift right) is used by
    317            the compiler to perform the shift (instead of LSR logical shift right) */
    318            Output.beta = ( int16_t )( ( beta_tmp2 - beta_tmp1 ) >> 15 );
   \       0x20   0xFB12 0xF003      SMULBB   R0,R2,R3
   \       0x24   0xFB12 0x5501      SMLABB   R5,R2,R1,R5
   \       0x28   0xFB01 0x0114      MLS      R1,R1,R4,R0
   \       0x2C   0x13ED             ASRS     R5,R5,#+15
   \       0x2E   0x13C9             ASRS     R1,R1,#+15
   \       0x30   0xF8AD 0x5000      STRH     R5,[SP, #+0]
   \       0x34   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    319          #endif
    320          
    321            return ( Output );
   \       0x38   0x9800             LDR      R0,[SP, #+0]
   \       0x3A   0xBD3E             POP      {R1-R5,PC}       ;; return
    322          }
    323          
    324          #if defined (CCMRAM)
    325          #if defined (__ICCARM__)
    326          #pragma location = ".ccmram"
    327          #elif defined (__CC_ARM) || defined(__GNUC__)
    328          __attribute__( ( section ( ".ccmram" ) ) )
    329          #endif
    330          #endif
    331          /**
    332            * @brief  This function returns cosine and sine functions of the angle fed in
    333            *         input
    334            * @param  hAngle: angle in q1.15 format
    335            * @retval Sin(angle) and Cos(angle) in Trig_Components format
    336            */
    337          

   \                                 In section .text, align 4
    338          __weak Trig_Components MCM_Trig_Functions( int16_t hAngle )
    339          {
    340            
    341            int32_t shindex;
    342            uint16_t uhindex;
    343          
    344            Trig_Components Local_Components;
    345          
    346            /* 10 bit index computation  */
    347            shindex = ( ( int32_t )32768 + ( int32_t )hAngle );
    348            uhindex = ( uint16_t )shindex;
    349            uhindex /= ( uint16_t )64;
   \                     MCM_Trig_Functions: (+1)
   \        0x0   0xF5A0 0x4000      SUB      R0,R0,#+32768
   \        0x4   0x0400             LSLS     R0,R0,#+16
   \        0x6   0x0D80             LSRS     R0,R0,#+22
    350          
    351            switch ( ( uint16_t )( uhindex ) & SIN_MASK )
   \        0x8   0xB2C2             UXTB     R2,R0
   \        0xA   0xF1C0 0x01FF      RSB      R1,R0,#+255
   \        0xE   0xF410 0x7040      ANDS     R0,R0,#0x300
   \       0x12   0xB081             SUB      SP,SP,#+4
   \       0x14   0xB2C9             UXTB     R1,R1
   \       0x16   0x4B17             LDR.N    R3,??MCM_Trig_Functions_0
   \       0x18   0xD017             BEQ.N    ??MCM_Trig_Functions_1
   \       0x1A   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x1E   0xD01D             BEQ.N    ??MCM_Trig_Functions_2
   \       0x20   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x24   0xD003             BEQ.N    ??MCM_Trig_Functions_3
   \       0x26   0xF5B0 0x7F40      CMP      R0,#+768
   \       0x2A   0xD007             BEQ.N    ??MCM_Trig_Functions_4
   \       0x2C   0xE01F             B.N      ??MCM_Trig_Functions_5
    352            {
    353              case U0_90:
    354                Local_Components.hSin = hSin_Cos_Table[( uint8_t )( uhindex )];
   \                     ??MCM_Trig_Functions_3: (+1)
   \       0x2E   0xF833 0x2012      LDRH     R2,[R3, R2, LSL #+1]
   \       0x32   0xF8AD 0x2002      STRH     R2,[SP, #+2]
    355                Local_Components.hCos = hSin_Cos_Table[( uint8_t )( 0xFFu - ( uint8_t )( uhindex ) )];
   \       0x36   0xF933 0x1011      LDRSH    R1,[R3, R1, LSL #+1]
   \       0x3A   0xE016             B.N      ??MCM_Trig_Functions_6
    356                break;
    357          
    358              case U90_180:
    359                Local_Components.hSin = hSin_Cos_Table[( uint8_t )( 0xFFu - ( uint8_t )( uhindex ) )];
   \                     ??MCM_Trig_Functions_4: (+1)
   \       0x3C   0xF833 0x1011      LDRH     R1,[R3, R1, LSL #+1]
   \       0x40   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    360                Local_Components.hCos = -hSin_Cos_Table[( uint8_t )( uhindex )];
   \       0x44   0xF933 0x1012      LDRSH    R1,[R3, R2, LSL #+1]
   \       0x48   0xE006             B.N      ??MCM_Trig_Functions_7
    361                break;
    362          
    363              case U180_270:
    364                Local_Components.hSin = -hSin_Cos_Table[( uint8_t )( uhindex )];
   \                     ??MCM_Trig_Functions_1: (+1)
   \       0x4A   0xF933 0x2012      LDRSH    R2,[R3, R2, LSL #+1]
   \       0x4E   0x4252             RSBS     R2,R2,#+0
   \       0x50   0xF8AD 0x2002      STRH     R2,[SP, #+2]
    365                Local_Components.hCos = -hSin_Cos_Table[( uint8_t )( 0xFFu - ( uint8_t )( uhindex ) )];
   \       0x54   0xF933 0x1011      LDRSH    R1,[R3, R1, LSL #+1]
   \                     ??MCM_Trig_Functions_7: (+1)
   \       0x58   0x4249             RSBS     R1,R1,#+0
   \       0x5A   0xE006             B.N      ??MCM_Trig_Functions_6
    366                break;
    367          
    368              case U270_360:
    369                Local_Components.hSin =  -hSin_Cos_Table[( uint8_t )( 0xFFu - ( uint8_t )( uhindex ) )];
   \                     ??MCM_Trig_Functions_2: (+1)
   \       0x5C   0xF933 0x1011      LDRSH    R1,[R3, R1, LSL #+1]
   \       0x60   0x4249             RSBS     R1,R1,#+0
   \       0x62   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    370                Local_Components.hCos =  hSin_Cos_Table[( uint8_t )( uhindex )];
   \       0x66   0xF933 0x1012      LDRSH    R1,[R3, R2, LSL #+1]
   \                     ??MCM_Trig_Functions_6: (+1)
   \       0x6A   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    371                break;
    372              default:
    373                break;
    374            }
    375            return ( Local_Components );
   \                     ??MCM_Trig_Functions_5: (+1)
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   \       0x70   0xB001             ADD      SP,SP,#+4
   \       0x72   0x4770             BX       LR               ;; return
   \                     ??MCM_Trig_Functions_0:
   \       0x74   0x....'....        DC32     hSin_Cos_Table
    376          }
    377          
    378          #if defined (CCMRAM)
    379          #if defined (__ICCARM__)
    380          #pragma location = ".ccmram"
    381          #elif defined (__CC_ARM) || defined(__GNUC__)
    382          __attribute__( ( section ( ".ccmram" ) ) )
    383          #endif
    384          #endif
    385          /**
    386            * @brief  It calculates the square root of a non-negative int32_t. It returns 0
    387            *         for negative int32_t.
    388            * @param  Input int32_t number
    389            * @retval int32_t Square root of Input (0 if Input<0)
    390            */

   \                                 In section .text, align 4
    391          __weak int32_t MCM_Sqrt( int32_t wInput )
    392          {
   \                     MCM_Sqrt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4601             MOV      R1,R0
    393            int32_t wtemprootnew;
    394          
    395            if ( wInput > 0 )
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xDD14             BLE.N    ??MCM_Sqrt_1
    396            {
    397            uint8_t biter = 0u;
   \        0x8   0x2200             MOVS     R2,#+0
    398            int32_t wtemproot;
    399              
    400              if ( wInput <= ( int32_t )2097152 )
   \        0xA   0x480B             LDR.N    R0,??MCM_Sqrt_0  ;; 0x200001
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xBFAC             ITE      GE
   \       0x10   0xF44F 0x5300      MOVGE    R3,#+8192
   \       0x14   0x2380             MOVLT    R3,#+128
    401              {
    402                wtemproot = ( int32_t )128;
    403              }
    404              else
    405              {
    406                wtemproot = ( int32_t )8192;
    407              }
    408          
    409              do
    410              {
    411                wtemprootnew = ( wtemproot + wInput / wtemproot ) / ( int32_t )2;
   \                     ??MCM_Sqrt_2: (+1)
   \       0x16   0xFB91 0xF0F3      SDIV     R0,R1,R3
   \       0x1A   0x18C0             ADDS     R0,R0,R3
   \       0x1C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \       0x20   0x1040             ASRS     R0,R0,#+1
    412                if ( wtemprootnew == wtemproot )
   \       0x22   0x4298             CMP      R0,R3
   \       0x24   0xD004             BEQ.N    ??MCM_Sqrt_3
    413                {
    414                  biter = 6u;
    415                }
    416                else
    417                {
    418                  biter ++;
   \       0x26   0x1C52             ADDS     R2,R2,#+1
    419                  wtemproot = wtemprootnew;
    420                }
    421              }
    422              while ( biter < 6u );
   \       0x28   0xB2D4             UXTB     R4,R2
   \       0x2A   0x2C06             CMP      R4,#+6
   \       0x2C   0x4603             MOV      R3,R0
   \       0x2E   0xD3F2             BCC.N    ??MCM_Sqrt_2
    423          
    424            }
    425            else
    426            {
    427              wtemprootnew = ( int32_t )0;
    428            }
    429          
    430            return ( wtemprootnew );
   \                     ??MCM_Sqrt_3: (+1)
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
   \                     ??MCM_Sqrt_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD10             POP      {R4,PC}
   \       0x36   0xBF00             Nop
   \                     ??MCM_Sqrt_0:
   \       0x38   0x0020'0001        DC32     0x200001
    431          }
    432          
    433          /**
    434            * @brief  It executes CORDIC algorithm for rotor position extraction from B-emf
    435            *         alpha and beta
    436            * @param  wBemf_alfa_est estimated Bemf alpha on the stator reference frame
    437            *         wBemf_beta_est estimated Bemf beta on the stator reference frame
    438            * @retval int16_t rotor electrical angle (s16degrees)
    439            */

   \                                 In section .text, align 4, keep-with-next
    440          inline int16_t MCM_PhaseComputation( int32_t wBemf_alfa_est, int32_t wBemf_beta_est )
    441          {
   \                     MCM_PhaseComputation: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    442          
    443            int16_t hAngle;
    444            int32_t wXi, wYi, wXold;
    445          
    446            /*Determining quadrant*/
    447            if ( wBemf_alfa_est < 0 )
   \        0x2   0xEB00 0x72D0      ADD      R2,R0,R0, LSR #+31
   \        0x6   0xEB01 0x73D1      ADD      R3,R1,R1, LSR #+31
   \        0xA   0x1052             ASRS     R2,R2,#+1
   \        0xC   0x105B             ASRS     R3,R3,#+1
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD50A             BPL.N    ??MCM_PhaseComputation_1
    448            {
    449              if ( wBemf_beta_est < 0 )
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD504             BPL.N    ??MCM_PhaseComputation_2
    450              {
    451                /*Quadrant III, add 90 degrees so as to move to quadrant IV*/
    452                hAngle = 16384;
    453                wXi = - ( wBemf_beta_est / 2 );
   \       0x16   0x425B             RSBS     R3,R3,#+0
   \       0x18   0xF44F 0x4080      MOV      R0,#+16384
   \       0x1C   0x4619             MOV      R1,R3
    454                wYi = wBemf_alfa_est / 2;
   \       0x1E   0xE006             B.N      ??MCM_PhaseComputation_3
    455              }
    456              else
    457              {
    458                /*Quadrant II, subtract 90 degrees so as to move to quadrant I*/
    459                hAngle = -16384;
   \                     ??MCM_PhaseComputation_2: (+1)
   \       0x20   0x4846             LDR.N    R0,??MCM_PhaseComputation_0  ;; 0xffffc000
    460                wXi = wBemf_beta_est / 2;
   \       0x22   0x4619             MOV      R1,R3
    461                wYi = - ( wBemf_alfa_est / 2 );
   \       0x24   0x4252             RSBS     R2,R2,#+0
   \       0x26   0xE002             B.N      ??MCM_PhaseComputation_3
    462              }
    463            }
    464            else
    465            {
    466              /* Quadrant I or IV*/
    467              hAngle = 0;
    468              wXi = wBemf_alfa_est / 2;
   \                     ??MCM_PhaseComputation_1: (+1)
   \       0x28   0x4611             MOV      R1,R2
   \       0x2A   0x2000             MOVS     R0,#+0
    469              wYi = wBemf_beta_est / 2;
   \       0x2C   0x461A             MOV      R2,R3
    470            }
    471            wXold = wXi;
    472          
    473            /*begin the successive approximation process*/
    474            /*iteration0*/
    475            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_3: (+1)
   \       0x2E   0x1854             ADDS     R4,R2,R1
   \       0x30   0x2A00             CMP      R2,#+0
   \       0x32   0xD504             BPL.N    ??MCM_PhaseComputation_4
    476            {
    477              /*vector is in Quadrant IV*/
    478              hAngle += ATAN1DIV1;
    479              wXi = wXi - wYi;
   \       0x34   0x1A8B             SUBS     R3,R1,R2
   \       0x36   0xF500 0x5000      ADD      R0,R0,#+8192
    480              wYi = wXold + wYi;
   \       0x3A   0x4622             MOV      R2,R4
   \       0x3C   0xE003             B.N      ??MCM_PhaseComputation_5
    481            }
    482            else
    483            {
    484              /*vector is in Quadrant I*/
    485              hAngle -= ATAN1DIV1;
   \                     ??MCM_PhaseComputation_4: (+1)
   \       0x3E   0xF5A0 0x5000      SUB      R0,R0,#+8192
    486              wXi = wXi + wYi;
   \       0x42   0x4623             MOV      R3,R4
    487              wYi = -wXold + wYi;
   \       0x44   0x1A52             SUBS     R2,R2,R1
    488            }
    489            wXold = wXi;
    490          
    491            /*iteration1*/
    492            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_5: (+1)
   \       0x46   0x2A00             CMP      R2,#+0
   \       0x48   0xEB03 0x74D3      ADD      R4,R3,R3, LSR #+31
   \       0x4C   0xEB02 0x75D2      ADD      R5,R2,R2, LSR #+31
   \       0x50   0xD507             BPL.N    ??MCM_PhaseComputation_6
    493            {
    494              /*vector is in Quadrant IV*/
    495              hAngle += ATAN1DIV2;
   \       0x52   0xF500 0x5090      ADD      R0,R0,#+4608
   \       0x56   0x30E4             ADDS     R0,R0,#+228
    496              wXi = wXi - wYi / 2;
   \       0x58   0xEBA3 0x0365      SUB      R3,R3,R5, ASR #+1
    497              wYi = wXold / 2 + wYi;
   \       0x5C   0xEB02 0x0264      ADD      R2,R2,R4, ASR #+1
   \       0x60   0xE005             B.N      ??MCM_PhaseComputation_7
    498            }
    499            else
    500            {
    501              /*vector is in Quadrant I*/
    502              hAngle -= ATAN1DIV2;
   \                     ??MCM_PhaseComputation_6: (+1)
   \       0x62   0x4937             LDR.N    R1,??MCM_PhaseComputation_0+0x4  ;; 0xffffed1c
   \       0x64   0x1808             ADDS     R0,R1,R0
    503              wXi = wXi + wYi / 2;
   \       0x66   0xEB03 0x0365      ADD      R3,R3,R5, ASR #+1
    504              wYi = -wXold / 2 + wYi;
   \       0x6A   0xEBA2 0x0264      SUB      R2,R2,R4, ASR #+1
    505            }
    506            wXold = wXi;
    507          
    508            /*iteration2*/
    509            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_7: (+1)
   \       0x6E   0x105C             ASRS     R4,R3,#+1
   \       0x70   0xEB03 0x7194      ADD      R1,R3,R4, LSR #+30
   \       0x74   0x1055             ASRS     R5,R2,#+1
   \       0x76   0x2A00             CMP      R2,#+0
   \       0x78   0xEB02 0x7495      ADD      R4,R2,R5, LSR #+30
   \       0x7C   0xD506             BPL.N    ??MCM_PhaseComputation_8
    510            {
    511              /*vector is in Quadrant IV*/
    512              hAngle += ATAN1DIV4;
   \       0x7E   0xF600 0x10FB      ADDW     R0,R0,#+2555
    513              wXi = wXi - wYi / 4;
   \       0x82   0xEBA3 0x03A4      SUB      R3,R3,R4, ASR #+2
    514              wYi = wXold / 4 + wYi;
   \       0x86   0xEB02 0x02A1      ADD      R2,R2,R1, ASR #+2
   \       0x8A   0xE005             B.N      ??MCM_PhaseComputation_9
    515            }
    516            else
    517            {
    518              /*vector is in Quadrant I*/
    519              hAngle -= ATAN1DIV4;
   \                     ??MCM_PhaseComputation_8: (+1)
   \       0x8C   0xF6A0 0x10FB      SUBW     R0,R0,#+2555
    520              wXi = wXi + wYi / 4;
   \       0x90   0xEB03 0x03A4      ADD      R3,R3,R4, ASR #+2
    521              wYi = -wXold / 4 + wYi;
   \       0x94   0xEBA2 0x02A1      SUB      R2,R2,R1, ASR #+2
    522            }
    523            wXold = wXi;
    524          
    525            /*iteration3*/
    526            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_9: (+1)
   \       0x98   0x1099             ASRS     R1,R3,#+2
   \       0x9A   0x1094             ASRS     R4,R2,#+2
   \       0x9C   0x2A00             CMP      R2,#+0
   \       0x9E   0xEB03 0x7151      ADD      R1,R3,R1, LSR #+29
   \       0xA2   0xEB02 0x7454      ADD      R4,R2,R4, LSR #+29
   \       0xA6   0xD506             BPL.N    ??MCM_PhaseComputation_10
    527            {
    528              /*vector is in Quadrant IV*/
    529              hAngle += ATAN1DIV8;
   \       0xA8   0xF200 0x5011      ADDW     R0,R0,#+1297
    530              wXi = wXi - wYi / 8;
   \       0xAC   0xEBA3 0x03E4      SUB      R3,R3,R4, ASR #+3
    531              wYi = wXold / 8 + wYi;
   \       0xB0   0xEB02 0x02E1      ADD      R2,R2,R1, ASR #+3
   \       0xB4   0xE005             B.N      ??MCM_PhaseComputation_11
    532            }
    533            else
    534            {
    535              /*vector is in Quadrant I*/
    536              hAngle -= ATAN1DIV8;
   \                     ??MCM_PhaseComputation_10: (+1)
   \       0xB6   0xF2A0 0x5011      SUBW     R0,R0,#+1297
    537              wXi = wXi + wYi / 8;
   \       0xBA   0xEB03 0x03E4      ADD      R3,R3,R4, ASR #+3
    538              wYi = -wXold / 8 + wYi;
   \       0xBE   0xEBA2 0x02E1      SUB      R2,R2,R1, ASR #+3
    539            }
    540            wXold = wXi;
    541          
    542            /*iteration4*/
    543            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_11: (+1)
   \       0xC2   0x10D9             ASRS     R1,R3,#+3
   \       0xC4   0x10D4             ASRS     R4,R2,#+3
   \       0xC6   0x2A00             CMP      R2,#+0
   \       0xC8   0xEB03 0x7111      ADD      R1,R3,R1, LSR #+28
   \       0xCC   0xEB02 0x7414      ADD      R4,R2,R4, LSR #+28
   \       0xD0   0xD506             BPL.N    ??MCM_PhaseComputation_12
    544            {
    545              /*vector is in Quadrant IV*/
    546              hAngle += ATAN1DIV16;
   \       0xD2   0xF200 0x208B      ADDW     R0,R0,#+651
    547              wXi = wXi - wYi / 16;
   \       0xD6   0xEBA3 0x1324      SUB      R3,R3,R4, ASR #+4
    548              wYi = wXold / 16 + wYi;
   \       0xDA   0xEB02 0x1221      ADD      R2,R2,R1, ASR #+4
   \       0xDE   0xE005             B.N      ??MCM_PhaseComputation_13
    549            }
    550            else
    551            {
    552              /*vector is in Quadrant I*/
    553              hAngle -= ATAN1DIV16;
   \                     ??MCM_PhaseComputation_12: (+1)
   \       0xE0   0xF2A0 0x208B      SUBW     R0,R0,#+651
    554              wXi = wXi + wYi / 16;
   \       0xE4   0xEB03 0x1324      ADD      R3,R3,R4, ASR #+4
    555              wYi = -wXold / 16 + wYi;
   \       0xE8   0xEBA2 0x1221      SUB      R2,R2,R1, ASR #+4
    556            }
    557            wXold = wXi;
    558          
    559            /*iteration5*/
    560            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_13: (+1)
   \       0xEC   0x1119             ASRS     R1,R3,#+4
   \       0xEE   0x1114             ASRS     R4,R2,#+4
   \       0xF0   0x2A00             CMP      R2,#+0
   \       0xF2   0xEB03 0x61D1      ADD      R1,R3,R1, LSR #+27
   \       0xF6   0xEB02 0x64D4      ADD      R4,R2,R4, LSR #+27
   \       0xFA   0xD506             BPL.N    ??MCM_PhaseComputation_14
    561            {
    562              /*vector is in Quadrant IV*/
    563              hAngle += ATAN1DIV32;
   \       0xFC   0xF500 0x70A3      ADD      R0,R0,#+326
    564              wXi = wXi - wYi / 32;
   \      0x100   0xEBA3 0x1364      SUB      R3,R3,R4, ASR #+5
    565              wYi = wXold / 32 + wYi;
   \      0x104   0xEB02 0x1261      ADD      R2,R2,R1, ASR #+5
   \      0x108   0xE005             B.N      ??MCM_PhaseComputation_15
    566            }
    567            else
    568            {
    569              /*vector is in Quadrant I*/
    570              hAngle -= ATAN1DIV32;
   \                     ??MCM_PhaseComputation_14: (+1)
   \      0x10A   0xF5A0 0x70A3      SUB      R0,R0,#+326
    571              wXi = wXi + wYi / 32;
   \      0x10E   0xEB03 0x1364      ADD      R3,R3,R4, ASR #+5
    572              wYi = -wXold / 32 + wYi;
   \      0x112   0xEBA2 0x1261      SUB      R2,R2,R1, ASR #+5
    573            }
    574            wXold = wXi;
    575          
    576            /*iteration6*/
    577            if ( wYi < 0 )
   \                     ??MCM_PhaseComputation_15: (+1)
   \      0x116   0x1159             ASRS     R1,R3,#+5
   \      0x118   0xEB03 0x6391      ADD      R3,R3,R1, LSR #+26
   \      0x11C   0x2A00             CMP      R2,#+0
   \      0x11E   0xBF47             ITTEE    MI
   \      0x120   0x30A3             ADDMI    R0,R0,#+163
   \      0x122   0xEB02 0x13A3      ADDMI    R3,R2,R3, ASR #+6
   \      0x126   0x38A3             SUBPL    R0,R0,#+163
   \      0x128   0xEBA2 0x13A3      SUBPL    R3,R2,R3, ASR #+6
    578            {
    579              /*vector is in Quadrant IV*/
    580              hAngle += ATAN1DIV64;
    581              wXi = wXi - wYi / 64;
    582              wYi = wXold / 64 + wYi;
    583            }
    584            else
    585            {
    586              /*vector is in Quadrant I*/
    587              hAngle -= ATAN1DIV64;
    588              wXi = wXi + wYi / 64;
    589              wYi = -wXold / 64 + wYi;
    590            }
    591            wXold = wXi;
    592          
    593            /*iteration7*/
    594            if ( wYi < 0 )
   \      0x12C   0x2B00             CMP      R3,#+0
   \      0x12E   0xBF4C             ITE      MI
   \      0x130   0x3051             ADDMI    R0,R0,#+81
   \      0x132   0x3851             SUBPL    R0,R0,#+81
    595            {
    596              /*vector is in Quadrant IV*/
    597              hAngle += ATAN1DIV128;
    598              wXi = wXi - wYi / 128;
    599              wYi = wXold / 128 + wYi;
    600            }
    601            else
    602            {
    603              /*vector is in Quadrant I*/
    604              hAngle -= ATAN1DIV128;
    605              wXi = wXi + wYi / 128;
    606              wYi = -wXold / 128 + wYi;
    607            }
    608          
    609            return ( -hAngle );
   \      0x134   0x4240             RSBS     R0,R0,#+0
   \      0x136   0xB200             SXTH     R0,R0
   \      0x138   0xBD30             POP      {R4,R5,PC}       ;; return
   \      0x13A   0xBF00             Nop
   \                     ??MCM_PhaseComputation_0:
   \      0x13C   0xFFFF'C000        DC32     0xffffc000
   \      0x140   0xFFFF'ED1C        DC32     0xffffed1c
    610          
    611          }
    612          
    613          /**
    614            * @brief  This function codify a floating point number into the relative
    615            *         32bit integer.
    616            * @param  float Floating point number to be coded.
    617            * @retval uint32_t Coded 32bit integer.
    618            */

   \                                 In section .text, align 2
    619          __weak uint32_t MCM_floatToIntBit( float x )
    620          {
   \                     MCM_floatToIntBit: (+1)
   \        0x0   0xED2D 0x0A01      VPUSH    {S0}
    621            uint32_t * pInt;
    622            pInt = ( uint32_t * )( &x );
    623            return *pInt;
   \        0x4   0x9800             LDR      R0,[SP, #+0]
   \        0x6   0xB001             ADD      SP,SP,#+4
   \        0x8   0x4770             BX       LR               ;; return
    624          }
    625          
    626          /**
    627            * @}
    628            */
    629          
    630          /**
    631            * @}
    632            */
    633          
    634          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   MCM_Clarke
      32   MCM_Park
        32   -> MCM_Trig_Functions
      12   MCM_PhaseComputation
      24   MCM_Rev_Park
        24   -> MCM_Trig_Functions
       8   MCM_Sqrt
       4   MCM_Trig_Functions
       4   MCM_floatToIntBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  MCM_Clarke
     104  MCM_Park
     324  MCM_PhaseComputation
      60  MCM_Rev_Park
      60  MCM_Sqrt
     120  MCM_Trig_Functions
      10  MCM_floatToIntBit
     512  hSin_Cos_Table

 
 512 bytes in section .rodata
 750 bytes in section .text
 
 324 bytes of CODE  memory (+ 426 bytes shared)
 512 bytes of CONST memory

Errors: none
Warnings: none
