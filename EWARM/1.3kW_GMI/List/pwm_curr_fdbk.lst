###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:42
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pwm_curr_fdbk.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW6D70.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pwm_curr_fdbk.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\pwm_curr_fdbk.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\pwm_curr_fdbk.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\pwm_curr_fdbk.c
      1          /**
      2            ******************************************************************************
      3            * @file    pwm_curr_fdbk.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the following features
      6            *          of the PWM & Current Feedback component of the Motor Control SDK:
      7            *
      8            *           * current sensing
      9            *           * regular ADC conversion execution
     10            *           * space vector modulation
     11            *
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     16            * All rights reserved.</center></h2>
     17            *
     18            * This software component is licensed by ST under Ultimate Liberty license
     19            * SLA0044, the "License"; You may not use this file except in compliance with
     20            * the License. You may obtain a copy of the License at:
     21            *                             www.st.com/SLA0044
     22            *
     23            ******************************************************************************
     24            */
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "pwm_curr_fdbk.h"
     28          
     29          #include "mc_type.h"
     30          
     31          /** @addtogroup MCSDK
     32            * @{
     33            */
     34          
     35          /** @defgroup pwm_curr_fdbk PWM & Current Feedback
     36            *
     37            * @brief PWM & Current Feedback components of the Motor Control SDK
     38            *
     39            * These components fulfill two functions in a Motor Control subsystem:
     40            *
     41            * - The generation of the Space Vector Pulse Width Modulation on the motor's phases
     42            * - The sampling of the actual motor's phases current
     43            *
     44            * Both these features are closely related as the instants when the values of the phase currents
     45            * should be sampled by the ADC channels are basically triggered by the timers used to generate
     46            * the duty cycles for the PWM.
     47            *
     48            * Several implementation of PWM and Current Feedback components are provided by the Motor Control
     49            * SDK to account for the specificities of the application:
     50            *
     51            * - The selected MCU: the number of ADCs available on a given MCU, the presence of internal
     52            * comparators or OpAmps, for instance, lead to different implementation of this feature
     53            * - The Current sensing topology also has an impact on the firmware: implementations are provided
     54            * for Insulated Current Sensors, Single Shunt and Three Shunt resistors current sensing topologies
     55            *
     56            * The choice of the implementation mostly depend on these two factors and is performed by the
     57            * Motor Control Workbench tool.
     58            *
     59            * All these implementations are built on a base PWM & Current Feedback component that they extend
     60            * and that provides the functions and data that are common to all of them. This base component is
     61            * never used directly as it does not provide a complete implementation of the features. Rather,
     62            * its handle structure (PWMC_Handle) is reused by all the PWM & Current Feedback specific
     63            * implementations and the functions it provides form the API of the PWM and Current feedback feature.
     64            * Calling them results in calling functions of the component that actually implement the feature.
     65            * See PWMC_Handle for more details on this mechanism.
     66            * @{
     67            */
     68          
     69          #if defined (CCMRAM)
     70          #if defined (__ICCARM__)
     71          #pragma location = ".ccmram"
     72          #elif defined (__CC_ARM) || defined(__GNUC__)
     73          __attribute__( ( section ( ".ccmram" ) ) )
     74          #endif
     75          #endif
     76          /**
     77            * @brief Returns the phase current of the motor as read by the ADC (in s16A unit)
     78            *
     79            * The function actually returns the current values of phase A & B. Phase C current
     80            * can be deduced thanks to the formula:
     81            *
     82            * @f[
     83            * I_{C} = -I_{A} - I_{C}
     84            * @f]
     85            *
     86            * @param  pHandle handle on the target PWMC component
     87            * @param  pStator_Currents Pointer to the structure that will receive motor current
     88            *         of phase A and B in ElectricalValue format.
     89          */

   \                                 In section .text, align 2
     90          __weak void PWMC_GetPhaseCurrents( PWMC_Handle_t * pHandle, ab_t * Iab )
     91          {
     92            pHandle->pFctGetPhaseCurrents( pHandle, Iab );
   \                     PWMC_GetPhaseCurrents: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   \        0x2   0x4710             BX       R2
     93          }
     94          
     95          #if defined (CCMRAM)
     96          #if defined (__ICCARM__)
     97          #pragma location = ".ccmram"
     98          #elif defined (__CC_ARM) || defined(__GNUC__)
     99          __attribute__( ( section ( ".ccmram" ) ) )
    100          #endif
    101          #endif
    102          /**
    103           * @brief Sets the PWM duty cycles
    104           *
    105           *
    106           */
    107          
    108          /**
    109            * @brief  Converts input voltages @f$ V_{\alpha} @f$ and @f$ V_{\beta} @f$ into PWM duty cycles
    110            *         and feed them to the inverter.
    111            * @param  pHandle handler on the target PWMC component.
    112            * @param  Valfa_beta Voltage Components expressed in the @f$(\alpha, \beta)@f$ reference frame
    113            *
    114            * This function computes the the time during wIch the transistors of each phase are to be switched on in
    115            * a PWM cycle in order to achieve the reference phase voltage set by @p Valfa_beta. Then, the function
    116            * programs the resulting duty cycles in the related timer channels. It also sets the phase current
    117            * sampling point for the next PWM cycle accordingly.
    118            *
    119            * This function is used in the FOC frequency loop and needs to complete before the next PWM cycle starts
    120            * so that the duty cycles it computes can be taken into account. Failing to do so (for instance because
    121            * the PWM Frequency is too high) results in the functions returning #MC_FOC_DURATION wIch entails a
    122            * Motor Control Fault that stops the motor.
    123            *
    124            * @retval Returns #MC_NO_ERROR if no error occurred or #MC_FOC_DURATION if the duty cycles were
    125            *         set too late for being taken into account in the next PWM cycle.
    126            */

   \                                 In section .text, align 2
    127          __weak uint16_t PWMC_SetPhaseVoltage( PWMC_Handle_t * pHandle, alphabeta_t Valfa_beta )
    128          {
   \                     PWMC_SetPhaseVoltage: (+1)
   \        0x0   0xE92D 0x43F2      PUSH     {R1,R4-R9,LR}
    129            int32_t wX, wY, wZ, wUAlpha, wUBeta, wTimePhA, wTimePhB, wTimePhC;
    130          
    131            wUAlpha = Valfa_beta.alpha * ( int32_t )pHandle->hT_Sqrt3;
    132            wUBeta = -( Valfa_beta.beta * ( int32_t )( pHandle->PWMperiod ) ) * 2;
   \        0x4   0xF100 0x023A      ADD      R2,R0,#+58
   \        0x8   0xF9BD 0x6002      LDRSH    R6,[SP, #+2]
   \        0xC   0x8AD3             LDRH     R3,[R2, #+22]
   \        0xE   0xF9BD 0x5000      LDRSH    R5,[SP, #+0]
   \       0x12   0x8E01             LDRH     R1,[R0, #+48]
   \       0x14   0x435E             MULS     R6,R6,R3
   \       0x16   0x4276             RSBS     R6,R6,#+0
   \       0x18   0x434D             MULS     R5,R1,R5
   \       0x1A   0x0076             LSLS     R6,R6,#+1
    133          
    134            wX = wUBeta;
    135            wY = ( wUBeta + wUAlpha ) / 2;
   \       0x1C   0x19AF             ADDS     R7,R5,R6
   \       0x1E   0xEB07 0x77D7      ADD      R7,R7,R7, LSR #+31
    136            wZ = ( wUBeta - wUAlpha ) / 2;
   \       0x22   0x1B75             SUBS     R5,R6,R5
   \       0x24   0x107F             ASRS     R7,R7,#+1
   \       0x26   0xEB05 0x75D5      ADD      R5,R5,R5, LSR #+31
    137          
    138            /* Sector calculation from wX, wY, wZ */
    139            if ( wY < 0 )
   \       0x2A   0x1431             ASRS     R1,R6,#+16
   \       0x2C   0x106D             ASRS     R5,R5,#+1
   \       0x2E   0xEB06 0x3CD1      ADD      R12,R6,R1, LSR #+15
   \       0x32   0x143C             ASRS     R4,R7,#+16
   \       0x34   0xEB07 0x31D4      ADD      R1,R7,R4, LSR #+15
   \       0x38   0xEA4F 0x4E25      ASR      LR,R5,#+16
   \       0x3C   0x089B             LSRS     R3,R3,#+2
   \       0x3E   0xEB05 0x34DE      ADD      R4,R5,LR, LSR #+15
   \       0x42   0x2F00             CMP      R7,#+0
   \       0x44   0xEBA7 0x0806      SUB      R8,R7,R6
   \       0x48   0xEBA6 0x0905      SUB      R9,R6,R5
   \       0x4C   0xEBA7 0x0E05      SUB      LR,R7,R5
   \       0x50   0xD542             BPL.N    ??PWMC_SetPhaseVoltage_0
    140            {
    141              if ( wZ < 0 )
   \       0x52   0x2D00             CMP      R5,#+0
   \       0x54   0xD521             BPL.N    ??PWMC_SetPhaseVoltage_1
    142              {
    143                pHandle->Sector = SECTOR_5;
    144                wTimePhA = ( int32_t )( pHandle->PWMperiod ) / 4 + ( ( wY - wZ ) / ( int32_t )262144 );
   \       0x56   0xEA4F 0x466E      ASR      R6,LR,#+17
   \       0x5A   0xEB0E 0x3696      ADD      R6,LR,R6, LSR #+14
   \       0x5E   0xEB03 0x43A6      ADD      R3,R3,R6, ASR #+18
    145                wTimePhB = wTimePhA + wZ / 131072;
   \       0x62   0xEB03 0x4464      ADD      R4,R3,R4, ASR #+17
    146                wTimePhC = wTimePhA - wY / 131072;
   \       0x66   0xEBA3 0x4161      SUB      R1,R3,R1, ASR #+17
   \       0x6A   0x2504             MOVS     R5,#+4
    147                pHandle->lowDuty = wTimePhC;
   \       0x6C   0x460E             MOV      R6,R1
    148                pHandle->midDuty = wTimePhA;
   \       0x6E   0x461F             MOV      R7,R3
    149                pHandle->highDuty = wTimePhB;
   \       0x70   0x46A4             MOV      R12,R4
   \                     ??PWMC_SetPhaseVoltage_2: (+1)
   \       0x72   0x7015             STRB     R5,[R2, #+0]
   \       0x74   0x8056             STRH     R6,[R2, #+2]
   \       0x76   0x8097             STRH     R7,[R2, #+4]
   \       0x78   0xF8A2 0xC006      STRH     R12,[R2, #+6]
    150              }
    151              else /* wZ >= 0 */
    152                if ( wX <= 0 )
    153                {
    154                  pHandle->Sector = SECTOR_4;
    155                  wTimePhA = ( int32_t )( pHandle->PWMperiod ) / 4 + ( ( wX - wZ ) / ( int32_t )262144 );
    156                  wTimePhB = wTimePhA + wZ / 131072;
    157                  wTimePhC = wTimePhB - wX / 131072;
    158                  pHandle->lowDuty = wTimePhC;
    159                  pHandle->midDuty = wTimePhB;
    160                  pHandle->highDuty = wTimePhA;
    161                }
    162                else /* wX > 0 */
    163                {
    164                  pHandle->Sector = SECTOR_3;
    165                  wTimePhA = ( int32_t )( pHandle->PWMperiod ) / 4 + ( ( wY - wX ) / ( int32_t )262144 );
    166                  wTimePhC = wTimePhA - wY / 131072;
    167                  wTimePhB = wTimePhC + wX / 131072;
    168                  pHandle->lowDuty = wTimePhB;
    169                  pHandle->midDuty = wTimePhC;
    170                  pHandle->highDuty = wTimePhA;
    171                }
    172            }
    173            else /* wY > 0 */
    174            {
    175              if ( wZ >= 0 )
    176              {
    177                pHandle->Sector = SECTOR_2;
    178                wTimePhA = ( int32_t )( pHandle->PWMperiod ) / 4 + ( ( wY - wZ ) / ( int32_t )262144 );
    179                wTimePhB = wTimePhA + wZ / 131072;
    180                wTimePhC = wTimePhA - wY / 131072;
    181                pHandle->lowDuty = wTimePhB;
    182                pHandle->midDuty = wTimePhA;
    183                pHandle->highDuty = wTimePhC;
    184              }
    185              else /* wZ < 0 */
    186                if ( wX <= 0 )
    187                {
    188                  pHandle->Sector = SECTOR_6;
    189                  wTimePhA = ( int32_t )( pHandle->PWMperiod ) / 4 + ( ( wY - wX ) / ( int32_t )262144 );
    190                  wTimePhC = wTimePhA - wY / 131072;
    191                  wTimePhB = wTimePhC + wX / 131072;
    192                  pHandle->lowDuty = wTimePhA;
    193                  pHandle->midDuty = wTimePhC;
    194                  pHandle->highDuty = wTimePhB;
    195                }
    196                else /* wX > 0 */
    197                {
    198                  pHandle->Sector = SECTOR_1;
    199                  wTimePhA = ( int32_t )( pHandle->PWMperiod ) / 4 + ( ( wX - wZ ) / ( int32_t )262144 );
    200                  wTimePhB = wTimePhA + wZ / 131072;
    201                  wTimePhC = wTimePhB - wX / 131072;
    202                  pHandle->lowDuty = wTimePhA;
    203                  pHandle->midDuty = wTimePhB;
    204                  pHandle->highDuty = wTimePhC;
    205                }
    206            }
    207          
    208            pHandle->CntPhA = ( uint16_t )wTimePhA;
    209            pHandle->CntPhB = ( uint16_t )wTimePhB;
    210            pHandle->CntPhC = ( uint16_t )wTimePhC;
   \       0x7C   0x86C1             STRH     R1,[R0, #+54]
   \       0x7E   0x8643             STRH     R3,[R0, #+50]
   \       0x80   0x8684             STRH     R4,[R0, #+52]
    211          
    212            if ( pHandle->DTTest == 1u )
   \       0x82   0x8A91             LDRH     R1,[R2, #+20]
   \       0x84   0x2901             CMP      R1,#+1
   \       0x86   0xD169             BNE.N    ??PWMC_SetPhaseVoltage_3
    213            {
    214              /* Dead time compensation */
    215              if ( pHandle->Ia > 0 )
   \       0x88   0xF9B2 0x400E      LDRSH    R4,[R2, #+14]
   \       0x8C   0x8B51             LDRH     R1,[R2, #+26]
   \       0x8E   0x8E43             LDRH     R3,[R0, #+50]
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xBFCC             ITE      GT
   \       0x94   0x18CB             ADDGT    R3,R1,R3
   \       0x96   0x1A5B             SUBLE    R3,R3,R1
    216              {
    217                pHandle->CntPhA += pHandle->DTCompCnt;
    218              }
    219              else
    220              {
    221                pHandle->CntPhA -= pHandle->DTCompCnt;
   \       0x98   0xE04F             B.N      ??PWMC_SetPhaseVoltage_4
    222              }
   \                     ??PWMC_SetPhaseVoltage_1: (+1)
   \       0x9A   0x2E00             CMP      R6,#+0
   \       0x9C   0xDC0E             BGT.N    ??PWMC_SetPhaseVoltage_5
   \       0x9E   0xEA4F 0x4169      ASR      R1,R9,#+17
   \       0xA2   0xEB09 0x3191      ADD      R1,R9,R1, LSR #+14
   \       0xA6   0xEB03 0x43A1      ADD      R3,R3,R1, ASR #+18
   \       0xAA   0xEB03 0x4464      ADD      R4,R3,R4, ASR #+17
   \       0xAE   0xEBA4 0x416C      SUB      R1,R4,R12, ASR #+17
   \       0xB2   0x2503             MOVS     R5,#+3
   \       0xB4   0x460E             MOV      R6,R1
   \       0xB6   0x4627             MOV      R7,R4
   \                     ??PWMC_SetPhaseVoltage_6: (+1)
   \       0xB8   0x469C             MOV      R12,R3
   \       0xBA   0xE7DA             B.N      ??PWMC_SetPhaseVoltage_2
   \                     ??PWMC_SetPhaseVoltage_5: (+1)
   \       0xBC   0xEA4F 0x4468      ASR      R4,R8,#+17
   \       0xC0   0xEB08 0x3494      ADD      R4,R8,R4, LSR #+14
   \       0xC4   0xEB03 0x43A4      ADD      R3,R3,R4, ASR #+18
   \       0xC8   0xEBA3 0x4161      SUB      R1,R3,R1, ASR #+17
   \       0xCC   0xEB01 0x446C      ADD      R4,R1,R12, ASR #+17
   \       0xD0   0x2502             MOVS     R5,#+2
   \       0xD2   0x4626             MOV      R6,R4
   \       0xD4   0x460F             MOV      R7,R1
   \       0xD6   0xE7EF             B.N      ??PWMC_SetPhaseVoltage_6
   \                     ??PWMC_SetPhaseVoltage_0: (+1)
   \       0xD8   0x2D00             CMP      R5,#+0
   \       0xDA   0xD40E             BMI.N    ??PWMC_SetPhaseVoltage_7
   \       0xDC   0xEA4F 0x466E      ASR      R6,LR,#+17
   \       0xE0   0xEB0E 0x3696      ADD      R6,LR,R6, LSR #+14
   \       0xE4   0xEB03 0x43A6      ADD      R3,R3,R6, ASR #+18
   \       0xE8   0xEB03 0x4464      ADD      R4,R3,R4, ASR #+17
   \       0xEC   0xEBA3 0x4161      SUB      R1,R3,R1, ASR #+17
   \       0xF0   0x2501             MOVS     R5,#+1
   \       0xF2   0x4626             MOV      R6,R4
   \       0xF4   0x461F             MOV      R7,R3
   \       0xF6   0x468C             MOV      R12,R1
   \       0xF8   0xE7BB             B.N      ??PWMC_SetPhaseVoltage_2
   \                     ??PWMC_SetPhaseVoltage_7: (+1)
   \       0xFA   0x2E00             CMP      R6,#+0
   \       0xFC   0xDC0E             BGT.N    ??PWMC_SetPhaseVoltage_8
   \       0xFE   0xEA4F 0x4468      ASR      R4,R8,#+17
   \      0x102   0xEB08 0x3494      ADD      R4,R8,R4, LSR #+14
   \      0x106   0xEB03 0x43A4      ADD      R3,R3,R4, ASR #+18
   \      0x10A   0xEBA3 0x4161      SUB      R1,R3,R1, ASR #+17
   \      0x10E   0xEB01 0x4C6C      ADD      R12,R1,R12, ASR #+17
   \      0x112   0x2505             MOVS     R5,#+5
   \      0x114   0x4664             MOV      R4,R12
   \      0x116   0x461E             MOV      R6,R3
   \      0x118   0x460F             MOV      R7,R1
   \      0x11A   0xE7AA             B.N      ??PWMC_SetPhaseVoltage_2
   \                     ??PWMC_SetPhaseVoltage_8: (+1)
   \      0x11C   0xEA4F 0x4169      ASR      R1,R9,#+17
   \      0x120   0xEB09 0x3191      ADD      R1,R9,R1, LSR #+14
   \      0x124   0xEB03 0x43A1      ADD      R3,R3,R1, ASR #+18
   \      0x128   0xEB03 0x4464      ADD      R4,R3,R4, ASR #+17
   \      0x12C   0xEBA4 0x4C6C      SUB      R12,R4,R12, ASR #+17
   \      0x130   0x2500             MOVS     R5,#+0
   \      0x132   0x4661             MOV      R1,R12
   \      0x134   0x461E             MOV      R6,R3
   \      0x136   0x4627             MOV      R7,R4
   \      0x138   0xE79B             B.N      ??PWMC_SetPhaseVoltage_2
   \                     ??PWMC_SetPhaseVoltage_4: (+1)
   \      0x13A   0x8643             STRH     R3,[R0, #+50]
    223          
    224              if ( pHandle->Ib > 0 )
   \      0x13C   0xF9B2 0x4010      LDRSH    R4,[R2, #+16]
   \      0x140   0x8E83             LDRH     R3,[R0, #+52]
   \      0x142   0x2C00             CMP      R4,#+0
   \      0x144   0xBFCC             ITE      GT
   \      0x146   0x18CB             ADDGT    R3,R1,R3
   \      0x148   0x1A5B             SUBLE    R3,R3,R1
    225              {
    226                pHandle->CntPhB += pHandle->DTCompCnt;
    227              }
    228              else
    229              {
    230                pHandle->CntPhB -= pHandle->DTCompCnt;
   \      0x14A   0x8683             STRH     R3,[R0, #+52]
    231              }
    232          
    233              if ( pHandle->Ic > 0 )
   \      0x14C   0xF9B2 0x2012      LDRSH    R2,[R2, #+18]
   \      0x150   0x8EC3             LDRH     R3,[R0, #+54]
   \      0x152   0x2A00             CMP      R2,#+0
   \      0x154   0xBFCC             ITE      GT
   \      0x156   0x18C9             ADDGT    R1,R1,R3
   \      0x158   0x1A59             SUBLE    R1,R3,R1
    234              {
    235                pHandle->CntPhC += pHandle->DTCompCnt;
    236              }
    237              else
    238              {
    239                pHandle->CntPhC -= pHandle->DTCompCnt;
   \      0x15A   0x86C1             STRH     R1,[R0, #+54]
    240              }
    241            }
    242          
    243            return ( pHandle->pFctSetADCSampPointSectX( pHandle ) );
   \                     ??PWMC_SetPhaseVoltage_3: (+1)
   \      0x15C   0x6981             LDR      R1,[R0, #+24]
   \      0x15E   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \      0x162   0x4708             BX       R1
    244          }
    245          
    246          /**
    247            * @brief  Switches PWM generation off, inactivating the outputs.
    248            * @param  pHandle Handle on the target instance of the PWMC component
    249            */

   \                                 In section .text, align 2
    250          __weak void PWMC_SwitchOffPWM( PWMC_Handle_t * pHandle )
    251          {
    252            pHandle->pFctSwitchOffPwm( pHandle );
   \                     PWMC_SwitchOffPWM: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   \        0x2   0x4708             BX       R1
    253          }
    254          
    255          /**
    256            * @brief  Switches PWM generation on
    257            * @param  pHandle Handle on the target instance of the PWMC component
    258            */

   \                                 In section .text, align 2
    259          __weak void PWMC_SwitchOnPWM( PWMC_Handle_t * pHandle )
    260          {
    261            pHandle->pFctSwitchOnPwm( pHandle );
   \                     PWMC_SwitchOnPWM: (+1)
   \        0x0   0x68C1             LDR      R1,[R0, #+12]
   \        0x2   0x4708             BX       R1
    262          }
    263          
    264          /**
    265            * @brief  Calibrates ADC current conversions by reading the offset voltage
    266            *         present on ADC pins when no motor current is flowing in.
    267            *
    268            * This function should be called before each motor start-up.
    269            *
    270            * @param  pHandle Handle on the target instance of the PWMC component
    271            * @param  action Can be #CRC_START to initialize the offset calibration or
    272            *         #CRC_EXEC to execute the offset calibration.
    273            * @retval true if the current calibration has been completed, false if it is
    274            *         still ongoing.
    275            */

   \                                 In section .text, align 2
    276          __weak bool PWMC_CurrentReadingCalibr( PWMC_Handle_t * pHandle, CRCAction_t action )
    277          {
   \                     PWMC_CurrentReadingCalibr: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    278            bool retVal = false;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x4604             MOV      R4,R0
    279            if ( action == CRC_START )
   \        0x6   0x0008             MOVS     R0,R1
   \        0x8   0xF104 0x0610      ADD      R6,R4,#+16
   \        0xC   0xD107             BNE.N    ??PWMC_CurrentReadingCalibr_0
    280            {
    281              PWMC_SwitchOffPWM( pHandle );
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x....'....        BL       PWMC_SwitchOffPWM
    282              pHandle->OffCalibrWaitTimeCounter = pHandle->OffCalibrWaitTicks;
   \       0x14   0xF8B4 0x0052      LDRH     R0,[R4, #+82]
   \       0x18   0x86B0             STRH     R0,[R6, #+52]
    283              if ( pHandle->OffCalibrWaitTicks == 0u )
   \       0x1A   0xB960             CBNZ.N   R0,??PWMC_CurrentReadingCalibr_1
   \       0x1C   0xE007             B.N      ??PWMC_CurrentReadingCalibr_2
    284              {
    285                pHandle->pFctCurrReadingCalib( pHandle );
    286                retVal = true;
    287              }
    288            }
    289            else if ( action == CRC_EXEC )
   \                     ??PWMC_CurrentReadingCalibr_0: (+1)
   \       0x1E   0x2901             CMP      R1,#+1
   \       0x20   0xD109             BNE.N    ??PWMC_CurrentReadingCalibr_1
    290            {
    291              if ( pHandle->OffCalibrWaitTimeCounter > 0u )
   \       0x22   0x8EB0             LDRH     R0,[R6, #+52]
   \       0x24   0xB130             CBZ.N    R0,??PWMC_CurrentReadingCalibr_3
    292              {
    293                pHandle->OffCalibrWaitTimeCounter--;
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0x86B0             STRH     R0,[R6, #+52]
    294                if ( pHandle->OffCalibrWaitTimeCounter == 0u )
   \       0x2A   0xB280             UXTH     R0,R0
   \       0x2C   0xB918             CBNZ.N   R0,??PWMC_CurrentReadingCalibr_1
    295                {
    296                  pHandle->pFctCurrReadingCalib( pHandle );
   \                     ??PWMC_CurrentReadingCalibr_2: (+1)
   \       0x2E   0x6831             LDR      R1,[R6, #+0]
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x4788             BLX      R1
    297                  retVal = true;
    298                }
    299              }
    300              else
    301              {
    302                retVal = true;
   \                     ??PWMC_CurrentReadingCalibr_3: (+1)
   \       0x34   0x2501             MOVS     R5,#+1
    303              }
    304            }
    305            else
    306            {
    307            }
    308            return retVal;
   \                     ??PWMC_CurrentReadingCalibr_1: (+1)
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0xBD70             POP      {R4-R6,PC}       ;; return
    309          }
    310          
    311          /**
    312            * @brief  Switches power stage Low Sides transistors on.
    313            *
    314            * This function is meant for charging boot capacitors of the driving
    315            * section. It has to be called on each motor start-up when using high
    316            * voltage drivers.
    317            *
    318            * @param  pHandle: handle on the target instance of the PWMC component
    319            */

   \                                 In section .text, align 2
    320          __weak void PWMC_TurnOnLowSides( PWMC_Handle_t * pHandle )
    321          {
    322            pHandle->pFctTurnOnLowSides( pHandle );
   \                     PWMC_TurnOnLowSides: (+1)
   \        0x0   0x6941             LDR      R1,[R0, #+20]
   \        0x2   0x4708             BX       R1
    323          }
    324          
    325          
    326          /** @brief Returns #MC_BREAK_IN if an over current condition was detected on the power stage
    327           *         controlled by the PWMC component pointed by  @p pHandle, since the last call to this function;
    328           *         returns #MC_NO_FAULTS otherwise. */

   \                                 In section .text, align 2
    329          __weak uint16_t PWMC_CheckOverCurrent( PWMC_Handle_t * pHandle )
    330          {
    331            return pHandle->pFctIsOverCurrentOccurred( pHandle );
   \                     PWMC_CheckOverCurrent: (+1)
   \        0x0   0x69C1             LDR      R1,[R0, #+28]
   \        0x2   0x4708             BX       R1
    332          }
    333          
    334          /**
    335            * @brief  Sets the over current threshold to be used
    336            *
    337            * The value to be set is relative to the VDD_DAC DAC reference voltage with
    338            * 0 standing for 0 V and 65536 standing for VDD_DAC.
    339            *
    340            * @param  pHandle handle on the target instance of the PWMC component
    341            * @param  hDACVref Value of DAC reference expressed as 16bit unsigned integer
    342            */

   \                                 In section .text, align 2
    343          __weak void PWMC_OCPSetReferenceVoltage( PWMC_Handle_t * pHandle, uint16_t hDACVref )
    344          {
    345            if ( pHandle->pFctOCPSetReferenceVoltage )
   \                     PWMC_OCPSetReferenceVoltage: (+1)
   \        0x0   0x6A02             LDR      R2,[R0, #+32]
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xBF18             IT       NE
    346            {
    347              pHandle->pFctOCPSetReferenceVoltage( pHandle, hDACVref );
   \        0x6   0x4710             BXNE     R2
    348            }
    349          }
   \        0x8   0x4770             BX       LR               ;; return
    350          
    351          /**
    352            * @brief  It is used to retrieve the satus of TurnOnLowSides action.
    353            * @param  pHandle: handler of the current instance of the PWMC component
    354            * @retval bool It returns the state of TurnOnLowSides action:
    355            *         true if TurnOnLowSides action is active, false otherwise.
    356            */
    357          /** @brief Returns the status of the "TurnOnLowSide" action on the power stage
    358           *         controlled by the @p pHandle PWMC component: true if it
    359           *         is active, false otherwise*/

   \                                 In section .text, align 2
    360          __weak bool PWMC_GetTurnOnLowSidesAction( PWMC_Handle_t * pHandle )
    361          {
    362            return pHandle->TurnOnLowSidesAction;
   \                     PWMC_GetTurnOnLowSidesAction: (+1)
   \        0x0   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \        0x4   0x4770             BX       LR               ;; return
    363          }
    364          
    365          /** @brief Enables the RL detection mode on the power stage controlled by the @p pHandle PWMC component. */

   \                                 In section .text, align 2
    366          __weak void PWMC_RLDetectionModeEnable( PWMC_Handle_t * pHandle )
    367          {
    368            if ( pHandle->pFctRLDetectionModeEnable )
   \                     PWMC_RLDetectionModeEnable: (+1)
   \        0x0   0x6A41             LDR      R1,[R0, #+36]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF18             IT       NE
    369            {
    370              pHandle->pFctRLDetectionModeEnable( pHandle );
   \        0x6   0x4708             BXNE     R1
    371            }
    372          }
   \        0x8   0x4770             BX       LR               ;; return
    373          
    374          /** @brief Disables the RL detection mode on the power stage controlled by the @p pHandle PWMC component. */

   \                                 In section .text, align 2
    375          __weak void PWMC_RLDetectionModeDisable( PWMC_Handle_t * pHandle )
    376          {
    377            if ( pHandle->pFctRLDetectionModeDisable )
   \                     PWMC_RLDetectionModeDisable: (+1)
   \        0x0   0x6A81             LDR      R1,[R0, #+40]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF18             IT       NE
    378            {
    379              pHandle->pFctRLDetectionModeDisable( pHandle );
   \        0x6   0x4708             BXNE     R1
    380            }
    381          }
   \        0x8   0x4770             BX       LR               ;; return
    382          
    383          /**
    384            * @brief  Sets the PWM duty cycle to apply in the RL Detection mode.
    385            * @param  pHandle: handle on the target instance of the PWMC component
    386            * @param  hDuty Duty cycle to apply
    387            *
    388            * @todo TODO: Describe the unit of the hDuty variable.
    389            *
    390            * @retval If the Duty Cycle could be applied on time for the next PWM period,
    391            *         #MC_NO_ERROR is returned. Otherwise, #MC_FOC_DURATION is returned.
    392            */

   \                                 In section .text, align 2
    393          __weak uint16_t PWMC_RLDetectionModeSetDuty( PWMC_Handle_t * pHandle, uint16_t hDuty )
    394          {
   \                     PWMC_RLDetectionModeSetDuty: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    395            uint16_t hRetVal = MC_FOC_DURATION;
    396            if ( pHandle->pFctRLDetectionModeSetDuty )
   \        0x2   0x6AC3             LDR      R3,[R0, #+44]
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xB10B             CBZ.N    R3,??PWMC_RLDetectionModeSetDuty_0
    397            {
    398              hRetVal = pHandle->pFctRLDetectionModeSetDuty( pHandle, hDuty );
   \        0x8   0x4798             BLX      R3
   \        0xA   0x4602             MOV      R2,R0
    399            }
    400            return hRetVal;
   \                     ??PWMC_RLDetectionModeSetDuty_0: (+1)
   \        0xC   0x4610             MOV      R0,R2
   \        0xE   0xBD02             POP      {R1,PC}          ;; return
    401          }
    402          
    403          /**
    404           * @brief Sets the Callback that the PWMC component shall invoke to get phases current.
    405           * @param pCallBack pointer on the callback
    406           * @param pHandle pointer on the handle structure of the PWMC instance
    407           *
    408           */

   \                                 In section .text, align 2
    409          __weak void PWMC_RegisterGetPhaseCurrentsCallBack( PWMC_GetPhaseCurr_Cb_t pCallBack,
    410              PWMC_Handle_t * pHandle )
    411          {
    412            pHandle->pFctGetPhaseCurrents = pCallBack;
   \                     PWMC_RegisterGetPhaseCurrentsCallBack: (+1)
   \        0x0   0x6048             STR      R0,[R1, #+4]
    413          }
   \        0x2   0x4770             BX       LR               ;; return
    414          
    415          /**
    416           * @brief Sets the Callback that the PWMC component shall invoke to switch PWM
    417           *        generation off.
    418           * @param pCallBack pointer on the callback
    419           * @param pHandle pointer on the handle structure of the PWMC instance
    420           *
    421           */

   \                                 In section .text, align 2
    422          __weak void PWMC_RegisterSwitchOffPwmCallBack( PWMC_Generic_Cb_t pCallBack,
    423                                                  PWMC_Handle_t * pHandle )
    424          {
    425            pHandle->pFctSwitchOffPwm = pCallBack;
   \                     PWMC_RegisterSwitchOffPwmCallBack: (+1)
   \        0x0   0x6088             STR      R0,[R1, #+8]
    426          }
   \        0x2   0x4770             BX       LR               ;; return
    427          
    428          /**
    429           * @brief Sets the Callback that the PWMC component shall invoke to switch PWM
    430           *        generation on.
    431           * @param pCallBack pointer on the callback
    432           * @param pHandle pointer on the handle structure of the PWMC instance
    433           *
    434           */

   \                                 In section .text, align 2
    435          __weak void PWMC_RegisterSwitchonPwmCallBack( PWMC_Generic_Cb_t pCallBack,
    436                                                 PWMC_Handle_t * pHandle )
    437          {
    438            pHandle->pFctSwitchOnPwm = pCallBack;
   \                     PWMC_RegisterSwitchonPwmCallBack: (+1)
   \        0x0   0x60C8             STR      R0,[R1, #+12]
    439          }
   \        0x2   0x4770             BX       LR               ;; return
    440          
    441          /**
    442           * @brief Sets the Callback that the PWMC component shall invoke to execute a calibration
    443           *        of the current sensing system.
    444           * @param pCallBack pointer on the callback
    445           * @param pHandle pointer on the handle structure of the PWMC instance
    446           *
    447           */

   \                                 In section .text, align 2
    448          __weak void PWMC_RegisterReadingCalibrationCallBack( PWMC_Generic_Cb_t pCallBack,
    449              PWMC_Handle_t * pHandle )
    450          {
    451            pHandle->pFctCurrReadingCalib = pCallBack;
   \                     PWMC_RegisterReadingCalibrationCallBack: (+1)
   \        0x0   0x6108             STR      R0,[R1, #+16]
    452          }
   \        0x2   0x4770             BX       LR               ;; return
    453          
    454          /**
    455           * @brief Sets the Callback that the PWMC component shall invoke to turn low sides on.
    456           * @param pCallBack pointer on the callback
    457           * @param pHandle pointer on the handle structure of the PWMC instance
    458           *
    459           */

   \                                 In section .text, align 2
    460          __weak void PWMC_RegisterTurnOnLowSidesCallBack( PWMC_Generic_Cb_t pCallBack,
    461              PWMC_Handle_t * pHandle )
    462          {
    463            pHandle->pFctTurnOnLowSides = pCallBack;
   \                     PWMC_RegisterTurnOnLowSidesCallBack: (+1)
   \        0x0   0x6148             STR      R0,[R1, #+20]
    464          }
   \        0x2   0x4770             BX       LR               ;; return
    465          
    466          /**
    467           * @brief Sets the Callback that the PWMC component shall invoke to compute ADC sampling point
    468           * @param pCallBack pointer on the callback
    469           * @param pHandle pointer on the handle structure of the PWMC instance
    470           *
    471           */

   \                                 In section .text, align 2
    472          __weak void PWMC_RegisterSampPointSectXCallBack( PWMC_SetSampPointSectX_Cb_t pCallBack,
    473              PWMC_Handle_t * pHandle )
    474          {
    475            pHandle->pFctSetADCSampPointSectX = pCallBack;
   \                     PWMC_RegisterSampPointSectXCallBack: (+1)
   \        0x0   0x6188             STR      R0,[R1, #+24]
    476          }
   \        0x2   0x4770             BX       LR               ;; return
    477          
    478          /**
    479           * @brief Sets the Callback that the PWMC component shall invoke to the overcurrent status
    480           * @param pCallBack pointer on the callback
    481           * @param pHandle pointer on the handle structure of the PWMC instance
    482           *
    483           */

   \                                 In section .text, align 2
    484          __weak void PWMC_RegisterIsOverCurrentOccurredCallBack( PWMC_OverCurr_Cb_t pCallBack,
    485              PWMC_Handle_t * pHandle )
    486          {
    487            pHandle->pFctIsOverCurrentOccurred = pCallBack;
   \                     PWMC_RegisterIsOverCurrentOccurredCallBack: (+1)
   \        0x0   0x61C8             STR      R0,[R1, #+28]
    488          }
   \        0x2   0x4770             BX       LR               ;; return
    489          
    490          /**
    491           * @brief Sets the Callback that the PWMC component shall invoke to set the reference
    492           *        voltage for the over current protection
    493           * @param pHandle pointer on the handle structure of the PWMC instance
    494           *
    495           */

   \                                 In section .text, align 2
    496          __weak void PWMC_RegisterOCPSetRefVoltageCallBack( PWMC_SetOcpRefVolt_Cb_t pCallBack,
    497              PWMC_Handle_t * pHandle )
    498          {
    499            pHandle->pFctOCPSetReferenceVoltage = pCallBack;
   \                     PWMC_RegisterOCPSetRefVoltageCallBack: (+1)
   \        0x0   0x6208             STR      R0,[R1, #+32]
    500          }
   \        0x2   0x4770             BX       LR               ;; return
    501          
    502          /**
    503           * @brief Sets the Callback that the PWMC component shall invoke to enable the R/L detection mode
    504           * @param pHandle pointer on the handle structure of the PWMC instance
    505           *
    506           */

   \                                 In section .text, align 2
    507          __weak void PWMC_RegisterRLDetectionModeEnableCallBack( PWMC_Generic_Cb_t pCallBack,
    508              PWMC_Handle_t * pHandle )
    509          {
    510            pHandle->pFctRLDetectionModeEnable = pCallBack;
   \                     PWMC_RegisterRLDetectionModeEnableCallBack: (+1)
   \        0x0   0x6248             STR      R0,[R1, #+36]
    511          }
   \        0x2   0x4770             BX       LR               ;; return
    512          
    513          /**
    514           * @brief Sets the Callback wIch PWMC shall invoke to disable the R/L detection mode
    515           * @param pHandle pointer on the handle structure of the PWMC instance
    516           *
    517           */

   \                                 In section .text, align 2
    518          __weak void PWMC_RegisterRLDetectionModeDisableCallBack( PWMC_Generic_Cb_t pCallBack,
    519              PWMC_Handle_t * pHandle )
    520          {
    521            pHandle->pFctRLDetectionModeDisable = pCallBack;
   \                     PWMC_RegisterRLDetectionModeDisableCallBack: (+1)
   \        0x0   0x6288             STR      R0,[R1, #+40]
    522          }
   \        0x2   0x4770             BX       LR               ;; return
    523          
    524          /**
    525           * @brief Sets the Callback that the PWMC component shall invoke to set the duty cycle
    526           *        for the R/L detection mode
    527           * @param pHandle pointer on the handle structure of the PWMC instance
    528           *
    529           */

   \                                 In section .text, align 2
    530          __weak void PWMC_RegisterRLDetectionModeSetDutyCallBack( PWMC_RLDetectSetDuty_Cb_t pCallBack,
    531              PWMC_Handle_t * pHandle )
    532          {
    533            pHandle->pFctRLDetectionModeSetDuty = pCallBack;
   \                     PWMC_RegisterRLDetectionModeSetDutyCallBack: (+1)
   \        0x0   0x62C8             STR      R0,[R1, #+44]
    534          }
   \        0x2   0x4770             BX       LR               ;; return
    535          
    536          /**
    537           * @brief Sets the Callback that the PWMC component shall invoke to call PWMC instance IRQ handler
    538           * @param pHandle pointer on the handle structure of the PWMC instance
    539           *
    540           * @note this function is deprecated.
    541           */

   \                                 In section .text, align 2
    542          __weak void PWMC_RegisterIrqHandlerCallBack( PWMC_IrqHandler_Cb_t pCallBack,
    543                                                PWMC_Handle_t * pHandle )
    544          {
    545            pHandle->pFctIrqHandler = pCallBack;
   \                     PWMC_RegisterIrqHandlerCallBack: (+1)
   \        0x0   0x6008             STR      R0,[R1, #+0]
    546          }
   \        0x2   0x4770             BX       LR               ;; return
    547          
    548          /**
    549            * @}
    550            */
    551          
    552          /**
    553            * @}
    554            */
    555          
    556          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   PWMC_CheckOverCurrent
         0   -- Indirect call
      16   PWMC_CurrentReadingCalibr
        16   -- Indirect call
        16   -> PWMC_SwitchOffPWM
       0   PWMC_GetPhaseCurrents
         0   -- Indirect call
       0   PWMC_GetTurnOnLowSidesAction
       0   PWMC_OCPSetReferenceVoltage
         0   -- Indirect call
       0   PWMC_RLDetectionModeDisable
         0   -- Indirect call
       0   PWMC_RLDetectionModeEnable
         0   -- Indirect call
       8   PWMC_RLDetectionModeSetDuty
         8   -- Indirect call
       0   PWMC_RegisterGetPhaseCurrentsCallBack
       0   PWMC_RegisterIrqHandlerCallBack
       0   PWMC_RegisterIsOverCurrentOccurredCallBack
       0   PWMC_RegisterOCPSetRefVoltageCallBack
       0   PWMC_RegisterRLDetectionModeDisableCallBack
       0   PWMC_RegisterRLDetectionModeEnableCallBack
       0   PWMC_RegisterRLDetectionModeSetDutyCallBack
       0   PWMC_RegisterReadingCalibrationCallBack
       0   PWMC_RegisterSampPointSectXCallBack
       0   PWMC_RegisterSwitchOffPwmCallBack
       0   PWMC_RegisterSwitchonPwmCallBack
       0   PWMC_RegisterTurnOnLowSidesCallBack
      32   PWMC_SetPhaseVoltage
         0   -- Indirect call
       0   PWMC_SwitchOffPWM
         0   -- Indirect call
       0   PWMC_SwitchOnPWM
         0   -- Indirect call
       0   PWMC_TurnOnLowSides
         0   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  PWMC_CheckOverCurrent
      58  PWMC_CurrentReadingCalibr
       4  PWMC_GetPhaseCurrents
       6  PWMC_GetTurnOnLowSidesAction
      10  PWMC_OCPSetReferenceVoltage
      10  PWMC_RLDetectionModeDisable
      10  PWMC_RLDetectionModeEnable
      16  PWMC_RLDetectionModeSetDuty
       4  PWMC_RegisterGetPhaseCurrentsCallBack
       4  PWMC_RegisterIrqHandlerCallBack
       4  PWMC_RegisterIsOverCurrentOccurredCallBack
       4  PWMC_RegisterOCPSetRefVoltageCallBack
       4  PWMC_RegisterRLDetectionModeDisableCallBack
       4  PWMC_RegisterRLDetectionModeEnableCallBack
       4  PWMC_RegisterRLDetectionModeSetDutyCallBack
       4  PWMC_RegisterReadingCalibrationCallBack
       4  PWMC_RegisterSampPointSectXCallBack
       4  PWMC_RegisterSwitchOffPwmCallBack
       4  PWMC_RegisterSwitchonPwmCallBack
       4  PWMC_RegisterTurnOnLowSidesCallBack
     356  PWMC_SetPhaseVoltage
       4  PWMC_SwitchOffPWM
       4  PWMC_SwitchOnPWM
       4  PWMC_TurnOnLowSides

 
 534 bytes in section .text
 
 0 bytes of CODE memory (+ 534 bytes shared)

Errors: none
Warnings: none
