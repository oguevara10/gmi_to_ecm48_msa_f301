###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:35
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\module_flash.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW519C.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\module_flash.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\module_flash.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\module_flash.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\module_flash.c
      1          /**
      2          ********************************************************************************************************************************
      3          * @file    module_flash.c 
      4          * @author  Pamela Lee
      5          * @brief   Main driver module for flash.
      6          * @details This module initializes the flash
      7          *          The ST motor libraries parameters will be mapped from the top of FLASH_USER_START_ADDR in 16bit data,
      8          *          the data can be updated by using the function of uint8_t FlashDatSet(uint16_t _offset, uint16_t _flashDat), then 
      9          *          data and offset will store in internal buffer as temporary data, user can either store all the temporary data into flash 
     10          *          by flashPageUpdate(), or if the internal buffer is full will also update the temporary into flash.
     11          ********************************************************************************************************************************
     12          */
     13          
     14          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     15          #include "zz_module_flash.h"

   \                                 In section .rodata, at 0x800f000
   \   __absolute uint16_t const A_POLE_PAIR_NUM
   \                     A_POLE_PAIR_NUM:
   \        0x0   0x0005             DC16 5

   \                                 In section .rodata, at 0x800f002
   \   __absolute uint16_t const A_RS
   \                     A_RS:
   \        0x0   0x0258             DC16 600

   \                                 In section .rodata, at 0x800f004
   \   __absolute uint16_t const A_LS
   \                     A_LS:
   \        0x0   0x0010             DC16 16

   \                                 In section .rodata, at 0x800f006
   \   __absolute uint16_t const A_NOMINAL_CURRENT
   \                     A_NOMINAL_CURRENT:
   \        0x0   0x6A1E             DC16 27'166

   \                                 In section .rodata, at 0x800f008
   \   __absolute uint16_t const A_MAX_APPLICATION_SPEED_RPM
   \                     A_MAX_APPLICATION_SPEED_RPM:
   \        0x0   0x08CA             DC16 2'250

   \                                 In section .rodata, at 0x800f00a
   \   __absolute uint16_t const A_MIN_APPLICATION_SPEED_RPM
   \                     A_MIN_APPLICATION_SPEED_RPM:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f00c
   \   __absolute uint16_t const A_PLL_KP_GAIN
   \                     A_PLL_KP_GAIN:
   \        0x0   0x0214             DC16 532

   \                                 In section .rodata, at 0x800f00e
   \   __absolute uint16_t const A_PLL_KI_GAIN
   \                     A_PLL_KI_GAIN:
   \        0x0   0x0025             DC16 37

   \                                 In section .rodata, at 0x800f010
   \   __absolute uint16_t const A_PWM_FREQUENCY
   \                     A_PWM_FREQUENCY:
   \        0x0   0x2710             DC16 10'000

   \                                 In section .rodata, at 0x800f012
   \   __absolute uint16_t const A_PID_TORQUE_KP_DEFAULT
   \                     A_PID_TORQUE_KP_DEFAULT:
   \        0x0   0x0ECF             DC16 3'791

   \                                 In section .rodata, at 0x800f014
   \   __absolute uint16_t const A_PID_TORQUE_KI_DEFAULT
   \                     A_PID_TORQUE_KI_DEFAULT:
   \        0x0   0x0038             DC16 56

   \                                 In section .rodata, at 0x800f016
   \   __absolute uint16_t const A_PID_FLUX_KP_DEFAULT
   \                     A_PID_FLUX_KP_DEFAULT:
   \        0x0   0x14B7             DC16 5'303

   \                                 In section .rodata, at 0x800f018
   \   __absolute uint16_t const A_PID_FLUX_KI_DEFAULT
   \                     A_PID_FLUX_KI_DEFAULT:
   \        0x0   0x0038             DC16 56

   \                                 In section .rodata, at 0x800f01a
   \   __absolute uint16_t const A_PID_SPEED_KP_DEFAULT
   \                     A_PID_SPEED_KP_DEFAULT:
   \        0x0   0x0064             DC16 100

   \                                 In section .rodata, at 0x800f01c
   \   __absolute uint16_t const A_PID_SPEED_KI_DEFAULT
   \                     A_PID_SPEED_KI_DEFAULT:
   \        0x0   0x03E8             DC16 1'000

   \                                 In section .rodata, at 0x800f01e
   \   __absolute uint16_t const A_IQMAX
   \                     A_IQMAX:
   \        0x0   0x6A1E             DC16 27'166

   \                                 In section .rodata, at 0x800f020
   \   __absolute uint16_t const A_DEFAULT_CONTROL_MODE
   \                     A_DEFAULT_CONTROL_MODE:
   \        0x0   0x0001             DC16 1

   \                                 In section .rodata, at 0x800f022
   \   __absolute uint16_t const A_OV_VOLTAGE_THRESHOLD_V
   \                     A_OV_VOLTAGE_THRESHOLD_V:
   \        0x0   0x01EC             DC16 492

   \                                 In section .rodata, at 0x800f024
   \   __absolute uint16_t const A_UD_VOLTAGE_THRESHOLD_V
   \                     A_UD_VOLTAGE_THRESHOLD_V:
   \        0x0   0x00AF             DC16 175

   \                                 In section .rodata, at 0x800f026
   \   __absolute uint16_t const A_OV_TEMPERATURE_THRESHOLD_C
   \                     A_OV_TEMPERATURE_THRESHOLD_C:
   \        0x0   0x005F             DC16 95

   \                                 In section .rodata, at 0x800f028
   \   __absolute uint16_t const A_OV_TEMPERATURE_HYSTERESIS_C
   \                     A_OV_TEMPERATURE_HYSTERESIS_C:
   \        0x0   0x000A             DC16 10

   \                                 In section .rodata, at 0x800f02a
   \   __absolute uint16_t const A_PHASE1_DURATION
   \                     A_PHASE1_DURATION:
   \        0x0   0x03E8             DC16 1'000

   \                                 In section .rodata, at 0x800f02c
   \   __absolute uint16_t const A_PHASE1_FINAL_SPEED_UNIT
   \                     A_PHASE1_FINAL_SPEED_UNIT:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f02e
   \   __absolute uint16_t const A_PHASE1_FINAL_CURRENT
   \                     A_PHASE1_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f030
   \   __absolute uint16_t const A_PHASE2_DURATION
   \                     A_PHASE2_DURATION:
   \        0x0   0x1770             DC16 6'000

   \                                 In section .rodata, at 0x800f032
   \   __absolute uint16_t const A_PHASE2_FINAL_SPEED_UNIT
   \                     A_PHASE2_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f034
   \   __absolute uint16_t const A_PHASE2_FINAL_CURRENT
   \                     A_PHASE2_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f036
   \   __absolute uint16_t const A_PHASE3_DURATION
   \                     A_PHASE3_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f038
   \   __absolute uint16_t const A_PHASE3_FINAL_SPEED_UNIT
   \                     A_PHASE3_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f03a
   \   __absolute uint16_t const A_PHASE3_FINAL_CURRENT
   \                     A_PHASE3_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f03c
   \   __absolute uint16_t const A_PHASE4_DURATION
   \                     A_PHASE4_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f03e
   \   __absolute uint16_t const A_PHASE4_FINAL_SPEED_UNIT
   \                     A_PHASE4_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f040
   \   __absolute uint16_t const A_PHASE4_FINAL_CURRENT
   \                     A_PHASE4_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f042
   \   __absolute uint16_t const A_PHASE5_DURATION
   \                     A_PHASE5_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f044
   \   __absolute uint16_t const A_PHASE5_FINAL_SPEED_UNIT
   \                     A_PHASE5_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f046
   \   __absolute uint16_t const A_PHASE5_FINAL_CURRENT
   \                     A_PHASE5_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f048
   \   __absolute uint16_t const A_TRANSITION_DURATION
   \                     A_TRANSITION_DURATION:
   \        0x0   0x01F4             DC16 500

   \                                 In section .rodata, at 0x800f04a
   \   __absolute uint16_t const D_HALL_SENSORS_PLACEMENT
   \                     D_HALL_SENSORS_PLACEMENT:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f04c
   \   __absolute uint16_t const D_HALL_PHASE_SHIFT
   \                     D_HALL_PHASE_SHIFT:
   \        0x0   0x012C             DC16 300

   \                                 In section .rodata, at 0x800f04e
   \   __absolute uint16_t const D_M1_ENCODER_PPR
   \                     D_M1_ENCODER_PPR:
   \        0x0   0x0190             DC16 400

   \                                 In section .rodata, at 0x800f050
   \   __absolute int16_t const A_GAIN1
   \                     A_GAIN1:
   \        0x0   0xA02E             DC16 -24'530

   \                                 In section .rodata, at 0x800f052
   \   __absolute int16_t const A_GAIN2
   \                     A_GAIN2:
   \        0x0   0x5EA3             DC16 24'227
     16          #include "user_interface.h"
     17          #include "motor_control_protocol.h"
     18          #include "ui_task.h"
     19          
     20          
     21          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     22          
     23          //extern Ram_Buf sharedMemArray[STRUCT_MEM_ARRAY_SIZE];
     24          extern ProcessInfo processInfoTable[];
     25          extern VirtualSpeedSensor_Handle_t VirtualSpeedSensorM1;

   \                                 In section .bss, align 4
     26          uint32_t Address = 0;                                     //, PageError = 0;
   \                     Address:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
     27          __IO uint8_t readData = 0 , MemoryProgramStatus = 0;
   \                     readData:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     MemoryProgramStatus:
   \        0x0                      DS8 1
     28          
     29          /*Variable used for Erase procedure*/

   \                                 In section .bss, align 4
     30          static FLASH_EraseInitTypeDef EraseInitStruct;
   \                     EraseInitStruct:
   \        0x0                      DS8 12
     31          
     32          
     33          //*****************************************************************************************
     34          typedef  struct 
     35          {
     36              uint16_t      offset;
     37              uint16_t      flashDat;
     38          }FlashBufInfo;
     39          #define FlashBufSize 20

   \                                 In section .bss, align 4
     40          FlashBufInfo flashBuf[FlashBufSize];
   \                     flashBuf:
   \        0x0                      DS8 80

   \                                 In section .bss, align 1
     41          uint8_t Flash_BufHead = 0;
   \                     Flash_BufHead:
   \        0x0                      DS8 1
     42          uint8_t Flash_BufTail = 0;
   \                     Flash_BufTail:
   \        0x1                      DS8 1
     43          //********************************************************************************************************************************************************
     44          
     45          enum {
     46            INIT_MODULE,
     47            RUN_MODULE,
     48            // additional states to be added here as necessary.
     49            IRQ_MODULE = DEFAULT_IRQ_STATE,
     50            KILL_MODULE = KILL_APP
     51          };
     52          

   \                                 In section .text, align 2, keep-with-next
     53          uint8_t moduleFlash_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     moduleFlash_u32: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     54            uint8_t return_state_u8 = INIT_MODULE;
     55            switch (next_state_u8) {
   \        0x2   0x24FF             MOVS     R4,#+255
   \        0x4   0xB122             CBZ.N    R2,??moduleFlash_u32_0
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD004             BEQ.N    ??moduleFlash_u32_1
   \        0xA   0x2AFF             CMP      R2,#+255
   \        0xC   0xD004             BEQ.N    ??moduleFlash_u32_2
   \        0xE   0xE00C             B.N      ??moduleFlash_u32_3
     56              case INIT_MODULE: {
     57                FlashBufInit();
   \                     ??moduleFlash_u32_0: (+1)
   \       0x10   0x....'....        BL       FlashBufInit
     58                /** for pam testing the buffer system **/
     59               /*
     60                FlashDatSet(0, 0xaaaa);
     61                FlashDatSet(0x1ff, 0x5555);
     62                FlashDatSet(0x122, 0x5555);   //going to delete before write inflash
     63                FlashDatSet(0x3fe, 0xaaaa);
     64                FlashDatSet(0x200, 0x5555);
     65                FlashDatSet(0x3fe, 0xaa55);   //going to replace the former same address
     66                FlashDatSet(0x0ff, 0xaaaa);
     67                FlashDatSet(0x320, 0xaaaa);
     68                FlashDatSet(0x200, 0xaaaa);
     69                
     70                flashPageErase(drv_id_u8, FLASH_USER_START_ADDR, 2);       //elase all two page for update 
     71                
     72                flashPageUpdate(drv_id_u8, (FLASH_USER_START_ADDR + FLASH_PAGE_SIZE), FLASH_USER_START_ADDR, 1); //copy the lower page to upper page with ram data in buffer
     73                
     74                flashPageCopy(drv_id_u8, FLASH_USER_START_ADDR, (FLASH_USER_START_ADDR + FLASH_PAGE_SIZE), 1); //copy the whole page from one to other
     75                */
     76              //  flashPageErase(drv_id_u8, ADDR_FLASH_PAGE_31);
     77             //   flashPageCopy(drv_id_u8, ADDR_FLASH_PAGE_30, ADDR_FLASH_PAGE_31);
     78                
     79                return_state_u8 = RUN_MODULE;
     80                break;
     81              }
     82              case RUN_MODULE: {
     83                /** Program the user Flash area word by word(area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR) **/
     84                    
     85           
     86                
     87          
     88          
     89                return_state_u8 = RUN_MODULE;
   \                     ??moduleFlash_u32_1: (+1)
   \       0x14   0x2401             MOVS     R4,#+1
     90                break;
   \       0x16   0xE008             B.N      ??moduleFlash_u32_3
     91              }
     92              case KILL_MODULE: {
     93                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
     94                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??moduleFlash_u32_2: (+1)
   \       0x18   0x....'....        BL       getProcessInfoIndex
     95                if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0x1C   0x28FF             CMP      R0,#+255
   \       0x1E   0xD004             BEQ.N    ??moduleFlash_u32_3
     96                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \       0x20   0x2116             MOVS     R1,#+22
   \       0x22   0x....             LDR.N    R2,??DataTable8
   \       0x24   0x4348             MULS     R0,R1,R0
   \       0x26   0x4410             ADD      R0,R2,R0
   \       0x28   0x7284             STRB     R4,[R0, #+10]
     97                }
     98                return_state_u8 = KILL_MODULE;
     99                break;
    100              }
    101              default: {
    102                return_state_u8 = KILL_MODULE;
    103                break;
    104              }
    105            }
    106            return return_state_u8;
   \                     ??moduleFlash_u32_3: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
    107          }
    108          
    109          /** =========================== private functions =========================================== **/
    110          /**
    111            * @brief  Erase page/s of flash data
    112            * @param      drv_id_u8       The function caller module ID in case error occur within this function
    113            *             pageAddress     The starting address of the flash page
    114            * @retval successful
    115            */

   \                                 In section .text, align 2, keep-with-next
    116          uint8_t flashPageErase(uint8_t drv_id_u8, uint32_t pageAddress)                 //pam tested
    117          {
   \                     flashPageErase: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    118              uint8_t returnValue = true;
    119              uint32_t PageError = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9002             STR      R0,[SP, #+8]
   \        0x8   0x460D             MOV      R5,R1
    120              /** Unlock the Flash to enable the flash control register access **/
    121              HAL_FLASH_Unlock();
   \        0xA   0x....'....        BL       HAL_FLASH_Unlock
    122              /* Fill EraseInit structure*/
    123              EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
   \        0xE   0x....             LDR.N    R0,??DataTable8_1
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6001             STR      R1,[R0, #+0]
   \       0x14   0x2601             MOVS     R6,#+1
    124              EraseInitStruct.PageAddress = pageAddress;
   \       0x16   0x6045             STR      R5,[R0, #+4]
    125              EraseInitStruct.NbPages     = (uint32_t)NumOfPage;
   \       0x18   0x6086             STR      R6,[R0, #+8]
    126              /**                                                Flash erase                                             **/
    127              if (HAL_FLASHEx_Erase(&EraseInitStruct, &PageError) != HAL_OK)   //22ms
   \       0x1A   0xA902             ADD      R1,SP,#+8
   \       0x1C   0x....'....        BL       HAL_FLASHEx_Erase
   \       0x20   0xB150             CBZ.N    R0,??flashPageErase_0
    128              {  // Error occurred while page erase.                                                                           
    129                 setupSoftwareIRQ(drv_id_u8, MODULE_ERR_LOGHANDLE, 0xE4, 0x00, sizeof(uint32_t), (uint8_t*)(&PageError));     //report the error address 
   \       0x22   0xA802             ADD      R0,SP,#+8
   \       0x24   0x2104             MOVS     R1,#+4
   \       0x26   0x9001             STR      R0,[SP, #+4]
   \       0x28   0x9100             STR      R1,[SP, #+0]
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x22E4             MOVS     R2,#+228
   \       0x2E   0x2109             MOVS     R1,#+9
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       setupSoftwareIRQ
    130                 returnValue = false;
   \       0x36   0x2600             MOVS     R6,#+0
    131              }
    132              /** Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) **/
    133              HAL_FLASH_Lock();    
   \                     ??flashPageErase_0: (+1)
   \       0x38   0x....'....        BL       HAL_FLASH_Lock
    134              return returnValue;
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0xB004             ADD      SP,SP,#+16
   \       0x40   0xBD70             POP      {R4-R6,PC}       ;; return
    135          }
    136          
    137          /**
    138            * @brief  Copy page/s of flash data to another sector with all the temporary storage in internal buffer
    139            * @param      drv_id_u8               The function caller module ID in case error occur within this function
    140            *             _FrompageAddress        The starting address of the source flash page/s
    141            *             _TopageAddress          The starting address of the sink flash page/s
    142            * @retval successful
    143            */

   \                                 In section .text, align 2, keep-with-next
    144          uint8_t flashPageUpdate(uint8_t drv_id_u8, uint32_t _FrompageAddress, uint32_t _TopageAddress)
    145          {
   \                     flashPageUpdate: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4690             MOV      R8,R2
    146              /** Unlock the Flash to enable the flash control register access **/
    147              HAL_FLASH_Unlock();
   \        0xA   0x....'....        BL       HAL_FLASH_Unlock
    148              uint16_t indx = 0;
   \        0xE   0x2700             MOVS     R7,#+0
    149              uint16_t currentDat;
    150              uint16_t returnBuf = 0;
   \       0x10   0xF8AD 0x7008      STRH     R7,[SP, #+8]
    151              uint8_t returnValue = TRUE;
   \       0x14   0x2401             MOVS     R4,#+1
   \       0x16   0xF240 0x75FE      MOVW     R5,#+2046
   \       0x1A   0x....             LDR.N    R6,??DataTable8_2
    152              for(  ;  indx < ((FLASH_PAGE_SIZE * NumOfPage) - 2) ; indx +=2)
    153              {
    154                if(FlashBufDeRegistered(indx, &returnBuf))  //check this offset address is changed 
   \                     ??flashPageUpdate_0: (+1)
   \       0x1C   0xA902             ADD      R1,SP,#+8
   \       0x1E   0xB2B8             UXTH     R0,R7
   \       0x20   0x....'....        BL       FlashBufDeRegistered
   \       0x24   0xB110             CBZ.N    R0,??flashPageUpdate_1
    155                {
    156                  currentDat = returnBuf;         
   \       0x26   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \       0x2A   0xE004             B.N      ??flashPageUpdate_2
    157                }
    158                else
    159                {
    160                  currentDat = FlashRead((unsigned char*) _FrompageAddress, indx); //no updated data then just read the old data
   \                     ??flashPageUpdate_1: (+1)
   \       0x2C   0xB2B9             UXTH     R1,R7
   \       0x2E   0x4650             MOV      R0,R10
   \       0x30   0x....'....        BL       FlashRead
   \       0x34   0x4602             MOV      R2,R0
    161                } 
    162                if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, (_TopageAddress + indx), (uint64_t)currentDat) == HAL_OK) //write 16bit data
   \                     ??flashPageUpdate_2: (+1)
   \       0x36   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x3A   0xB918             CBNZ.N   R0,??flashPageUpdate_3
    163                {
    164                  Address += 2;
   \       0x3C   0x6830             LDR      R0,[R6, #+0]
   \       0x3E   0x1C80             ADDS     R0,R0,#+2
   \       0x40   0x6030             STR      R0,[R6, #+0]
   \       0x42   0xE004             B.N      ??CrossCallReturnLabel_4
    165                }
    166               else
    167                {
    168                  // Error occurred while writing data in Flash memory.                                                                 
    169                 setupSoftwareIRQ(drv_id_u8, MODULE_ERR_LOGHANDLE, 0xE4, 0x00, 0x00, NULL);     //report the error address 
   \                     ??flashPageUpdate_3: (+1)
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x9101             STR      R1,[SP, #+4]
   \       0x48   0x9100             STR      R1,[SP, #+0]
   \       0x4A   0x....'....        BL       ?Subroutine1
    170                }  
    171              }
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x4E   0x1CBF             ADDS     R7,R7,#+2
   \       0x50   0xB2B8             UXTH     R0,R7
   \       0x52   0x42A8             CMP      R0,R5
   \       0x54   0xDBE2             BLT.N    ??flashPageUpdate_0
    172              // put CRC to the last 2byte
    173              uint16_t uwCRCValue = Calculate_CRC((uint16_t)((FLASH_PAGE_SIZE * NumOfPage) - 2) , (unsigned char*)_TopageAddress);    
   \       0x56   0x4641             MOV      R1,R8
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       Calculate_CRC
   \       0x5E   0x4602             MOV      R2,R0
    174              //put calculated CRC back to the last word of the page
    175              if (!HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, (_TopageAddress + indx), (uint64_t)uwCRCValue) == HAL_OK) //write 16bit data
   \       0x60   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x64   0xB128             CBZ.N    R0,??flashPageUpdate_4
    176              {
    177                // Error occurred while writing data in Flash memory.                                                                 
    178               setupSoftwareIRQ(drv_id_u8, MODULE_ERR_LOGHANDLE, 0xE4, 0x00, 0x00, NULL);     //report the error address
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x9001             STR      R0,[SP, #+4]
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x....'....        BL       ?Subroutine1
    179               returnValue = FALSE;
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x70   0x2400             MOVS     R4,#+0
    180              }  
    181              /** Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) **/
    182              HAL_FLASH_Lock();
   \                     ??flashPageUpdate_4: (+1)
   \       0x72   0x....'....        BL       HAL_FLASH_Lock
    183            return returnValue;
   \       0x76   0x4620             MOV      R0,R4
   \       0x78   0xB004             ADD      SP,SP,#+16
   \       0x7A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    184          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0xFA18 0xF187      UXTAH    R1,R8,R7
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x....'....        B.W      HAL_FLASH_Program

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x22E4             MOVS     R2,#+228
   \        0x4   0x2109             MOVS     R1,#+9
   \        0x6   0x4648             MOV      R0,R9
   \        0x8   0x....'....        B.W      setupSoftwareIRQ
    185          
    186          /**
    187            * @brief  Program a block of datae into flash with input buffer
    188            * @param      drv_id_u8               The function caller module ID in case error occur within this function
    189            *             _TopageAddress          The starting address of the sink flash page/s
    190            *             _buf                    Buffer of data to burn into flash
    191            *             _length                 The starting address of the source flash page/s
    192            * @retval successful
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          uint8_t flashBlockProgram(uint8_t drv_id_u8, uint32_t _TopageAddress, uint8_t* _buf, uint32_t _length)                  //Pam Tested
    195          {
   \                     flashBlockProgram: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4699             MOV      R9,R3
    196              uint8_t returnValue = TRUE;
    197              HAL_FLASH_Unlock();
   \        0xC   0x....'....        BL       HAL_FLASH_Unlock
   \       0x10   0x2401             MOVS     R4,#+1
    198          
    199              for(uint16_t index = 0  ;  index < _length ; index +=2)
   \       0x12   0x2700             MOVS     R7,#+0
   \       0x14   0xE016             B.N      ??flashBlockProgram_0
    200              {
    201                if (!HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, (_TopageAddress + index), (uint64_t)((_buf[index+1] << 8) + _buf[index] )) == HAL_OK) //write 16bit data
   \                     ??flashBlockProgram_1: (+1)
   \       0x16   0x19F0             ADDS     R0,R6,R7
   \       0x18   0x5DF1             LDRB     R1,[R6, R7]
   \       0x1A   0x7840             LDRB     R0,[R0, #+1]
   \       0x1C   0xEB01 0x2200      ADD      R2,R1,R0, LSL #+8
   \       0x20   0x17D3             ASRS     R3,R2,#+31
   \       0x22   0x1979             ADDS     R1,R7,R5
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x....'....        BL       HAL_FLASH_Program
   \       0x2A   0xB148             CBZ.N    R0,??flashBlockProgram_2
    202                {
    203                  // Error occurred while writing data in Flash memory.                                                                 
    204                 setupSoftwareIRQ(drv_id_u8, MODULE_ERR_LOGHANDLE, 0xE4, 0x00, 0x00, NULL);     //report the error address 
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x9001             STR      R0,[SP, #+4]
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x2300             MOVS     R3,#+0
   \       0x34   0x22E4             MOVS     R2,#+228
   \       0x36   0x2109             MOVS     R1,#+9
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0x....'....        BL       setupSoftwareIRQ
    205                 returnValue = FALSE;
   \       0x3E   0x2400             MOVS     R4,#+0
    206                }  
    207              }
   \                     ??flashBlockProgram_2: (+1)
   \       0x40   0x1CBF             ADDS     R7,R7,#+2
   \       0x42   0xB2BF             UXTH     R7,R7
   \                     ??flashBlockProgram_0: (+1)
   \       0x44   0x454F             CMP      R7,R9
   \       0x46   0xD3E6             BCC.N    ??flashBlockProgram_1
    208              /** Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) **/
    209                HAL_FLASH_Lock();
   \       0x48   0x....'....        BL       HAL_FLASH_Lock
    210              return returnValue;
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    211          }
    212          
    213              
    214            /**
    215            * @brief  Check the active flash content with the last word CRC is valid
    216            * @param      _FLASH_START_ADDR    CRC sector starting address
    217            *             _NumOfPage           Number of sector for CRC check (   @Caution each page will contains two bytes of CRC and is accumulated                                             
    218            *                                                                        for example> page0 CRC= page0, if also has page1 CRC in the last two bytes of page1 will be from page0 to page1 )
    219            * @retval successful
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          uint8_t isFlashCRCValid(uint32_t _FLASH_START_ADDR, uint16_t _NumOfPage){               //pam tested
   \                     isFlashCRCValid: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
    222              unsigned char* _pageAddress = (unsigned char*) _FLASH_START_ADDR;
    223              uint16_t uwCRCValue = Calculate_CRC((uint16_t)((FLASH_PAGE_SIZE * _NumOfPage) - 2) , _pageAddress);   
   \        0x6   0x02C0             LSLS     R0,R0,#+11
   \        0x8   0x1E80             SUBS     R0,R0,#+2
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x....'....        BL       Calculate_CRC
   \       0x12   0x4605             MOV      R5,R0
    224              uint16_t FlashCRCValue = FlashRead((unsigned char*)_pageAddress, (uint16_t)((FLASH_PAGE_SIZE * NumOfPage) - 2));
    225              if(uwCRCValue == FlashCRCValue) 
   \       0x14   0xF240 0x71FE      MOVW     R1,#+2046
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       FlashRead
   \       0x1E   0x4285             CMP      R5,R0
   \       0x20   0xD101             BNE.N    ??isFlashCRCValid_0
    226                return(true);
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
    227              else
    228                return (false);
   \                     ??isFlashCRCValid_0: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    229          }
    230          
    231          
    232          /**
    233            * @brief  Copy page/s of flash memory to another sector
    234            * @param      drv_id_u8               The function caller module ID in case error occur within this function
    235            *             _FrompageAddress        The starting address of the source flash page/s
    236            *             _TopageAddress          The starting address of the sink flash page/s
    237            * @retval successful
    238            */
    239            //copy the whole page to another page only

   \                                 In section .text, align 2, keep-with-next
    240          uint8_t flashPageCopy(uint8_t drv_id_u8, uint32_t _FrompageAddress, uint32_t _TopageAddress)
    241          {
   \                     flashPageCopy: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4617             MOV      R7,R2
    242                /** Unlock the Flash to enable the flash control register access **/
    243              HAL_FLASH_Unlock();
   \        0xA   0x....'....        BL       HAL_FLASH_Unlock
    244              uint16_t indx = 0;
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0x....             LDR.N    R4,??DataTable8_2
    245              uint16_t currentDat;
    246              for(  ;  indx < (FLASH_PAGE_SIZE * NumOfPage) ; indx +=2)
    247              {
    248                currentDat = FlashRead((unsigned char*)_FrompageAddress, indx); 
   \                     ??flashPageCopy_0: (+1)
   \       0x12   0xB2B1             UXTH     R1,R6
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0x....'....        BL       FlashRead
   \       0x1A   0x4602             MOV      R2,R0
    249                if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, (_TopageAddress + indx), (uint64_t)currentDat) == HAL_OK) //write 16bit data
   \       0x1C   0x2300             MOVS     R3,#+0
   \       0x1E   0x19F1             ADDS     R1,R6,R7
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0x....'....        BL       HAL_FLASH_Program
   \       0x26   0xB918             CBNZ.N   R0,??flashPageCopy_1
    250                {
    251                  Address += 2;
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x1C80             ADDS     R0,R0,#+2
   \       0x2C   0x6020             STR      R0,[R4, #+0]
   \       0x2E   0xE008             B.N      ??flashPageCopy_2
    252                }
    253               else
    254                {
    255                  // Error occurred while writing data in Flash memory.                                                                 
    256                 setupSoftwareIRQ(drv_id_u8, MODULE_ERR_LOGHANDLE, 0xE4, 0x00, 0x00, NULL);     //report the error address 
   \                     ??flashPageCopy_1: (+1)
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x9101             STR      R1,[SP, #+4]
   \       0x34   0x9100             STR      R1,[SP, #+0]
   \       0x36   0x2300             MOVS     R3,#+0
   \       0x38   0x22E4             MOVS     R2,#+228
   \       0x3A   0x2109             MOVS     R1,#+9
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x....'....        BL       setupSoftwareIRQ
    257                }  
    258              }     
   \                     ??flashPageCopy_2: (+1)
   \       0x42   0x1CB6             ADDS     R6,R6,#+2
   \       0x44   0xF5B6 0x6F00      CMP      R6,#+2048
   \       0x48   0xDBE3             BLT.N    ??flashPageCopy_0
    259              /** Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) **/
    260              HAL_FLASH_Lock();
   \       0x4A   0x....'....        BL       HAL_FLASH_Lock
    261            return 0;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    262          }
    263          

   \                                 In section .bss, align 4
    264          uint32_t testdat = 0;
   \                     testdat:
   \        0x0                      DS8 4
    265          /**
    266            * @brief  Read data from flash
    267            * @param  pageAddress flash page starting address
    268            *         offsetByte  offset of the physical flash address (as the offset in byte [caution !!! this is absolute offset address in flash !!!])
    269            * @retval data (16bit)
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          uint16_t FlashRead(unsigned char* aDataBuf, uint16_t offsetByte)       //this read a word
    272          {
    273                return((((uint16_t)aDataBuf[offsetByte]) << 8) +  aDataBuf[offsetByte +1]);
   \                     FlashRead: (+1)
   \        0x0   0x5C42             LDRB     R2,[R0, R1]
   \        0x2   0x4408             ADD      R0,R0,R1
   \        0x4   0x7841             LDRB     R1,[R0, #+1]
   \        0x6   0xEB01 0x2002      ADD      R0,R1,R2, LSL #+8
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x4770             BX       LR               ;; return
    274          }
    275          
    276          /** ----------------------------------------- Flash internal ram storage system ----------------------------------------------------------------- **/
    277          
    278          /**
    279            * @brief  initialize the internal buffer and head, tail pointer
    280            * @param  None
    281            * @retval None
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          void FlashBufInit(void)
    284          {
   \                     FlashBufInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    285            for(uint8_t index = 0; index < FlashBufSize ; index++)
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....             LDR.N    R1,??DataTable8_3
   \        0x6   0xF64F 0x72FF      MOVW     R2,#+65535
   \        0xA   0x2300             MOVS     R3,#+0
    286            {
    287              flashBuf[index].offset = 0xffff;
   \                     ??FlashBufInit_0: (+1)
   \        0xC   0xF821 0x2020      STRH     R2,[R1, R0, LSL #+2]
    288              flashBuf[index].flashDat = 0;
   \       0x10   0xEB01 0x0480      ADD      R4,R1,R0, LSL #+2
    289            }  
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x2814             CMP      R0,#+20
   \       0x18   0x8063             STRH     R3,[R4, #+2]
   \       0x1A   0xDBF7             BLT.N    ??FlashBufInit_0
    290            Flash_BufHead = 0;
   \       0x1C   0x....             LDR.N    R0,??DataTable8_4
   \       0x1E   0x7003             STRB     R3,[R0, #+0]
    291            Flash_BufTail = 0;
   \       0x20   0x7043             STRB     R3,[R0, #+1]
    292          }
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    293          
    294          /**
    295            * @brief  Empty the setting data according to offset of the setting data
    296            * @param  _offset     offset of the setting data
    297            *         _returnBuf  data found 
    298            * @retval data found successfully = true/false, the data found will store in  _returnBuf
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          uint16_t FlashBufDeRegistered(uint16_t _offset, uint16_t* _returnBuf)                       //Got the ack from the receiver and de-registered the record 
    301          {
   \                     FlashBufDeRegistered: (+1)
   \        0x0   0xB520             PUSH     {R5,LR}
    302            for(uint8_t index = 0; index < FlashBufSize ; index++)
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x....             LDR.N    R3,??DataTable8_3
    303            {
    304               if(_offset == flashBuf[index].offset)                           //search the received FrameAckID in buffer
   \                     ??FlashBufDeRegistered_0: (+1)
   \        0x6   0xF833 0x5022      LDRH     R5,[R3, R2, LSL #+2]
   \        0xA   0x42A8             CMP      R0,R5
   \        0xC   0xD004             BEQ.N    ??FlashBufDeRegistered_1
   \        0xE   0x1C52             ADDS     R2,R2,#+1
   \       0x10   0x2A14             CMP      R2,#+20
   \       0x12   0xDBF8             BLT.N    ??FlashBufDeRegistered_0
    305               {  //clear all this record when found
    306                  flashBuf[index].offset = 0xffff;
    307                  *_returnBuf = flashBuf[index].flashDat;                       //return the found value 
    308                  flashBuf[index].flashDat = 0;                                //clear data
    309                  FlashFlushBuf();
    310                  return true;
    311               }
    312            }  
    313            return false;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD20             POP      {R5,PC}
   \                     ??FlashBufDeRegistered_1: (+1)
   \       0x18   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x1C   0xF823 0x0022      STRH     R0,[R3, R2, LSL #+2]
   \       0x20   0xEB03 0x0082      ADD      R0,R3,R2, LSL #+2
   \       0x24   0x8842             LDRH     R2,[R0, #+2]
   \       0x26   0x800A             STRH     R2,[R1, #+0]
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x8041             STRH     R1,[R0, #+2]
   \       0x2C   0x....'....        BL       FlashFlushBuf
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xBD20             POP      {R5,PC}          ;; return
    314          }
    315          
    316          /**
    317            * @brief  Flush the internal buffer and packed the leading or trailing record is/are empty
    318            * @param  None
    319            * @retval None
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          void FlashFlushBuf(void)                                                           
    322          { //push back all the trailing empty record, and move the tail back to the last trailing record
   \                     FlashFlushBuf: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....             LDR.N    R0,??DataTable8_4
   \        0x4   0x7843             LDRB     R3,[R0, #+1]
   \        0x6   0x7804             LDRB     R4,[R0, #+0]
   \        0x8   0x....             LDR.N    R2,??DataTable8_3
   \        0xA   0xF64F 0x71FF      MOVW     R1,#+65535
    323            while((Flash_BufHead != Flash_BufTail) && (flashBuf[Flash_BufTail].offset == 0xffff) )    
   \                     ??FlashFlushBuf_0: (+1)
   \        0xE   0xB2DE             UXTB     R6,R3
   \       0x10   0x42B4             CMP      R4,R6
   \       0x12   0xD00F             BEQ.N    ??FlashFlushBuf_1
   \       0x14   0xB2DD             UXTB     R5,R3
   \       0x16   0xF832 0x5025      LDRH     R5,[R2, R5, LSL #+2]
   \       0x1A   0x428D             CMP      R5,R1
   \       0x1C   0xD10A             BNE.N    ??FlashFlushBuf_1
    324            { //Move head to the closest in buffer
    325              if(Flash_BufTail != 0 ){
   \       0x1E   0xB2DD             UXTB     R5,R3
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xBF0C             ITE      EQ
   \       0x24   0x2313             MOVEQ    R3,#+19
   \       0x26   0x1E5B             SUBNE    R3,R3,#+1
    326                Flash_BufTail--;
    327              }
    328              else
    329              {
    330                Flash_BufTail = (FlashBufSize - 1);
   \       0x28   0xE7F1             B.N      ??FlashFlushBuf_0
    331              }
    332            } 
    333            //push back all the leading empty record, and move the head back to the first leading record
    334            while((Flash_BufHead != Flash_BufTail) && (flashBuf[Flash_BufHead].offset == 0xffff) )
    335            { //Move head to the closest in buffer
    336              if(++Flash_BufHead == FlashBufSize)  Flash_BufHead = 0;
   \                     ??FlashFlushBuf_2: (+1)
   \       0x2A   0x1C64             ADDS     R4,R4,#+1
   \       0x2C   0xB2E5             UXTB     R5,R4
   \       0x2E   0x2D14             CMP      R5,#+20
   \       0x30   0xBF08             IT       EQ
   \       0x32   0x2400             MOVEQ    R4,#+0
    337            }  
   \                     ??FlashFlushBuf_1: (+1)
   \       0x34   0xB2E5             UXTB     R5,R4
   \       0x36   0x42B5             CMP      R5,R6
   \       0x38   0xD003             BEQ.N    ??FlashFlushBuf_3
   \       0x3A   0xF832 0x5025      LDRH     R5,[R2, R5, LSL #+2]
   \       0x3E   0x428D             CMP      R5,R1
   \       0x40   0xD0F3             BEQ.N    ??FlashFlushBuf_2
    338          }
   \                     ??FlashFlushBuf_3: (+1)
   \       0x42   0x7004             STRB     R4,[R0, #+0]
   \       0x44   0x7043             STRB     R3,[R0, #+1]
   \       0x46   0xBD70             POP      {R4-R6,PC}       ;; return
    339          
    340          
    341          /**
    342            * @brief  store current data(16bit offset) into internal buffer
    343            * @param  _offset: ofset position of the 16bit setting data 
    344            * @warning [caution !!! not absolute offset address in flash !!! please follow the FlashOffsetIndex ]
    345            * @retval None
    346            */

   \                                 In section .text, align 2, keep-with-next
    347          uint8_t FlashDatSet(uint16_t _offset, uint16_t _flashDat)
    348          {
   \                     FlashDatSet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    349            uint16_t tmpryDat;
    350            if(!IsFlashBufFull())
   \        0x6   0x....'....        BL       IsFlashBufFull
   \        0xA   0xB9A8             CBNZ.N   R0,??FlashDatSet_0
    351            {
    352              FlashBufDeRegistered((_offset * 2), &tmpryDat); //find this offset has already got data, will be replace    
   \        0xC   0x0064             LSLS     R4,R4,#+1
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0xB2A0             UXTH     R0,R4
   \       0x12   0x....'....        BL       FlashBufDeRegistered
    353              if(++Flash_BufTail == FlashBufSize) {
   \       0x16   0x....             LDR.N    R0,??DataTable8_4
   \       0x18   0x7841             LDRB     R1,[R0, #+1]
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0xB2CA             UXTB     R2,R1
   \       0x1E   0x2A14             CMP      R2,#+20
   \       0x20   0xBF08             IT       EQ
   \       0x22   0x2100             MOVEQ    R1,#+0
    354                Flash_BufTail = 0;
   \       0x24   0x7041             STRB     R1,[R0, #+1]
    355              }  
    356              flashBuf[Flash_BufTail].offset = _offset * 2;               //store as 16bit effective offset as no odd address!!! 
   \       0x26   0x7840             LDRB     R0,[R0, #+1]
   \       0x28   0x....             LDR.N    R1,??DataTable8_3
   \       0x2A   0xF821 0x4020      STRH     R4,[R1, R0, LSL #+2]
    357              flashBuf[Flash_BufTail].flashDat = _flashDat;
   \       0x2E   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \       0x32   0x8045             STRH     R5,[R0, #+2]
    358              return true;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
    359            }
    360            return false;                         //if return also mean buffer full
   \                     ??FlashDatSet_0: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    361          }
    362          
    363          /**
    364            * @brief  Internal buffer is full
    365            * @param  None
    366            * @retval ture/false
    367            */

   \                                 In section .text, align 2, keep-with-next
    368          uint8_t IsFlashBufFull(void) 
    369          {
    370            int16_t result = (int16_t)Flash_BufHead - (int16_t)Flash_BufTail;
   \                     IsFlashBufFull: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable8_4
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0x7840             LDRB     R0,[R0, #+1]
   \        0x6   0x1A08             SUBS     R0,R1,R0
    371            if( (result == -(FlashBufSize-1)) || (result == 1)) 
   \        0x8   0xF110 0x0F13      CMN      R0,#+19
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2801             CMPNE    R0,#+1
   \       0x10   0xD101             BNE.N    ??IsFlashBufFull_0
    372            { 
    373              return (true);
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x4770             BX       LR
    374            }  
    375            return (false);
   \                     ??IsFlashBufFull_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR               ;; return
    376          }
    377          

   \                                 In section .text, align 4, keep-with-next
    378          uint8_t Reg2Ram(uint32_t _RegNum, uint16_t _Value)
    379          {
   \                     Reg2Ram: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    380            uint8_t stage = 0;
    381            bool bNoError = FALSE;
    382            uint16_t Durationms;
    383            int16_t FinalMecSpeedUnit;
    384            int16_t FinalTorque;
    385            switch((FlashOffsetIndex)_RegNum)
   \        0x2   0xB200             SXTH     R0,R0
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x1F80             SUBS     R0,R0,#+6
   \        0x8   0x281D             CMP      R0,#+29
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0xD83E             BHI.N    ??Reg2Ram_1
   \        0xE   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??Reg2Ram_0:
   \       0x12   0x0F 0x14          DC8      0xF,0x14,0x71,0x19

   \              0x71 0x19
   \       0x16   0x1E 0x23          DC8      0x1E,0x23,0x28,0x2D

   \              0x28 0x2D
   \       0x1A   0x32 0x71          DC8      0x32,0x71,0x37,0x71

   \              0x37 0x71
   \       0x1E   0x71 0x71          DC8      0x71,0x71,0x71,0x42

   \              0x71 0x42
   \       0x22   0x53 0x62          DC8      0x53,0x62,0x41,0x52

   \              0x41 0x52
   \       0x26   0x61 0x40          DC8      0x61,0x40,0x51,0x60

   \              0x51 0x60
   \       0x2A   0x3F 0x50          DC8      0x3F,0x50,0x5F,0x3E

   \              0x5F 0x3E
   \       0x2E   0x4F 0x5E          DC8      0x4F,0x5E
    386            {
    387              case Index_A_POLE_PAIR_NUM                :     //reg0  _1
    388                {
    389                  break;
    390                }
    391              case Index_A_RS                           :     //reg1  _ 
    392                {
    393                  break;
    394                }
    395              case Index_A_LS                           :     //reg2  _ 
    396                {
    397                  break;
    398                }
    399              case Index_A_NOMINAL_CURRENT              :     //reg3  _1
    400                {
    401                  break;
    402                }
    403              case Index_A_MAX_APPLICATION_SPEED_RPM    :     //reg4  _ 
    404                {
    405                  break;
    406                }
    407              case Index_A_MIN_APPLICATION_SPEED_RPM    :     //reg5  _ 
    408                {
    409                  break;
    410                }
    411              case Index_A_PLL_KP_GAIN                  :     //reg6  _1   
    412                { //MC_PROTOCOL_REG_PLL_KI,    
    413                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_PLL_KI, _Value); //tested working
   \                     ??Reg2Ram_2: (+1)
   \       0x30   0x....'....        BL       GetMCP
   \       0x34   0x4622             MOV      R2,R4
   \       0x36   0x2114             MOVS     R1,#+20
   \       0x38   0xE026             B.N      ??Reg2Ram_3
    414                  break;
    415                }
    416              case Index_A_PLL_KI_GAIN                  :     //reg7  _1   
    417                { //MC_PROTOCOL_REG_PLL_KP,  
    418                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_PLL_KP, _Value);
   \                     ??Reg2Ram_4: (+1)
   \       0x3A   0x....'....        BL       GetMCP
   \       0x3E   0x4622             MOV      R2,R4
   \       0x40   0x2115             MOVS     R1,#+21
   \       0x42   0xE021             B.N      ??Reg2Ram_3
    419                  break;
    420                }
    421              case Index_A_PWM_FREQUENCY                :     //reg8  _ 
    422                { 
    423                  break;
    424                }
    425              case Index_A_PID_TORQUE_KP_DEFAULT        :     //reg9  _1
    426                { //MC_PROTOCOL_REG_TORQUE_KP
    427                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_TORQUE_KP, _Value);
   \                     ??Reg2Ram_5: (+1)
   \       0x44   0x....'....        BL       GetMCP
   \       0x48   0x4622             MOV      R2,R4
   \       0x4A   0x2109             MOVS     R1,#+9
   \       0x4C   0xE01C             B.N      ??Reg2Ram_3
    428                  break;
    429                }
    430              case Index_A_PID_TORQUE_KI_DEFAULT        :     //reg10  _1
    431                { //MC_PROTOCOL_REG_TORQUE_KI
    432                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_TORQUE_KI, _Value);
   \                     ??Reg2Ram_6: (+1)
   \       0x4E   0x....'....        BL       GetMCP
   \       0x52   0x4622             MOV      R2,R4
   \       0x54   0x210A             MOVS     R1,#+10
   \       0x56   0xE017             B.N      ??Reg2Ram_3
    433                  break;
    434                }
    435              case Index_A_PID_FLUX_KP_DEFAULT          :     //reg11  _1
    436                { //MC_PROTOCOL_REG_FLUX_KP
    437                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_FLUX_KP, _Value);
   \                     ??Reg2Ram_7: (+1)
   \       0x58   0x....'....        BL       GetMCP
   \       0x5C   0x4622             MOV      R2,R4
   \       0x5E   0x210D             MOVS     R1,#+13
   \       0x60   0xE012             B.N      ??Reg2Ram_3
    438                  break;
    439                }
    440              case Index_A_PID_FLUX_KI_DEFAULT          :     //reg12  _1
    441                { //MC_PROTOCOL_REG_FLUX_KI
    442                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_FLUX_KI, _Value);
   \                     ??Reg2Ram_8: (+1)
   \       0x62   0x....'....        BL       GetMCP
   \       0x66   0x4622             MOV      R2,R4
   \       0x68   0x210E             MOVS     R1,#+14
   \       0x6A   0xE00D             B.N      ??Reg2Ram_3
    443                  break;
    444                }
    445              case Index_A_PID_SPEED_KP_DEFAULT         :     //reg13  _1
    446                { //MC_PROTOCOL_REG_SPEED_KP
    447                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_SPEED_KP, _Value);
   \                     ??Reg2Ram_9: (+1)
   \       0x6C   0x....'....        BL       GetMCP
   \       0x70   0x4622             MOV      R2,R4
   \       0x72   0x2105             MOVS     R1,#+5
   \       0x74   0xE008             B.N      ??Reg2Ram_3
    448                  break;
    449                }
    450              case Index_A_PID_SPEED_KI_DEFAULT         :     //reg14  _1
    451                { //MC_PROTOCOL_REG_SPEED_KI
    452                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_SPEED_KI, _Value);
   \                     ??Reg2Ram_10: (+1)
   \       0x76   0x....'....        BL       GetMCP
   \       0x7A   0x4622             MOV      R2,R4
   \       0x7C   0x2106             MOVS     R1,#+6
   \       0x7E   0xE003             B.N      ??Reg2Ram_3
    453                  break;
    454                }
    455              case Index_A_IQMAX                        :     //reg15  _1
    456                {
    457                  break;
    458                }
    459              case Index_A_DEFAULT_CONTROL_MODE         :     //reg16  _1 
    460                { //MC_PROTOCOL_REG_CONTROL_MODE
    461                  UI_SetReg(&(GetMCP()->_Super), MC_PROTOCOL_REG_CONTROL_MODE, _Value);
   \                     ??Reg2Ram_11: (+1)
   \       0x80   0x....'....        BL       GetMCP
   \       0x84   0x4622             MOV      R2,R4
   \       0x86   0x2103             MOVS     R1,#+3
   \                     ??Reg2Ram_3: (+1)
   \       0x88   0x....'....        BL       UI_SetReg
    462                  break;
   \                     ??Reg2Ram_1: (+1)
   \       0x8C   0xE032             B.N      ??Reg2Ram_12
    463                }
    464              case Index_A_OV_VOLTAGE_THRESHOLD_V       :     //reg17  _
    465                {
    466                  break;
    467                }        
    468              case Index_A_UD_VOLTAGE_THRESHOLD_V       :     //reg18  _
    469                {
    470                  break;
    471                }
    472              case Index_A_OV_TEMPERATURE_THRESHOLD_C   :     //reg19  _
    473                {
    474                  break;
    475                }        
    476              case Index_A_OV_TEMPERATURE_HYSTERESIS_C  :     //reg20  _
    477                {
    478                  break;
    479                }
    480                
    481              case Index_A_PHASE5_DURATION              :     //reg33  _1
    482                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    483                  stage++;
   \                     ??Reg2Ram_13: (+1)
   \       0x8E   0x2501             MOVS     R5,#+1
    484                }
    485              case Index_A_PHASE4_DURATION              :     //reg30  _1
    486                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    487                  stage++;
   \                     ??Reg2Ram_14: (+1)
   \       0x90   0x1C6D             ADDS     R5,R5,#+1
    488                } 
    489              case Index_A_PHASE3_DURATION              :     //reg21  _1
    490                { //MC_PROTOCOL_CODE_SET_REVUP_DATA      
    491                  stage++;  
   \                     ??Reg2Ram_15: (+1)
   \       0x92   0x1C6D             ADDS     R5,R5,#+1
    492                }
    493              case Index_A_PHASE2_DURATION              :     //reg24  _1
    494                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    495                  stage++;
   \                     ??Reg2Ram_16: (+1)
   \       0x94   0x1C6D             ADDS     R5,R5,#+1
    496                }
    497              case Index_A_PHASE1_DURATION              :     //reg27  _1
    498                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    499                  //read   ,rpm = (FinalMecSpeedUnit * _RPM) / SPEED_UNIT;
    500                  UI_GetRevupData(&(GetMCP()->_Super), stage, &Durationms, &FinalMecSpeedUnit, &FinalTorque);
   \                     ??Reg2Ram_17: (+1)
   \       0x96   0x....'....        BL       GetMCP
   \       0x9A   0x....'....        BL       ?Subroutine0
    501                  //write
    502                  bNoError = UI_SetRevupData( &(GetMCP()->_Super), stage, _Value, FinalMecSpeedUnit, FinalTorque );
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x9E   0x....'....        BL       GetMCP
   \       0xA2   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \       0xA6   0xF9BD 0x3006      LDRSH    R3,[SP, #+6]
   \       0xAA   0x9100             STR      R1,[SP, #+0]
   \       0xAC   0x4622             MOV      R2,R4
   \       0xAE   0xE01E             B.N      ??Reg2Ram_18
    503                  break;
    504                }
    505              
    506              case Index_A_PHASE5_FINAL_SPEED_UNIT      :     //reg34  _1
    507                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    508                  stage++;
   \                     ??Reg2Ram_19: (+1)
   \       0xB0   0x2501             MOVS     R5,#+1
    509                }  
    510              case Index_A_PHASE4_FINAL_SPEED_UNIT      :     //reg31  _1
    511                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    512                  stage++;
   \                     ??Reg2Ram_20: (+1)
   \       0xB2   0x1C6D             ADDS     R5,R5,#+1
    513                }
    514              case Index_A_PHASE3_FINAL_SPEED_UNIT      :     //reg28  _1
    515                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    516                  stage++;
   \                     ??Reg2Ram_21: (+1)
   \       0xB4   0x1C6D             ADDS     R5,R5,#+1
    517                }
    518              case Index_A_PHASE2_FINAL_SPEED_UNIT      :     //reg25  _1
    519                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    520                  stage++;
   \                     ??Reg2Ram_22: (+1)
   \       0xB6   0x1C6D             ADDS     R5,R5,#+1
    521                }  
    522              case Index_A_PHASE1_FINAL_SPEED_UNIT      :     //reg22  _1
    523                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    524                  //read   ,rpm = (FinalMecSpeedUnit * _RPM) / SPEED_UNIT;
    525                  UI_GetRevupData(&(GetMCP()->_Super), stage, &Durationms, &FinalMecSpeedUnit, &FinalTorque);
   \                     ??Reg2Ram_23: (+1)
   \       0xB8   0x....'....        BL       GetMCP
   \       0xBC   0x....'....        BL       ?Subroutine0
    526                  //write
    527                  bNoError = UI_SetRevupData( &(GetMCP()->_Super), stage, Durationms, _Value, FinalTorque );     
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xC0   0x....'....        BL       GetMCP
   \       0xC4   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \       0xC8   0x9100             STR      R1,[SP, #+0]
   \       0xCA   0xB223             SXTH     R3,R4
   \       0xCC   0xE00D             B.N      ??Reg2Ram_24
    528                  break;
    529                }
    530              
    531              case Index_A_PHASE5_FINAL_CURRENT         :     //reg35  _1
    532                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    533                  stage++;
   \                     ??Reg2Ram_25: (+1)
   \       0xCE   0x2501             MOVS     R5,#+1
    534                }
    535              case Index_A_PHASE4_FINAL_CURRENT         :     //reg32  _1
    536                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    537                  stage++;
   \                     ??Reg2Ram_26: (+1)
   \       0xD0   0x1C6D             ADDS     R5,R5,#+1
    538                }
    539              case Index_A_PHASE3_FINAL_CURRENT         :     //reg29  _1
    540                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    541                  stage++;
   \                     ??Reg2Ram_27: (+1)
   \       0xD2   0x1C6D             ADDS     R5,R5,#+1
    542                }
    543              case Index_A_PHASE2_FINAL_CURRENT         :     //reg23  _1
    544                {
    545                  stage++;
   \                     ??Reg2Ram_28: (+1)
   \       0xD4   0x1C6D             ADDS     R5,R5,#+1
    546                }
    547              case Index_A_PHASE1_FINAL_CURRENT         :     //reg26  _1
    548                { //MC_PROTOCOL_CODE_SET_REVUP_DATA
    549                  UI_GetRevupData(&(GetMCP()->_Super), stage, &Durationms, &FinalMecSpeedUnit, &FinalTorque);
   \                     ??Reg2Ram_29: (+1)
   \       0xD6   0x....'....        BL       GetMCP
   \       0xDA   0x....'....        BL       ?Subroutine0
    550                  //write
    551                  bNoError = UI_SetRevupData( &(GetMCP()->_Super), stage, Durationms, FinalMecSpeedUnit, _Value );     
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xDE   0x....'....        BL       GetMCP
   \       0xE2   0xB224             SXTH     R4,R4
   \       0xE4   0xF9BD 0x3006      LDRSH    R3,[SP, #+6]
   \       0xE8   0x9400             STR      R4,[SP, #+0]
   \                     ??Reg2Ram_24: (+1)
   \       0xEA   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \                     ??Reg2Ram_18: (+1)
   \       0xEE   0xB2E9             UXTB     R1,R5
   \       0xF0   0x....'....        BL       UI_SetRevupData
    552                  break;
    553                }
    554          
    555              case Index_A_TRANSITION_DURATION          :     //reg36  _1
    556                { 
    557                 // VirtualSpeedSensorM1.hTransitionSteps = (int16_t)((uint32_t) ((uint32_t)(A_PWM_FREQUENCY)/(REGULATION_EXECUTION_RATE)) * A_TRANSITION_DURATION/ 1000.0); // TF_REGULATION_RATE
    558                  //REMNG_ExecRamp( pREMNG[M1], StatorCurrent.q, A_TRANSITION_DURATION ); 
    559                  break;
    560                }
    561              // below are future configurable data    
    562              case Index_D_HALL_SENSORS_PLACEMENT       :     //_1
    563              case Index_D_HALL_PHASE_SHIFT             :     //_1
    564              case Index_D_M1_ENCODER_PPR               :     //_ 
    565          #if GAIN1 != 0   //pll or cord
    566              case Index_A_GAIN1                        :     //_ 
    567              case Index_A_GAIN2                        :     //_ 
    568          #else
    569              case Index_D_CORD_GAIN1                   :     //_ 
    570              case Index_D_CORD_GAIN2                   :     //_ 
    571              case Index_D_CORD_MAX_ACCEL_DPPP          :      //_1
    572                break;
    573          #endif //GAIN1   //pll or cord
    574          
    575          #ifdef _AB_MODULE_MC_STATEMACHINE_H_
    576              case Index_MIN_COMMANDABLE_SPEED:
    577                {
    578                  break;
    579                }
    580              case Index_MAX_COMMANDABLE_SPEED:
    581                {
    582                  break;
    583                }
    584              case Index_SPEED_UP_RAMP_RATE:
    585                {
    586                  break;
    587                }
    588              case Index_SPEED_DOWN_RAMP_RATE:
    589                {
    590                  break;
    591                }
    592              case Index_SPEED_CONSIDERED_STOPPED: 
    593                {
    594                  break;
    595                }
    596              case Index_MotSpinTimeOut: 
    597                {
    598                  break;
    599                }
    600              case Index_SpinPollPeriod: 
    601                {
    602                  break;
    603                }
    604              case Index_numOfStartRetry: 
    605                {
    606                  break;
    607                }
    608              case Index_StartRetryPeriod: 
    609                {
    610                  break;
    611                }
    612              case Index_StartPeriodInc: 
    613                {
    614                  break;
    615                }
    616              case Index_over_current_threshold: 
    617                {
    618                  break;
    619                }
    620              case Index_over_current_rpm_Reduce: 
    621                {
    622                  break;
    623                }
    624              case Index_OvCurrent_derate_period: 
    625                {
    626                  break;
    627                }
    628              case Index_over_power_threshold: 
    629                {
    630                  break;
    631                }
    632              case Index_over_power_rpm_Reduce: 
    633                {
    634                  break;
    635                }
    636              case Index_OvPower_derate_period:
    637                {
    638                  break;
    639                }
    640              case Index_over_temperature_threshold:
    641                {
    642                  break;
    643                }
    644              case Index_over_temperature_rpm_Reduce: 
    645                {
    646                  break;
    647                }
    648              case Index_OvTemp_derate_period: 
    649                {
    650                  break;
    651                }
    652          #endif //_MODULE_MC_STATEMACHINE_H_
    653            default:
    654              break;
    655            }
    656            return TRUE;
   \                     ??Reg2Ram_12: (+1)
   \       0xF4   0x2001             MOVS     R0,#+1
   \       0xF6   0xBD3E             POP      {R1-R5,PC}       ;; return
    657          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xA901             ADD      R1,SP,#+4
   \        0x2   0x9100             STR      R1,[SP, #+0]
   \        0x4   0xF10D 0x0306      ADD      R3,SP,#+6
   \        0x8   0xAA02             ADD      R2,SP,#+8
   \        0xA   0xB2E9             UXTB     R1,R5
   \        0xC   0x....'....        B.W      UI_GetRevupData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     EraseInitStruct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     Address

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     flashBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     Flash_BufHead

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FlashBufDeRegistered
         8   -> FlashFlushBuf
       8   FlashBufInit
      16   FlashDatSet
        16   -> FlashBufDeRegistered
        16   -> IsFlashBufFull
      16   FlashFlushBuf
       0   FlashRead
       0   IsFlashBufFull
      24   Reg2Ram
        24   -> GetMCP
        24   -> UI_GetRevupData
        24   -> UI_SetReg
        24   -> UI_SetRevupData
      40   flashBlockProgram
        40   -> HAL_FLASH_Lock
        40   -> HAL_FLASH_Program
        40   -> HAL_FLASH_Unlock
        40   -> setupSoftwareIRQ
      32   flashPageCopy
        32   -> FlashRead
        32   -> HAL_FLASH_Lock
        32   -> HAL_FLASH_Program
        32   -> HAL_FLASH_Unlock
        32   -> setupSoftwareIRQ
      32   flashPageErase
        32   -> HAL_FLASHEx_Erase
        32   -> HAL_FLASH_Lock
        32   -> HAL_FLASH_Unlock
        32   -> setupSoftwareIRQ
      48   flashPageUpdate
        48   -> Calculate_CRC
        48   -> FlashBufDeRegistered
        48   -> FlashRead
        48   -> HAL_FLASH_Lock
        48   -> HAL_FLASH_Program
        48   -> HAL_FLASH_Unlock
        48   -> setupSoftwareIRQ
      16   isFlashCRCValid
        16   -> Calculate_CRC
        16   -> FlashRead
       8   moduleFlash_u32
         8   -> FlashBufInit
         8   -> getProcessInfoIndex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
      16  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
       2  A_DEFAULT_CONTROL_MODE
       2  A_GAIN1
       2  A_GAIN2
       2  A_IQMAX
       2  A_LS
       2  A_MAX_APPLICATION_SPEED_RPM
       2  A_MIN_APPLICATION_SPEED_RPM
       2  A_NOMINAL_CURRENT
       2  A_OV_TEMPERATURE_HYSTERESIS_C
       2  A_OV_TEMPERATURE_THRESHOLD_C
       2  A_OV_VOLTAGE_THRESHOLD_V
       2  A_PHASE1_DURATION
       2  A_PHASE1_FINAL_CURRENT
       2  A_PHASE1_FINAL_SPEED_UNIT
       2  A_PHASE2_DURATION
       2  A_PHASE2_FINAL_CURRENT
       2  A_PHASE2_FINAL_SPEED_UNIT
       2  A_PHASE3_DURATION
       2  A_PHASE3_FINAL_CURRENT
       2  A_PHASE3_FINAL_SPEED_UNIT
       2  A_PHASE4_DURATION
       2  A_PHASE4_FINAL_CURRENT
       2  A_PHASE4_FINAL_SPEED_UNIT
       2  A_PHASE5_DURATION
       2  A_PHASE5_FINAL_CURRENT
       2  A_PHASE5_FINAL_SPEED_UNIT
       2  A_PID_FLUX_KI_DEFAULT
       2  A_PID_FLUX_KP_DEFAULT
       2  A_PID_SPEED_KI_DEFAULT
       2  A_PID_SPEED_KP_DEFAULT
       2  A_PID_TORQUE_KI_DEFAULT
       2  A_PID_TORQUE_KP_DEFAULT
       2  A_PLL_KI_GAIN
       2  A_PLL_KP_GAIN
       2  A_POLE_PAIR_NUM
       2  A_PWM_FREQUENCY
       2  A_RS
       2  A_TRANSITION_DURATION
       2  A_UD_VOLTAGE_THRESHOLD_V
       4  Address
       2  D_HALL_PHASE_SHIFT
       2  D_HALL_SENSORS_PLACEMENT
       2  D_M1_ENCODER_PPR
      12  EraseInitStruct
      52  FlashBufDeRegistered
      36  FlashBufInit
      60  FlashDatSet
      72  FlashFlushBuf
      14  FlashRead
       2  Flash_BufHead
          Flash_BufTail
      26  IsFlashBufFull
       1  MemoryProgramStatus
     248  Reg2Ram
      82  flashBlockProgram
      80  flashBuf
      84  flashPageCopy
      66  flashPageErase
     126  flashPageUpdate
      42  isFlashCRCValid
      46  moduleFlash_u32
       1  readData
       4  testdat

 
   104 bytes in section .bss
    84 bytes in section .rodata  (abs)
 1'014 bytes in section .text
 
 1'014 bytes of CODE  memory
     0 bytes of CONST memory (+ 84 bytes shared)
   104 bytes of DATA  memory

Errors: none
Warnings: 2
