###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:17
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\usart_frame_communication_protocol.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW65BF.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\usart_frame_communication_protocol.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\usart_frame_communication_protocol.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\usart_frame_communication_protocol.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\usart_frame_communication_protocol.c
      1          /**
      2            ******************************************************************************
      3            * @file    usart_frame_communication_protocol.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Frame Communication Protocol for USART component of the Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          
     23              /* ****************************************** */
     24              /* *** BEWARE! THIS CODE IS FOR STM32F3xx *** */
     25              /* ****************************************** */
     26          
     27          /* Includes ------------------------------------------------------------------*/
     28          #include "usart_frame_communication_protocol.h"
     29          #include "ui_irq_handler.h"
     30          
     31          /** @addtogroup MCSDK
     32            * @{
     33            */
     34          
     35          /**
     36           * @addtogroup MCUI
     37           * @{
     38           */
     39          
     40          /** @defgroup UFCP USART Frame Communication Protocol
     41            * @brief UFCP UFCP component of the Motor Control SDK
     42            *
     43            * Detailed documentation for the component.
     44            * @{
     45            */
     46          
     47          /* Private macros ------------------------------------------------------------*/
     48          #define UFCP_IRQ_FLAG_RX      0
     49          #define UFCP_IRQ_FLAG_TX      1
     50          #define UFCP_IRQ_FLAG_OVERRUN 2
     51          #define UFCP_IRQ_FLAG_TIMEOUT 3
     52          #define UFCP_IRQ_FLAG_ATR     4
     53          
     54          /* Private function prototypes -----------------------------------------------*/
     55          
     56          
     57          /* Private variables ---------------------------------------------------------*/

   \                                 In section .rodata, align 2, keep-with-next
     58          static const uint16_t UFCP_Usart_Timeout_none = 0;
   \                     UFCP_Usart_Timeout_none:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, align 2, keep-with-next
     59          static const uint16_t UFCP_Usart_Timeout_start = 1;
   \                     UFCP_Usart_Timeout_start:
   \        0x0   0x0001             DC16 1

   \                                 In section .rodata, align 2, keep-with-next
     60          static const uint16_t UFCP_Usart_Timeout_stop = 2;
   \                     UFCP_Usart_Timeout_stop:
   \        0x0   0x0002             DC16 2
     61          
     62          /* Functions ---------------------------------------------------------*/
     63          

   \                                 In section .text, align 2
     64          __weak void UFCP_Init( UFCP_Handle_t * pHandle )
     65          {
     66          
     67            /* Initialize generic component part */
     68            FCP_Init( & pHandle->_Super );
   \                     UFCP_Init: (+1)
   \        0x0   0x....'....        B.W      FCP_Init
     69          }
     70          
     71          /*
     72           *
     73           */

   \                                 In section .text, align 4
     74          __weak void * UFCP_RX_IRQ_Handler( UFCP_Handle_t * pHandle, unsigned short rx_data )
     75          {
   \                     UFCP_RX_IRQ_Handler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
     76            void * ret_val = (void *) & UFCP_Usart_Timeout_none;
     77            FCP_Handle_t * pBaseHandle = & pHandle->_Super;
     78            uint8_t error_code;
     79          
     80            if ( FCP_TRANSFER_IDLE != pBaseHandle->RxFrameState )
   \        0x4   0xF204 0x161B      ADDW     R6,R4,#+283
   \        0x8   0x4D25             LDR.N    R5,??UFCP_RX_IRQ_Handler_0
   \        0xA   0x7870             LDRB     R0,[R6, #+1]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD044             BEQ.N    ??UFCP_RX_IRQ_Handler_1
     81            {
     82              uint8_t rx_byte = (uint8_t) rx_data;
     83          
     84              switch ( pBaseHandle->RxFrameLevel )
   \       0x10   0x78B0             LDRB     R0,[R6, #+2]
   \       0x12   0x0002             MOVS     R2,R0
   \       0x14   0xF104 0x0799      ADD      R7,R4,#+153
   \       0x18   0xD002             BEQ.N    ??UFCP_RX_IRQ_Handler_2
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD007             BEQ.N    ??UFCP_RX_IRQ_Handler_3
   \       0x1E   0xE010             B.N      ??UFCP_RX_IRQ_Handler_4
     85              {
     86                case 0: // First Byte received --> The Code
     87                  pBaseHandle->RxFrame.Code = rx_byte;
   \                     ??UFCP_RX_IRQ_Handler_2: (+1)
   \       0x20   0x7039             STRB     R1,[R7, #+0]
     88                  /* Need to ask the caller to start our timeout... TODO: Is this really useful? */
     89                  ret_val = (void *) & UFCP_Usart_Timeout_start;
     90          
     91                  /* Start Rx Timeout */
     92                  pBaseHandle->RxTimeoutCountdown = pBaseHandle->RxTimeout;
   \       0x22   0x8A20             LDRH     R0,[R4, #+16]
   \       0x24   0x4D1F             LDR.N    R5,??UFCP_RX_IRQ_Handler_0+0x4
   \       0x26   0x8260             STRH     R0,[R4, #+18]
     93                  pBaseHandle->RxFrameLevel++;
   \       0x28   0x78B1             LDRB     R1,[R6, #+2]
   \       0x2A   0x1C49             ADDS     R1,R1,#+1
   \       0x2C   0xE007             B.N      ??UFCP_RX_IRQ_Handler_5
     94                  break;
     95          
     96                case 1: // Second Byte received --> Size of the payload
     97                  pBaseHandle->RxFrame.Size = rx_byte;
   \                     ??UFCP_RX_IRQ_Handler_3: (+1)
   \       0x2E   0x7079             STRB     R1,[R7, #+1]
     98                  pBaseHandle->RxFrameLevel++;
   \       0x30   0x78B0             LDRB     R0,[R6, #+2]
   \       0x32   0x1C40             ADDS     R0,R0,#+1
   \       0x34   0x70B0             STRB     R0,[R6, #+2]
     99                  if ( pBaseHandle->RxFrame.Size >= FCP_MAX_PAYLOAD_SIZE)
   \       0x36   0x7878             LDRB     R0,[R7, #+1]
   \       0x38   0x2880             CMP      R0,#+128
   \       0x3A   0xDB2E             BLT.N    ??UFCP_RX_IRQ_Handler_1
    100                  { /* Garbage data received decoded with a payload size that exceeds max*/
    101                    pBaseHandle->RxFrameLevel =0 ;
   \       0x3C   0x2100             MOVS     R1,#+0
   \                     ??UFCP_RX_IRQ_Handler_5: (+1)
   \       0x3E   0x70B1             STRB     R1,[R6, #+2]
   \       0x40   0xE02B             B.N      ??UFCP_RX_IRQ_Handler_1
    102                  }
    103                  break;
    104          
    105                default: // In the payload or the "CRC"
    106                  if ( pBaseHandle->RxFrameLevel < pBaseHandle->RxFrame.Size + FCP_HEADER_SIZE )
   \                     ??UFCP_RX_IRQ_Handler_4: (+1)
   \       0x42   0x787A             LDRB     R2,[R7, #+1]
   \       0x44   0x1C92             ADDS     R2,R2,#+2
   \       0x46   0x4290             CMP      R0,R2
   \       0x48   0xDA04             BGE.N    ??UFCP_RX_IRQ_Handler_6
    107                  {
    108                    // read byte is for the payload
    109                    pBaseHandle->RxFrame.Buffer[pBaseHandle->RxFrameLevel - FCP_HEADER_SIZE] = rx_byte;
   \       0x4A   0x5439             STRB     R1,[R7, R0]
    110                    pBaseHandle->RxFrameLevel++;
   \       0x4C   0x78B0             LDRB     R0,[R6, #+2]
   \       0x4E   0x1C40             ADDS     R0,R0,#+1
   \       0x50   0x70B0             STRB     R0,[R6, #+2]
   \       0x52   0xE022             B.N      ??UFCP_RX_IRQ_Handler_1
    111                  }
    112                  else
    113                  {
    114                    // read byte is for the "CRC"
    115                    pBaseHandle->RxFrame.FrameCRC = rx_byte;
   \                     ??UFCP_RX_IRQ_Handler_6: (+1)
   \       0x54   0x7031             STRB     R1,[R6, #+0]
    116          
    117                    /* Need to ask the caller to stop our timeout... TODO: Is this really useful? */
    118                    ret_val = (void *) & UFCP_Usart_Timeout_stop;
    119          
    120                    /* Stop Rx Timeout */
    121                    pBaseHandle->RxTimeoutCountdown = 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x8260             STRH     R0,[R4, #+18]
    122                    /* Disable the reception IRQ */
    123                    LL_USART_DisableIT_RXNE(pHandle->USARTx);
    124                    /* Indicate the reception is complete. */
    125                    pBaseHandle->RxFrameState = FCP_TRANSFER_IDLE;
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x60   0x4D11             LDR.N    R5,??UFCP_RX_IRQ_Handler_0+0x8
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0xF021 0x0120      BIC      R1,R1,#0x20
   \       0x68   0x6001             STR      R1,[R0, #+0]
   \       0x6A   0x7072             STRB     R2,[R6, #+1]
    126          
    127                    /* Check the Control Sum */
    128                    if ( FCP_CalcCRC( & pBaseHandle->RxFrame ) == pBaseHandle->RxFrame.FrameCRC )
   \       0x6C   0x4638             MOV      R0,R7
   \       0x6E   0x....'....        BL       FCP_CalcCRC
   \       0x72   0x7831             LDRB     R1,[R6, #+0]
   \       0x74   0x4288             CMP      R0,R1
   \       0x76   0xD107             BNE.N    ??UFCP_RX_IRQ_Handler_7
    129                    {
    130                      /* OK. the frame is considered correct. Let's forward to client. */
    131                      pBaseHandle->ClientFrameReceivedCallback( pBaseHandle->ClientEntity,
    132                                                                pBaseHandle->RxFrame.Code,
    133                                                                pBaseHandle->RxFrame.Buffer,
    134                                                                pBaseHandle->RxFrame.Size );
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x787B             LDRB     R3,[R7, #+1]
   \       0x7C   0x7839             LDRB     R1,[R7, #+0]
   \       0x7E   0xF104 0x029B      ADD      R2,R4,#+155
   \       0x82   0x68A4             LDR      R4,[R4, #+8]
   \       0x84   0x47A0             BLX      R4
   \       0x86   0xE008             B.N      ??UFCP_RX_IRQ_Handler_1
    135                    }
    136                    else
    137                    {
    138                      error_code = FCP_MSG_RX_BAD_CRC;
   \                     ??UFCP_RX_IRQ_Handler_7: (+1)
   \       0x88   0x200A             MOVS     R0,#+10
   \       0x8A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    139                      (void) UFCP_Send( pBaseHandle, FCP_CODE_NACK, & error_code, 1 );
   \       0x8E   0x2301             MOVS     R3,#+1
   \       0x90   0x466A             MOV      R2,SP
   \       0x92   0x21FF             MOVS     R1,#+255
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0x....'....        BL       UFCP_Send
    140                    }
    141                  }
    142              } /* end of switch ( pBaseHandle->RxFrameLevel ) */
    143            } /* end of if ( FCP_TRANSFER_IDLE != pBaseHandle->RxFrameState ) */
    144          
    145            return ret_val;
   \                     ??UFCP_RX_IRQ_Handler_1: (+1)
   \       0x9A   0x4628             MOV      R0,R5
   \       0x9C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \       0x9E   0xBF00             Nop
   \                     ??UFCP_RX_IRQ_Handler_0:
   \       0xA0   0x....'....        DC32     UFCP_Usart_Timeout_none
   \       0xA4   0x....'....        DC32     UFCP_Usart_Timeout_start
   \       0xA8   0x....'....        DC32     UFCP_Usart_Timeout_stop
    146          }
    147          
    148          /*
    149           *
    150           */

   \                                 In section .text, align 2
    151          __weak void UFCP_TX_IRQ_Handler( UFCP_Handle_t * pHandle )
    152          {
   \                     UFCP_TX_IRQ_Handler: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xF101 0x0296      ADD      R2,R1,#+150
   \        0x6   0x7850             LDRB     R0,[R2, #+1]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD100             BNE.N    ??UFCP_TX_IRQ_Handler_0
   \        0xC   0x4770             BX       LR
   \                     ??UFCP_TX_IRQ_Handler_0: (+1)
   \        0xE   0xB510             PUSH     {R4,LR}
    153            FCP_Handle_t * pBaseHandle = & pHandle->_Super;
    154          
    155            if ( FCP_TRANSFER_IDLE != pBaseHandle->TxFrameState )
    156            {
    157              uint16_t tx_data;
    158          
    159              switch ( pBaseHandle->TxFrameLevel )
   \       0x10   0x7890             LDRB     R0,[R2, #+2]
   \       0x12   0x0003             MOVS     R3,R0
   \       0x14   0xD002             BEQ.N    ??UFCP_TX_IRQ_Handler_1
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD002             BEQ.N    ??UFCP_TX_IRQ_Handler_2
   \       0x1A   0xE003             B.N      ??UFCP_TX_IRQ_Handler_3
    160              {
    161                case 0:
    162                  tx_data = (uint16_t) pBaseHandle->TxFrame.Code;
   \                     ??UFCP_TX_IRQ_Handler_1: (+1)
   \       0x1C   0x7D08             LDRB     R0,[R1, #+20]
    163                  break;
   \       0x1E   0xE009             B.N      ??UFCP_TX_IRQ_Handler_4
    164          
    165                case 1:
    166                  tx_data = (uint16_t) pBaseHandle->TxFrame.Size;
   \                     ??UFCP_TX_IRQ_Handler_2: (+1)
   \       0x20   0x7D48             LDRB     R0,[R1, #+21]
    167                  break;
   \       0x22   0xE007             B.N      ??UFCP_TX_IRQ_Handler_4
    168          
    169                default:
    170                  if ( pBaseHandle->TxFrameLevel < pBaseHandle->TxFrame.Size + FCP_HEADER_SIZE )
   \                     ??UFCP_TX_IRQ_Handler_3: (+1)
   \       0x24   0x7D4B             LDRB     R3,[R1, #+21]
   \       0x26   0x1C9B             ADDS     R3,R3,#+2
   \       0x28   0x4298             CMP      R0,R3
   \       0x2A   0xBFBA             ITTE     LT
   \       0x2C   0xF101 0x0414      ADDLT    R4,R1,#+20
   \       0x30   0x5C20             LDRBLT   R0,[R4, R0]
   \       0x32   0x7810             LDRBGE   R0,[R2, #+0]
    171                  {
    172                    tx_data = (uint16_t) pBaseHandle->TxFrame.Buffer[ pBaseHandle->TxFrameLevel - FCP_HEADER_SIZE ];
    173                  }
    174                  else
    175                  {
    176                    tx_data = (uint16_t) pBaseHandle->TxFrame.FrameCRC;
    177                  }
    178              } /* end of switch ( pBaseHandle->TxFrameLevel ) */
    179          
    180              /* Send the data byte */
    181              LL_USART_TransmitData8(pHandle->USARTx, tx_data);
   \                     ??UFCP_TX_IRQ_Handler_4: (+1)
   \       0x34   0xF8D1 0x3120      LDR      R3,[R1, #+288]
   \       0x38   0x8518             STRH     R0,[R3, #+40]
    182          
    183              if ( pBaseHandle->TxFrameLevel < pBaseHandle->TxFrame.Size + FCP_HEADER_SIZE )
   \       0x3A   0x7D4B             LDRB     R3,[R1, #+21]
   \       0x3C   0x7890             LDRB     R0,[R2, #+2]
   \       0x3E   0x1C9B             ADDS     R3,R3,#+2
   \       0x40   0x4298             CMP      R0,R3
   \       0x42   0xDA02             BGE.N    ??UFCP_TX_IRQ_Handler_5
    184              {
    185                pBaseHandle->TxFrameLevel++;
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x7090             STRB     R0,[R2, #+2]
   \       0x48   0xBD10             POP      {R4,PC}
    186              }
    187              else
    188              {
    189                LL_USART_DisableIT_TXE(pHandle->USARTx);
   \                     ??UFCP_TX_IRQ_Handler_5: (+1)
   \       0x4A   0xF8D1 0x0120      LDR      R0,[R1, #+288]
   \       0x4E   0x6803             LDR      R3,[R0, #+0]
   \       0x50   0xF023 0x0380      BIC      R3,R3,#0x80
   \       0x54   0x6003             STR      R3,[R0, #+0]
    190                pBaseHandle->TxFrameState = FCP_TRANSFER_IDLE;
   \       0x56   0x2400             MOVS     R4,#+0
   \       0x58   0x7054             STRB     R4,[R2, #+1]
    191          
    192                pBaseHandle->ClientFrameSentCallback( pBaseHandle->ClientEntity );
   \       0x5A   0x6808             LDR      R0,[R1, #+0]
   \       0x5C   0x6849             LDR      R1,[R1, #+4]
   \       0x5E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x62   0x4708             BX       R1
    193              }
    194          
    195            } /* end of if ( FCP_TRANSFER_IDLE != pBaseHandle->TxFrameState ) */
    196          }
    197          
    198          /*
    199           *
    200           */

   \                                 In section .text, align 2
    201          __weak void UFCP_OVR_IRQ_Handler( UFCP_Handle_t * pHandle )
    202          {
   \                     UFCP_OVR_IRQ_Handler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    203            FCP_Handle_t * pBaseHandle = & pHandle->_Super;
    204            uint8_t error_code;
    205          
    206            error_code = UFCP_MSG_OVERRUN;
   \        0x2   0x2108             MOVS     R1,#+8
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
    207            (void) UFCP_Send( pBaseHandle, FCP_CODE_NACK, & error_code, 1 );
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x21FF             MOVS     R1,#+255
   \        0xE   0x....'....        BL       UFCP_Send
    208          
    209          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    210          
    211          /*
    212           *
    213           */

   \                                 In section .text, align 2
    214          __weak void UFCP_TIMEOUT_IRQ_Handler( UFCP_Handle_t * pHandle )
    215          {
   \                     UFCP_TIMEOUT_IRQ_Handler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    216            FCP_Handle_t * pBaseHandle = & pHandle->_Super;
    217            uint8_t error_code;
    218          
    219            error_code = FCP_MSG_RX_TIMEOUT;
   \        0x2   0x2109             MOVS     R1,#+9
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
    220            (void) UFCP_Send( pBaseHandle, FCP_CODE_NACK, & error_code, 1 );
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x466A             MOV      R2,SP
   \        0xC   0x21FF             MOVS     R1,#+255
   \        0xE   0x....'....        BL       UFCP_Send
    221          
    222          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
    223          

   \                                 In section .text, align 2
    224          __weak uint8_t UFCP_Receive( FCP_Handle_t * pHandle )
    225          {
    226            uint8_t ret_val;
    227          
    228            if ( FCP_TRANSFER_IDLE == pHandle->RxFrameState )
   \                     UFCP_Receive: (+1)
   \        0x0   0xF500 0x718E      ADD      R1,R0,#+284
   \        0x4   0x7808             LDRB     R0,[R1, #+0]
   \        0x6   0xB950             CBNZ.N   R0,??UFCP_Receive_0
    229            {
    230              UFCP_Handle_t * pActualHandle = (UFCP_Handle_t *) pHandle;
    231          
    232              pHandle->RxFrameLevel = 0;
    233              pHandle->RxFrameState = FCP_TRANSFER_ONGOING;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x7008             STRB     R0,[R1, #+0]
   \        0xC   0x2200             MOVS     R2,#+0
    234          
    235              LL_USART_EnableIT_RXNE(pActualHandle->USARTx);
   \        0xE   0x6848             LDR      R0,[R1, #+4]
   \       0x10   0x704A             STRB     R2,[R1, #+1]
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x18   0x6001             STR      R1,[R0, #+0]
    236              ret_val = FCP_STATUS_WAITING_TRANSFER;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x4770             BX       LR
    237            }
    238            else
    239            {
    240              ret_val = FCP_STATUS_TRANSFER_ONGOING;
   \                     ??UFCP_Receive_0: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
    241            }
    242          
    243            return ret_val;
   \       0x20   0x4770             BX       LR               ;; return
    244          }
    245          

   \                                 In section .text, align 2
    246          __weak uint8_t UFCP_Send( FCP_Handle_t * pHandle, uint8_t code, uint8_t *buffer, uint8_t size)
    247          {
   \                     UFCP_Send: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    248            uint8_t ret_val;
    249          
    250            if ( FCP_TRANSFER_IDLE == pHandle->TxFrameState )
   \        0x4   0xF104 0x0596      ADD      R5,R4,#+150
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   \        0xA   0xB9F0             CBNZ.N   R0,??UFCP_Send_0
    251            {
    252              UFCP_Handle_t * pActualHandle = (UFCP_Handle_t *) pHandle;
    253              uint8_t *dest = pHandle->TxFrame.Buffer;
   \        0xC   0xF104 0x0016      ADD      R0,R4,#+22
    254          
    255              pHandle->TxFrame.Code = code;
   \       0x10   0x7521             STRB     R1,[R4, #+20]
    256              pHandle->TxFrame.Size = size;
   \       0x12   0x7563             STRB     R3,[R4, #+21]
   \       0x14   0xE003             B.N      ??UFCP_Send_1
    257              while ( size-- ) *dest++ = *buffer++;
   \                     ??UFCP_Send_2: (+1)
   \       0x16   0xF812 0x1B01      LDRB     R1,[R2], #+1
   \       0x1A   0xF800 0x1B01      STRB     R1,[R0], #+1
   \                     ??UFCP_Send_1: (+1)
   \       0x1E   0x4619             MOV      R1,R3
   \       0x20   0x1E4B             SUBS     R3,R1,#+1
   \       0x22   0xB2C9             UXTB     R1,R1
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD1F6             BNE.N    ??UFCP_Send_2
    258              pHandle->TxFrame.FrameCRC = FCP_CalcCRC( & pHandle->TxFrame );
   \       0x28   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x2C   0x....'....        BL       FCP_CalcCRC
   \       0x30   0x7028             STRB     R0,[R5, #+0]
    259          
    260              pHandle->TxFrameLevel = 0;
   \       0x32   0x2100             MOVS     R1,#+0
    261              pHandle->TxFrameState = FCP_TRANSFER_ONGOING;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0x7068             STRB     R0,[R5, #+1]
   \       0x38   0x70A9             STRB     R1,[R5, #+2]
    262          
    263              LL_USART_EnableIT_TXE(pActualHandle->USARTx);
   \       0x3A   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x3E   0x6801             LDR      R1,[R0, #+0]
   \       0x40   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0x44   0x6001             STR      R1,[R0, #+0]
    264              ret_val = FCP_STATUS_WAITING_TRANSFER;
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}
    265            }
    266            else
    267            {
    268              ret_val = FCP_STATUS_TRANSFER_ONGOING;
   \                     ??UFCP_Send_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
    269            }
    270          
    271            return ret_val;
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    272          }
    273          

   \                                 In section .text, align 2
    274          __weak void UFCP_AbortReceive( FCP_Handle_t * pHandle )
    275          {
    276            pHandle->RxFrameState = FCP_TRANSFER_IDLE;
   \                     UFCP_AbortReceive: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0xF880 0x111C      STRB     R1,[R0, #+284]
    277          }
   \        0x6   0x4770             BX       LR               ;; return
    278          
    279          
    280          /**
    281            * @}
    282            */
    283          
    284          /**
    285            * @}
    286            */
    287          
    288          /**
    289            * @}
    290            */
    291          
    292          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   UFCP_AbortReceive
       0   UFCP_Init
         0   -> FCP_Init
       8   UFCP_OVR_IRQ_Handler
         8   -> UFCP_Send
      24   UFCP_RX_IRQ_Handler
        24   -- Indirect call
        24   -> FCP_CalcCRC
        24   -> UFCP_Send
       0   UFCP_Receive
      16   UFCP_Send
        16   -> FCP_CalcCRC
       8   UFCP_TIMEOUT_IRQ_Handler
         8   -> UFCP_Send
       8   UFCP_TX_IRQ_Handler
         0   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  UFCP_AbortReceive
       4  UFCP_Init
      20  UFCP_OVR_IRQ_Handler
     172  UFCP_RX_IRQ_Handler
      34  UFCP_Receive
      78  UFCP_Send
      20  UFCP_TIMEOUT_IRQ_Handler
     100  UFCP_TX_IRQ_Handler
       2  UFCP_Usart_Timeout_none
       2  UFCP_Usart_Timeout_start
       2  UFCP_Usart_Timeout_stop

 
   6 bytes in section .rodata
 436 bytes in section .text
 
 0 bytes of CODE  memory (+ 436 bytes shared)
 6 bytes of CONST memory

Errors: none
Warnings: none
