###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:45
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\mc_api.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EWE5C9.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\mc_api.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\mc_api.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\mc_api.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\mc_api.c
      1          /**
      2            ******************************************************************************
      3            * @file    mc_api.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file implements the high level interface of the Motor Control SDK.
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under Ultimate Liberty license
     13            * SLA0044, the "License"; You may not use this file except in compliance with
     14            * the License. You may obtain a copy of the License at:
     15            *                             www.st.com/SLA0044
     16            *
     17            ******************************************************************************
     18            */
     19            
     20          #include "mc_interface.h"
     21          #include "mc_api.h"
     22          #include "mc_config.h"
     23          
     24          /** @addtogroup MCSDK
     25            * @{
     26            */
     27          
     28          /** @defgroup MCIAPI Motor Control API
     29            *
     30            * @brief High level Programming Interface of the Motor Control SDK
     31            *
     32            *  This interface allows for performing basic operations on the motor(s) driven by an
     33            * Motor Control SDK based application. With it, motors can be started and stopped, speed or
     34            * torque ramps can be programmed and executed and information on the state of the motors can
     35            * be retrieved, among others.
     36            *
     37            *  This interface consists in functions that target a specific motor, indicated in their name. 
     38            * These functions aims at being the main interface used by an Application to control motors.
     39            *
     40            *  The current Motor Control API can cope with up to 2 motors.  
     41            * @{
     42            */
     43          
     44          extern MCI_Handle_t * pMCI[NBR_OF_MOTORS];
     45          
     46          /**
     47            * @brief  Initiates the start-up procedure for Motor 1
     48            * 
     49            * If the state machine of Motor 1 is in #IDLE state, the command is immediately
     50            * executed. Otherwise the command is discarded. The Application can check the
     51            * return value to know whether the command was executed or discarded.
     52            *
     53            * One of the following commands must be executed before calling MC_StartMotor1():
     54            *
     55            * - MC_ProgramSpeedRampMotor1()
     56            * - MC_ProgramTorqueRampMotor1()
     57            * - MC_SetCurrentReferenceMotor1()
     58            *
     59            * Failing to do so results in an unpredictable behaviour.
     60            *
     61            * @note The MC_StartMotor1() command only triggers the start-up procedure: 
     62            * It moves Motor 1's state machine from the #IDLE to the #IDLE_START state and then 
     63            * returns. It is not blocking the application until the motor is indeed running. 
     64            * To know if it is running, the application can query Motor 1's state machine and 
     65            * check if it has reached the #RUN state. See MC_GetSTMStateMotor1() for more details.
     66            *
     67            * @retval returns true if the command is successfully executed, false otherwise.
     68            */

   \                                 In section .text, align 4
     69          __weak bool MC_StartMotor1(void)
     70          {
     71          	return MCI_StartMotor( pMCI[M1] );
   \                     MC_StartMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_StartMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_StartMotor
   \                     ??MC_StartMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
     72          }
     73          
     74          /**
     75            * @brief  Initiates the stop procedure for Motor 1.
     76            *
     77            *  If the state machine is in #RUN or #START states the command is immediately
     78            * executed. Otherwise, the command is discarded. The Application can check the
     79            * return value to know whether the command was executed or discarded.
     80            *  
     81            * @note The MCI_StopMotor1() command only triggers the stop motor procedure 
     82            * moving Motor 1's state machine to #ANY_STOP and then returns. It is not 
     83            * blocking the application until the motor is indeed stopped. To know if it has
     84            * stopped, the application can query Motor 1's state machine ans check if the 
     85            * #IDLE state has been reached back.
     86            *
     87            * @retval returns true if the command is successfully executed, false otherwise.
     88            */

   \                                 In section .text, align 4
     89          __weak bool MC_StopMotor1(void)
     90          {
     91          	return MCI_StopMotor( pMCI[M1] );
   \                     MC_StopMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_StopMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_StopMotor
   \                     ??MC_StopMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
     92          }
     93          
     94          /**
     95            * @brief Programs a speed ramp for Motor 1 for later or immediate execution.
     96            *
     97            *  A speed ramp is a linear change from the current speed reference to the @p hFinalSpeed 
     98            * target speed in the given @p hDurationms time. 
     99            *
    100            *  Invoking the MC_ProgramSpeedRampMotor1() function programs a new speed ramp
    101            * with the provided parameters. The programmed ramp is executed immediately if
    102            * Motor 1's state machine is in the #START_RUN or #RUN states. Otherwise, the 
    103            * ramp is buffered and will be executed when the state machine reaches any of 
    104            * the aforementioned state.
    105            *
    106            *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
    107            * to know whether the last command was executed immediately or not.
    108            *
    109            * Only one command can be buffered at any given time. If another ramp - whether a
    110            * speed or a torque one - or if another buffered command is programmed before the 
    111            * current one has completed, the latter replaces the former.
    112            *
    113            * @note A ramp cannot reverse the rotation direction if the Application is using 
    114            * sensorless motor control techniques. If the sign of the hFinalSpeed parameter 
    115            * differs from that of the current speed, the ramp will not complete and a Speed 
    116            * Feedback error (#MC_SPEED_FDBK) will occur when the rotation speed is about to 
    117            * reach 0 rpm.    
    118            * 
    119            * @param  hFinalSpeed Mechanical rotor speed reference at the end of the ramp.
    120            *                     Expressed in the unit defined by #SPEED_UNIT.
    121            * @param  hDurationms Duration of the ramp expressed in milliseconds. It
    122            *         is possible to set 0 to perform an instantaneous change in the speed
    123            *         value.
    124            */

   \                                 In section .text, align 4
    125          __weak void MC_ProgramSpeedRampMotor1( int16_t hFinalSpeed, uint16_t hDurationms )
    126          {
   \                     MC_ProgramSpeedRampMotor1: (+1)
   \        0x0   0x460A             MOV      R2,R1
    127          	MCI_ExecSpeedRamp( pMCI[M1], hFinalSpeed, hDurationms );
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0x4801             LDR.N    R0,??MC_ProgramSpeedRampMotor1_0
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x....'....        B.W      MCI_ExecSpeedRamp
   \                     ??MC_ProgramSpeedRampMotor1_0:
   \        0xC   0x....'....        DC32     pMCI
    128          }
    129          
    130          /**
    131            * @brief Programs a torque ramp for Motor 1 for later or immediate execution.
    132            *
    133            *  A torque ramp is a linear change from the current torque reference to the @p hFinalTorque 
    134            * target torque reference in the given @p hDurationms time. 
    135            *
    136            *  Invoking the MC_ProgramTorqueRampMotor1() function programs a new torque ramp
    137            * with the provided parameters. The programmed ramp is executed immediately if
    138            * Motor 1's state machine is in the #START_RUN or #RUN states. Otherwise, the 
    139            * ramp is buffered and will be executed when the state machine reaches any of 
    140            * the aforementioned state.
    141            *
    142            *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
    143            * to know whether the last command was executed immediately or not.
    144            *
    145            * Only one command can be buffered at any given time. If another ramp - whether a
    146            * torque or a speed one - or if another buffered command is programmed before the 
    147            * current one has completed, the latter replaces the former.
    148            *
    149            * @note A ramp cannot reverse the rotation direction if the Application is using 
    150            * sensorless motor control techniques. If the sign of the hFinalTorque parameter 
    151            * differs from that of the current torque, the ramp will not complete and a Speed 
    152            * Feedback error (#MC_SPEED_FDBK) will occur when the rotation speed is about to 
    153            * reach 0 rpm.    
    154            * 
    155            * @param  hFinalTorque Mechanical motor torque reference at the end of the ramp.
    156            *         This value represents actually the Iq current expressed in digit.
    157            * @param  hDurationms Duration of the ramp expressed in milliseconds. It
    158            *         is possible to set 0 to perform an instantaneous change in the torque
    159            *         value.
    160            */

   \                                 In section .text, align 4
    161          __weak void MC_ProgramTorqueRampMotor1( int16_t hFinalTorque, uint16_t hDurationms )
    162          {
   \                     MC_ProgramTorqueRampMotor1: (+1)
   \        0x0   0x460A             MOV      R2,R1
    163          	MCI_ExecTorqueRamp( pMCI[M1], hFinalTorque, hDurationms );
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0x4801             LDR.N    R0,??MC_ProgramTorqueRampMotor1_0
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x....'....        B.W      MCI_ExecTorqueRamp
   \                     ??MC_ProgramTorqueRampMotor1_0:
   \        0xC   0x....'....        DC32     pMCI
    164          }
    165          
    166          /**
    167            * @brief Programs the current reference to Motor 1 for later or immediate execution.
    168            *
    169            *  The current reference to consider is made of the Id and Iq current components. 
    170            *
    171            *  Invoking the MC_SetCurrentReferenceMotor1() function programs a current reference
    172            * with the provided parameters. The programmed reference is executed immediately if
    173            * Motor 1's state machine is in the #START_RUN or #RUN states. Otherwise, the 
    174            * command is buffered and will be executed when the state machine reaches any of 
    175            * the aforementioned state.
    176            *
    177            *  The Application can check the status of the command with the MC_GetCommandStateMotor1()
    178            * to know whether the last command was executed immediately or not.
    179            *
    180            * Only one command can be buffered at any given time. If another buffered command is 
    181            * programmed before the current one has completed, the latter replaces the former.
    182            *
    183            * @param  Iqdref current reference in the Direct-Quadratic reference frame. Expressed 
    184            *         in the qd_t format.
    185            */

   \                                 In section .text, align 4
    186          __weak void MC_SetCurrentReferenceMotor1( qd_t Iqdref )
    187          {
   \                     MC_SetCurrentReferenceMotor1: (+1)
   \        0x0   0x4601             MOV      R1,R0
    188          	MCI_SetCurrentReferences( pMCI[M1], Iqdref );
   \        0x2   0x4802             LDR.N    R0,??MC_SetCurrentReferenceMotor1_0
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x....'....        B.W      MCI_SetCurrentReferences
   \        0xA   0xBF00             Nop
   \                     ??MC_SetCurrentReferenceMotor1_0:
   \        0xC   0x....'....        DC32     pMCI
    189          }
    190          
    191          /**
    192            * @brief  Returns the status of the last buffered command for Motor 1.
    193            * The status can be one of the following values:
    194            * - #MCI_BUFFER_EMPTY: no buffered command is currently programmed.
    195            * - #MCI_COMMAND_NOT_ALREADY_EXECUTED: A command has been buffered but the conditions for its
    196            *   execution have not occurred yet. The command is still in the buffer, pending execution.
    197            * - #MCI_COMMAND_EXECUTED_SUCCESFULLY: the last buffered command has been executed successfully. 
    198            *   In this case calling this function reset the command state to #BC_BUFFER_EMPTY.
    199            * - #MCI_COMMAND_EXECUTED_UNSUCCESFULLY: the buffered command has been executed unsuccessfully. 
    200            *   In this case calling this function reset the command state to #BC_BUFFER_EMPTY.
    201            */

   \                                 In section .text, align 4
    202          __weak MCI_CommandState_t  MC_GetCommandStateMotor1( void)
    203          {
    204          	return MCI_IsCommandAcknowledged( pMCI[M1] );
   \                     MC_GetCommandStateMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetCommandStateMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_IsCommandAcknowledged
   \                     ??MC_GetCommandStateMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    205          }
    206          
    207          /** 
    208           * @brief Stops the execution of the on-going speed ramp for Motor 1, if any.
    209           *
    210           *  If a speed ramp is currently being executed, it is immediately stopped, the rotation
    211           * speed of Motor 1 is maintained to its current value and true is returned. If no speed 
    212           * ramp is on-going, nothing is done and false is returned.
    213           */

   \                                 In section .text, align 4
    214          __weak bool MC_StopSpeedRampMotor1(void)
    215          {
    216          	return MCI_StopSpeedRamp( pMCI[M1] );
   \                     MC_StopSpeedRampMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_StopSpeedRampMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_StopSpeedRamp
   \                     ??MC_StopSpeedRampMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    217          }
    218          
    219          /** 
    220           * @brief Stops the execution of the on-going ramp for Motor 1, if any.
    221           *
    222           *  If a ramp is currently being executed, it is immediately stopped, the torque or the speed
    223           *  of Motor 1 is maintained to its current value.
    224           */

   \                                 In section .text, align 4
    225          __weak void MC_StopRampMotor1(void)
    226          {
    227            MCI_StopRamp( pMCI[M1] );
   \                     MC_StopRampMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_StopRampMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_StopRamp
   \                     ??MC_StopRampMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    228          }
    229          
    230          /**
    231           * @brief Returns true if the last ramp submited for Motor 1 has completed, false otherwise 
    232           */

   \                                 In section .text, align 4
    233          __weak bool MC_HasRampCompletedMotor1(void)
    234          {
    235          	return MCI_RampCompleted( pMCI[M1] );
   \                     MC_HasRampCompletedMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_HasRampCompletedMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_RampCompleted
   \                     ??MC_HasRampCompletedMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    236          }
    237          
    238          /**
    239           *  @brief Returns the current mechanical rotor speed reference set for Motor 1, expressed in the unit defined by #SPEED_UNIT 
    240           */

   \                                 In section .text, align 4
    241          __weak int16_t MC_GetMecSpeedReferenceMotor1(void)
    242          {
    243          	return MCI_GetMecSpeedRefUnit( pMCI[M1] );
   \                     MC_GetMecSpeedReferenceMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetMecSpeedReferenceMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetMecSpeedRefUnit
   \                     ??MC_GetMecSpeedReferenceMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    244          }
    245          
    246          /**
    247           * @brief Returns the last computed average mechanical rotor speed for Motor 1, expressed in the unit defined by #SPEED_UNIT
    248           */

   \                                 In section .text, align 4
    249          __weak int16_t MC_GetMecSpeedAverageMotor1(void)
    250          {
    251          	return MCI_GetAvrgMecSpeedUnit( pMCI[M1] );
   \                     MC_GetMecSpeedAverageMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetMecSpeedAverageMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetAvrgMecSpeedUnit
   \                     ??MC_GetMecSpeedAverageMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    252          }
    253          
    254          /**
    255           * @brief Returns the final speed of the last ramp programmed for Motor 1 if this ramp was a speed ramp, 0 otherwise.
    256           */

   \                                 In section .text, align 4
    257          __weak int16_t MC_GetLastRampFinalSpeedMotor1(void)
    258          {
    259          	return MCI_GetLastRampFinalSpeed( pMCI[M1] );
   \                     MC_GetLastRampFinalSpeedMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetLastRampFinalSpeedMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetLastRampFinalSpeed
   \                     ??MC_GetLastRampFinalSpeedMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    260          }
    261          
    262          /**
    263           * @brief Returns the Control Mode used for Motor 1 (either Speed or Torque)
    264           */

   \                                 In section .text, align 4
    265          __weak STC_Modality_t MC_GetControlModeMotor1(void)
    266          {
    267          	return MCI_GetControlMode( pMCI[M1] );
   \                     MC_GetControlModeMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetControlModeMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetControlMode
   \                     ??MC_GetControlModeMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    268          }
    269          
    270          /**
    271           * @brief Returns the rotation direction imposed by the last command on Motor 1 
    272           *
    273           * The last command is either MC_ProgramSpeedRampMotor1(), MC_ProgramTorqueRampMotor1() or
    274           * MC_SetCurrentReferenceMotor1(). 
    275           *
    276           * The function returns -1 if the sign of the final speed, the final torque or the Iq current 
    277           * reference component of the last command is negative. Otherwise, 1 is returned. 
    278           *   
    279           * @note if no such command has ever been submitted, 1 is returned as well.  
    280           */

   \                                 In section .text, align 4
    281          __weak int16_t MC_GetImposedDirectionMotor1(void)
    282          {
    283          	return MCI_GetImposedMotorDirection( pMCI[M1] );
   \                     MC_GetImposedDirectionMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetImposedDirectionMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetImposedMotorDirection
   \                     ??MC_GetImposedDirectionMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    284          }
    285          
    286          /** 
    287           * @brief Returns true if the speed sensor used for Motor 1 is reliable, false otherwise 
    288           */

   \                                 In section .text, align 4
    289          __weak bool MC_GetSpeedSensorReliabilityMotor1(void)
    290          {
    291          	return MCI_GetSpdSensorReliability( pMCI[M1] );
   \                     MC_GetSpeedSensorReliabilityMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetSpeedSensorReliabilityMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetSpdSensorReliability
   \                     ??MC_GetSpeedSensorReliabilityMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    292          }
    293          
    294          /** 
    295           * @brief returns the amplitude of the phase current injected in Motor 1
    296           *
    297           * The returned amplitude (0-to-peak) is expressed in s16A unit. To convert it to amperes, use the following formula:
    298           *
    299           * @f[
    300           * I_{Amps} = \frac{ I_{s16A} \times V_{dd}}{ 65536 \times R_{shunt} \times A_{op} }
    301           * @f]
    302           *
    303           */

   \                                 In section .text, align 4
    304          __weak int16_t MC_GetPhaseCurrentAmplitudeMotor1(void)
    305          {
    306          	return MCI_GetPhaseCurrentAmplitude( pMCI[M1] );
   \                     MC_GetPhaseCurrentAmplitudeMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetPhaseCurrentAmplitudeMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetPhaseCurrentAmplitude
   \                     ??MC_GetPhaseCurrentAmplitudeMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    307          }
    308          
    309          /**
    310           * @brief returns the amplitude of the phase voltage applied to Motor 1 
    311           *
    312           * The returned amplitude (0-to-peak) is expressed in s16V unit. To convert it to volts, use the following formula:
    313           *
    314           * @f[
    315           * U_{Volts} = \frac{ U_{s16V} \times V_{bus}}{ \sqrt{3} \times 32768  }
    316           * @f]
    317           *
    318           */

   \                                 In section .text, align 4
    319          __weak int16_t MC_GetPhaseVoltageAmplitudeMotor1(void)
    320          {
    321          	return MCI_GetPhaseVoltageAmplitude( pMCI[M1] );
   \                     MC_GetPhaseVoltageAmplitudeMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetPhaseVoltageAmplitudeMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetPhaseVoltageAmplitude
   \                     ??MC_GetPhaseVoltageAmplitudeMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    322          }
    323          
    324          /**
    325           * @brief returns Ia and Ib current values for Motor 1 in ab_t format
    326           */

   \                                 In section .text, align 4
    327          __weak ab_t MC_GetIabMotor1(void)
    328          {
   \                     MC_GetIabMotor1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4903             LDR.N    R1,??MC_GetIabMotor1_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x....'....        BL       MCI_GetIab
   \        0xA   0x9000             STR      R0,[SP, #+0]
    329          	return MCI_GetIab( pMCI[M1] );
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   \        0xE   0xBF00             Nop
   \                     ??MC_GetIabMotor1_0:
   \       0x10   0x....'....        DC32     pMCI
    330          }
    331          
    332          /**
    333           * @brief returns Ialpha and Ibeta current values for Motor 1 in alphabeta_t format
    334           */

   \                                 In section .text, align 4
    335          __weak alphabeta_t MC_GetIalphabetaMotor1(void)
    336          {
   \                     MC_GetIalphabetaMotor1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4903             LDR.N    R1,??MC_GetIalphabetaMotor1_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x....'....        BL       MCI_GetIalphabeta
   \        0xA   0x9000             STR      R0,[SP, #+0]
    337          	return MCI_GetIalphabeta( pMCI[M1] );
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   \        0xE   0xBF00             Nop
   \                     ??MC_GetIalphabetaMotor1_0:
   \       0x10   0x....'....        DC32     pMCI
    338          }
    339          
    340          /**
    341           * @brief returns Iq and Id current values for Motor 1 in qd_t format 
    342           */

   \                                 In section .text, align 4
    343          __weak qd_t MC_GetIqdMotor1(void)
    344          {
   \                     MC_GetIqdMotor1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4903             LDR.N    R1,??MC_GetIqdMotor1_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x....'....        BL       MCI_GetIqd
   \        0xA   0x9000             STR      R0,[SP, #+0]
    345          	return MCI_GetIqd( pMCI[M1] );
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   \        0xE   0xBF00             Nop
   \                     ??MC_GetIqdMotor1_0:
   \       0x10   0x....'....        DC32     pMCI
    346          }
    347          
    348          /**
    349           * @brief returns Iq and Id reference current values for Motor 1 in qd_t format
    350           */

   \                                 In section .text, align 4
    351          __weak qd_t MC_GetIqdrefMotor1(void)
    352          {
   \                     MC_GetIqdrefMotor1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4903             LDR.N    R1,??MC_GetIqdrefMotor1_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x....'....        BL       MCI_GetIqdref
   \        0xA   0x9000             STR      R0,[SP, #+0]
    353          	return MCI_GetIqdref( pMCI[M1] );
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   \        0xE   0xBF00             Nop
   \                     ??MC_GetIqdrefMotor1_0:
   \       0x10   0x....'....        DC32     pMCI
    354          }
    355          
    356          /**
    357           * @brief returns Vq and Vd voltage values for Motor 1 in qd_t format
    358           */

   \                                 In section .text, align 4
    359          __weak qd_t MC_GetVqdMotor1(void)
    360          {
   \                     MC_GetVqdMotor1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4903             LDR.N    R1,??MC_GetVqdMotor1_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x....'....        BL       MCI_GetVqd
   \        0xA   0x9000             STR      R0,[SP, #+0]
    361          	return MCI_GetVqd( pMCI[M1] );
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   \        0xE   0xBF00             Nop
   \                     ??MC_GetVqdMotor1_0:
   \       0x10   0x....'....        DC32     pMCI
    362          }
    363          
    364          /**
    365           * @brief returns Valpha and Vbeta voltage values for Motor 1 in alphabeta_t format 
    366           */

   \                                 In section .text, align 4
    367          __weak alphabeta_t MC_GetValphabetaMotor1(void)
    368          {
   \                     MC_GetValphabetaMotor1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4903             LDR.N    R1,??MC_GetValphabetaMotor1_0
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x....'....        BL       MCI_GetValphabeta
   \        0xA   0x9000             STR      R0,[SP, #+0]
    369          	return MCI_GetValphabeta( pMCI[M1] );
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   \        0xE   0xBF00             Nop
   \                     ??MC_GetValphabetaMotor1_0:
   \       0x10   0x....'....        DC32     pMCI
    370          }
    371          
    372          /**
    373           * @brief returns the electrical angle of the rotor of Motor 1, in DDP format 
    374           */

   \                                 In section .text, align 4
    375          __weak int16_t MC_GetElAngledppMotor1(void)
    376          {
    377          	return MCI_GetElAngledpp( pMCI[M1] );
   \                     MC_GetElAngledppMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetElAngledppMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetElAngledpp
   \                     ??MC_GetElAngledppMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    378          }
    379          
    380          /**
    381           * @brief returns the electrical torque reference for Motor 1 
    382           */

   \                                 In section .text, align 4
    383          __weak int16_t MC_GetTerefMotor1(void)
    384          {
    385          	return MCI_GetTeref( pMCI[M1] );
   \                     MC_GetTerefMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetTerefMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetTeref
   \                     ??MC_GetTerefMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    386          }
    387          
    388          /**
    389           * @brief Sets Id reference value for Motor 2 
    390           *
    391           * When the current reference drive is internal (the FOCVars_t.bDriveInput field is set to #INTERNAL), 
    392           * Idref is normally managed by the FOC_CalcCurrRef() function. Neverthless, this function allows to 
    393           * force a change in Idref value. 
    394           * 
    395           * Calling this function has no effect when either flux weakening region is entered or MTPA is enabled.
    396           */

   \                                 In section .text, align 4
    397          __weak void MC_SetIdrefMotor1( int16_t hNewIdref )
    398          {
   \                     MC_SetIdrefMotor1: (+1)
   \        0x0   0x4601             MOV      R1,R0
    399          	MCI_SetIdref( pMCI[M1], hNewIdref );
   \        0x2   0x4802             LDR.N    R0,??MC_SetIdrefMotor1_0
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x....'....        B.W      MCI_SetIdref
   \        0xA   0xBF00             Nop
   \                     ??MC_SetIdrefMotor1_0:
   \        0xC   0x....'....        DC32     pMCI
    400          }
    401          
    402          /**
    403           * @brief re-initializes Iq and Id references to their default values for Motor 1
    404           *
    405           * The default values for the Iq and Id references are comming from the Speed 
    406           * or the Torque controller depending on the control mode. 
    407           *
    408           * @see   SpeednTorqCtrl for more details.
    409           */

   \                                 In section .text, align 4
    410          __weak void MC_Clear_IqdrefMotor1(void)
    411          {
    412          	MCI_Clear_Iqdref( pMCI[M1] );
   \                     MC_Clear_IqdrefMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_Clear_IqdrefMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_Clear_Iqdref
   \                     ??MC_Clear_IqdrefMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    413          }
    414          
    415          /**
    416           * @brief Acknowledge a Motor Control fault that occured on Motor 1
    417           *
    418           *  This function informs Motor 1's state machine that the Application has taken
    419           * the error condition that occured into account. If no error condition exists when
    420           * the function is called, nothing is done and false is returned. Otherwise, true is
    421           * returned. 
    422           */

   \                                 In section .text, align 4
    423          __weak bool MC_AcknowledgeFaultMotor1( void )
    424          {
    425          	return MCI_FaultAcknowledged( pMCI[M1] );
   \                     MC_AcknowledgeFaultMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_AcknowledgeFaultMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_FaultAcknowledged
   \                     ??MC_AcknowledgeFaultMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    426          }
    427          
    428          /**
    429           * @brief Returns a bitfiled showing "new" faults that occured on Motor 1
    430           *
    431           * This function returns a 16 bit fields containing the Motor Control faults 
    432           * that have occurred on Motor 1 since its state machine moved to the #FAULT_NOW state.
    433           *
    434           * See \link Fault_generation_error_codes Motor Control Faults\endlink for a list of 
    435           * of all possible faults codes.
    436           */

   \                                 In section .text, align 4
    437          __weak uint16_t MC_GetOccurredFaultsMotor1(void)
    438          {
    439          	return MCI_GetOccurredFaults( pMCI[M1] );
   \                     MC_GetOccurredFaultsMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetOccurredFaultsMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetOccurredFaults
   \                     ??MC_GetOccurredFaultsMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    440          }
    441          
    442          /**
    443           * @brief returns a bitfield showing all current faults on Motor 1 
    444           *
    445           * This function returns a 16 bit fields containing the Motor Control faults 
    446           * that are currently active.
    447           *
    448           * See \link Fault_generation_error_codes Motor Control Faults\endlink for a list of 
    449           * of all possible faults codes.
    450           */

   \                                 In section .text, align 4
    451          __weak uint16_t MC_GetCurrentFaultsMotor1(void)
    452          {
    453          	return MCI_GetCurrentFaults( pMCI[M1] );
   \                     MC_GetCurrentFaultsMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetCurrentFaultsMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetCurrentFaults
   \                     ??MC_GetCurrentFaultsMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    454          }
    455          
    456          /**
    457           * @brief returns the current state of Motor 1 state machine
    458           */

   \                                 In section .text, align 4
    459          __weak State_t  MC_GetSTMStateMotor1(void)
    460          {
    461          	return MCI_GetSTMState( pMCI[M1] );
   \                     MC_GetSTMStateMotor1: (+1)
   \        0x0   0x4801             LDR.N    R0,??MC_GetSTMStateMotor1_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....'....        B.W      MCI_GetSTMState
   \                     ??MC_GetSTMStateMotor1_0:
   \        0x8   0x....'....        DC32     pMCI
    462          }
    463          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MC_AcknowledgeFaultMotor1
         0   -> MCI_FaultAcknowledged
       0   MC_Clear_IqdrefMotor1
         0   -> MCI_Clear_Iqdref
       0   MC_GetCommandStateMotor1
         0   -> MCI_IsCommandAcknowledged
       0   MC_GetControlModeMotor1
         0   -> MCI_GetControlMode
       0   MC_GetCurrentFaultsMotor1
         0   -> MCI_GetCurrentFaults
       0   MC_GetElAngledppMotor1
         0   -> MCI_GetElAngledpp
       8   MC_GetIabMotor1
         8   -> MCI_GetIab
       8   MC_GetIalphabetaMotor1
         8   -> MCI_GetIalphabeta
       0   MC_GetImposedDirectionMotor1
         0   -> MCI_GetImposedMotorDirection
       8   MC_GetIqdMotor1
         8   -> MCI_GetIqd
       8   MC_GetIqdrefMotor1
         8   -> MCI_GetIqdref
       0   MC_GetLastRampFinalSpeedMotor1
         0   -> MCI_GetLastRampFinalSpeed
       0   MC_GetMecSpeedAverageMotor1
         0   -> MCI_GetAvrgMecSpeedUnit
       0   MC_GetMecSpeedReferenceMotor1
         0   -> MCI_GetMecSpeedRefUnit
       0   MC_GetOccurredFaultsMotor1
         0   -> MCI_GetOccurredFaults
       0   MC_GetPhaseCurrentAmplitudeMotor1
         0   -> MCI_GetPhaseCurrentAmplitude
       0   MC_GetPhaseVoltageAmplitudeMotor1
         0   -> MCI_GetPhaseVoltageAmplitude
       0   MC_GetSTMStateMotor1
         0   -> MCI_GetSTMState
       0   MC_GetSpeedSensorReliabilityMotor1
         0   -> MCI_GetSpdSensorReliability
       0   MC_GetTerefMotor1
         0   -> MCI_GetTeref
       8   MC_GetValphabetaMotor1
         8   -> MCI_GetValphabeta
       8   MC_GetVqdMotor1
         8   -> MCI_GetVqd
       0   MC_HasRampCompletedMotor1
         0   -> MCI_RampCompleted
       0   MC_ProgramSpeedRampMotor1
         0   -> MCI_ExecSpeedRamp
       0   MC_ProgramTorqueRampMotor1
         0   -> MCI_ExecTorqueRamp
       0   MC_SetCurrentReferenceMotor1
         0   -> MCI_SetCurrentReferences
       0   MC_SetIdrefMotor1
         0   -> MCI_SetIdref
       0   MC_StartMotor1
         0   -> MCI_StartMotor
       0   MC_StopMotor1
         0   -> MCI_StopMotor
       0   MC_StopRampMotor1
         0   -> MCI_StopRamp
       0   MC_StopSpeedRampMotor1
         0   -> MCI_StopSpeedRamp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  MC_AcknowledgeFaultMotor1
      12  MC_Clear_IqdrefMotor1
      12  MC_GetCommandStateMotor1
      12  MC_GetControlModeMotor1
      12  MC_GetCurrentFaultsMotor1
      12  MC_GetElAngledppMotor1
      20  MC_GetIabMotor1
      20  MC_GetIalphabetaMotor1
      12  MC_GetImposedDirectionMotor1
      20  MC_GetIqdMotor1
      20  MC_GetIqdrefMotor1
      12  MC_GetLastRampFinalSpeedMotor1
      12  MC_GetMecSpeedAverageMotor1
      12  MC_GetMecSpeedReferenceMotor1
      12  MC_GetOccurredFaultsMotor1
      12  MC_GetPhaseCurrentAmplitudeMotor1
      12  MC_GetPhaseVoltageAmplitudeMotor1
      12  MC_GetSTMStateMotor1
      12  MC_GetSpeedSensorReliabilityMotor1
      12  MC_GetTerefMotor1
      20  MC_GetValphabetaMotor1
      20  MC_GetVqdMotor1
      12  MC_HasRampCompletedMotor1
      16  MC_ProgramSpeedRampMotor1
      16  MC_ProgramTorqueRampMotor1
      16  MC_SetCurrentReferenceMotor1
      16  MC_SetIdrefMotor1
      12  MC_StartMotor1
      12  MC_StopMotor1
      12  MC_StopRampMotor1
      12  MC_StopSpeedRampMotor1

 
 436 bytes in section .text
 
 0 bytes of CODE memory (+ 436 bytes shared)

Errors: none
Warnings: none
