###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:34
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_AutoAck.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW4EEA.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_AutoAck.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\module_AutoAck.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\module_AutoAck.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_AutoAck.c
      1          /**
      2            ********************************************************************************************************************************
      3            * @file    module_AutoAck.c 
      4            * @author  Pamela Lee
      5            * @version V1.0
      6            * @date    21-OCT-2020
      7            * @brief   Main driver module for Auto Acknowledgement of Universal procotol.
      8            * @details 
      9            ********************************************************************************************************************************
     10            */
     11          
     12          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     13          #include "module_AutoAck.h"

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     14          #include "mc_api.h"
     15          #include "ab_module_Mc_StateMachine.h"
     16          
     17          //#include "driver_usart2.h"
     18          
     19          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     20          /* Auto acknowledgement handle declaration */
     21          extern ProcessInfo processInfoTable[];
     22          

   \                                 In section .bss, align 8
     23          AutoAck_Control *autoAckControl;
     24          Module_StateMachineControl*  module_StateMachineControl_AutoAck;
     25          
     26          #define AckTimeOut 5000                        //Ack waiting timeout period
     27          uint64_t Ack_WaitTime; 
     28          
     29          uint8_t FrameAckID = 0;
     30          bool ValidRx = false;
   \                     ValidRx:
   \        0x0                      DS8 1
     31          #define shifter 1
     32          
     33          //******************************************************************************************
     34          static void LinkLost(void);
     35          
     36          //*****************************************************************************************
     37          typedef  struct 
     38          {
     39              uint8_t       AckCmd;
     40              uint16_t      E_AckCmd;
     41              uint8_t       ProcessAckID;                                          //Ack process ID
     42              uint8_t       FrameAckID;                                            //
     43          }UniversalAckInfo;
     44          #define AckBufSize 16
     45          UniversalAckInfo buf[AckBufSize];//= { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0} };
     46          uint8_t Uni_AckHead = 0;
   \                     Uni_AckHead:
   \        0x1                      DS8 1
     47          uint8_t Uni_AckTail = 0;
   \                     Uni_AckTail:
   \        0x2                      DS8 1
     48          uint8_t Uni_NextFrameID = 0;                    //Unversal Ack frame ID (which the number continue count up and roll over) 
   \                     Uni_NextFrameID:
   \        0x3                      DS8 1
   \        0x4                      DS8 4
   \                     Ack_WaitTime:
   \        0x8                      DS8 8
   \                     autoAckControl:
   \       0x10                      DS8 4
   \                     module_StateMachineControl_AutoAck:
   \       0x14                      DS8 4

   \                                 In section .bss, align 1
   \                     FrameAckID:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
   \                     buf:
   \        0x0                      DS8 96
     49          //********************************************************************************************************************************************************
     50          
     51          enum {
     52            INIT_AUTOACK_MODULE,
     53            RUN_AUTOACK_MODULE,
     54            // additional states to be added here as necessary.
     55            IRQ_AUTOACK_MODULE = DEFAULT_IRQ_STATE,
     56            KILL_AUTOACK_MODULE = KILL_APP
     57          };
     58          
     59          
     60          
     61          

   \                                 In section .text, align 2, keep-with-next
     62          uint8_t moduleAutoAck_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     moduleAutoAck_u32: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
     63            uint8_t return_state_u8 = INIT_AUTOACK_MODULE;
     64            switch (next_state_u8) {
   \        0x6   0xF241 0x3888      MOVW     R8,#+5000
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x....             LDR.N    R7,??DataTable6
   \        0xE   0x....             LDR.N    R6,??DataTable6_1
   \       0x10   0x2416             MOVS     R4,#+22
   \       0x12   0xF04F 0x0AFF      MOV      R10,#+255
   \       0x16   0xB122             CBZ.N    R2,??moduleAutoAck_u32_0
   \       0x18   0x2A01             CMP      R2,#+1
   \       0x1A   0xD01E             BEQ.N    ??moduleAutoAck_u32_1
   \       0x1C   0x2AFF             CMP      R2,#+255
   \       0x1E   0xD054             BEQ.N    ??moduleAutoAck_u32_2
   \       0x20   0xE05C             B.N      ??moduleAutoAck_u32_3
     65              case INIT_AUTOACK_MODULE: {
     66                // Initialize Auto Ackledgement ring 
     67                UniversalAckInit();
   \                     ??moduleAutoAck_u32_0: (+1)
   \       0x22   0x....'....        BL       UniversalAckInit
     68                
     69                AutoAckStructMem_u32 = StructMem_CreateInstance(MODULE_AUTOACK, sizeof(AutoAck_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory
   \       0x26   0x9500             STR      R5,[SP, #+0]
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x2202             MOVS     R2,#+2
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x2008             MOVS     R0,#+8
   \       0x30   0x....'....        BL       StructMem_CreateInstance
     70                autoAckControl = (AutoAck_Control*)(*AutoAckStructMem_u32).p_ramBuf_u8;
     71                (*autoAckControl).RxAckFrameID = 0;
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x6138             STR      R0,[R7, #+16]
   \       0x38   0x7005             STRB     R5,[R0, #+0]
     72                ValidRx = false;
   \       0x3A   0x703D             STRB     R5,[R7, #+0]
     73                Ack_WaitTime = getSysCount() + AckTimeOut;                        //store time tick value  
   \       0x3C   0x....'....        BL       getSysCount
   \       0x40   0x....'....        BL       ?Subroutine0
     74                uint8_t Mc_StateMachineindex  = getProcessInfoIndex(MODULE_MC_STATEMACHINE);              //return Process index from processInfo array with the MC_statemachine module
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x44   0x2002             MOVS     R0,#+2
   \       0x46   0x....'....        BL       getProcessInfoIndex
     75                module_StateMachineControl_AutoAck = (Module_StateMachineControl*) ((*(processInfoTable[Mc_StateMachineindex].Sched_ModuleData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x4A   0xFB14 0xF400      SMULBB   R4,R4,R0
   \       0x4E   0x1931             ADDS     R1,R6,R4
   \       0x50   0xF8D1 0x000B      LDR      R0,[R1, #+11]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0x6178             STR      R0,[R7, #+20]
     76                
     77                return_state_u8 = RUN_AUTOACK_MODULE;
   \       0x58   0xE034             B.N      ??moduleAutoAck_u32_4
     78                break;
     79              }
     80              case RUN_AUTOACK_MODULE: {                                                  //        
     81                if (getSysCount() >= Ack_WaitTime) 
   \                     ??moduleAutoAck_u32_1: (+1)
   \       0x5A   0x....'....        BL       getSysCount
   \       0x5E   0xE9D7 0x2302      LDRD     R2,R3,[R7, #+8]
   \       0x62   0x4299             CMP      R1,R3
   \       0x64   0xD328             BCC.N    ??moduleAutoAck_u32_5
   \       0x66   0xD801             BHI.N    ??moduleAutoAck_u32_6
   \       0x68   0x4290             CMP      R0,R2
   \       0x6A   0xD325             BCC.N    ??moduleAutoAck_u32_5
     82                {
     83                  AckFlushBuf();                                             //make sure the AckHead is pointing to the first Leading record
   \                     ??moduleAutoAck_u32_6: (+1)
   \       0x6C   0x....'....        BL       AckFlushBuf
     84                  if(Uni_AckHead != Uni_AckTail)                                  //if buffer is not empty
   \       0x70   0x7878             LDRB     R0,[R7, #+1]
   \       0x72   0x78B9             LDRB     R1,[R7, #+2]
   \       0x74   0x4288             CMP      R0,R1
   \       0x76   0xD015             BEQ.N    ??moduleAutoAck_u32_7
     85                  { // timeout the AckHead record
     86                    /**prepare software interrupt for the Ack timeout module**/
     87                    setupSoftwareIRQ(drv_id_u8, buf[Uni_AckHead].ProcessAckID, 0xE0, buf[Uni_AckHead].FrameAckID, buf[Uni_AckHead].AckCmd, NULL);
   \       0x78   0x2406             MOVS     R4,#+6
   \       0x7A   0xFB14 0xF000      SMULBB   R0,R4,R0
   \       0x7E   0x....             LDR.N    R6,??DataTable6_2
   \       0x80   0x9501             STR      R5,[SP, #+4]
   \       0x82   0x1831             ADDS     R1,R6,R0
   \       0x84   0x1D72             ADDS     R2,R6,#+5
   \       0x86   0x780B             LDRB     R3,[R1, #+0]
   \       0x88   0x9300             STR      R3,[SP, #+0]
   \       0x8A   0x5C13             LDRB     R3,[R2, R0]
   \       0x8C   0x7909             LDRB     R1,[R1, #+4]
   \       0x8E   0x22E0             MOVS     R2,#+224
   \       0x90   0x4648             MOV      R0,R9
   \       0x92   0x....'....        BL       setupSoftwareIRQ
     88                    
     89                    
     90           //         uint8_t SoftwareIrqBitPtIndx = buf[Uni_AckHead].ProcessAckID / 64;     // get the interrupt pointer group of software IRQ point index
     91           //         uint64_t IrqBitTempry = shifter;
     92           //         SoftwareIrqBitPt[SoftwareIrqBitPtIndx] = IrqBitTempry << (buf[Uni_AckHead].ProcessAckID - (SoftwareIrqBitPtIndx * 64)); //set software interrupt trigger bit
     93           //         IrqTrigProcessID = drv_id_u8;                                     /**set current module ID to let the IRQ response module know who triggered this interrupt  **/          
     94                   
     95           //         //find out the ISR module and enter all the parameter for it to respone the interrupt, "this ACK time out error"
     96           //         uint8_t table_index_u8 = getProcessInfoIndex(buf[Uni_AckHead].ProcessAckID);  
     97           //         if (table_index_u8 != INDEX_NOT_FOUND) {
     98           //           processInfoTable[table_index_u8].Sched_DrvData.irqType_u8 = 0xE0;                           /**inform the interrupt response module this is an error message**/
     99           //           processInfoTable[table_index_u8].Sched_DrvData.irqDat_u8 = buf[Uni_AckHead].FrameAckID;
    100           
    101           //           processInfoTable[table_index_u8].Sched_DrvData.irqDat1_len_u8 = buf[Uni_AckHead].AckCmd;     /**The time out command it send **/       
    102           //           if(buf[Uni_AckHead].FrameAckID == 0x20)
    103           //           {
    104           //           processInfoTable[table_index_u8].Sched_DrvData.irqDatPt_u8 = NULL;                          /**usually set as NULL pointer for no extended data (else irqDat_u8 = data length of data pointer)**/
    105           //           }
    106           //         }
    107                    AckDeRegistered(buf[Uni_AckHead].FrameAckID);                 //delete and free the first record from buffer          
   \       0x96   0x7879             LDRB     R1,[R7, #+1]
   \       0x98   0x1D70             ADDS     R0,R6,#+5
   \       0x9A   0xFB14 0xF401      SMULBB   R4,R4,R1
   \       0x9E   0x5D00             LDRB     R0,[R0, R4]
   \       0xA0   0x....'....        BL       AckDeRegistered
    108                  }    
    109                  Ack_WaitTime = getSysCount() + AckTimeOut;                      //store time tick value  
   \                     ??moduleAutoAck_u32_7: (+1)
   \       0xA4   0x....'....        BL       getSysCount
   \       0xA8   0x....'....        BL       ?Subroutine0
    110                  
    111                  if (ValidRx != false)
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xAC   0x7838             LDRB     R0,[R7, #+0]
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xBF12             ITEE     NE
   \       0xB2   0x703D             STRBNE   R5,[R7, #+0]
   \       0xB4   0x6979             LDREQ    R1,[R7, #+20]
   \       0xB6   0x6008             STREQ    R0,[R1, #+0]
    112                  {
    113                    ValidRx = false;         
    114                  }
    115                  else
    116                  {
    117                    LinkLost();
    118                  }
    119                }
    120                if((*autoAckControl).RxAckFrameID){
   \                     ??moduleAutoAck_u32_5: (+1)
   \       0xB8   0x693C             LDR      R4,[R7, #+16]
   \       0xBA   0x7820             LDRB     R0,[R4, #+0]
   \       0xBC   0xB110             CBZ.N    R0,??moduleAutoAck_u32_4
    121                  AckDeRegistered((*autoAckControl).RxAckFrameID);                //got auto-ack receiver acknowledment, then de-registered this to fulfil the whole Auto-ack process
   \       0xBE   0x....'....        BL       AckDeRegistered
    122                  (*autoAckControl).RxAckFrameID = 0;                             //clear the de-resister request
   \       0xC2   0x7025             STRB     R5,[R4, #+0]
    123                  
    124                }
    125                return_state_u8 = RUN_AUTOACK_MODULE;
   \                     ??moduleAutoAck_u32_4: (+1)
   \       0xC4   0xF04F 0x0A01      MOV      R10,#+1
    126                break;
   \       0xC8   0xE008             B.N      ??moduleAutoAck_u32_3
    127              }
    128              case KILL_AUTOACK_MODULE: {
    129                // The USART2 driver module must only be executed once.
    130                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    131                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??moduleAutoAck_u32_2: (+1)
   \       0xCA   0x....'....        BL       getProcessInfoIndex
    132                if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0xCE   0x28FF             CMP      R0,#+255
   \       0xD0   0xD004             BEQ.N    ??moduleAutoAck_u32_3
    133                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \       0xD2   0xFB14 0xF400      SMULBB   R4,R4,R0
   \       0xD6   0x1930             ADDS     R0,R6,R4
   \       0xD8   0xF880 0xA00A      STRB     R10,[R0, #+10]
    134                }
    135                return_state_u8 = KILL_AUTOACK_MODULE;
    136                break;
    137              }
    138              default: {
    139                return_state_u8 = KILL_AUTOACK_MODULE;
    140                break;
    141              }
    142            }
    143            return return_state_u8;
   \                     ??moduleAutoAck_u32_3: (+1)
   \       0xDC   0x4650             MOV      R0,R10
   \       0xDE   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    144          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xEB10 0x0008      ADDS     R0,R0,R8
   \        0x4   0x4169             ADCS     R1,R1,R5
   \        0x6   0xE9C7 0x0102      STRD     R0,R1,[R7, #+8]
   \        0xA   0x4770             BX       LR
    145          

   \                                 In section .text, align 2, keep-with-next
    146          void UniversalAckInit(void)
    147          {
   \                     UniversalAckInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    148            for(uint8_t index = 0; index < AckBufSize ; index++)
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2300             MOVS     R3,#+0
    149            {
    150              buf[index].AckCmd = 0;
   \                     ??UniversalAckInit_0: (+1)
   \        0x8   0x2206             MOVS     R2,#+6
   \        0xA   0x....             LDR.N    R1,??DataTable6_2
   \        0xC   0x4342             MULS     R2,R2,R0
   \        0xE   0x4411             ADD      R1,R1,R2
    151              buf[index].E_AckCmd = 0;
    152              buf[index].FrameAckID = 0;
    153              buf[index].ProcessAckID = 0;
    154            }  
   \       0x10   0x1C40             ADDS     R0,R0,#+1
   \       0x12   0x2810             CMP      R0,#+16
   \       0x14   0x700B             STRB     R3,[R1, #+0]
   \       0x16   0x804C             STRH     R4,[R1, #+2]
   \       0x18   0x714B             STRB     R3,[R1, #+5]
   \       0x1A   0x710B             STRB     R3,[R1, #+4]
   \       0x1C   0xDBF4             BLT.N    ??UniversalAckInit_0
    155            Uni_AckHead = 0;
   \       0x1E   0x....             LDR.N    R0,??DataTable6
   \       0x20   0x7043             STRB     R3,[R0, #+1]
    156            Uni_AckTail = 0;
   \       0x22   0x7083             STRB     R3,[R0, #+2]
    157            Uni_NextFrameID = 0;
   \       0x24   0x70C3             STRB     R3,[R0, #+3]
    158          }
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
    159          

   \                                 In section .text, align 2, keep-with-next
    160          uint8_t AckDeRegistered(uint8_t _FrameAckID)                     //Got the ack from the receiver and de-registered the record 
    161          {
   \                     AckDeRegistered: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    162            uint8_t _success_u8 = false;
   \        0x4   0x2600             MOVS     R6,#+0
    163            for(uint8_t index = 0; index < AckBufSize ; index++)
   \        0x6   0x2500             MOVS     R5,#+0
    164            {
    165               if(_FrameAckID == buf[index].FrameAckID)                   //search the received FrameAckID in buffer
   \                     ??AckDeRegistered_0: (+1)
   \        0x8   0x2106             MOVS     R1,#+6
   \        0xA   0x....             LDR.N    R0,??DataTable6_2
   \        0xC   0x4369             MULS     R1,R1,R5
   \        0xE   0x4408             ADD      R0,R0,R1
   \       0x10   0x7942             LDRB     R2,[R0, #+5]
   \       0x12   0x4294             CMP      R4,R2
   \       0x14   0xD107             BNE.N    ??AckDeRegistered_1
    166               {  //clear all this record when found
    167                  buf[index].AckCmd = 0;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x7001             STRB     R1,[R0, #+0]
    168                  buf[index].E_AckCmd = 0;
   \       0x1A   0x8041             STRH     R1,[R0, #+2]
    169                  buf[index].FrameAckID = 0;
   \       0x1C   0x7141             STRB     R1,[R0, #+5]
    170                  buf[index].ProcessAckID = 0;   
   \       0x1E   0x7101             STRB     R1,[R0, #+4]
    171                  _success_u8 = true;
   \       0x20   0x2601             MOVS     R6,#+1
    172                  AckFlushBuf();
   \       0x22   0x....'....        BL       AckFlushBuf
    173               }
    174            }  
   \                     ??AckDeRegistered_1: (+1)
   \       0x26   0x1C6D             ADDS     R5,R5,#+1
   \       0x28   0x2D10             CMP      R5,#+16
   \       0x2A   0xDBED             BLT.N    ??AckDeRegistered_0
    175            return(_success_u8);
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    176          }
    177          

   \                                 In section .text, align 2, keep-with-next
    178          void AckFlushBuf(void)                                          //FLash any empty record in buffer, starting from the buffer[Uni_AckHead]      
    179          {
   \                     AckFlushBuf: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x....             LDR.N    R1,??DataTable6
   \        0x4   0x788C             LDRB     R4,[R1, #+2]
   \        0x6   0x784D             LDRB     R5,[R1, #+1]
   \        0x8   0x....             LDR.N    R3,??DataTable6_2
   \        0xA   0x2206             MOVS     R2,#+6
    180            while((Uni_AckHead != Uni_AckTail) && (buf[Uni_AckTail].FrameAckID == 0) ) //push back all the trailing empty record, and move the tail back to the last trailing record
   \                     ??AckFlushBuf_0: (+1)
   \        0xC   0xB2E6             UXTB     R6,R4
   \        0xE   0x42B5             CMP      R5,R6
   \       0x10   0xD00F             BEQ.N    ??AckFlushBuf_1
   \       0x12   0xB2E7             UXTB     R7,R4
   \       0x14   0x1D5E             ADDS     R6,R3,#+5
   \       0x16   0x4357             MULS     R7,R2,R7
   \       0x18   0x5DF0             LDRB     R0,[R6, R7]
   \       0x1A   0xB950             CBNZ.N   R0,??AckFlushBuf_1
    181            { //Move head to the closest in buffer
    182              if(Uni_AckTail != 0 ){
   \       0x1C   0xB2E0             UXTB     R0,R4
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xBF0C             ITE      EQ
   \       0x22   0x240F             MOVEQ    R4,#+15
   \       0x24   0x1E64             SUBNE    R4,R4,#+1
    183                Uni_AckTail--;
    184              }
    185              else
    186              {
    187                Uni_AckTail = (AckBufSize - 1);
   \       0x26   0xE7F1             B.N      ??AckFlushBuf_0
    188              }
    189            } 
    190            //push back all the leading empty record, and move the head back to the first leading record
    191            while((Uni_AckHead != Uni_AckTail) && (buf[Uni_AckHead].FrameAckID == 0) )
    192            { //Move head to the closest in buffer
    193              if(++Uni_AckHead == AckBufSize)  Uni_AckHead = 0;
   \                     ??AckFlushBuf_2: (+1)
   \       0x28   0x1C6D             ADDS     R5,R5,#+1
   \       0x2A   0xB2E8             UXTB     R0,R5
   \       0x2C   0x2810             CMP      R0,#+16
   \       0x2E   0xBF08             IT       EQ
   \       0x30   0x2500             MOVEQ    R5,#+0
    194            }  
   \                     ??AckFlushBuf_1: (+1)
   \       0x32   0xB2E8             UXTB     R0,R5
   \       0x34   0xB2E6             UXTB     R6,R4
   \       0x36   0x42B0             CMP      R0,R6
   \       0x38   0xD005             BEQ.N    ??AckFlushBuf_3
   \       0x3A   0xB2EF             UXTB     R7,R5
   \       0x3C   0x1D5E             ADDS     R6,R3,#+5
   \       0x3E   0x4357             MULS     R7,R2,R7
   \       0x40   0x5DF0             LDRB     R0,[R6, R7]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD0F0             BEQ.N    ??AckFlushBuf_2
    195          }
   \                     ??AckFlushBuf_3: (+1)
   \       0x46   0x704D             STRB     R5,[R1, #+1]
   \       0x48   0x708C             STRB     R4,[R1, #+2]
   \       0x4A   0xBDF0             POP      {R4-R7,PC}       ;; return
    196          
    197          

   \                                 In section .text, align 2, keep-with-next
    198          uint8_t AckDatSet(uint8_t _AckCmd, uint16_t _E_AckCmd, uint8_t _ProcessAckID)
    199          {
   \                     AckDatSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4617             MOV      R7,R2
    200            if(!IsAckBufFull())
   \        0x8   0x....'....        BL       IsAckBufFull
   \        0xC   0xBB28             CBNZ.N   R0,??AckDatSet_0
    201            {
    202              if(Uni_AckHead == Uni_AckTail){                                     //if this is the first data in buffer, reload the timeout value 
   \        0xE   0x....             LDR.N    R4,??DataTable6
   \       0x10   0x7860             LDRB     R0,[R4, #+1]
   \       0x12   0x78A1             LDRB     R1,[R4, #+2]
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD108             BNE.N    ??AckDatSet_1
    203                Ack_WaitTime = getSysCount() + AckTimeOut;                        //store time tick value  
   \       0x18   0x....'....        BL       getSysCount
   \       0x1C   0xF241 0x3288      MOVW     R2,#+5000
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0x1880             ADDS     R0,R0,R2
   \       0x24   0x4159             ADCS     R1,R1,R3
   \       0x26   0xE9C4 0x0102      STRD     R0,R1,[R4, #+8]
    204              }
    205              if(++Uni_AckTail == AckBufSize) {
   \                     ??AckDatSet_1: (+1)
   \       0x2A   0x78A0             LDRB     R0,[R4, #+2]
   \       0x2C   0x1C40             ADDS     R0,R0,#+1
   \       0x2E   0xB2C1             UXTB     R1,R0
   \       0x30   0x2910             CMP      R1,#+16
   \       0x32   0xBF08             IT       EQ
   \       0x34   0x2000             MOVEQ    R0,#+0
    206                Uni_AckTail = 0;
   \       0x36   0x70A0             STRB     R0,[R4, #+2]
    207              }
    208              buf[Uni_AckTail].AckCmd = _AckCmd;
   \       0x38   0x2006             MOVS     R0,#+6
   \       0x3A   0x78A2             LDRB     R2,[R4, #+2]
   \       0x3C   0x....             LDR.N    R1,??DataTable6_2
   \       0x3E   0x4342             MULS     R2,R0,R2
   \       0x40   0x4411             ADD      R1,R1,R2
   \       0x42   0x700D             STRB     R5,[R1, #+0]
    209              buf[Uni_AckTail].E_AckCmd = _E_AckCmd;
   \       0x44   0x804E             STRH     R6,[R1, #+2]
    210              buf[Uni_AckTail].ProcessAckID = _ProcessAckID;
   \       0x46   0x710F             STRB     R7,[R1, #+4]
    211              if(++Uni_NextFrameID == 0)
   \       0x48   0x78E0             LDRB     R0,[R4, #+3]
   \       0x4A   0x1C40             ADDS     R0,R0,#+1
   \       0x4C   0xB2C2             UXTB     R2,R0
   \       0x4E   0xB902             CBNZ.N   R2,??AckDatSet_2
    212              {
    213                Uni_NextFrameID = 1;
   \       0x50   0x2001             MOVS     R0,#+1
   \                     ??AckDatSet_2: (+1)
   \       0x52   0x70E0             STRB     R0,[R4, #+3]
    214              }
    215              buf[Uni_AckTail].FrameAckID = Uni_NextFrameID;
   \       0x54   0x78E0             LDRB     R0,[R4, #+3]
   \       0x56   0x7148             STRB     R0,[R1, #+5]
    216              return buf[Uni_AckTail].FrameAckID;  // Return current FrameID to construct the frame 
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}
    217            }
    218            return 0;
   \                     ??AckDatSet_0: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    219          }
    220          

   \                                 In section .text, align 2, keep-with-next
    221          uint8_t IsAckBufFull(void) 
    222          {
    223            int16_t result = (int16_t)Uni_AckHead - (int16_t)Uni_AckTail;
   \                     IsAckBufFull: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable6
   \        0x2   0x7841             LDRB     R1,[R0, #+1]
   \        0x4   0x7880             LDRB     R0,[R0, #+2]
   \        0x6   0x1A08             SUBS     R0,R1,R0
    224            if( (result == -(AckBufSize-1)) || (result == 1)) 
   \        0x8   0xF110 0x0F0F      CMN      R0,#+15
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2801             CMPNE    R0,#+1
   \       0x10   0xD101             BNE.N    ??IsAckBufFull_0
    225            { 
    226              return (true);
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x4770             BX       LR
    227            }  
    228            return (false);
   \                     ??IsAckBufFull_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR               ;; return
    229          }
    230          
    231          /* 
    232          RPa: do the necessary sequence when Communication link is lost
    233          */
    234          static void LinkLost(void)
    235          {
    236            // Add the necessary process when link is lost between app-side and motor-side
    237            (*module_StateMachineControl_AutoAck).command_Speed = 0;
    238          }
    239          
    240          /*
    241          RPa: Setting the Valid received packet flag which is a private variable
    242          */

   \                                 In section .text, align 2, keep-with-next
    243          void Set_ValidRx(void)
    244          {
    245            ValidRx = true;
   \                     Set_ValidRx: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable6
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x7008             STRB     R0,[R1, #+0]
    246          }
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     ValidRx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     buf

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   AckDatSet
        24   -> IsAckBufFull
        24   -> getSysCount
      16   AckDeRegistered
        16   -> AckFlushBuf
      20   AckFlushBuf
       0   IsAckBufFull
       0   Set_ValidRx
       8   UniversalAckInit
      40   moduleAutoAck_u32
        40   -> AckDeRegistered
        40   -> AckFlushBuf
        40   -> StructMem_CreateInstance
        40   -> UniversalAckInit
        40   -> getProcessInfoIndex
        40   -> getSysCount
        40   -> setupSoftwareIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
      12  ?Subroutine0
      94  AckDatSet
      48  AckDeRegistered
      76  AckFlushBuf
       4  AutoAckStructMem_u32
       1  FrameAckID
      26  IsAckBufFull
       8  Set_ValidRx
      40  UniversalAckInit
      24  ValidRx
          Uni_AckHead
          Uni_AckTail
          Uni_NextFrameID
          Ack_WaitTime
          autoAckControl
          module_StateMachineControl_AutoAck
      96  buf
     226  moduleAutoAck_u32

 
 125 bytes in section .bss
 542 bytes in section .text
 
 542 bytes of CODE memory
 125 bytes of DATA memory

Errors: none
Warnings: none
