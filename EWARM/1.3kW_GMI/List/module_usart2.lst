###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:05:27
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Drivers\module_usart2.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW4317.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Drivers\module_usart2.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\module_usart2.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\module_usart2.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Drivers\module_usart2.c
      1          /**
      2          ********************************************************************************************************************************
      3          * @file    module_usart2.c 
      4          * @author  Pamela Lee
      5          * @brief   Main driver module for USART2 Communication.
      6          * @details This module initializes the USART2 port and attaches the pre-selected fixed memory allocation to the module.
      7          To Transmitt data in the RUN_MODULE case: put data into seqMemTX_u32, and call this function:
      8          *             USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
      9          ********************************************************************************************************************************
     10          */
     11          
     12          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     13          #include "module_usart2.h"
     14          
     15          #include "driver_usart2.h"
     16          
     17          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     18          /* Uarts handle declaration */
     19          extern void Delay(__IO uint32_t nTime);
     20          
     21          extern Ram_Buf sharedMemArray[STRUCT_MEM_ARRAY_SIZE];
     22          extern ProcessInfo processInfoTable[];
     23          extern Ram_Buf *usart2StructMem_u32;
     24          
     25          //Usart2_Control* usart2_Module_Control;
     26          unsigned char* RxCMD ;
     27          extern uint8_t usart2CaptureLen;
     28          extern uint8_t UniProtocolState;
     29          extern __IO uint8_t indexTx;
     30          
     31          extern Usart2_Control *usart2Control;
     32          
     33          enum {
     34            INIT_MODULE,
     35            RUN_MODULE,
     36            // additional states to be added here as necessary.
     37            IRQ_MODULE = DEFAULT_IRQ_STATE,
     38            KILL_MODULE = KILL_APP
     39          };
     40          
     41          
     42          void assign_UART2_ModuleMem(){  
     43            usart2InternalSeqMem_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, 
     44                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for this driver need to be bigger than 1 complete frame 
     45            usart2SeqMemRXG1_2_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, 
     46                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
     47            usart2SeqMemRXG3_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, 
     48                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
     49            usart2SeqMemRXG4L_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE +80, 
     50                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
     51            usart2SeqMemRXG4H_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE +80, 
     52                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for final packet receiver buffer 
     53            usart2SeqMemTX_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE +7 , 
     54                                        ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a buffer for Tx data 
     55            usart2StructMem_u32 =  StructMem_CreateInstance(MODULE_USART2, sizeof(Usart2_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory for this driver [should map it back to this driver local struct]
     56            
     57            usart2Control = (Usart2_Control*)(*usart2StructMem_u32).p_ramBuf_u8;
     58            
     59            /** assign all the new generated sequential-memory of USART2 to the structured-memory **/
     60            usart2Control->seqMemTX_u32 = usart2SeqMemTX_u32;
     61            usart2Control->seqMemTX_u32->is_OverwrittingAllowed_u8 = FALSE;
     62            usart2Control->seqMemRXG1_2_u32 = usart2SeqMemRXG1_2_u32;
     63            usart2Control->seqMemRXG3_u32 = usart2SeqMemRXG3_u32;
     64            usart2Control->seqMemRXG4L_u32 = usart2SeqMemRXG4L_u32;
     65            usart2Control->seqMemRXG4H_u32 = usart2SeqMemRXG4H_u32;
     66            usart2Control->seqMem_InternalPipe_u32 = usart2InternalSeqMem_u32;
     67            usart2Control->errorCode_u8 = 0;
     68          }
     69          
     70          uint8_t moduleUsart2_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
     71            uint8_t return_state_u8 = INIT_MODULE;
     72            switch (next_state_u8) {
     73            case INIT_MODULE: {
     74              // Initialize UART
     75              
     76              usart2_Init();
     77              assign_UART2_ModuleMem();
     78              
     79              // Find the structured memory for the UART2 driver module, by searching for the UART2 onwer id.
     80              Ram_Buf_Handle this_ram_buf_u32;
     81              for (uint8_t struct_mem_index_u8 = 0; struct_mem_index_u8 < TOTAL_NUM_OF_STRUCT_MEM_INSTANCES;
     82              struct_mem_index_u8++) {
     83                this_ram_buf_u32 = &sharedMemArray[struct_mem_index_u8];
     84                if (RamBuf_GetOwner(this_ram_buf_u32) == drv_id_u8) {
     85                  usart2StructMem_u32 = &sharedMemArray[struct_mem_index_u8];
     86                }
     87              }
     88              
     89              // Attach the structured memory to the process's master shared memory.
     90              uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
     91              if (table_index_u8 != INDEX_NOT_FOUND) {
     92                processInfoTable[table_index_u8].Sched_DrvData.irqState_u8 = DEFAULT_IRQ_STATE;
     93                processInfoTable[table_index_u8].Sched_DrvData.p_masterSharedMem_u32 =
     94                  usart2StructMem_u32;
     95              }
     96              
     97              //Get structured memory for ADC1 data
     98              usart2Control = (Usart2_Control*)((*(processInfoTable[table_index_u8].Sched_DrvData.p_masterSharedMem_u32)).p_ramBuf_u8);
     99              usart2CaptureLen = UniHeaderlen;                                 //pam bug without this
    100              return_state_u8 = RUN_MODULE;
    101              break;
    102            }
    103            case RUN_MODULE: {
    104              // test Uart2 transmits data
    105              // if (USART_GetITStatus(USART2, USART_IT_TXE) == RESET) {
    106              //     (*(*usart2Control).seqMemTX_u32).Write(Txbuf, &Len);
    107              //     USART_ITConfig(USART2, USART_IT_TXE, ENABLE); //  Enable when something to send
    108              // }
    109              
    110           
    111              //(*usart2Control).seqMem_InternalPipe_u32->systemInstanceIndex_u8)
    112              //if(RingBuf_GetUsedNumOfElements((Ring_Buf_Handle)((*(*usart2Control).seqMem_InternalPipe_u32).p_ringBuf_u8)) >= usart2CaptureLen )
    113              if(RingBuf_GetUsedNumOfElements((*usart2Control).seqMem_InternalPipe_u32) >= usart2CaptureLen )
    114              {
    115                protocolHeaderfetch();
    116              }
    117              uint8_t TxLen = UniHeaderlen;
    118              //if((RingBuf_GetUsedNumOfElements((Ring_Buf_Handle)((*(*usart2Control).seqMemTX_u32).p_ringBuf_u8)) >= TxLen) && !indexTx)
    119              if(((RingBuf_GetUsedNumOfElements((*usart2Control).seqMemTX_u32) >= TxLen) && !indexTx) && (LL_USART_IsActiveFlag_TXE(USART1)))
    120              {
    121                TxProcess();
    122              }  
    123              return_state_u8 = RUN_MODULE;
    124              break;
    125            }
    126            case KILL_MODULE: {
    127              // The USART2 driver module must only be executed once.
    128              // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    129              uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
    130              if (table_index_u8 != INDEX_NOT_FOUND) {
    131                processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
    132              }
    133              return_state_u8 = KILL_MODULE;
    134              break;
    135            }
    136            default: {
    137              return_state_u8 = KILL_MODULE;
    138              break;
    139            }
    140            }
    141            return return_state_u8;
    142          }

Errors: 1
Warnings: none
