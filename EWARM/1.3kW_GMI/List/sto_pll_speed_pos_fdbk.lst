###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:21
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\sto_pll_speed_pos_fdbk.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW6D6E.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\sto_pll_speed_pos_fdbk.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\sto_pll_speed_pos_fdbk.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\sto_pll_speed_pos_fdbk.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\sto_pll_speed_pos_fdbk.c
      1          /**
      2            ******************************************************************************
      3            * @file    sto_speed_pos_fdbk.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the State Observer + PLL Speed & Position Feedback component of the
      7            *          Motor Control SDK.
      8            *
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics International N.V.
     13            * All rights reserved.</center></h2>
     14            *
     15            * Redistribution and use in source and binary forms, with or without
     16            * modification, are permitted, provided that the following conditions are met:
     17            *
     18            * 1. Redistribution of source code must retain the above copyright notice,
     19            *    this list of conditions and the following disclaimer.
     20            * 2. Redistributions in binary form must reproduce the above copyright notice,
     21            *    this list of conditions and the following disclaimer in the documentation
     22            *    and/or other materials provided with the distribution.
     23            * 3. Neither the name of STMicroelectronics nor the names of other
     24            *    contributors to this software may be used to endorse or promote products
     25            *    derived from this software without specific written permission.
     26            * 4. This software, including modifications and/or derivative works of this
     27            *    software, must execute solely and exclusively on microcontroller or
     28            *    microprocessor devices manufactured by or for STMicroelectronics.
     29            * 5. Redistribution and use of this software other than as permitted under
     30            *    this license is void and will automatically terminate your rights under
     31            *    this license.
     32            *
     33            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
     34            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
     35            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
     36            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     37            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
     38            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     39            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     40            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     41            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     42            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     43            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     44            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     45            *
     46            ******************************************************************************
     47            */
     48          
     49          /* Includes ------------------------------------------------------------------*/
     50          #include "sto_pll_speed_pos_fdbk.h"
     51          #include "mc_math.h"
     52          
     53          
     54          
     55          /** @addtogroup MCSDK
     56            * @{
     57            */
     58          
     59          /** @addtogroup SpeednPosFdbk
     60            * @{
     61            */
     62          
     63          /** @defgroup SpeednPosFdbk_STO State Observer Speed & Position Feedback
     64            * @brief State Observer with PLL Speed & Position Feedback implementation
     65            *
     66            * This component uses a State Observer coupled with a software PLL to provide an estimation of
     67            * the speed and the position of the rotor of the motor.
     68            *
     69            * @todo Document the State Observer + PLL Speed & Position Feedback "module".
     70            * @{
     71            */
     72          
     73          /* Private defines -----------------------------------------------------------*/
     74          #define C6_COMP_CONST1  (int32_t) 1043038
     75          #define C6_COMP_CONST2  (int32_t) 10430
     76          
     77          /* Private function prototypes -----------------------------------------------*/
     78          static void STO_Store_Rotor_Speed( STO_PLL_Handle_t * pHandle, int16_t hRotor_Speed );
     79          static int16_t STO_ExecutePLL( STO_PLL_Handle_t * pHandle, int16_t hBemf_alfa_est,
     80                                         int16_t hBemf_beta_est );
     81          static void STO_InitSpeedBuffer( STO_PLL_Handle_t * pHandle );
     82          
     83          
     84          /**
     85            * @brief  It initializes the state observer component
     86            * @param  pHandle: handler of the current instance of the STO component
     87            * @retval none
     88            */

   \                                 In section .text, align 4
     89          __weak void STO_PLL_Init( STO_PLL_Handle_t * pHandle )
     90          {
   \                     STO_PLL_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     91            int16_t htempk;
     92            int32_t wAux;
     93          
     94          
     95            pHandle->ConsistencyCounter = pHandle->StartUpConsistThreshold;
   \        0x4   0xF104 0x00F6      ADD      R0,R4,#+246
   \        0x8   0xF894 0x1116      LDRB     R1,[R4, #+278]
   \        0xC   0x7001             STRB     R1,[R0, #+0]
     96            pHandle->EnableDualCheck = true;
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0x7382             STRB     R2,[R0, #+14]
     97          
     98            wAux = ( int32_t )1;
   \       0x12   0x2101             MOVS     R1,#+1
     99            pHandle->F3POW2 = 0u;
    100          
    101            htempk = ( int16_t )( C6_COMP_CONST1 / ( pHandle->hF2 ) );
   \       0x14   0xF9B4 0x202E      LDRSH    R2,[R4, #+46]
   \       0x18   0x4812             LDR.N    R0,??STO_PLL_Init_0  ;; 0xfea5e
   \       0x1A   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \       0x1E   0xB200             SXTH     R0,R0
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0xE005             B.N      ??STO_PLL_Init_1
    102          
    103            while ( htempk != 0 )
    104            {
    105              htempk /= ( int16_t )2;
   \                     ??STO_PLL_Init_2: (+1)
   \       0x24   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \       0x28   0x03C0             LSLS     R0,R0,#+15
   \       0x2A   0x1400             ASRS     R0,R0,#+16
    106              wAux *= ( int32_t )2;
   \       0x2C   0x0049             LSLS     R1,R1,#+1
    107              pHandle->F3POW2++;
   \       0x2E   0x1C52             ADDS     R2,R2,#+1
    108            }
   \                     ??STO_PLL_Init_1: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1F7             BNE.N    ??STO_PLL_Init_2
    109          
    110            pHandle->hF3 = ( int16_t )wAux;
    111            wAux = ( int32_t )( pHandle->hF2 ) * pHandle->hF3;
    112            pHandle->hC6 = ( int16_t )( wAux / C6_COMP_CONST2 );
   \       0x34   0x8621             STRH     R1,[R4, #+48]
   \       0x36   0x8662             STRH     R2,[R4, #+50]
   \       0x38   0xF9B4 0x002E      LDRSH    R0,[R4, #+46]
   \       0x3C   0xF9B4 0x1030      LDRSH    R1,[R4, #+48]
   \       0x40   0xFB10 0xF101      SMULBB   R1,R0,R1
   \       0x44   0xF642 0x02BE      MOVW     R2,#+10430
   \       0x48   0xFB91 0xF2F2      SDIV     R2,R1,R2
   \       0x4C   0x8562             STRH     R2,[R4, #+42]
    113          
    114            STO_PLL_Clear( pHandle );
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       STO_PLL_Clear
    115          
    116            PID_HandleInit( & pHandle->PIRegulator );
   \       0x54   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x58   0x....'....        BL       PID_HandleInit
    117          
    118            /* Acceleration measurement set to zero */
    119            pHandle->_Super.hMecAccelUnitP = 0;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x8260             STRH     R0,[R4, #+18]
    120          
    121            return;
   \       0x60   0xBD10             POP      {R4,PC}          ;; return
   \       0x62   0xBF00             Nop
   \                     ??STO_PLL_Init_0:
   \       0x64   0x000F'EA5E        DC32     0xfea5e
    122          }
    123          
    124          /**
    125            * @brief  It only returns, necessary to implement fictitious IRQ_Handler
    126            * @param  pHandle: handler of the current instance of the STO component
    127            * @param  uint8_t Fictitious interrupt flag
    128            * @retval none
    129            */
    130          

   \                                 In section .text, align 2
    131          __weak void STO_PLL_Return( STO_PLL_Handle_t * pHandle, uint8_t flag )
    132          {
    133            return;
   \                     STO_PLL_Return: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    134          }
    135          
    136          #if defined (CCMRAM)
    137          #if defined (__ICCARM__)
    138          #pragma location = ".ccmram"
    139          #elif defined (__CC_ARM) || defined(__GNUC__)
    140          __attribute__( ( section ( ".ccmram" ) ) )
    141          #endif
    142          #endif
    143          /**
    144            * @brief  This method executes Luenberger state observer equations and calls
    145            *         PLL with the purpose of computing a new speed estimation and
    146            *         updating the estimated electrical angle.
    147            * @param  pHandle: handler of the current instance of the STO component
    148            * @param  pInputVars_str pointer to the observer inputs structure
    149            * @retval int16_t rotor electrical angle (s16Degrees)
    150            */

   \                                 In section .text, align 2
    151          __weak int16_t STO_PLL_CalcElAngle( STO_PLL_Handle_t * pHandle, Observer_Inputs_t * pInputs )
    152          {
   \                     STO_PLL_CalcElAngle: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0xB085             SUB      SP,SP,#+20
    153            int32_t wAux, wDirection;
    154            int32_t wIalfa_est_Next, wIbeta_est_Next;
    155            int32_t wBemf_alfa_est_Next, wBemf_beta_est_Next;
    156            int16_t hAux, hAux_Alfa, hAux_Beta, hIalfa_err, hIbeta_err, hRotor_Speed,
    157                    hValfa, hVbeta;
    158          
    159          
    160            if ( pHandle->wBemf_alfa_est > ( int32_t )( pHandle->hF2 )*INT16_MAX )
   \        0x8   0xF9B5 0x002E      LDRSH    R0,[R5, #+46]
   \        0xC   0x6EAB             LDR      R3,[R5, #+104]
   \        0xE   0xEBC0 0x32C0      RSB      R2,R0,R0, LSL #+15
   \       0x12   0x429A             CMP      R2,R3
   \       0x14   0xBFB8             IT       LT
   \       0x16   0x66AA             STRLT    R2,[R5, #+104]
    161            {
    162              pHandle->wBemf_alfa_est = INT16_MAX * ( int32_t )( pHandle->hF2 );
   \       0x18   0xDB04             BLT.N    ??STO_PLL_CalcElAngle_0
    163            }
    164            else if ( pHandle->wBemf_alfa_est <= -INT16_MAX * ( int32_t )( pHandle->hF2 ) )
   \       0x1A   0xEBA0 0x30C0      SUB      R0,R0,R0, LSL #+15
   \       0x1E   0x4298             CMP      R0,R3
   \       0x20   0xBFA8             IT       GE
   \       0x22   0x66A8             STRGE    R0,[R5, #+104]
    165            {
    166              pHandle->wBemf_alfa_est = -INT16_MAX * ( int32_t )( pHandle->hF2 );
    167            }
    168            else
    169            {
    170            }
    171          #ifdef FULL_MISRA_C_COMPLIANCY
    172            hAux_Alfa = ( int16_t )( pHandle->wBemf_alfa_est / pHandle->hF2 );
    173          #else
    174            hAux_Alfa = ( int16_t )( pHandle->wBemf_alfa_est >> pHandle->F2LOG );
   \                     ??STO_PLL_CalcElAngle_0: (+1)
   \       0x24   0xF105 0x00F4      ADD      R0,R5,#+244
   \       0x28   0x6EAE             LDR      R6,[R5, #+104]
   \       0x2A   0x8D42             LDRH     R2,[R0, #+42]
    175          #endif
    176          
    177            if ( pHandle->wBemf_beta_est > INT16_MAX * ( int32_t )( pHandle->hF2 ) )
   \       0x2C   0xF9B5 0x002E      LDRSH    R0,[R5, #+46]
   \       0x30   0x6EEB             LDR      R3,[R5, #+108]
   \       0x32   0x4116             ASRS     R6,R6,R2
   \       0x34   0xEBC0 0x32C0      RSB      R2,R0,R0, LSL #+15
   \       0x38   0x429A             CMP      R2,R3
   \       0x3A   0xB236             SXTH     R6,R6
   \       0x3C   0xBFB8             IT       LT
   \       0x3E   0x66EA             STRLT    R2,[R5, #+108]
    178            {
    179              pHandle->wBemf_beta_est = INT16_MAX * ( int32_t )( pHandle->hF2 );
   \       0x40   0xDB04             BLT.N    ??STO_PLL_CalcElAngle_1
    180            }
    181            else if ( pHandle->wBemf_beta_est <= -INT16_MAX * ( int32_t )( pHandle->hF2 ) )
   \       0x42   0xEBA0 0x30C0      SUB      R0,R0,R0, LSL #+15
   \       0x46   0x4298             CMP      R0,R3
   \       0x48   0xBFA8             IT       GE
   \       0x4A   0x66E8             STRGE    R0,[R5, #+108]
    182            {
    183              pHandle->wBemf_beta_est = -INT16_MAX * ( int32_t )( pHandle->hF2 );
    184            }
    185            else
    186            {
    187            }
    188          #ifdef FULL_MISRA_C_COMPLIANCY
    189            hAux_Beta = ( int16_t )( pHandle->wBemf_beta_est / pHandle->hF2 );
    190          #else
    191            hAux_Beta = ( int16_t )( pHandle->wBemf_beta_est >> pHandle->F2LOG );
   \                     ??STO_PLL_CalcElAngle_1: (+1)
   \       0x4C   0xF105 0x00F4      ADD      R0,R5,#+244
   \       0x50   0x6EEB             LDR      R3,[R5, #+108]
   \       0x52   0x8D42             LDRH     R2,[R0, #+42]
   \       0x54   0xFA43 0xF002      ASR      R0,R3,R2
   \       0x58   0xFA0F 0xF980      SXTH     R9,R0
    192          #endif
    193          
    194            if ( pHandle->Ialfa_est > INT16_MAX * ( int32_t )( pHandle->hF1 ) )
   \       0x5C   0xF9B5 0x002C      LDRSH    R0,[R5, #+44]
   \       0x60   0x6E2B             LDR      R3,[R5, #+96]
   \       0x62   0xEBC0 0x32C0      RSB      R2,R0,R0, LSL #+15
   \       0x66   0x429A             CMP      R2,R3
   \       0x68   0xBFB8             IT       LT
   \       0x6A   0x662A             STRLT    R2,[R5, #+96]
    195            {
    196              pHandle->Ialfa_est = INT16_MAX * ( int32_t )( pHandle->hF1 );
   \       0x6C   0xDB04             BLT.N    ??STO_PLL_CalcElAngle_2
    197            }
    198            else if ( pHandle->Ialfa_est <= -INT16_MAX * ( int32_t )( pHandle->hF1 ) )
   \       0x6E   0xEBA0 0x30C0      SUB      R0,R0,R0, LSL #+15
   \       0x72   0x4298             CMP      R0,R3
   \       0x74   0xBFA8             IT       GE
   \       0x76   0x6628             STRGE    R0,[R5, #+96]
    199            {
    200              pHandle->Ialfa_est = -INT16_MAX * ( int32_t )( pHandle->hF1 );
    201            }
    202            else
    203            {
    204            }
    205          
    206            if ( pHandle->Ibeta_est > INT16_MAX * ( int32_t )( pHandle->hF1 ) )
   \                     ??STO_PLL_CalcElAngle_2: (+1)
   \       0x78   0x6E6B             LDR      R3,[R5, #+100]
   \       0x7A   0xF9B5 0x002C      LDRSH    R0,[R5, #+44]
   \       0x7E   0x429A             CMP      R2,R3
   \       0x80   0xBFB8             IT       LT
   \       0x82   0x666A             STRLT    R2,[R5, #+100]
    207            {
    208              pHandle->Ibeta_est = INT16_MAX * ( int32_t )( pHandle->hF1 );
   \       0x84   0xDB04             BLT.N    ??STO_PLL_CalcElAngle_3
    209            }
    210            else if ( pHandle->Ibeta_est <= -INT16_MAX * ( int32_t )( pHandle->hF1 ) )
   \       0x86   0xEBA0 0x30C0      SUB      R0,R0,R0, LSL #+15
   \       0x8A   0x4298             CMP      R0,R3
   \       0x8C   0xBFA8             IT       GE
   \       0x8E   0x6668             STRGE    R0,[R5, #+100]
    211            {
    212              pHandle->Ibeta_est = -INT16_MAX * ( int32_t )( pHandle->hF1 );
    213            }
    214            else
    215            {
    216            }
    217          
    218          #ifdef FULL_MISRA_C_COMPLIANCY
    219            hIalfa_err = ( int16_t )( pHandle->Ialfa_est / pHandle->hF1 );
    220          #else
    221            hIalfa_err = ( int16_t )( pHandle->Ialfa_est >> pHandle->F1LOG );
    222          #endif
    223          
    224            hIalfa_err = hIalfa_err - pInputs->Ialfa_beta.alpha;
   \                     ??STO_PLL_CalcElAngle_3: (+1)
   \       0x90   0xF105 0x00F4      ADD      R0,R5,#+244
   \       0x94   0xF8D5 0x8060      LDR      R8,[R5, #+96]
   \       0x98   0x8D02             LDRH     R2,[R0, #+40]
   \       0x9A   0x8888             LDRH     R0,[R1, #+4]
    225          
    226          #ifdef FULL_MISRA_C_COMPLIANCY
    227            hIbeta_err = ( int16_t )( pHandle->Ibeta_est / pHandle->hF1 );
    228          #else
    229            hIbeta_err = ( int16_t )( pHandle->Ibeta_est >> pHandle->F1LOG );
    230          #endif
    231          
    232            hIbeta_err = hIbeta_err - pInputs->Ialfa_beta.beta;
   \       0x9C   0xF8D5 0xE064      LDR      LR,[R5, #+100]
   \       0xA0   0xFA48 0xF402      ASR      R4,R8,R2
   \       0xA4   0x1A20             SUBS     R0,R4,R0
   \       0xA6   0xB200             SXTH     R0,R0
   \       0xA8   0xFA4E 0xF302      ASR      R3,LR,R2
   \       0xAC   0xF8AD 0x3002      STRH     R3,[SP, #+2]
   \       0xB0   0xF8BD 0x2002      LDRH     R2,[SP, #+2]
   \       0xB4   0x88CB             LDRH     R3,[R1, #+6]
   \       0xB6   0x1AD3             SUBS     R3,R2,R3
    233          
    234            wAux = ( int32_t )( pInputs->Vbus ) * pInputs->Valfa_beta.alpha;
    235          #ifdef FULL_MISRA_C_COMPLIANCY
    236            hValfa = ( int16_t ) ( wAux / 65536 );
    237          #else
    238            hValfa = ( int16_t ) ( wAux >> 16 );
    239          #endif
    240          
    241            wAux = ( int32_t )( pInputs->Vbus ) * pInputs->Valfa_beta.beta;
    242          #ifdef FULL_MISRA_C_COMPLIANCY
    243            hVbeta = ( int16_t ) ( wAux / 65536 );
    244          #else
    245            hVbeta = ( int16_t ) ( wAux >> 16 );
    246          #endif
    247          
    248            /*alfa axes observer*/
    249          #ifdef FULL_MISRA_C_COMPLIANCY
    250            hAux = ( int16_t ) ( pHandle->Ialfa_est / pHandle->hF1 );
    251          #else
    252            hAux = ( int16_t ) ( pHandle->Ialfa_est >> pHandle->F1LOG );
    253          #endif
    254          
    255            wAux = ( int32_t ) ( pHandle->hC1 ) * hAux;
    256            wIalfa_est_Next = pHandle->Ialfa_est - wAux;
    257          
    258            wAux = ( int32_t ) ( pHandle->hC2 ) * hIalfa_err;
    259            wIalfa_est_Next += wAux;
    260          
    261            wAux = ( int32_t ) ( pHandle->hC5 ) * hValfa;
    262            wIalfa_est_Next += wAux;
    263          
    264            wAux = ( int32_t )  ( pHandle->hC3 ) * hAux_Alfa;
    265            wIalfa_est_Next -= wAux;
   \       0xB8   0xF9B5 0x2024      LDRSH    R2,[R5, #+36]
   \       0xBC   0x9204             STR      R2,[SP, #+16]
   \       0xBE   0xB21B             SXTH     R3,R3
   \       0xC0   0x890F             LDRH     R7,[R1, #+8]
   \       0xC2   0x9703             STR      R7,[SP, #+12]
   \       0xC4   0xF9B5 0x2028      LDRSH    R2,[R5, #+40]
   \       0xC8   0x9202             STR      R2,[SP, #+8]
   \       0xCA   0xF9B5 0xA020      LDRSH    R10,[R5, #+32]
   \       0xCE   0xF9B5 0x7022      LDRSH    R7,[R5, #+34]
   \       0xD2   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   \       0xD6   0xFB1A 0xF204      SMULBB   R2,R10,R4
   \       0xDA   0x9C03             LDR      R4,[SP, #+12]
   \       0xDC   0xEBA8 0x0802      SUB      R8,R8,R2
   \       0xE0   0xF9B1 0x2000      LDRSH    R2,[R1, #+0]
   \       0xE4   0x4354             MULS     R4,R4,R2
    266          
    267            wAux = ( int32_t )( pHandle->hC4 ) * hIalfa_err;
    268            wBemf_alfa_est_Next = pHandle->wBemf_alfa_est + wAux;
    269          
    270          #ifdef FULL_MISRA_C_COMPLIANCY
    271            wAux = ( int32_t ) hAux_Beta / pHandle->hF3;
    272          #else
    273            wAux = ( int32_t ) hAux_Beta >> pHandle->F3POW2;
    274          #endif
    275          
    276            wAux = wAux * pHandle->hC6;
    277            wAux = pHandle->_Super.hElSpeedDpp * wAux;
    278            wBemf_alfa_est_Next += wAux;
   \       0xE6   0xF9B5 0x202A      LDRSH    R2,[R5, #+42]
   \       0xEA   0xFB10 0x8807      SMLABB   R8,R0,R7,R8
   \       0xEE   0x1424             ASRS     R4,R4,#+16
   \       0xF0   0xFB1C 0x8804      SMLABB   R8,R12,R4,R8
   \       0xF4   0x9C04             LDR      R4,[SP, #+16]
   \       0xF6   0x9201             STR      R2,[SP, #+4]
   \       0xF8   0xFB06 0x8414      MLS      R4,R6,R4,R8
   \       0xFC   0x8E6A             LDRH     R2,[R5, #+50]
   \       0xFE   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \      0x102   0xF9B5 0xC026      LDRSH    R12,[R5, #+38]
   \      0x106   0xF8D5 0xB068      LDR      R11,[R5, #+104]
   \      0x10A   0xF9B5 0x200E      LDRSH    R2,[R5, #+14]
   \      0x10E   0xFB10 0xB00C      SMLABB   R0,R0,R12,R11
   \      0x112   0xF99D 0xB000      LDRSB    R11,[SP, #+0]
   \      0x116   0xFA49 0xF80B      ASR      R8,R9,R11
   \      0x11A   0xF8DD 0xB004      LDR      R11,[SP, #+4]
   \      0x11E   0xFB18 0xF802      SMULBB   R8,R8,R2
   \      0x122   0xFB0B 0x0808      MLA      R8,R11,R8,R0
    279          
    280            /*beta axes observer*/
    281          #ifdef FULL_MISRA_C_COMPLIANCY
    282            hAux = ( int16_t ) ( pHandle->Ibeta_est / pHandle->hF1 );
    283          #else
    284            hAux = ( int16_t ) ( pHandle->Ibeta_est >> pHandle->F1LOG );
    285          #endif
    286          
    287            wAux = ( int32_t )  ( pHandle->hC1 ) * hAux;
    288            wIbeta_est_Next = pHandle->Ibeta_est - wAux;
    289          
    290            wAux = ( int32_t ) ( pHandle->hC2 ) * hIbeta_err;
    291            wIbeta_est_Next += wAux;
    292          
    293            wAux = ( int32_t ) ( pHandle->hC5 ) * hVbeta;
    294            wIbeta_est_Next += wAux;
    295          
    296            wAux = ( int32_t )  ( pHandle->hC3 ) * hAux_Beta;
    297            wIbeta_est_Next -= wAux;
   \      0x126   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \      0x12A   0xFB1A 0xF000      SMULBB   R0,R10,R0
   \      0x12E   0xEBAE 0x0E00      SUB      LR,LR,R0
   \      0x132   0xF8DD 0xA00C      LDR      R10,[SP, #+12]
   \      0x136   0xF9B1 0x0002      LDRSH    R0,[R1, #+2]
   \      0x13A   0xFB13 0xEE07      SMLABB   LR,R3,R7,LR
   \      0x13E   0x9F02             LDR      R7,[SP, #+8]
   \      0x140   0xFB00 0xF00A      MUL      R0,R0,R10
   \      0x144   0x1400             ASRS     R0,R0,#+16
   \      0x146   0xFB17 0xE100      SMLABB   R1,R7,R0,LR
    298          
    299            wAux = ( int32_t )( pHandle->hC4 ) * hIbeta_err;
    300            wBemf_beta_est_Next = pHandle->wBemf_beta_est + wAux;
    301          
    302          #ifdef FULL_MISRA_C_COMPLIANCY
    303            wAux = ( int32_t )hAux_Alfa / pHandle->hF3;
    304          #else
    305            wAux = ( int32_t ) hAux_Alfa >> pHandle->F3POW2;
    306          #endif
    307          
    308            wAux = wAux * pHandle->hC6;
    309            wAux = pHandle->_Super.hElSpeedDpp * wAux;
    310            wBemf_beta_est_Next -= wAux;
   \      0x14A   0x6EE8             LDR      R0,[R5, #+108]
   \      0x14C   0x9F04             LDR      R7,[SP, #+16]
   \      0x14E   0xFB13 0x030C      SMLABB   R3,R3,R12,R0
   \      0x152   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \      0x156   0xFA46 0xF000      ASR      R0,R6,R0
   \      0x15A   0xFB10 0xF202      SMULBB   R2,R0,R2
   \      0x15E   0x469A             MOV      R10,R3
   \      0x160   0xFB0B 0xAA12      MLS      R10,R11,R2,R10
    311          
    312            if(pHandle->hForcedAvrSpeed_VSS >=0)
   \      0x164   0xF105 0x02F4      ADD      R2,R5,#+244
    313            {
    314              wDirection = 1;
    315            }
    316            else
    317            {
    318              wDirection = -1;
    319            }
    320          
    321            /*Calls the PLL blockset*/
    322            pHandle->hBemf_alfa_est = hAux_Alfa;
   \      0x168   0xF105 0x0070      ADD      R0,R5,#+112
   \      0x16C   0xF9B2 0x3030      LDRSH    R3,[R2, #+48]
   \      0x170   0x8006             STRH     R6,[R0, #+0]
    323            pHandle->hBemf_beta_est = hAux_Beta;
   \      0x172   0xF8A0 0x9002      STRH     R9,[R0, #+2]
   \      0x176   0x2B00             CMP      R3,#+0
    324          
    325            hAux_Alfa = ( int16_t )( hAux_Alfa * wDirection );
    326            hAux_Beta = ( int16_t )( hAux_Beta * wDirection );
    327          
    328            hRotor_Speed = STO_ExecutePLL( pHandle, hAux_Alfa, -hAux_Beta );
   \      0x178   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \      0x17C   0xFB09 0x1717      MLS      R7,R9,R7,R1
   \      0x180   0xBF54             ITE      PL
   \      0x182   0xF04F 0x0B01      MOVPL    R11,#+1
   \      0x186   0xF04F 0x3BFF      MOVMI    R11,#-1
   \      0x18A   0x....'....        BL       MCM_Trig_Functions
   \      0x18E   0x9000             STR      R0,[SP, #+0]
   \      0x190   0xFB19 0xF10B      SMULBB   R1,R9,R11
   \      0x194   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \      0x198   0x4249             RSBS     R1,R1,#+0
   \      0x19A   0xFB11 0xF100      SMULBB   R1,R1,R0
   \      0x19E   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \      0x1A2   0xFB0B 0xF606      MUL      R6,R11,R6
   \      0x1A6   0x0049             LSLS     R1,R1,#+1
   \      0x1A8   0xFB16 0xF000      SMULBB   R0,R6,R0
   \      0x1AC   0x1409             ASRS     R1,R1,#+16
   \      0x1AE   0x0040             LSLS     R0,R0,#+1
   \      0x1B0   0xEBA1 0x4120      SUB      R1,R1,R0, ASR #+16
   \      0x1B4   0xF105 0x0034      ADD      R0,R5,#+52
   \      0x1B8   0x....'....        BL       PI_Controller
    329            pHandle->_Super.InstantaneousElSpeedDpp = hRotor_Speed;
    330          
    331            STO_Store_Rotor_Speed( pHandle, hRotor_Speed );
   \      0x1BC   0xF105 0x03F4      ADD      R3,R5,#+244
   \      0x1C0   0x8228             STRH     R0,[R5, #+16]
   \      0x1C2   0x7819             LDRB     R1,[R3, #+0]
   \      0x1C4   0x7E9A             LDRB     R2,[R3, #+26]
   \      0x1C6   0x1C49             ADDS     R1,R1,#+1
   \      0x1C8   0xB2C9             UXTB     R1,R1
   \      0x1CA   0x4291             CMP      R1,R2
   \      0x1CC   0xBF08             IT       EQ
   \      0x1CE   0x2100             MOVEQ    R1,#+0
   \      0x1D0   0xEB05 0x0241      ADD      R2,R5,R1, LSL #+1
   \      0x1D4   0xF8B2 0x6074      LDRH     R6,[R2, #+116]
   \      0x1D8   0x831E             STRH     R6,[R3, #+24]
   \      0x1DA   0xF8A2 0x0074      STRH     R0,[R2, #+116]
   \      0x1DE   0x7019             STRB     R1,[R3, #+0]
    332          
    333            pHandle->_Super.hElAngle += hRotor_Speed;
   \      0x1E0   0x88A9             LDRH     R1,[R5, #+4]
   \      0x1E2   0x1840             ADDS     R0,R0,R1
   \      0x1E4   0x80A8             STRH     R0,[R5, #+4]
    334          
    335            /*storing previous values of currents and bemfs*/
    336            pHandle->Ialfa_est = wIalfa_est_Next;
   \      0x1E6   0x662C             STR      R4,[R5, #+96]
    337            pHandle->wBemf_alfa_est = wBemf_alfa_est_Next;
   \      0x1E8   0xF8C5 0x8068      STR      R8,[R5, #+104]
    338          
    339            pHandle->Ibeta_est = wIbeta_est_Next;
   \      0x1EC   0x666F             STR      R7,[R5, #+100]
    340            pHandle->wBemf_beta_est = wBemf_beta_est_Next;
   \      0x1EE   0xF8C5 0xA06C      STR      R10,[R5, #+108]
    341          
    342            return ( pHandle->_Super.hElAngle );
   \      0x1F2   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \      0x1F6   0xB005             ADD      SP,SP,#+20
   \      0x1F8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    343          }
    344          
    345          /**
    346            * @brief  This method must be called - at least - with the same periodicity
    347            *         on which speed control is executed. It computes and returns - through
    348            *         parameter hMecSpeedUnit - the rotor average mechanical speed,
    349            *         expressed in Unit. Average is computed considering a FIFO depth
    350            *         equal to bSpeedBufferSizeUnit. Moreover it also computes and returns
    351            *         the reliability state of the sensor.
    352            * @param  pHandle: handler of the current instance of the STO component
    353            * @param  pMecSpeedUnit pointer to int16_t, used to return the rotor average
    354            *         mechanical speed (expressed in the unit defined by #SPEED_UNIT)
    355            * @retval bool speed sensor reliability, measured with reference to parameters
    356            *         bReliability_hysteresys, hVariancePercentage and bSpeedBufferSize
    357            *         true = sensor information is reliable
    358            *         false = sensor information is not reliable
    359            */
    360          

   \                                 In section .text, align 2
    361          __weak bool STO_PLL_CalcAvrgMecSpeedUnit( STO_PLL_Handle_t * pHandle, int16_t * pMecSpeedUnit )
    362          {
   \                     STO_PLL_CalcAvrgMecSpeedUnit: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    363            int32_t wAvrSpeed_dpp = ( int32_t )0;
    364            int32_t wError, wAux, wAvrSquareSpeed, wAvrQuadraticError = 0;
    365            uint8_t i, bSpeedBufferSizeUnit = pHandle->SpeedBufferSizeUnit;
   \        0x4   0xF100 0x05FC      ADD      R5,R0,#+252
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x7CAB             LDRB     R3,[R5, #+18]
    366            int32_t wObsBemf, wEstBemf;
    367            int32_t wObsBemfSq = 0, wEstBemfSq = 0;
    368            int32_t wEstBemfSqLo;
    369          
    370            bool bIs_Speed_Reliable = false, bAux = false;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0xF04F 0x0900      MOV      R9,#+0
   \       0x14   0x2600             MOVS     R6,#+0
   \       0x16   0x2700             MOVS     R7,#+0
   \       0x18   0x4694             MOV      R12,R2
    371            bool bIs_Bemf_Consistent = false;
   \       0x1A   0x468E             MOV      LR,R1
    372          
    373            for ( i = 0u; i < bSpeedBufferSizeUnit; i++ )
   \       0x1C   0x2400             MOVS     R4,#+0
   \       0x1E   0xF100 0x0B74      ADD      R11,R0,#+116
   \       0x22   0xE003             B.N      ??STO_PLL_CalcAvrgMecSpeedUnit_0
    374            {
    375              wAvrSpeed_dpp += ( int32_t )( pHandle->Speed_Buffer[i] );
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_1: (+1)
   \       0x24   0xF93B 0xA01A      LDRSH    R10,[R11, R10, LSL #+1]
   \       0x28   0x44D1             ADD      R9,R9,R10
    376            }
   \       0x2A   0x1C64             ADDS     R4,R4,#+1
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_0: (+1)
   \       0x2C   0xFA5F 0xFA84      UXTB     R10,R4
   \       0x30   0x459A             CMP      R10,R3
   \       0x32   0xDBF7             BLT.N    ??STO_PLL_CalcAvrgMecSpeedUnit_1
    377          
    378            wAvrSpeed_dpp = wAvrSpeed_dpp / ( int16_t )bSpeedBufferSizeUnit;
   \       0x34   0x461C             MOV      R4,R3
   \       0x36   0xFB99 0xF4F4      SDIV     R4,R9,R4
    379          
    380            for ( i = 0u; i < bSpeedBufferSizeUnit; i++ )
   \       0x3A   0x4689             MOV      R9,R1
   \       0x3C   0xE007             B.N      ??STO_PLL_CalcAvrgMecSpeedUnit_2
    381            {
    382              wError = ( int32_t )( pHandle->Speed_Buffer[i] ) - wAvrSpeed_dpp;
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_3: (+1)
   \       0x3E   0xF93B 0xA01A      LDRSH    R10,[R11, R10, LSL #+1]
   \       0x42   0xEBAA 0x0A04      SUB      R10,R10,R4
    383              wError = ( wError * wError );
    384              wAvrQuadraticError += wError;
   \       0x46   0xFB0A 0x220A      MLA      R2,R10,R10,R2
    385            }
   \       0x4A   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_2: (+1)
   \       0x4E   0xFA5F 0xFA89      UXTB     R10,R9
   \       0x52   0x459A             CMP      R10,R3
   \       0x54   0xDBF3             BLT.N    ??STO_PLL_CalcAvrgMecSpeedUnit_3
    386          
    387            /*It computes the measurement variance   */
    388            wAvrQuadraticError = wAvrQuadraticError / ( int16_t )bSpeedBufferSizeUnit;
    389          
    390            /* The maximum variance acceptable is here calculated as a function of average
    391               speed                                                                    */
    392            wAvrSquareSpeed = wAvrSpeed_dpp * wAvrSpeed_dpp;
    393            wAvrSquareSpeed = ( wAvrSquareSpeed * ( int32_t )( pHandle->VariancePercentage )) / ( int16_t )128;
    394          
    395            if ( wAvrQuadraticError < wAvrSquareSpeed )
   \       0x56   0xF8B5 0x9014      LDRH     R9,[R5, #+20]
   \       0x5A   0xFB04 0xFA04      MUL      R10,R4,R4
   \       0x5E   0xFB09 0xFA0A      MUL      R10,R9,R10
   \       0x62   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \       0x66   0xEA4F 0x13AA      ASR      R3,R10,#+6
   \       0x6A   0xEB0A 0x6353      ADD      R3,R10,R3, LSR #+25
   \       0x6E   0xEBB2 0x1FE3      CMP      R2,R3, ASR #+7
    396            {
    397              bIs_Speed_Reliable = true;
    398            }
    399          
    400            /*Computation of Mechanical speed Unit*/
    401            wAux = wAvrSpeed_dpp * ( int32_t )( pHandle->_Super.hMeasurementFrequency );
    402            wAux = wAux * ( int32_t ) ( pHandle->_Super.SpeedUnit );
    403            wAux = wAux / ( int32_t )( pHandle->_Super.DPPConvFactor);
    404            wAux = wAux / ( int16_t )( pHandle->_Super.bElToMecRatio );
   \       0x72   0x8B43             LDRH     R3,[R0, #+26]
   \       0x74   0x7882             LDRB     R2,[R0, #+2]
   \       0x76   0xBFB8             IT       LT
   \       0x78   0xF04F 0x0C01      MOVLT    R12,#+1
   \       0x7C   0x435C             MULS     R4,R4,R3
   \       0x7E   0x69C3             LDR      R3,[R0, #+28]
   \       0x80   0x4354             MULS     R4,R4,R2
   \       0x82   0x7842             LDRB     R2,[R0, #+1]
   \       0x84   0xFB94 0xF3F3      SDIV     R3,R4,R3
   \       0x88   0xFB93 0xF2F2      SDIV     R2,R3,R2
    405          
    406            *pMecSpeedUnit = ( int16_t )wAux;
   \       0x8C   0xF8A8 0x2000      STRH     R2,[R8, #+0]
    407            pHandle->_Super.hAvrMecSpeedUnit = ( int16_t )wAux;
    408          
    409            pHandle->IsSpeedReliable = bIs_Speed_Reliable;
   \       0x90   0xF100 0x04F5      ADD      R4,R0,#+245
   \       0x94   0x8182             STRH     R2,[R0, #+12]
   \       0x96   0xF884 0xC000      STRB     R12,[R4, #+0]
    410          
    411            /*Bemf Consistency Check algorithm*/
    412            if ( pHandle->EnableDualCheck == true ) /*do algorithm if it's enabled*/
   \       0x9A   0x7A2B             LDRB     R3,[R5, #+8]
   \       0x9C   0x2B01             CMP      R3,#+1
   \       0x9E   0xD12A             BNE.N    ??STO_PLL_CalcAvrgMecSpeedUnit_4
    413            {
    414              wAux = ( wAux < 0 ? ( -wAux ) : ( wAux ) ); /* wAux abs value   */
   \       0xA0   0x0013             MOVS     R3,R2
    415              if ( wAux < ( int32_t )( pHandle->MaxAppPositiveMecSpeedUnit ) )
   \       0xA2   0x8BEA             LDRH     R2,[R5, #+30]
   \       0xA4   0xBF48             IT       MI
   \       0xA6   0x425B             RSBMI    R3,R3,#+0
   \       0xA8   0x4293             CMP      R3,R2
   \       0xAA   0xDA1E             BGE.N    ??STO_PLL_CalcAvrgMecSpeedUnit_5
    416              {
    417                /*Computation of Observed back-emf*/
    418                wObsBemf = ( int32_t )( pHandle->hBemf_alfa_est );
   \       0xAC   0xF9B0 0x2070      LDRSH    R2,[R0, #+112]
    419                wObsBemfSq = wObsBemf * wObsBemf;
    420                wObsBemf = ( int32_t )( pHandle->hBemf_beta_est );
   \       0xB0   0xF9B0 0x6072      LDRSH    R6,[R0, #+114]
    421                wObsBemfSq += wObsBemf * wObsBemf;
    422          
    423                /*Computation of Estimated back-emf*/
    424                wEstBemf = ( wAux * 32767 ) / ( int16_t )( pHandle->_Super.hMaxReliableMecSpeedUnit );
    425                wEstBemfSq = ( wEstBemf * ( int32_t )( pHandle->BemfConsistencyGain ) ) / 64;
    426                wEstBemfSq *= wEstBemf;
   \       0xB4   0x7F6F             LDRB     R7,[R5, #+29]
   \       0xB6   0x4352             MULS     R2,R2,R2
   \       0xB8   0xFB16 0x2606      SMLABB   R6,R6,R6,R2
   \       0xBC   0xF9B0 0x2014      LDRSH    R2,[R0, #+20]
   \       0xC0   0xEBC3 0x33C3      RSB      R3,R3,R3, LSL #+15
   \       0xC4   0xFB93 0xF2F2      SDIV     R2,R3,R2
   \       0xC8   0x4357             MULS     R7,R7,R2
   \       0xCA   0x117B             ASRS     R3,R7,#+5
   \       0xCC   0xEB07 0x6793      ADD      R7,R7,R3, LSR #+26
   \       0xD0   0x11BF             ASRS     R7,R7,#+6
   \       0xD2   0x4357             MULS     R7,R2,R7
    427          
    428                /*Computation of threshold*/
    429                wEstBemfSqLo = wEstBemfSq -
    430                               ( wEstBemfSq / 64 ) * ( int32_t )( pHandle->BemfConsistencyCheck );
    431          
    432                /*Check*/
    433                if ( wObsBemfSq > wEstBemfSqLo )
   \       0xD4   0x117A             ASRS     R2,R7,#+5
   \       0xD6   0xEB07 0x6392      ADD      R3,R7,R2, LSR #+26
   \       0xDA   0x7F2A             LDRB     R2,[R5, #+28]
   \       0xDC   0x119B             ASRS     R3,R3,#+6
   \       0xDE   0xFB02 0x7313      MLS      R3,R2,R3,R7
   \       0xE2   0x42B3             CMP      R3,R6
   \       0xE4   0xBFB8             IT       LT
   \       0xE6   0xF04F 0x0E01      MOVLT    LR,#+1
    434                {
    435                  bIs_Bemf_Consistent = true;
    436                }
    437              }
    438          
    439              pHandle->IsBemfConsistent = bIs_Bemf_Consistent;
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_5: (+1)
   \       0xEA   0xF884 0xE004      STRB     LR,[R4, #+4]
    440              pHandle->Obs_Bemf_Level = wObsBemfSq;
   \       0xEE   0x602E             STR      R6,[R5, #+0]
    441              pHandle->Est_Bemf_Level = wEstBemfSq;
   \       0xF0   0x606F             STR      R7,[R5, #+4]
   \       0xF2   0x4672             MOV      R2,LR
   \       0xF4   0xE000             B.N      ??STO_PLL_CalcAvrgMecSpeedUnit_6
    442            }
    443            else
    444            {
    445              bIs_Bemf_Consistent = true;
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_4: (+1)
   \       0xF6   0x2201             MOVS     R2,#+1
    446            }
    447          
    448            /*Decision making*/
    449            if ( pHandle->IsAlgorithmConverged == false )
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_6: (+1)
   \       0xF8   0x78E6             LDRB     R6,[R4, #+3]
   \       0xFA   0xB196             CBZ.N    R6,??STO_PLL_CalcAvrgMecSpeedUnit_7
    450            {
    451              bAux = SPD_IsMecSpeedReliable ( &pHandle->_Super, pMecSpeedUnit );
    452            }
    453            else
    454            {
    455              if ( ( pHandle->IsSpeedReliable == false ) || ( bIs_Bemf_Consistent == false ) )
   \       0xFC   0x7823             LDRB     R3,[R4, #+0]
   \       0xFE   0x2B00             CMP      R3,#+0
   \      0x100   0xBF18             IT       NE
   \      0x102   0x2A00             CMPNE    R2,#+0
   \      0x104   0xD10C             BNE.N    ??STO_PLL_CalcAvrgMecSpeedUnit_8
    456              {
    457                pHandle->ReliabilityCounter++;
   \      0x106   0x78A2             LDRB     R2,[R4, #+2]
   \      0x108   0x1C52             ADDS     R2,R2,#+1
   \      0x10A   0x70A2             STRB     R2,[R4, #+2]
    458                if ( pHandle->ReliabilityCounter >= pHandle->Reliability_hysteresys )
   \      0x10C   0xB2D2             UXTB     R2,R2
   \      0x10E   0x7EEB             LDRB     R3,[R5, #+27]
   \      0x110   0x429A             CMP      R2,R3
   \      0x112   0xD306             BCC.N    ??STO_PLL_CalcAvrgMecSpeedUnit_7
    459                {
    460                  pHandle->ReliabilityCounter = 0u;
   \      0x114   0x70A1             STRB     R1,[R4, #+2]
    461                  pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
   \      0x116   0x78C3             LDRB     R3,[R0, #+3]
   \      0x118   0x7003             STRB     R3,[R0, #+0]
    462                  bAux = false;
    463                }
    464                else
    465                {
    466                  bAux = SPD_IsMecSpeedReliable ( &pHandle->_Super, pMecSpeedUnit );
    467                }
    468              }
    469              else
    470              {
    471                pHandle->ReliabilityCounter = 0u;
    472                bAux = SPD_IsMecSpeedReliable ( &pHandle->_Super, pMecSpeedUnit );
    473              }
    474            }
    475            return ( bAux );
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_9: (+1)
   \      0x11A   0x4608             MOV      R0,R1
   \      0x11C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_8: (+1)
   \      0x120   0x70A1             STRB     R1,[R4, #+2]
   \                     ??STO_PLL_CalcAvrgMecSpeedUnit_7: (+1)
   \      0x122   0x4641             MOV      R1,R8
   \      0x124   0x....'....        BL       SPD_IsMecSpeedReliable
   \      0x128   0x4601             MOV      R1,R0
   \      0x12A   0xE7F6             B.N      ??STO_PLL_CalcAvrgMecSpeedUnit_9
    476          }
    477          
    478          #if defined (CCMRAM)
    479          #if defined (__ICCARM__)
    480          #pragma location = ".ccmram"
    481          #elif defined (__CC_ARM) || defined(__GNUC__)
    482          __attribute__( ( section ( ".ccmram" ) ) )
    483          #endif
    484          #endif
    485          /**
    486            * @brief  This method must be called - at least - with the same periodicity
    487            *         on which speed control is executed. It computes and update component
    488            *         variable hElSpeedDpp that is estimated average electrical speed
    489            *         expressed in dpp used for instance in observer equations.
    490            *         Average is computed considering a FIFO depth equal to
    491            *         bSpeedBufferSizedpp.
    492            * @param  pHandle: handler of the current instance of the STO component
    493            * @retval none
    494            */

   \                                 In section .text, align 2
    495          __weak void STO_PLL_CalcAvrgElSpeedDpp( STO_PLL_Handle_t * pHandle )
    496          {
   \                     STO_PLL_CalcAvrgElSpeedDpp: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    497          
    498            int16_t hIndexNew = ( int16_t )pHandle->Speed_Buffer_Index;
   \        0x2   0xF100 0x02F4      ADD      R2,R0,#+244
    499            int16_t hIndexOld;
    500            int16_t hIndexOldTemp;
    501            int32_t wSum = pHandle->DppBufferSum;
    502            int32_t wAvrSpeed_dpp;
    503            int16_t hSpeedBufferSizedpp = ( int16_t )( pHandle->SpeedBufferSizeDpp );
    504            int16_t hSpeedBufferSizeUnit = ( int16_t )( pHandle->SpeedBufferSizeUnit );
   \        0x6   0x7E95             LDRB     R5,[R2, #+26]
    505            int16_t hBufferSizeDiff;
    506          
    507            hBufferSizeDiff = hSpeedBufferSizeUnit - hSpeedBufferSizedpp;
   \        0x8   0x7ED1             LDRB     R1,[R2, #+27]
   \        0xA   0x7813             LDRB     R3,[R2, #+0]
   \        0xC   0x6954             LDR      R4,[R2, #+20]
   \        0xE   0x1A69             SUBS     R1,R5,R1
    508          
    509            if ( hBufferSizeDiff == 0 )
   \       0x10   0xD107             BNE.N    ??STO_PLL_CalcAvrgElSpeedDpp_0
    510            {
    511              wSum = wSum + pHandle->Speed_Buffer[hIndexNew] -
    512                     pHandle->SpeedBufferOldestEl;
   \       0x12   0xF100 0x0174      ADD      R1,R0,#+116
   \       0x16   0xF931 0x3013      LDRSH    R3,[R1, R3, LSL #+1]
   \       0x1A   0xF9B2 0x1018      LDRSH    R1,[R2, #+24]
   \       0x1E   0x18E3             ADDS     R3,R4,R3
   \       0x20   0xE00D             B.N      ??STO_PLL_CalcAvrgElSpeedDpp_1
    513            }
    514            else
    515            {
    516              hIndexOldTemp = hIndexNew + hBufferSizeDiff;
   \                     ??STO_PLL_CalcAvrgElSpeedDpp_0: (+1)
   \       0x22   0x18C9             ADDS     R1,R1,R3
    517          
    518              if ( hIndexOldTemp >= hSpeedBufferSizeUnit )
   \       0x24   0x42A9             CMP      R1,R5
   \       0x26   0xBFAC             ITE      GE
   \       0x28   0x1B4D             SUBGE    R5,R1,R5
   \       0x2A   0x460D             MOVLT    R5,R1
    519              {
    520                hIndexOld = hIndexOldTemp - hSpeedBufferSizeUnit;
    521              }
    522              else
    523              {
    524                hIndexOld = hIndexOldTemp;
    525              }
    526          
    527              wSum = wSum + pHandle->Speed_Buffer[hIndexNew] -
    528                     pHandle->Speed_Buffer[hIndexOld];
   \       0x2C   0xF100 0x0174      ADD      R1,R0,#+116
   \       0x30   0xF931 0x3013      LDRSH    R3,[R1, R3, LSL #+1]
   \       0x34   0x18E3             ADDS     R3,R4,R3
   \       0x36   0xF100 0x0474      ADD      R4,R0,#+116
   \       0x3A   0xF934 0x1015      LDRSH    R1,[R4, R5, LSL #+1]
   \                     ??STO_PLL_CalcAvrgElSpeedDpp_1: (+1)
   \       0x3E   0x1A59             SUBS     R1,R3,R1
    529            }
    530          
    531          #ifdef FULL_MISRA_C_COMPLIANCY
    532            wAvrSpeed_dpp = wSum / hSpeedBufferSizeDpp;
    533          #else
    534            wAvrSpeed_dpp = wSum >> pHandle->SpeedBufferSizeDppLOG;
    535          #endif
    536          
    537            pHandle->_Super.hElSpeedDpp = ( int16_t )wAvrSpeed_dpp;
   \       0x40   0x8D93             LDRH     R3,[R2, #+44]
   \       0x42   0xFA41 0xF403      ASR      R4,R1,R3
   \       0x46   0x81C4             STRH     R4,[R0, #+14]
    538            pHandle->DppBufferSum = wSum;
   \       0x48   0x6151             STR      R1,[R2, #+20]
    539          }
   \       0x4A   0xBD30             POP      {R4,R5,PC}       ;; return
    540          
    541          /**
    542            * @brief  It clears state observer component by re-initializing private variables
    543            * @param  pHandle related object of class CSTO_SPD
    544            * @retval none
    545            */

   \                                 In section .text, align 2
    546          __weak void STO_PLL_Clear( STO_PLL_Handle_t * pHandle )
    547          {
   \                     STO_PLL_Clear: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    548            pHandle->Ialfa_est = ( int32_t )0;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6601             STR      R1,[R0, #+96]
    549            pHandle->Ibeta_est = ( int32_t )0;
    550            pHandle->wBemf_alfa_est = ( int32_t )0;
   \        0x6   0x6681             STR      R1,[R0, #+104]
    551            pHandle->wBemf_beta_est = ( int32_t )0;
    552            pHandle->_Super.hElAngle = ( int16_t )0;
   \        0x8   0x8081             STRH     R1,[R0, #+4]
   \        0xA   0x2200             MOVS     R2,#+0
    553            pHandle->_Super.hElSpeedDpp = ( int16_t )0;
    554            pHandle->ConsistencyCounter = 0u;
   \        0xC   0xF100 0x01F4      ADD      R1,R0,#+244
   \       0x10   0x6642             STR      R2,[R0, #+100]
   \       0x12   0x66C2             STR      R2,[R0, #+108]
   \       0x14   0x81C2             STRH     R2,[R0, #+14]
    555            pHandle->ReliabilityCounter = 0u;
   \       0x16   0x70CA             STRB     R2,[R1, #+3]
    556            pHandle->IsAlgorithmConverged = false;
    557            pHandle->IsBemfConsistent = false;
   \       0x18   0x714A             STRB     R2,[R1, #+5]
    558            pHandle->Obs_Bemf_Level = ( int32_t )0;
    559            pHandle->Est_Bemf_Level = ( int32_t )0;
   \       0x1A   0x60CA             STR      R2,[R1, #+12]
   \       0x1C   0x2300             MOVS     R3,#+0
    560            pHandle->DppBufferSum = ( int32_t )0;
    561            pHandle->ForceConvergency = false;
   \       0x1E   0xF500 0x7291      ADD      R2,R0,#+290
   \       0x22   0x708B             STRB     R3,[R1, #+2]
   \       0x24   0x710B             STRB     R3,[R1, #+4]
   \       0x26   0x608B             STR      R3,[R1, #+8]
   \       0x28   0x614B             STR      R3,[R1, #+20]
   \       0x2A   0x7013             STRB     R3,[R2, #+0]
    562            pHandle->ForceConvergency2 = false;
   \       0x2C   0x7053             STRB     R3,[R2, #+1]
    563          
    564            STO_InitSpeedBuffer( pHandle );
   \       0x2E   0x2500             MOVS     R5,#+0
   \       0x30   0x7E8A             LDRB     R2,[R1, #+26]
   \       0x32   0xE004             B.N      ??STO_PLL_Clear_0
   \                     ??STO_PLL_Clear_1: (+1)
   \       0x34   0xEB00 0x0444      ADD      R4,R0,R4, LSL #+1
   \       0x38   0x1C5B             ADDS     R3,R3,#+1
   \       0x3A   0xF8A4 0x5074      STRH     R5,[R4, #+116]
   \                     ??STO_PLL_Clear_0: (+1)
   \       0x3E   0xB2DC             UXTB     R4,R3
   \       0x40   0x4294             CMP      R4,R2
   \       0x42   0xDBF7             BLT.N    ??STO_PLL_Clear_1
   \       0x44   0x700D             STRB     R5,[R1, #+0]
   \       0x46   0x830D             STRH     R5,[R1, #+24]
    565            PID_SetIntegralTerm( & pHandle->PIRegulator, ( int32_t )0 );
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x4E   0x3034             ADDS     R0,R0,#+52
   \       0x50   0x....'....        B.W      PID_SetIntegralTerm
    566          }
    567          
    568          /**
    569            * @brief  It stores in estimated speed FIFO latest calculated value of motor
    570            *         speed
    571            * @param  pHandle: handler of the current instance of the STO component
    572            * @retval none
    573            */
    574          inline static void STO_Store_Rotor_Speed( STO_PLL_Handle_t * pHandle, int16_t hRotor_Speed )
    575          {
    576          
    577            uint8_t bBuffer_index = pHandle->Speed_Buffer_Index;
    578          
    579            bBuffer_index++;
    580            if ( bBuffer_index == pHandle->SpeedBufferSizeUnit )
    581            {
    582              bBuffer_index = 0u;
    583            }
    584          
    585            pHandle->SpeedBufferOldestEl = pHandle->Speed_Buffer[bBuffer_index];
    586          
    587            pHandle->Speed_Buffer[bBuffer_index] = hRotor_Speed;
    588            pHandle->Speed_Buffer_Index = bBuffer_index;
    589          }
    590          
    591          /**
    592            * @brief  It executes PLL algorithm for rotor position extraction from B-emf
    593            *         alpha and beta
    594            * @param  pHandle: handler of the current instance of the STO component
    595            *         hBemf_alfa_est estimated Bemf alpha on the stator reference frame
    596            *         hBemf_beta_est estimated Bemf beta on the stator reference frame
    597            * @retval none
    598            */
    599          inline static int16_t STO_ExecutePLL( STO_PLL_Handle_t * pHandle, int16_t hBemf_alfa_est, int16_t
    600                                         hBemf_beta_est )
    601          {
    602            int32_t wAlfa_Sin_tmp, wBeta_Cos_tmp;
    603            int16_t hOutput;
    604            Trig_Components Local_Components;
    605            int16_t hAux1, hAux2;
    606          
    607            Local_Components = MCM_Trig_Functions( pHandle->_Super.hElAngle );
    608          
    609            /* Alfa & Beta BEMF multiplied by Cos & Sin*/
    610            wAlfa_Sin_tmp = ( int32_t )( hBemf_alfa_est ) * ( int32_t )Local_Components.hSin;
    611            wBeta_Cos_tmp = ( int32_t )( hBemf_beta_est ) * ( int32_t )Local_Components.hCos;
    612          
    613          #ifdef FULL_MISRA_C_COMPLIANCY
    614            hAux1 = ( int16_t )( wBeta_Cos_tmp / 32768 );
    615          #else
    616            hAux1 = ( int16_t )( wBeta_Cos_tmp >> 15 );
    617          #endif
    618          
    619          #ifdef FULL_MISRA_C_COMPLIANCY
    620            hAux2 = ( int16_t )( wAlfa_Sin_tmp / 32768 );
    621          #else
    622            hAux2 = ( int16_t )( wAlfa_Sin_tmp >> 15 );
    623          #endif
    624          
    625            /* Speed PI regulator */
    626            hOutput = PI_Controller( & pHandle->PIRegulator, ( int32_t )( hAux1 ) - hAux2 );
    627          
    628            return ( hOutput );
    629          }
    630          
    631          /**
    632            * @brief  It clears the estimated speed buffer
    633            * @param  pHandle: handler of the current instance of the STO component
    634            * @retval none
    635            */
    636          static void STO_InitSpeedBuffer( STO_PLL_Handle_t * pHandle )
    637          {
    638            uint8_t b_i;
    639            uint8_t bSpeedBufferSize = pHandle->SpeedBufferSizeUnit;
    640          
    641            /*init speed buffer*/
    642            for ( b_i = 0u; b_i < bSpeedBufferSize; b_i++ )
    643            {
    644              pHandle->Speed_Buffer[b_i] = ( int16_t )0;
    645            }
    646            pHandle->Speed_Buffer_Index = 0u;
    647            pHandle->SpeedBufferOldestEl = ( int16_t )0;
    648          
    649            return;
    650          }
    651          
    652          /**
    653            * @brief  It internally performs a set of checks necessary to state whether
    654            *         the state observer algorithm converged. To be periodically called
    655            *         during motor open-loop ramp-up (e.g. at the same frequency of
    656            *         SPD_CalcElAngle), it returns true if the estimated angle and speed
    657            *         can be considered reliable, false otherwise
    658            * @param  pHandle: handler of the current instance of the STO component
    659            * @param  hForcedMecSpeedUnit Mechanical speed in 0.1Hz unit as forced by VSS
    660            * @retval bool sensor reliability state
    661            */

   \                                 In section .text, align 2
    662          __weak bool STO_PLL_IsObserverConverged( STO_PLL_Handle_t * pHandle, int16_t hForcedMecSpeedUnit )
    663          {
   \                     STO_PLL_IsObserverConverged: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    664            int16_t hEstimatedSpeedUnit, hUpperThreshold, hLowerThreshold;
    665            int32_t wAux;
    666            bool bAux = false;
    667            int32_t wtemp;
    668          
    669            
    670            pHandle->hForcedAvrSpeed_VSS = hForcedMecSpeedUnit;
   \        0x2   0xF500 0x748A      ADD      R4,R0,#+276
   \        0x6   0x460A             MOV      R2,R1
    671            
    672            
    673            if ( pHandle->ForceConvergency2 == true )
   \        0x8   0x7BE3             LDRB     R3,[R4, #+15]
   \        0xA   0x8222             STRH     R2,[R4, #+16]
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x2B01             CMP      R3,#+1
    674            {
    675              hForcedMecSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
    676            }
    677          
    678            if ( pHandle->ForceConvergency == true )
   \       0x10   0x7BA3             LDRB     R3,[R4, #+14]
   \       0x12   0xBF08             IT       EQ
   \       0x14   0xF9B0 0x200C      LDRSHEQ  R2,[R0, #+12]
   \       0x18   0x2B01             CMP      R3,#+1
   \       0x1A   0xF100 0x05F5      ADD      R5,R0,#+245
   \       0x1E   0xD02F             BEQ.N    ??STO_PLL_IsObserverConverged_0
    679            {
    680              bAux = true;
    681              pHandle->IsAlgorithmConverged = true;
    682              pHandle->_Super.bSpeedErrorNumber = 0u;
    683            }
    684            else
    685            {
    686              hEstimatedSpeedUnit = pHandle->_Super.hAvrMecSpeedUnit;
   \       0x20   0xF9B0 0x600C      LDRSH    R6,[R0, #+12]
    687          
    688              wtemp = ( int32_t )hEstimatedSpeedUnit * ( int32_t )hForcedMecSpeedUnit;
    689          
    690              if ( wtemp > 0 )
   \       0x24   0xFB12 0xF706      SMULBB   R7,R2,R6
   \       0x28   0x2F00             CMP      R7,#+0
   \       0x2A   0xDD2F             BLE.N    ??STO_PLL_IsObserverConverged_1
    691              {
    692                if ( hEstimatedSpeedUnit < 0 )
   \       0x2C   0x2E00             CMP      R6,#+0
   \       0x2E   0xBF44             ITT      MI
   \       0x30   0x4276             RSBMI    R6,R6,#+0
   \       0x32   0xB236             SXTHMI   R6,R6
    693                {
    694                  hEstimatedSpeedUnit = -hEstimatedSpeedUnit;
    695                }
    696          
    697                if ( hForcedMecSpeedUnit < 0 )
   \       0x34   0x2A00             CMP      R2,#+0
   \       0x36   0xBF48             IT       MI
   \       0x38   0x4252             RSBMI    R2,R2,#+0
    698                {
    699                  hForcedMecSpeedUnit = -hForcedMecSpeedUnit;
    700                }
    701                wAux = ( int32_t ) ( hForcedMecSpeedUnit ) * ( int16_t )pHandle->SpeedValidationBand_H;
    702                hUpperThreshold = ( int16_t )( wAux / ( int32_t )16 );
   \       0x3A   0x7F6F             LDRB     R7,[R5, #+29]
   \       0x3C   0xB212             SXTH     R2,R2
   \       0x3E   0xFB17 0xF702      SMULBB   R7,R7,R2
   \       0x42   0x10FB             ASRS     R3,R7,#+3
   \       0x44   0xEB07 0x7713      ADD      R7,R7,R3, LSR #+28
    703          
    704                wAux = ( int32_t ) ( hForcedMecSpeedUnit ) * ( int16_t )pHandle->SpeedValidationBand_L;
    705                hLowerThreshold = ( int16_t )( wAux / ( int32_t )16 );
   \       0x48   0x7FAB             LDRB     R3,[R5, #+30]
   \       0x4A   0x435A             MULS     R2,R3,R2
   \       0x4C   0x10D3             ASRS     R3,R2,#+3
   \       0x4E   0xEB02 0x7213      ADD      R2,R2,R3, LSR #+28
    706          
    707                /* If the variance of the estimated speed is low enough...*/
    708                if ( pHandle->IsSpeedReliable == true )
   \       0x52   0x782B             LDRB     R3,[R5, #+0]
   \       0x54   0x033F             LSLS     R7,R7,#+12
   \       0x56   0x0312             LSLS     R2,R2,#+12
   \       0x58   0x2B01             CMP      R3,#+1
   \       0x5A   0xD116             BNE.N    ??STO_PLL_IsObserverConverged_2
    709                {
    710                  if ( ( uint16_t )hEstimatedSpeedUnit > pHandle->MinStartUpValidSpeed )
   \       0x5C   0x8823             LDRH     R3,[R4, #+0]
   \       0x5E   0xFA1F 0xFE86      UXTH     LR,R6
   \       0x62   0x4573             CMP      R3,LR
   \       0x64   0xD211             BCS.N    ??STO_PLL_IsObserverConverged_2
    711                  {
    712                    /*...and the estimated value is quite close to the expected value... */
    713                    if ( hEstimatedSpeedUnit >= hLowerThreshold )
   \       0x66   0xEBB6 0x4F22      CMP      R6,R2, ASR #+16
   \       0x6A   0xBFA4             ITT      GE
   \       0x6C   0x143F             ASRGE    R7,R7,#+16
   \       0x6E   0x42B7             CMPGE    R7,R6
    714                    {
    715                      if ( hEstimatedSpeedUnit <= hUpperThreshold )
   \       0x70   0xDB0B             BLT.N    ??STO_PLL_IsObserverConverged_2
    716                      {
    717                        pHandle->ConsistencyCounter++;
   \       0x72   0x786A             LDRB     R2,[R5, #+1]
   \       0x74   0x1C52             ADDS     R2,R2,#+1
   \       0x76   0x706A             STRB     R2,[R5, #+1]
    718          
    719                        /*... for hConsistencyThreshold consecutive times... */
    720                        if ( pHandle->ConsistencyCounter >=
    721                             pHandle->StartUpConsistThreshold )
   \       0x78   0xB2D2             UXTB     R2,R2
   \       0x7A   0x78A3             LDRB     R3,[R4, #+2]
   \       0x7C   0x429A             CMP      R2,R3
   \       0x7E   0xD305             BCC.N    ??STO_PLL_IsObserverConverged_1
    722                        {
    723          
    724                          /* the algorithm converged.*/
    725                          bAux = true;
   \                     ??STO_PLL_IsObserverConverged_0: (+1)
   \       0x80   0x2101             MOVS     R1,#+1
    726                          pHandle->IsAlgorithmConverged = true;
   \       0x82   0x70E9             STRB     R1,[R5, #+3]
    727                          pHandle->_Super.bSpeedErrorNumber = 0u;
   \       0x84   0x2300             MOVS     R3,#+0
   \       0x86   0x7003             STRB     R3,[R0, #+0]
   \       0x88   0xE000             B.N      ??STO_PLL_IsObserverConverged_1
    728                        }
    729                      }
    730                      else
    731                      {
    732                        pHandle->ConsistencyCounter = 0u;
    733                      }
    734                    }
    735                    else
    736                    {
    737                      pHandle->ConsistencyCounter = 0u;
    738                    }
    739                  }
    740                  else
    741                  {
    742                    pHandle->ConsistencyCounter = 0u;
    743                  }
    744                }
    745                else
    746                {
    747                  pHandle->ConsistencyCounter = 0u;
   \                     ??STO_PLL_IsObserverConverged_2: (+1)
   \       0x8A   0x7069             STRB     R1,[R5, #+1]
    748                }
    749              }
    750            }
    751          
    752            return ( bAux );
   \                     ??STO_PLL_IsObserverConverged_1: (+1)
   \       0x8C   0x4608             MOV      R0,R1
   \       0x8E   0xBDF0             POP      {R4-R7,PC}       ;; return
    753          }
    754          
    755          /**
    756            * @brief  It exports estimated Bemf alpha-beta in alphabeta_t format
    757            * @param  pHandle: handler of the current instance of the STO component
    758            * @retval alphabeta_t Bemf alpha-beta
    759            */

   \                                 In section .text, align 2
    760          __weak alphabeta_t STO_PLL_GetEstimatedBemf( STO_PLL_Handle_t * pHandle )
    761          {
   \                     STO_PLL_GetEstimatedBemf: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    762            alphabeta_t Vaux;
    763            Vaux.alpha = pHandle->hBemf_alfa_est;
   \        0x2   0xF9B0 0x1070      LDRSH    R1,[R0, #+112]
   \        0x6   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    764            Vaux.beta = pHandle->hBemf_beta_est;
   \        0xA   0xF8B0 0x0072      LDRH     R0,[R0, #+114]
   \        0xE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    765            return ( Vaux );
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0xB001             ADD      SP,SP,#+4
   \       0x16   0x4770             BX       LR               ;; return
    766          }
    767          
    768          
    769          /**
    770            * @brief  It exports the stator current alpha-beta as estimated by state
    771            *         observer
    772            * @param  pHandle: handler of the current instance of the STO component
    773            * @retval alphabeta_t State observer estimated stator current Ialpha-beta
    774            */

   \                                 In section .text, align 2
    775          __weak alphabeta_t STO_PLL_GetEstimatedCurrent( STO_PLL_Handle_t * pHandle )
    776          {
   \                     STO_PLL_GetEstimatedCurrent: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    777            alphabeta_t Iaux;
    778          
    779          #ifdef FULL_MISRA_C_COMPLIANCY
    780            Iaux.alpha = ( int16_t )( pHandle->Ialfa_est / ( pHandle->hF1 ) );
    781          #else
    782            Iaux.alpha = ( int16_t )( pHandle->Ialfa_est >> pHandle->F1LOG );
   \        0x2   0xF8B0 0x111C      LDRH     R1,[R0, #+284]
   \        0x6   0x6E02             LDR      R2,[R0, #+96]
   \        0x8   0x410A             ASRS     R2,R2,R1
   \        0xA   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    783          #endif
    784          
    785          #ifdef FULL_MISRA_C_COMPLIANCY
    786            Iaux.beta = ( int16_t )( pHandle->Ibeta_est / ( pHandle->hF1 ) );
    787          #else
    788            Iaux.beta = ( int16_t )( pHandle->Ibeta_est >> pHandle->F1LOG );
   \        0xE   0x6E40             LDR      R0,[R0, #+100]
   \       0x10   0x4108             ASRS     R0,R0,R1
   \       0x12   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    789          #endif
    790          
    791            return ( Iaux );
   \       0x16   0x9800             LDR      R0,[SP, #+0]
   \       0x18   0xB001             ADD      SP,SP,#+4
   \       0x1A   0x4770             BX       LR               ;; return
    792          }
    793          
    794          /**
    795            * @brief  It exports current observer gains through parameters hhC2 and hhC4
    796            * @param  pHandle: handler of the current instance of the STO component
    797            * @param  phC2 pointer to int16_t used to return parameters hhC2
    798            * @param  phC4 pointer to int16_t used to return parameters hhC4
    799            * @retval none
    800            */

   \                                 In section .text, align 2
    801          __weak void STO_PLL_GetObserverGains( STO_PLL_Handle_t * pHandle, int16_t * phC2, int16_t * phC4 )
    802          {
    803            *phC2 = pHandle->hC2;
   \                     STO_PLL_GetObserverGains: (+1)
   \        0x0   0x8C43             LDRH     R3,[R0, #+34]
   \        0x2   0x800B             STRH     R3,[R1, #+0]
    804            *phC4 = pHandle->hC4;
   \        0x4   0x8CC0             LDRH     R0,[R0, #+38]
   \        0x6   0x8010             STRH     R0,[R2, #+0]
    805          }
   \        0x8   0x4770             BX       LR               ;; return
    806          
    807          
    808          /**
    809            * @brief  It allows setting new values for observer gains
    810            * @param  pHandle: handler of the current instance of the STO component
    811            * @param  wK1 new value for observer gain hhC1
    812            * @param  wK2 new value for observer gain hhC2
    813            * @retval none
    814            */

   \                                 In section .text, align 2
    815          __weak void STO_PLL_SetObserverGains( STO_PLL_Handle_t * pHandle, int16_t hhC1, int16_t hhC2 )
    816          {
    817          
    818            pHandle->hC2 = hhC1;
   \                     STO_PLL_SetObserverGains: (+1)
   \        0x0   0x8441             STRH     R1,[R0, #+34]
    819            pHandle->hC4 = hhC2;
   \        0x2   0x84C2             STRH     R2,[R0, #+38]
    820          }
   \        0x4   0x4770             BX       LR               ;; return
    821          
    822          /**
    823            * @brief  It exports current PLL gains through parameters pPgain and pIgain
    824            * @param  pHandle: handler of the current instance of the STO component
    825            * @param  pPgain pointer to int16_t used to return PLL proportional gain
    826            * @param  pIgain pointer to int16_t used to return PLL integral gain
    827            * @retval none
    828            */

   \                                 In section .text, align 2
    829          __weak void STO_GetPLLGains( STO_PLL_Handle_t * pHandle, int16_t * pPgain, int16_t * pIgain )
    830          {
   \                     STO_GetPLLGains: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    831          
    832            *pPgain = PID_GetKP( & pHandle->PIRegulator );
   \        0x8   0xF104 0x0034      ADD      R0,R4,#+52
   \        0xC   0x....'....        BL       PID_GetKP
   \       0x10   0x8028             STRH     R0,[R5, #+0]
    833            *pIgain = PID_GetKI( & pHandle->PIRegulator );
   \       0x12   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x16   0x....'....        BL       PID_GetKI
   \       0x1A   0x8030             STRH     R0,[R6, #+0]
    834          }
   \       0x1C   0xBD70             POP      {R4-R6,PC}       ;; return
    835          
    836          
    837          /**
    838            * @brief  It allows setting new values for PLL gains
    839            * @param  pHandle: handler of the current instance of the STO component
    840            * @param  hPgain new value for PLL proportional gain
    841            * @param  hIgain new value for PLL integral gain
    842            * @retval none
    843            */

   \                                 In section .text, align 2
    844          __weak void STO_SetPLLGains( STO_PLL_Handle_t * pHandle, int16_t hPgain, int16_t hIgain )
    845          {
   \                     STO_SetPLLGains: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
    846            PID_SetKP( & pHandle->PIRegulator, hPgain );
   \        0x6   0xF104 0x0034      ADD      R0,R4,#+52
   \        0xA   0x....'....        BL       PID_SetKP
    847            PID_SetKI( & pHandle->PIRegulator, hIgain );
   \        0xE   0x4629             MOV      R1,R5
   \       0x10   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x14   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x18   0x....'....        B.W      PID_SetKI
    848          }
    849          
    850          
    851          /**
    852            * @brief  It could be used to set istantaneous information on rotor mechanical
    853            *         angle.
    854            *         Note: Mechanical angle management is not implemented in this
    855            *         version of State observer sensor class.
    856            * @param  pHandle: handler of the current instance of the STO component
    857            * @param  hMecAngle istantaneous measure of rotor mechanical angle
    858            * @retval none
    859            */

   \                                 In section .text, align 2
    860          __weak void STO_PLL_SetMecAngle( STO_PLL_Handle_t * pHandle, int16_t hMecAngle )
    861          {
    862          }
   \                     STO_PLL_SetMecAngle: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    863          
    864          /**
    865            * @brief  It resets integral term of PLL during on-the-fly startup
    866            * @param  pHandle: handler of the current instance of the STO component
    867            * @retval none
    868            */

   \                                 In section .text, align 2
    869          __weak void STO_OTF_ResetPLL( STO_Handle_t * pHandle )
    870          {
    871            STO_PLL_Handle_t * pHdl = ( STO_PLL_Handle_t * )pHandle->_Super;
    872            PID_SetIntegralTerm( &pHdl->PIRegulator, ( int32_t )0 );
   \                     STO_OTF_ResetPLL: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x3034             ADDS     R0,R0,#+52
   \        0x6   0x....'....        B.W      PID_SetIntegralTerm
    873          }
    874          
    875          #if defined (CCMRAM)
    876          #if defined (__ICCARM__)
    877          #pragma location = ".ccmram"
    878          #elif defined (__CC_ARM) || defined(__GNUC__)
    879          __attribute__( ( section ( ".ccmram" ) ) )
    880          #endif
    881          #endif
    882          /**
    883            * @brief  It resets integral term of PLL
    884            * @param  pHandle: handler of the current instance of the STO component
    885            * @retval none
    886            */

   \                                 In section .text, align 2
    887          __weak void STO_ResetPLL( STO_PLL_Handle_t * pHandle )
    888          {
    889            PID_SetIntegralTerm( &pHandle->PIRegulator, ( int32_t )0 );
   \                     STO_ResetPLL: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x3034             ADDS     R0,R0,#+52
   \        0x4   0x....'....        B.W      PID_SetIntegralTerm
    890          }
    891          
    892          /**
    893            * @brief  It sends locking info for PLL
    894            * @param  pHandle: handler of the current instance of the STO component
    895            * @param  hElSpeedDpp:
    896            * @param  hElAngle:
    897            * @retval none
    898            */

   \                                 In section .text, align 2
    899          __weak void STO_SetPLL( STO_PLL_Handle_t * pHandle, int16_t hElSpeedDpp, int16_t hElAngle )
    900          {
   \                     STO_SetPLL: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    901            PID_SetIntegralTerm( & pHandle->PIRegulator,
    902                                 ( int32_t )hElSpeedDpp * ( int32_t )PID_GetKIDivisor( & pHandle->PIRegulator ) );
   \        0x8   0xF104 0x0034      ADD      R0,R4,#+52
   \        0xC   0x....'....        BL       PID_GetKIDivisor
   \       0x10   0x4345             MULS     R5,R0,R5
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x18   0x....'....        BL       PID_SetIntegralTerm
    903            pHandle->_Super.hElAngle = hElAngle;
   \       0x1C   0x80A6             STRH     R6,[R4, #+4]
    904          }
   \       0x1E   0xBD70             POP      {R4-R6,PC}       ;; return
    905          
    906          /**
    907            * @brief  It exports estimated Bemf squared level
    908            * @param  pHandle: handler of the current instance of the STO component
    909            * @retval int32_t
    910            */

   \                                 In section .text, align 2
    911          __weak int32_t STO_PLL_GetEstimatedBemfLevel( STO_PLL_Handle_t * pHandle )
    912          {
    913            return ( pHandle->Est_Bemf_Level );
   \                     STO_PLL_GetEstimatedBemfLevel: (+1)
   \        0x0   0xF8D0 0x0100      LDR      R0,[R0, #+256]
   \        0x4   0x4770             BX       LR               ;; return
    914          }
    915          
    916          /**
    917            * @brief  It exports observed Bemf squared level
    918            * @param  pHandle: handler of the current instance of the STO component
    919            * @retval int32_t
    920            */

   \                                 In section .text, align 2
    921          __weak int32_t STO_PLL_GetObservedBemfLevel( STO_PLL_Handle_t * pHandle )
    922          {
    923            return ( pHandle->Obs_Bemf_Level );
   \                     STO_PLL_GetObservedBemfLevel: (+1)
   \        0x0   0xF8D0 0x00FC      LDR      R0,[R0, #+252]
   \        0x4   0x4770             BX       LR               ;; return
    924          }
    925          
    926          /**
    927            * @brief  It enables/disables the bemf consistency check
    928            * @param  pHandle: handler of the current instance of the STO component
    929            * @param  bSel boolean; true enables check; false disables check
    930            */

   \                                 In section .text, align 2
    931          __weak void STO_PLL_BemfConsistencyCheckSwitch( STO_PLL_Handle_t * pHandle, bool bSel )
    932          {
    933            pHandle->EnableDualCheck = bSel;
   \                     STO_PLL_BemfConsistencyCheckSwitch: (+1)
   \        0x0   0xF880 0x1104      STRB     R1,[R0, #+260]
    934          }
   \        0x4   0x4770             BX       LR               ;; return
    935          
    936          /**
    937            * @brief  It returns the result of the Bemf consistency check
    938            * @param  pHandle: handler of the current instance of the STO component
    939            * @retval bool Bemf consistency state
    940            */

   \                                 In section .text, align 2
    941          __weak bool STO_PLL_IsBemfConsistent( STO_PLL_Handle_t * pHandle )
    942          {
    943            return ( pHandle->IsBemfConsistent );
   \                     STO_PLL_IsBemfConsistent: (+1)
   \        0x0   0xF890 0x00F9      LDRB     R0,[R0, #+249]
   \        0x4   0x4770             BX       LR               ;; return
    944          }
    945          
    946          /**
    947            * @brief  It returns the result of the last variance check
    948            * @param  pHandle: handler of the current instance of the STO component
    949            * @retval bool Variance state
    950            */

   \                                 In section .text, align 2
    951          __weak bool STO_PLL_IsVarianceTight( const STO_Handle_t * pHandle )
    952          {
    953            STO_PLL_Handle_t * pHdl = ( STO_PLL_Handle_t * )pHandle->_Super;
    954            return ( pHdl->IsSpeedReliable );
   \                     STO_PLL_IsVarianceTight: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0xF890 0x00F5      LDRB     R0,[R0, #+245]
   \        0x6   0x4770             BX       LR               ;; return
    955          }
    956          
    957          /**
    958            * @brief  It forces the state-observer to declare convergency
    959            * @param  pHandle: handler of the current instance of the STO component
    960            */

   \                                 In section .text, align 2
    961          __weak void STO_PLL_ForceConvergency1( STO_Handle_t * pHandle )
    962          {
    963            STO_PLL_Handle_t * pHdl = ( STO_PLL_Handle_t * )pHandle->_Super;
    964            pHdl->ForceConvergency = true;
   \                     STO_PLL_ForceConvergency1: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x1122      STRB     R1,[R0, #+290]
    965          }
   \        0x8   0x4770             BX       LR               ;; return
    966          
    967          /**
    968            * @brief  It forces the state-observer to declare convergency
    969            * @param  pHandle: handler of the current instance of the STO component
    970            */

   \                                 In section .text, align 2
    971          __weak void STO_PLL_ForceConvergency2( STO_Handle_t * pHandle )
    972          {
    973            STO_PLL_Handle_t * pHdl = ( STO_PLL_Handle_t * )pHandle->_Super;
    974            pHdl->ForceConvergency2 = true;
   \                     STO_PLL_ForceConvergency2: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0xF880 0x1123      STRB     R1,[R0, #+291]
    975          }
   \        0x8   0x4770             BX       LR               ;; return
    976          
    977          /**
    978            * @brief  Set the Absolute value of minimum mechanical speed (expressed in
    979            *         the unit defined by #SPEED_UNIT) required to validate the start-up.
    980            * @param  pHandle: handler of the current instance of the STO component
    981            * @param  hMinStartUpValidSpeed: Absolute value of minimum mechanical speed
    982            */

   \                                 In section .text, align 2
    983          __weak void STO_SetMinStartUpValidSpeedUnit( STO_PLL_Handle_t * pHandle, uint16_t hMinStartUpValidSpeed )
    984          {
    985            pHandle->MinStartUpValidSpeed = hMinStartUpValidSpeed;
   \                     STO_SetMinStartUpValidSpeedUnit: (+1)
   \        0x0   0xF8A0 0x1114      STRH     R1,[R0, #+276]
    986          }
   \        0x4   0x4770             BX       LR               ;; return
    987          
    988          /**
    989            * @}
    990            */
    991          
    992          /**
    993            * @}
    994            */
    995          
    996          /** @} */
    997          
    998          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   STO_GetPLLGains
        16   -> PID_GetKI
        16   -> PID_GetKP
       0   STO_OTF_ResetPLL
         0   -> PID_SetIntegralTerm
       0   STO_PLL_BemfConsistencyCheckSwitch
      12   STO_PLL_CalcAvrgElSpeedDpp
      40   STO_PLL_CalcAvrgMecSpeedUnit
        40   -> SPD_IsMecSpeedReliable
      56   STO_PLL_CalcElAngle
        56   -> MCM_Trig_Functions
        56   -> PI_Controller
      16   STO_PLL_Clear
         0   -> PID_SetIntegralTerm
       0   STO_PLL_ForceConvergency1
       0   STO_PLL_ForceConvergency2
       4   STO_PLL_GetEstimatedBemf
       0   STO_PLL_GetEstimatedBemfLevel
       4   STO_PLL_GetEstimatedCurrent
       0   STO_PLL_GetObservedBemfLevel
       0   STO_PLL_GetObserverGains
       8   STO_PLL_Init
         8   -> PID_HandleInit
         8   -> STO_PLL_Clear
       0   STO_PLL_IsBemfConsistent
      20   STO_PLL_IsObserverConverged
       0   STO_PLL_IsVarianceTight
       0   STO_PLL_Return
       0   STO_PLL_SetMecAngle
       0   STO_PLL_SetObserverGains
       0   STO_ResetPLL
         0   -> PID_SetIntegralTerm
       0   STO_SetMinStartUpValidSpeedUnit
      16   STO_SetPLL
        16   -> PID_GetKIDivisor
        16   -> PID_SetIntegralTerm
      16   STO_SetPLLGains
         0   -> PID_SetKI
        16   -> PID_SetKP


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      30  STO_GetPLLGains
      10  STO_OTF_ResetPLL
       6  STO_PLL_BemfConsistencyCheckSwitch
      76  STO_PLL_CalcAvrgElSpeedDpp
     300  STO_PLL_CalcAvrgMecSpeedUnit
     508  STO_PLL_CalcElAngle
      84  STO_PLL_Clear
      10  STO_PLL_ForceConvergency1
      10  STO_PLL_ForceConvergency2
      24  STO_PLL_GetEstimatedBemf
       6  STO_PLL_GetEstimatedBemfLevel
      28  STO_PLL_GetEstimatedCurrent
       6  STO_PLL_GetObservedBemfLevel
      10  STO_PLL_GetObserverGains
     104  STO_PLL_Init
       6  STO_PLL_IsBemfConsistent
     144  STO_PLL_IsObserverConverged
       8  STO_PLL_IsVarianceTight
       2  STO_PLL_Return
       2  STO_PLL_SetMecAngle
       6  STO_PLL_SetObserverGains
       8  STO_ResetPLL
       6  STO_SetMinStartUpValidSpeedUnit
      32  STO_SetPLL
      28  STO_SetPLLGains

 
 1'454 bytes in section .text
 
 0 bytes of CODE memory (+ 1'454 bytes shared)

Errors: none
Warnings: none
