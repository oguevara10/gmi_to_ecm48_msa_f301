###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:30
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\inrush_current_limiter.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW3E76.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\inrush_current_limiter.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\inrush_current_limiter.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\inrush_current_limiter.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\inrush_current_limiter.c
      1          /**
      2            ******************************************************************************
      3            * @file    inrush_current_limiter.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions implementing the
      6            *          InrushCurrentLimiter feature of the Motor Control SDK :
      7            *
      8            *          * ICL_Init() to initialize dedicated variables
      9            *          * ICL_Exec() to manage the ICL state machine
     10            *          * ICL_GetState() to get the current ICL state machine
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     15            * All rights reserved.</center></h2>
     16            *
     17            * This software component is licensed by ST under Ultimate Liberty license
     18            * SLA0044, the "License"; You may not use this file except in compliance with
     19            * the License. You may obtain a copy of the License at:
     20            *                             www.st.com/SLA0044
     21            *
     22            ******************************************************************************
     23            */
     24          
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "inrush_current_limiter.h"
     27          #include "mc_type.h"
     28          
     29          /** @addtogroup MCSDK
     30            * @{
     31            */
     32          
     33          /** @defgroup ICL Inrush Current Limiter
     34            * @brief Inrush Current Limiter component of the Motor Control SDK
     35            *
     36            * @todo Document the Inrush Current Limiter "module".
     37            *
     38            * @{
     39            */
     40          
     41          
     42          /* Private typedef -----------------------------------------------------------*/
     43          /* Private defines -----------------------------------------------------------*/
     44          /* Private macros ------------------------------------------------------------*/
     45          /* Global variables ----------------------------------------------------------*/
     46          /* Private function prototypes -----------------------------------------------*/
     47          /* Private functions ---------------------------------------------------------*/
     48          /**
     49            * @brief  It initializes all the needed ICL component variables.
     50            *         It shall be called only once, right after the ICL instance creation.
     51            *         It makes the bus voltage sensor and digital output assignment needed
     52            *         for the ICL instance usage.
     53            * @param  pHandle: handler of the current instance of the ICL component
     54            * @param  pVBS the bus voltage sensor used by the ICL.
     55            * @param  pDOUT the digital output used by the ICL.
     56            * @retval none.
     57            */

   \                                 In section .text, align 2
     58          __weak void ICL_Init( ICL_Handle_t * pHandle, BusVoltageSensor_Handle_t * pVBS, DOUT_handle_t * pDOUT )
     59          {
     60            uint32_t wAux;
     61          
     62            pHandle->pVBS = pVBS;
   \                     ICL_Init: (+1)
   \        0x0   0x6001             STR      R1,[R0, #+0]
     63            pHandle->pDOUT = pDOUT;
   \        0x2   0x6042             STR      R2,[R0, #+4]
     64            pHandle->ICLstate = ICL_ACTIVE;
   \        0x4   0x2102             MOVS     R1,#+2
   \        0x6   0x7201             STRB     R1,[R0, #+8]
     65            //DOUT_SetOutputState( pDOUT, ACTIVE );
     66            pHandle->hICLTicksCounter = 0u;
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x8142             STRH     R2,[R0, #+10]
     67            wAux = ( uint32_t )( pHandle->hICLDurationms );
     68            wAux *= ( uint32_t )( pHandle->hICLFrequencyHz );
     69            wAux /= 1000;
     70            wAux -= 1;
   \        0xC   0x8A03             LDRH     R3,[R0, #+16]
   \        0xE   0x89C1             LDRH     R1,[R0, #+14]
   \       0x10   0x434B             MULS     R3,R1,R3
   \       0x12   0xF44F 0x727A      MOV      R2,#+1000
   \       0x16   0xFBB3 0xF1F2      UDIV     R1,R3,R2
   \       0x1A   0x1E49             SUBS     R1,R1,#+1
     71            if ( wAux > UINT16_MAX )
   \       0x1C   0xF64F 0x72FF      MOVW     R2,#+65535
   \       0x20   0x4291             CMP      R1,R2
   \       0x22   0xBF88             IT       HI
   \       0x24   0x4611             MOVHI    R1,R2
     72            {
     73              wAux = UINT16_MAX;
   \       0x26   0xD801             BHI.N    ??ICL_Init_0
     74            }
     75            if ( wAux < 1 )
   \       0x28   0xB901             CBNZ.N   R1,??ICL_Init_0
     76            {
     77              wAux = 1;
   \       0x2A   0x2101             MOVS     R1,#+1
     78            }
     79            pHandle->hICLTotalTicks = ( uint16_t )( wAux );
   \                     ??ICL_Init_0: (+1)
   \       0x2C   0x8181             STRH     R1,[R0, #+12]
     80          }
   \       0x2E   0x4770             BX       LR               ;; return
     81          
     82          /**
     83            * @brief  It clocks the Inrush Current Limiter and must be called with a
     84            *         frequency equal to the one set in the hEACFrequencyHz parameter.
     85            * @param  pHandle: handler of the current instance of the ICL component
     86            * @retval ICLState_t returns the current ICL state machine
     87            */

   \                                 In section .text, align 4
     88          __weak ICL_State_t ICL_Exec( ICL_Handle_t * pHandle )
     89          {
   \                     ICL_Exec: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     90            /* ICL actions.*/
     91            switch ( pHandle->ICLstate )
   \        0x4   0x7A21             LDRB     R1,[R4, #+8]
   \        0x6   0x1E49             SUBS     R1,R1,#+1
   \        0x8   0x2903             CMP      R1,#+3
   \        0xA   0xD81E             BHI.N    ??ICL_Exec_1
   \        0xC   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??ICL_Exec_0:
   \       0x10   0x02 0x0D          DC8      0x2,0xD,0x6,0x14

   \              0x06 0x14
     92            {
     93              case ICL_ACTIVATION:
     94              {
     95                /* ICL activation: counting the step before pass in ICL_ACTIVE */
     96                if ( pHandle->hICLTicksCounter == 0u )
   \                     ??ICL_Exec_2: (+1)
   \       0x14   0x8960             LDRH     R0,[R4, #+10]
   \       0x16   0xB930             CBNZ.N   R0,??ICL_Exec_3
     97                {
     98                  pHandle->ICLstate = ICL_ACTIVE;
   \       0x18   0x2102             MOVS     R1,#+2
   \       0x1A   0xE002             B.N      ??ICL_Exec_4
     99                }
    100                else
    101                {
    102                  pHandle->hICLTicksCounter--;
    103                }
    104              }
    105              break;
    106          
    107              case ICL_DEACTIVATION:
    108              {
    109                /* ICL deactivation: counting the step before pass in ICL_INACTIVE.*/
    110                if ( pHandle->hICLTicksCounter == 0u )
   \                     ??ICL_Exec_5: (+1)
   \       0x1C   0x8960             LDRH     R0,[R4, #+10]
   \       0x1E   0xB910             CBNZ.N   R0,??ICL_Exec_3
    111                {
    112                  pHandle->ICLstate = ICL_INACTIVE;
   \       0x20   0x2104             MOVS     R1,#+4
   \                     ??ICL_Exec_4: (+1)
   \       0x22   0x7221             STRB     R1,[R4, #+8]
   \       0x24   0xE011             B.N      ??ICL_Exec_1
    113                }
    114                else
    115                {
    116                  pHandle->hICLTicksCounter--;
   \                     ??ICL_Exec_3: (+1)
   \       0x26   0x1E41             SUBS     R1,R0,#+1
   \       0x28   0xE00E             B.N      ??ICL_Exec_6
    117                }
    118              }
    119              break;
    120          
    121              case ICL_ACTIVE:
    122              {
    123                /* ICL is active: if bus is present deactivate the ICL */
    124                if ( VBS_CheckVbus( pHandle->pVBS ) != MC_UNDER_VOLT )
   \                     ??ICL_Exec_7: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x....'....        BL       VBS_CheckVbus
   \       0x30   0x2804             CMP      R0,#+4
   \       0x32   0xD00A             BEQ.N    ??ICL_Exec_1
    125                {
    126                  //DOUT_SetOutputState( pHandle->pDOUT, INACTIVE );
    127                  pHandle->ICLstate = ICL_DEACTIVATION;
   \       0x34   0x2003             MOVS     R0,#+3
   \       0x36   0xE005             B.N      ??ICL_Exec_8
    128                  pHandle->hICLTicksCounter = pHandle->hICLTotalTicks;
    129                }
    130              }
    131              break;
    132          
    133              case ICL_INACTIVE:
    134              {
    135                /* ICL is inactive: if bus is not present activate the ICL */
    136                if ( VBS_CheckVbus( pHandle->pVBS ) == MC_UNDER_VOLT )
   \                     ??ICL_Exec_9: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       VBS_CheckVbus
   \       0x3E   0x2804             CMP      R0,#+4
   \       0x40   0xD103             BNE.N    ??ICL_Exec_1
    137                {
    138                  //DOUT_SetOutputState( pHandle->pDOUT, ACTIVE );
    139                  pHandle->ICLstate = ICL_ACTIVATION;
   \       0x42   0x2001             MOVS     R0,#+1
    140                  pHandle->hICLTicksCounter = pHandle->hICLTotalTicks;
   \                     ??ICL_Exec_8: (+1)
   \       0x44   0x89A1             LDRH     R1,[R4, #+12]
   \       0x46   0x7220             STRB     R0,[R4, #+8]
   \                     ??ICL_Exec_6: (+1)
   \       0x48   0x8161             STRH     R1,[R4, #+10]
    141                }
    142              }
    143              break;
    144          
    145              case ICL_IDLE:
    146              default:
    147              {
    148              }
    149              break;
    150            }
    151          
    152            return pHandle->ICLstate;
   \                     ??ICL_Exec_1: (+1)
   \       0x4A   0x7A20             LDRB     R0,[R4, #+8]
   \       0x4C   0xBD10             POP      {R4,PC}          ;; return
    153          }
    154          
    155          
    156          /**
    157            * @brief It returns the current state of the ICL state machine.
    158            * @param  pHandle: handler of the current instance of the ICL component
    159            * @retval ICLState_t returns the current ICL state machine
    160            */

   \                                 In section .text, align 2
    161          __weak ICL_State_t ICL_GetState( ICL_Handle_t * pHandle )
    162          {
    163            return pHandle->ICLstate;
   \                     ICL_GetState: (+1)
   \        0x0   0x7A00             LDRB     R0,[R0, #+8]
   \        0x2   0x4770             BX       LR               ;; return
    164          }
    165          
    166          
    167          /**
    168            * @}
    169            */
    170          
    171          /**
    172            * @}
    173            */
    174          
    175          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ICL_Exec
         8   -> VBS_CheckVbus
       0   ICL_GetState
       0   ICL_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      78  ICL_Exec
       4  ICL_GetState
      48  ICL_Init

 
 130 bytes in section .text
 
 0 bytes of CODE memory (+ 130 bytes shared)

Errors: none
Warnings: none
