###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:13:58
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\motor_power_measurement.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW1153.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\motor_power_measurement.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\motor_power_measurement.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\motor_power_measurement.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\motor_power_measurement.c
      1          /**
      2            ******************************************************************************
      3            * @file    motor_power_measurement.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Motor Power Measurement component of the Motor Control SDK:
      7            *
      8            *           * Calculate power of the motor
      9            *           * Clear power measurement
     10            *           * Get Power of the motor
     11            *           * Get average Power of the motor
     12            *
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     17            * All rights reserved.</center></h2>
     18            *
     19            * This software component is licensed by ST under Ultimate Liberty license
     20            * SLA0044, the "License"; You may not use this file except in compliance with
     21            * the License. You may obtain a copy of the License at:
     22            *                             www.st.com/SLA0044
     23            *
     24            ******************************************************************************
     25            */
     26          
     27          /** @addtogroup MCSDK
     28            * @{
     29            */
     30          
     31          /** @defgroup motorpowermeasurement Motor Power Measurement
     32            * @brief Motor Power Measurement component of the Motor Control SDK
     33            *
     34            * @todo Document the Motor Power Measurement "module".
     35            *
     36            * @{
     37            */
     38          
     39          /* Includes ------------------------------------------------------------------*/
     40          #include "motor_power_measurement.h"
     41          
     42          #include "mc_type.h"
     43          
     44          
     45          /**
     46            * @brief  It should be called before each motor restart. It clears the
     47            *         measurement buffer and initialize the index.
     48            * @param power handle.
     49            * @retval none.
     50            */

   \                                 In section .text, align 2
     51          __weak void MPM_Clear( MotorPowMeas_Handle_t * pHandle )
     52          {
   \                     MPM_Clear: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     53            uint16_t i;
     54            for ( i = 0u; i < MPM_BUFFER_LENGHT; i++ )
     55            {
     56              pHandle->hMeasBuffer[i] = 0;
   \        0x4   0xF44F 0x7180      MOV      R1,#+256
   \        0x8   0x....'....        BL       __aeabi_memclr
     57            }
     58            pHandle->hNextMeasBufferIndex = 0u;
   \        0xC   0xF504 0x7080      ADD      R0,R4,#+256
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x8002             STRH     R2,[R0, #+0]
     59            pHandle->hLastMeasBufferIndex = 0u;
   \       0x14   0x8042             STRH     R2,[R0, #+2]
     60          
     61          }
   \       0x16   0xBD10             POP      {R4,PC}          ;; return
     62          
     63          /**
     64            * @brief  This method should be called with periodicity. It computes and
     65            *         returns the measured motor power expressed in watt. It is also used
     66            *         to fill, with that measure, the buffer used to compute the average
     67            *         motor power.
     68            * @param pHandle pointer on the related component instance.
     69            * @retval int16_t The measured motor power expressed in watt.
     70            */

   \                                 In section .text, align 2
     71          __weak int16_t MPM_CalcElMotorPower( MotorPowMeas_Handle_t * pHandle, int16_t CurrentMotorPower )
     72          {
   \                     MPM_CalcElMotorPower: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
     73            uint16_t i;
     74            int32_t wAux = 0;
     75          
     76            /* Store the measured values in the buffer.*/
     77            pHandle->hMeasBuffer[pHandle->hNextMeasBufferIndex] = CurrentMotorPower;
   \        0x2   0xF500 0x7380      ADD      R3,R0,#+256
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x881C             LDRH     R4,[R3, #+0]
   \        0xA   0xF820 0x1014      STRH     R1,[R0, R4, LSL #+1]
     78            pHandle->hLastMeasBufferIndex = pHandle->hNextMeasBufferIndex;
     79            pHandle->hNextMeasBufferIndex++;
   \        0xE   0x881C             LDRH     R4,[R3, #+0]
   \       0x10   0x881D             LDRH     R5,[R3, #+0]
   \       0x12   0x805D             STRH     R5,[R3, #+2]
   \       0x14   0x1C64             ADDS     R4,R4,#+1
   \       0x16   0x801C             STRH     R4,[R3, #+0]
     80            if ( pHandle->hNextMeasBufferIndex >= MPM_BUFFER_LENGHT )
   \       0x18   0xB2A4             UXTH     R4,R4
   \       0x1A   0x2C80             CMP      R4,#+128
   \       0x1C   0xBF28             IT       CS
   \       0x1E   0x801A             STRHCS   R2,[R3, #+0]
     81            {
     82              pHandle->hNextMeasBufferIndex = 0u;
     83            }
     84            /* Compute the average measured motor power */
     85            for ( i = 0u; i < MPM_BUFFER_LENGHT; i++ )
   \       0x20   0x2400             MOVS     R4,#+0
     86            {
     87              wAux += ( int32_t )( pHandle->hMeasBuffer[i] );
   \                     ??MPM_CalcElMotorPower_0: (+1)
   \       0x22   0xB2A5             UXTH     R5,R4
   \       0x24   0xF930 0x5015      LDRSH    R5,[R0, R5, LSL #+1]
     88            }
   \       0x28   0x1C64             ADDS     R4,R4,#+1
   \       0x2A   0x1952             ADDS     R2,R2,R5
   \       0x2C   0xB2A6             UXTH     R6,R4
   \       0x2E   0x2E80             CMP      R6,#+128
   \       0x30   0xD3F7             BCC.N    ??MPM_CalcElMotorPower_0
     89            wAux /= ( int32_t )MPM_BUFFER_LENGHT;
     90            pHandle->hAvrgElMotorPowerW = ( int16_t )( wAux );
   \       0x32   0x1190             ASRS     R0,R2,#+6
   \       0x34   0xEB02 0x6250      ADD      R2,R2,R0, LSR #+25
   \       0x38   0x11D2             ASRS     R2,R2,#+7
   \       0x3A   0x809A             STRH     R2,[R3, #+4]
     91            /* Return the last measured motor power */
     92            return CurrentMotorPower;
   \       0x3C   0x4608             MOV      R0,R1
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
     93          }
     94          /**
     95            * @brief  This method is used to get the last measured motor power
     96            *         (instantaneous value) expressed in watt.
     97            * @param pHandle pointer on the related component instance.
     98            * @retval int16_t The last measured motor power (instantaneous value)
     99            *         expressed in watt.
    100            */

   \                                 In section .text, align 2
    101          __weak int16_t MPM_GetElMotorPowerW( MotorPowMeas_Handle_t * pHandle )
    102          {
    103            return ( pHandle->hMeasBuffer[pHandle->hLastMeasBufferIndex] );
   \                     MPM_GetElMotorPowerW: (+1)
   \        0x0   0xF8B0 0x1102      LDRH     R1,[R0, #+258]
   \        0x4   0xF930 0x0011      LDRSH    R0,[R0, R1, LSL #+1]
   \        0x8   0x4770             BX       LR               ;; return
    104          }
    105          
    106          /**
    107            * @brief  This method is used to get the average measured motor power
    108            *         expressed in watt.
    109            * @param pHandle pointer on the related component instance.
    110            * @retval int16_t The average measured motor power expressed in watt.
    111            */

   \                                 In section .text, align 2
    112          __weak int16_t MPM_GetAvrgElMotorPowerW( MotorPowMeas_Handle_t * pHandle )
    113          {
    114            return ( pHandle->hAvrgElMotorPowerW );
   \                     MPM_GetAvrgElMotorPowerW: (+1)
   \        0x0   0xF9B0 0x0104      LDRSH    R0,[R0, #+260]
   \        0x4   0x4770             BX       LR               ;; return
    115          }
    116          
    117          /**
    118            * @}
    119            */
    120          
    121          /**
    122            * @}
    123            */
    124          
    125          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MPM_CalcElMotorPower
       8   MPM_Clear
         8   -> __aeabi_memclr
       0   MPM_GetAvrgElMotorPowerW
       0   MPM_GetElMotorPowerW


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      64  MPM_CalcElMotorPower
      24  MPM_Clear
       6  MPM_GetAvrgElMotorPowerW
      10  MPM_GetElMotorPowerW

 
 104 bytes in section .text
 
 0 bytes of CODE memory (+ 104 bytes shared)

Errors: none
Warnings: none
