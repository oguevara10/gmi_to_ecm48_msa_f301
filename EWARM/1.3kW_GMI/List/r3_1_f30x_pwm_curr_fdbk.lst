###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:57
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\F3xx\Src\r3_1_f30x_pwm_curr_fdbk.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW1697.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\F3xx\Src\r3_1_f30x_pwm_curr_fdbk.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\r3_1_f30x_pwm_curr_fdbk.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\r3_1_f30x_pwm_curr_fdbk.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\F3xx\Src\r3_1_f30x_pwm_curr_fdbk.c
      1          /**
      2            ******************************************************************************
      3            * @file    r3_1_f3xx_pwm_curr_fdbk.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement current sensor
      6            *          class to be stantiated when the three shunts current sensing
      7            *          topology is used. It is specifically designed for STM32F30X
      8            *          microcontrollers and implements the successive sampling of two motor
      9            *          current using shared ADC.
     10            *           + MCU peripheral and handle initialization function
     11            *           + three shunt current sesnsing
     12            *           + space vector modulation function
     13            *           + ADC sampling function
     14            *
     15            ******************************************************************************
     16            * @attention
     17            *
     18            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     19            * All rights reserved.</center></h2>
     20            *
     21            * This software component is licensed by ST under Ultimate Liberty license
     22            * SLA0044, the "License"; You may not use this file except in compliance with
     23            * the License. You may obtain a copy of the License at:
     24            *                             www.st.com/SLA0044
     25            *
     26            ******************************************************************************
     27            */
     28          
     29          /* Includes ------------------------------------------------------------------*/
     30          #include "r3_1_f30x_pwm_curr_fdbk.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_ADC_INJ_StartConversion(ADC_TypeDef *)
   \                     LL_ADC_INJ_StartConversion: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x....'....        LDR.W    R1,??DataTable8  ;; 0x7fffffc0
   \        0x6   0x400A             ANDS     R2,R1,R2
   \        0x8   0xF042 0x0208      ORR      R2,R2,#0x8
   \        0xC   0x6082             STR      R2,[R0, #+8]
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint8_t const OFFSET_TAB_CCMRx[9]
   \                     OFFSET_TAB_CCMRx:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 4, 4, 4, 60, 60

   \              0x00 0x00    

   \              0x04 0x04    

   \              0x04 0x3C    

   \              0x3C
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint8_t const SHIFT_TAB_OCxx[9]
   \                     SHIFT_TAB_OCxx:
   \        0x0   0x00 0x00          DC8 0, 0, 8, 0, 0, 0, 8, 0, 8

   \              0x08 0x00    

   \              0x00 0x00    

   \              0x08 0x00    

   \              0x08
   \        0x9                      DS8 3

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_SetMode(TIM_TypeDef *, uint32_t, uint32_t)
   \                     LL_TIM_OC_SetMode: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xBF08             IT       EQ
   \        0x6   0x2100             MOVEQ    R1,#+0
   \        0x8   0xD01F             BEQ.N    ??LL_TIM_OC_SetMode_0
   \        0xA   0x2904             CMP      R1,#+4
   \        0xC   0xBF08             IT       EQ
   \        0xE   0x2101             MOVEQ    R1,#+1
   \       0x10   0xD01B             BEQ.N    ??LL_TIM_OC_SetMode_0
   \       0x12   0x2910             CMP      R1,#+16
   \       0x14   0xBF08             IT       EQ
   \       0x16   0x2102             MOVEQ    R1,#+2
   \       0x18   0xD017             BEQ.N    ??LL_TIM_OC_SetMode_0
   \       0x1A   0x2940             CMP      R1,#+64
   \       0x1C   0xBF08             IT       EQ
   \       0x1E   0x2103             MOVEQ    R1,#+3
   \       0x20   0xD013             BEQ.N    ??LL_TIM_OC_SetMode_0
   \       0x22   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x26   0xBF08             IT       EQ
   \       0x28   0x2104             MOVEQ    R1,#+4
   \       0x2A   0xD00E             BEQ.N    ??LL_TIM_OC_SetMode_0
   \       0x2C   0xF5B1 0x6F80      CMP      R1,#+1024
   \       0x30   0xBF08             IT       EQ
   \       0x32   0x2105             MOVEQ    R1,#+5
   \       0x34   0xD009             BEQ.N    ??LL_TIM_OC_SetMode_0
   \       0x36   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x3A   0xBF08             IT       EQ
   \       0x3C   0x2106             MOVEQ    R1,#+6
   \       0x3E   0xD004             BEQ.N    ??LL_TIM_OC_SetMode_0
   \       0x40   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0x44   0xBF0C             ITE      EQ
   \       0x46   0x2107             MOVEQ    R1,#+7
   \       0x48   0x2108             MOVNE    R1,#+8
   \                     ??LL_TIM_OC_SetMode_0: (+1)
   \       0x4A   0x....'....        ADR.W    R3,OFFSET_TAB_CCMRx
   \       0x4E   0x....'....        ADR.W    R5,SHIFT_TAB_OCxx
   \       0x52   0x5C5C             LDRB     R4,[R3, R1]
   \       0x54   0x5C69             LDRB     R1,[R5, R1]
   \       0x56   0x3018             ADDS     R0,R0,#+24
   \       0x58   0x1900             ADDS     R0,R0,R4
   \       0x5A   0x....'....        LDR.W    R4,??DataTable8_1  ;; 0x10073
   \       0x5E   0x6803             LDR      R3,[R0, #+0]
   \       0x60   0x408C             LSLS     R4,R4,R1
   \       0x62   0x43A3             BICS     R3,R3,R4
   \       0x64   0x408A             LSLS     R2,R2,R1
   \       0x66   0x431A             ORRS     R2,R2,R3
   \       0x68   0x6002             STR      R2,[R0, #+0]
   \       0x6A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_EnablePreload(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_EnablePreload: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xBF08             IT       EQ
   \        0x6   0x2100             MOVEQ    R1,#+0
   \        0x8   0xD01F             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \        0xA   0x2904             CMP      R1,#+4
   \        0xC   0xBF08             IT       EQ
   \        0xE   0x2101             MOVEQ    R1,#+1
   \       0x10   0xD01B             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \       0x12   0x2910             CMP      R1,#+16
   \       0x14   0xBF08             IT       EQ
   \       0x16   0x2102             MOVEQ    R1,#+2
   \       0x18   0xD017             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \       0x1A   0x2940             CMP      R1,#+64
   \       0x1C   0xBF08             IT       EQ
   \       0x1E   0x2103             MOVEQ    R1,#+3
   \       0x20   0xD013             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \       0x22   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x26   0xBF08             IT       EQ
   \       0x28   0x2104             MOVEQ    R1,#+4
   \       0x2A   0xD00E             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \       0x2C   0xF5B1 0x6F80      CMP      R1,#+1024
   \       0x30   0xBF08             IT       EQ
   \       0x32   0x2105             MOVEQ    R1,#+5
   \       0x34   0xD009             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \       0x36   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x3A   0xBF08             IT       EQ
   \       0x3C   0x2106             MOVEQ    R1,#+6
   \       0x3E   0xD004             BEQ.N    ??LL_TIM_OC_EnablePreload_0
   \       0x40   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0x44   0xBF0C             ITE      EQ
   \       0x46   0x2107             MOVEQ    R1,#+7
   \       0x48   0x2108             MOVNE    R1,#+8
   \                     ??LL_TIM_OC_EnablePreload_0: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x4E   0x432C             ORRS     R4,R5,R4
   \       0x50   0x6014             STR      R4,[R2, #+0]
   \       0x52   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....'....        ADR.W    R2,OFFSET_TAB_CCMRx
   \        0x4   0x....'....        ADR.W    R6,SHIFT_TAB_OCxx
   \        0x8   0x5C53             LDRB     R3,[R2, R1]
   \        0xA   0x3018             ADDS     R0,R0,#+24
   \        0xC   0x18C2             ADDS     R2,R0,R3
   \        0xE   0x2508             MOVS     R5,#+8
   \       0x10   0x6814             LDR      R4,[R2, #+0]
   \       0x12   0x5C70             LDRB     R0,[R6, R1]
   \       0x14   0x4085             LSLS     R5,R5,R0
   \       0x16   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_DisablePreload(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_DisablePreload: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xBF08             IT       EQ
   \        0x6   0x2100             MOVEQ    R1,#+0
   \        0x8   0xD01F             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \        0xA   0x2904             CMP      R1,#+4
   \        0xC   0xBF08             IT       EQ
   \        0xE   0x2101             MOVEQ    R1,#+1
   \       0x10   0xD01B             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \       0x12   0x2910             CMP      R1,#+16
   \       0x14   0xBF08             IT       EQ
   \       0x16   0x2102             MOVEQ    R1,#+2
   \       0x18   0xD017             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \       0x1A   0x2940             CMP      R1,#+64
   \       0x1C   0xBF08             IT       EQ
   \       0x1E   0x2103             MOVEQ    R1,#+3
   \       0x20   0xD013             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \       0x22   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x26   0xBF08             IT       EQ
   \       0x28   0x2104             MOVEQ    R1,#+4
   \       0x2A   0xD00E             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \       0x2C   0xF5B1 0x6F80      CMP      R1,#+1024
   \       0x30   0xBF08             IT       EQ
   \       0x32   0x2105             MOVEQ    R1,#+5
   \       0x34   0xD009             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \       0x36   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x3A   0xBF08             IT       EQ
   \       0x3C   0x2106             MOVEQ    R1,#+6
   \       0x3E   0xD004             BEQ.N    ??LL_TIM_OC_DisablePreload_0
   \       0x40   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0x44   0xBF0C             ITE      EQ
   \       0x46   0x2107             MOVEQ    R1,#+7
   \       0x48   0x2108             MOVNE    R1,#+8
   \                     ??LL_TIM_OC_DisablePreload_0: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x4E   0x43AC             BICS     R4,R4,R5
   \       0x50   0x6014             STR      R4,[R2, #+0]
   \       0x52   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH1: (+1)
   \        0x0   0x6341             STR      R1,[R0, #+52]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH2: (+1)
   \        0x0   0x6381             STR      R1,[R0, #+56]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH3: (+1)
   \        0x0   0x63C1             STR      R1,[R0, #+60]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH4: (+1)
   \        0x0   0x6401             STR      R1,[R0, #+64]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_SetTriggerOutput(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_SetTriggerOutput: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   \        0x2   0xF022 0x0270      BIC      R2,R2,#0x70
   \        0x6   0x4311             ORRS     R1,R1,R2
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_EnableAllOutputs(TIM_TypeDef *)
   \                     LL_TIM_EnableAllOutputs: (+1)
   \        0x0   0x6C41             LDR      R1,[R0, #+68]
   \        0x2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x6   0x6441             STR      R1,[R0, #+68]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *)
   \                     LL_TIM_ClearFlag_UPDATE: (+1)
   \        0x0   0xF06F 0x0101      MVN      R1,#+1
   \        0x4   0x6101             STR      R1,[R0, #+16]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp uint32_t LL_TIM_IsActiveFlag_UPDATE(TIM_TypeDef *)
   \                     LL_TIM_IsActiveFlag_UPDATE: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0xF000 0x0001      AND      R0,R0,#0x1
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *)
   \                     LL_TIM_EnableIT_UPDATE: (+1)
   \        0x0   0x68C1             LDR      R1,[R0, #+12]
   \        0x2   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0x6   0x60C1             STR      R1,[R0, #+12]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_GPIO_SetOutputPin(GPIO_TypeDef *, uint32_t)
   \                     LL_GPIO_SetOutputPin: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_GPIO_ResetOutputPin(GPIO_TypeDef *, uint32_t)
   \                     LL_GPIO_ResetOutputPin: (+1)
   \        0x0   0x6281             STR      R1,[R0, #+40]
   \        0x2   0x4770             BX       LR               ;; return
     31          #include "pwm_common.h"
     32          #include "mc_type.h"
     33          
     34          /** @addtogroup MCSDK
     35            * @{
     36            */
     37          
     38          /** @addtogroup pwm_curr_fdbk
     39            * @{
     40            */
     41          
     42          /**
     43           * @defgroup R3_1_F30XX_pwm_curr_fdbk R3 2 ADCs F3 PWM & Current Feedback
     44           *
     45           * @brief STM32F3, 3-Shunt PWM & Current Feedback implementation
     46           *
     47           * This component is used in applications based on an STM32F3 MCU, using a three
     48           * shunt resistors current sensing topology and 2 ADC peripherals to acquire the current
     49           * values.
     50           *
     51           *
     52           * @todo: TODO: complete documentation.
     53           *
     54           * @{
     55           */
     56          
     57          /* Private defines -----------------------------------------------------------*/
     58          #define TIMxCCER_MASK_CH123        ((uint16_t)  (LL_TIM_CHANNEL_CH1|LL_TIM_CHANNEL_CH1N|\
     59                                                           LL_TIM_CHANNEL_CH2|LL_TIM_CHANNEL_CH2N|\
     60                                                           LL_TIM_CHANNEL_CH3|LL_TIM_CHANNEL_CH3N))
     61          #define CCMR2_CH4_DISABLE 0x8FFFu   //
     62          
     63          /* Private typedef -----------------------------------------------------------*/
     64          
     65          /* Private function prototypes -----------------------------------------------*/
     66          static void R3_1_TIMxInit( TIM_TypeDef * TIMx, PWMC_Handle_t * pHdl );
     67          static void R3_1_ADCxInit( ADC_TypeDef * ADCx );
     68          __STATIC_INLINE uint16_t R3_1_WriteTIMRegisters( PWMC_Handle_t * pHdl, uint16_t hCCR4Reg  );
     69          static void R3_1_HFCurrentsPolarizationAB( PWMC_Handle_t * pHdl,ab_t * Iab );
     70          static void R3_1_HFCurrentsPolarizationC( PWMC_Handle_t * pHdl, ab_t * Iab );
     71          static void R3_1_SetAOReferenceVoltage( uint32_t DAC_Channel, uint16_t hDACVref );
     72          uint16_t R3_1_SetADCSampPointPolarization( PWMC_Handle_t * pHdl) ;
     73          static void R3_1_RLGetPhaseCurrents( PWMC_Handle_t * pHdl, ab_t * pStator_Currents );
     74          static void R3_1_RLTurnOnLowSides( PWMC_Handle_t * pHdl );
     75          static void R3_1_RLSwitchOnPWM( PWMC_Handle_t * pHdl );
     76          /**
     77            * @brief  It initializes TIMx, ADC, GPIO, DMA1 and NVIC for current reading
     78            *         in three shunt topology using STM32F30X and shared ADC
     79            * @param  pHandle: handler of the current instance of the PWM component
     80            * @retval none
     81            */

   \                                 In section .text, align 4
     82          __weak void R3_1_Init( PWMC_R3_1_Handle_t * pHandle )
     83          {
   \                     R3_1_Init: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
     84            COMP_TypeDef * COMP_OCPAx = pHandle->pParams_str->CompOCPASelection;
     85            COMP_TypeDef * COMP_OCPBx = pHandle->pParams_str->CompOCPBSelection;
     86            COMP_TypeDef * COMP_OCPCx = pHandle->pParams_str->CompOCPCSelection;
     87            COMP_TypeDef * COMP_OVPx = pHandle->pParams_str->CompOVPSelection;
     88            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
     89            ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
     90          
     91            /*Check that _Super is the first member of the structure PWMC_R3_1_Handle_t */
     92            if ( ( uint32_t )pHandle == ( uint32_t )&pHandle->_Super )
     93            {
     94              /* disable IT and flags in case of LL driver usage
     95               * workaround for unwanted interrupt enabling done by LL driver */
     96              LL_ADC_DisableIT_EOC( ADCx );
     97              LL_ADC_ClearFlag_EOC( ADCx );
   \        0x6   0x2204             MOVS     R2,#+4
   \        0x8   0xF8D8 0x0074      LDR      R0,[R8, #+116]
   \        0xC   0x6807             LDR      R7,[R0, #+0]
   \        0xE   0x6884             LDR      R4,[R0, #+8]
   \       0x10   0x68C6             LDR      R6,[R0, #+12]
   \       0x12   0xF8D0 0xA010      LDR      R10,[R0, #+16]
   \       0x16   0xF8D0 0x9014      LDR      R9,[R0, #+20]
   \       0x1A   0x6845             LDR      R5,[R0, #+4]
   \       0x1C   0x6879             LDR      R1,[R7, #+4]
   \       0x1E   0xF021 0x0104      BIC      R1,R1,#0x4
   \       0x22   0x6079             STR      R1,[R7, #+4]
   \       0x24   0x603A             STR      R2,[R7, #+0]
     98              LL_ADC_DisableIT_JEOC( ADCx );
     99              LL_ADC_ClearFlag_JEOC( ADCx );
   \       0x26   0x2220             MOVS     R2,#+32
   \       0x28   0x6879             LDR      R1,[R7, #+4]
   \       0x2A   0xF021 0x0120      BIC      R1,R1,#0x20
   \       0x2E   0x6079             STR      R1,[R7, #+4]
   \       0x30   0x603A             STR      R2,[R7, #+0]
    100          
    101              if ( TIMx == TIM1 )
   \       0x32   0x4980             LDR.N    R1,??R3_1_Init_0  ;; 0x40012c00
   \       0x34   0x428D             CMP      R5,R1
   \       0x36   0xD104             BNE.N    ??R3_1_Init_1
    102              {
    103                /* TIM1 Counter Clock stopped when the core is halted */
    104                LL_DBGMCU_APB2_GRP1_FreezePeriph( LL_DBGMCU_APB2_GRP1_TIM1_STOP );
   \       0x38   0x497F             LDR.N    R1,??R3_1_Init_0+0x4  ;; 0xe004200c
   \       0x3A   0x680A             LDR      R2,[R1, #+0]
   \       0x3C   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x40   0x600A             STR      R2,[R1, #+0]
    105              }
    106          #ifdef TIM8    
    107              else
    108              {
    109                /* TIM8 Counter Clock stopped when the core is halted */
    110                LL_DBGMCU_APB2_GRP1_FreezePeriph( LL_DBGMCU_APB2_GRP1_TIM8_STOP );
    111              }
    112          #endif
    113              /* Over current protection phase A */
    114              if ( COMP_OCPAx != NULL )
   \                     ??R3_1_Init_1: (+1)
   \       0x42   0xF8DF 0xB1F8      LDR.W    R11,??R3_1_Init_0+0x8  ;; 0x2100001
   \       0x46   0xB1A4             CBZ.N    R4,??R3_1_Init_2
    115              {
    116                /* Inverting input*/
    117                if ( pHandle->pParams_str->CompOCPAInvInput_MODE != EXT_MODE )
   \       0x48   0x3076             ADDS     R0,R0,#+118
   \       0x4A   0x79C1             LDRB     R1,[R0, #+7]
   \       0x4C   0x2901             CMP      R1,#+1
   \       0x4E   0xD008             BEQ.N    ??R3_1_Init_3
    118                {
    119                  if ( LL_COMP_GetInputMinus( COMP_OCPAx ) == LL_COMP_INPUT_MINUS_DAC1_CH1 )
   \       0x50   0x6822             LDR      R2,[R4, #+0]
   \       0x52   0xF002 0x0270      AND      R2,R2,#0x70
   \       0x56   0x2A40             CMP      R2,#+64
   \       0x58   0xD103             BNE.N    ??R3_1_Init_3
    120                  {
    121                    R3_1_SetAOReferenceVoltage( LL_DAC_CHANNEL_1, ( uint16_t )( pHandle->pParams_str->DAC_OCP_Threshold ) );
   \       0x5A   0x8801             LDRH     R1,[R0, #+0]
   \       0x5C   0x4658             MOV      R0,R11
   \       0x5E   0x....'....        BL       R3_1_SetAOReferenceVoltage
    122                  }
    123          #if defined(DAC_CHANNEL2_SUPPORT)
    124                  else if ( LL_COMP_GetInputMinus( COMP_OCPAx ) == LL_COMP_INPUT_MINUS_DAC1_CH2 )
    125                  {
    126                    R3_1_SetAOReferenceVoltage( LL_DAC_CHANNEL_2, ( uint16_t )( pHandle->pParams_str->DAC_OCP_Threshold ) );
    127                  }
    128          #endif
    129                  else
    130                  {
    131                  }
    132                }
    133                /* Output */
    134                LL_COMP_Enable ( COMP_OCPAx );
   \                     ??R3_1_Init_3: (+1)
   \       0x62   0x6822             LDR      R2,[R4, #+0]
   \       0x64   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x68   0x6022             STR      R2,[R4, #+0]
    135                LL_COMP_Lock( COMP_OCPAx );
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \       0x70   0x6020             STR      R0,[R4, #+0]
    136              }
    137          
    138              /* Over current protection phase B */
    139              if ( COMP_OCPBx != NULL )
   \                     ??R3_1_Init_2: (+1)
   \       0x72   0xB13E             CBZ.N    R6,??R3_1_Init_4
    140              {
    141                LL_COMP_Enable ( COMP_OCPBx );
   \       0x74   0x6830             LDR      R0,[R6, #+0]
   \       0x76   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x7A   0x6030             STR      R0,[R6, #+0]
    142                LL_COMP_Lock( COMP_OCPBx );
   \       0x7C   0x6831             LDR      R1,[R6, #+0]
   \       0x7E   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \       0x82   0x6031             STR      R1,[R6, #+0]
    143              }
    144          
    145              /* Over current protection phase C */
    146              if ( COMP_OCPCx != NULL )
   \                     ??R3_1_Init_4: (+1)
   \       0x84   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x88   0xD00B             BEQ.N    ??R3_1_Init_5
    147              {
    148                LL_COMP_Enable ( COMP_OCPCx );
   \       0x8A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x8E   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x92   0xF8CA 0x0000      STR      R0,[R10, #+0]
    149                LL_COMP_Lock( COMP_OCPCx );
   \       0x96   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0x9A   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \       0x9E   0xF8CA 0x1000      STR      R1,[R10, #+0]
    150              }
    151          
    152              /* Over voltage protection */
    153              if ( COMP_OVPx != NULL )
   \                     ??R3_1_Init_5: (+1)
   \       0xA2   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xA6   0xD01B             BEQ.N    ??R3_1_Init_6
    154              {
    155                /* Inverting input*/
    156                if ( pHandle->pParams_str->CompOVPInvInput_MODE != EXT_MODE )
   \       0xA8   0xF8D8 0x0074      LDR      R0,[R8, #+116]
   \       0xAC   0x3078             ADDS     R0,R0,#+120
   \       0xAE   0x7A01             LDRB     R1,[R0, #+8]
   \       0xB0   0x2901             CMP      R1,#+1
   \       0xB2   0xD009             BEQ.N    ??R3_1_Init_7
    157                {
    158                  if ( LL_COMP_GetInputMinus( COMP_OVPx ) == LL_COMP_INPUT_MINUS_DAC1_CH1 )
   \       0xB4   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0xB8   0xF002 0x0270      AND      R2,R2,#0x70
   \       0xBC   0x2A40             CMP      R2,#+64
   \       0xBE   0xD103             BNE.N    ??R3_1_Init_7
    159                  {
    160                    R3_1_SetAOReferenceVoltage( LL_DAC_CHANNEL_1, ( uint16_t )( pHandle->pParams_str->DAC_OVP_Threshold ) );
   \       0xC0   0x8801             LDRH     R1,[R0, #+0]
   \       0xC2   0x4658             MOV      R0,R11
   \       0xC4   0x....'....        BL       R3_1_SetAOReferenceVoltage
    161                  }
    162          #if defined(DAC_CHANNEL2_SUPPORT)
    163                  else if ( LL_COMP_GetInputMinus( COMP_OVPx ) == LL_COMP_INPUT_MINUS_DAC1_CH2 )
    164                  {
    165                    R3_1_SetAOReferenceVoltage( LL_DAC_CHANNEL_2, ( uint16_t )( pHandle->pParams_str->DAC_OVP_Threshold ) );
    166                  }
    167          #endif
    168                  else
    169                  {
    170                  }
    171                }
    172                /* Output */
    173                LL_COMP_Enable ( COMP_OVPx );
   \                     ??R3_1_Init_7: (+1)
   \       0xC8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xCC   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0xD0   0xF8C9 0x0000      STR      R0,[R9, #+0]
    174                LL_COMP_Lock( COMP_OVPx );
   \       0xD4   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0xD8   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \       0xDC   0xF8C9 0x1000      STR      R1,[R9, #+0]
    175              }
    176              
    177              if (LL_ADC_IsEnabled (ADCx) == 0)
   \                     ??R3_1_Init_6: (+1)
   \       0xE0   0x68B8             LDR      R0,[R7, #+8]
   \       0xE2   0x07C1             LSLS     R1,R0,#+31
   \       0xE4   0xD441             BMI.N    ??R3_1_Init_8
    178              {
    179                R3_1_ADCxInit (ADCx);
   \       0xE6   0x68B8             LDR      R0,[R7, #+8]
   \       0xE8   0x4955             LDR.N    R1,??R3_1_Init_0+0xC  ;; 0x7fffffc0
   \       0xEA   0xF000 0x5040      AND      R0,R0,#0x30000000
   \       0xEE   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0xF2   0xD015             BEQ.N    ??R3_1_Init_9
   \       0xF4   0x68B8             LDR      R0,[R7, #+8]
   \       0xF6   0x4A53             LDR.N    R2,??R3_1_Init_0+0x10
   \       0xF8   0x4B53             LDR.N    R3,??R3_1_Init_0+0x14  ;; 0x30d40
   \       0xFA   0xF020 0x5040      BIC      R0,R0,#0x30000000
   \       0xFE   0x60B8             STR      R0,[R7, #+8]
   \      0x100   0x68B8             LDR      R0,[R7, #+8]
   \      0x102   0x4008             ANDS     R0,R1,R0
   \      0x104   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \      0x108   0x60B8             STR      R0,[R7, #+8]
   \      0x10A   0x6810             LDR      R0,[R2, #+0]
   \      0x10C   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \      0x110   0x9300             STR      R3,[SP, #+0]
   \      0x112   0xE002             B.N      ??R3_1_Init_10
   \                     ??R3_1_Init_11: (+1)
   \      0x114   0x9800             LDR      R0,[SP, #+0]
   \      0x116   0x1E40             SUBS     R0,R0,#+1
   \      0x118   0x9000             STR      R0,[SP, #+0]
   \                     ??R3_1_Init_10: (+1)
   \      0x11A   0x9800             LDR      R0,[SP, #+0]
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD1F9             BNE.N    ??R3_1_Init_11
   \                     ??R3_1_Init_9: (+1)
   \      0x120   0x68BA             LDR      R2,[R7, #+8]
   \      0x122   0x484A             LDR.N    R0,??R3_1_Init_0+0x18  ;; 0x3fffffc0
   \      0x124   0x4002             ANDS     R2,R0,R2
   \      0x126   0xF042 0x4200      ORR      R2,R2,#0x80000000
   \      0x12A   0x60BA             STR      R2,[R7, #+8]
   \                     ??R3_1_Init_12: (+1)
   \      0x12C   0x68B8             LDR      R0,[R7, #+8]
   \      0x12E   0x0FC0             LSRS     R0,R0,#+31
   \      0x130   0xD1FC             BNE.N    ??R3_1_Init_12
   \                     ??R3_1_Init_13: (+1)
   \      0x132   0x6838             LDR      R0,[R7, #+0]
   \      0x134   0x07C2             LSLS     R2,R0,#+31
   \      0x136   0x68B8             LDR      R0,[R7, #+8]
   \      0x138   0xBF5E             ITTT     PL
   \      0x13A   0x4008             ANDPL    R0,R1,R0
   \      0x13C   0xF040 0x0001      ORRPL    R0,R0,#0x1
   \      0x140   0x60B8             STRPL    R0,[R7, #+8]
   \      0x142   0xD5F6             BPL.N    ??R3_1_Init_13
   \      0x144   0x4008             ANDS     R0,R1,R0
   \      0x146   0xF040 0x0008      ORR      R0,R0,#0x8
   \      0x14A   0x60B8             STR      R0,[R7, #+8]
   \      0x14C   0x68B8             LDR      R0,[R7, #+8]
   \      0x14E   0x4001             ANDS     R1,R1,R0
   \      0x150   0xF041 0x0120      ORR      R1,R1,#0x20
   \      0x154   0x60B9             STR      R1,[R7, #+8]
    180                /* Only the Interrupt of the first ADC is enabled. 
    181                 * As Both ADCs are fired by HW at the same moment 
    182                 * It is safe to consider that both conversion are ready at the same time*/
    183                LL_ADC_ClearFlag_JEOS( ADCx );
   \      0x156   0x2140             MOVS     R1,#+64
   \      0x158   0x68F8             LDR      R0,[R7, #+12]
   \      0x15A   0xF440 0x1000      ORR      R0,R0,#0x200000
   \      0x15E   0x60F8             STR      R0,[R7, #+12]
   \      0x160   0x6039             STR      R1,[R7, #+0]
    184                LL_ADC_EnableIT_JEOS( ADCx );
   \      0x162   0x6878             LDR      R0,[R7, #+4]
   \      0x164   0xF040 0x0040      ORR      R0,R0,#0x40
   \      0x168   0x6078             STR      R0,[R7, #+4]
    185              }
    186              else 
    187              {
    188                /* Nothing to do ADCx_1 already configured */
    189              }
    190              R3_1_TIMxInit( TIMx, &pHandle->_Super );
   \                     ??R3_1_Init_8: (+1)
   \      0x16A   0xF44F 0x747A      MOV      R4,#+1000
   \      0x16E   0x6828             LDR      R0,[R5, #+0]
   \      0x170   0x0840             LSRS     R0,R0,#+1
   \      0x172   0x0040             LSLS     R0,R0,#+1
   \      0x174   0x6028             STR      R0,[R5, #+0]
   \      0x176   0x4628             MOV      R0,R5
   \      0x178   0x6869             LDR      R1,[R5, #+4]
   \      0x17A   0xF021 0x0170      BIC      R1,R1,#0x70
   \      0x17E   0x6069             STR      R1,[R5, #+4]
   \      0x180   0x2101             MOVS     R1,#+1
   \      0x182   0x....'....        BL       LL_TIM_OC_EnablePreload
   \      0x186   0x2110             MOVS     R1,#+16
   \      0x188   0x4628             MOV      R0,R5
   \      0x18A   0x....'....        BL       LL_TIM_OC_EnablePreload
   \      0x18E   0xF44F 0x7180      MOV      R1,#+256
   \      0x192   0x4628             MOV      R0,R5
   \      0x194   0x....'....        BL       LL_TIM_OC_EnablePreload
   \      0x198   0xF44F 0x5180      MOV      R1,#+4096
   \      0x19C   0x4628             MOV      R0,R5
   \      0x19E   0x....'....        BL       LL_TIM_OC_EnablePreload
   \      0x1A2   0x6968             LDR      R0,[R5, #+20]
   \      0x1A4   0xF040 0x0001      ORR      R0,R0,#0x1
   \      0x1A8   0x6168             STR      R0,[R5, #+20]
   \      0x1AA   0xF108 0x0246      ADD      R2,R8,#+70
   \      0x1AE   0xF8D8 0x0074      LDR      R0,[R8, #+116]
   \      0x1B2   0xF100 0x017B      ADD      R1,R0,#+123
   \      0x1B6   0x7988             LDRB     R0,[R1, #+6]
   \      0x1B8   0x2802             CMP      R0,#+2
   \      0x1BA   0xD10D             BNE.N    ??R3_1_Init_14
   \      0x1BC   0x79C8             LDRB     R0,[R1, #+7]
   \      0x1BE   0x2801             CMP      R0,#+1
   \      0x1C0   0xBF04             ITT      EQ
   \      0x1C2   0x780B             LDRBEQ   R3,[R1, #+0]
   \      0x1C4   0x2B03             CMPEQ    R3,#+3
   \      0x1C6   0xD10C             BNE.N    ??R3_1_Init_15
   \      0x1C8   0x6328             STR      R0,[R5, #+48]
   \      0x1CA   0x2603             MOVS     R6,#+3
   \      0x1CC   0x696B             LDR      R3,[R5, #+20]
   \      0x1CE   0xF043 0x0301      ORR      R3,R3,#0x1
   \      0x1D2   0x616B             STR      R3,[R5, #+20]
   \      0x1D4   0x632E             STR      R6,[R5, #+48]
   \      0x1D6   0xE004             B.N      ??R3_1_Init_15
   \                     ??R3_1_Init_14: (+1)
   \      0x1D8   0x7810             LDRB     R0,[R2, #+0]
   \      0x1DA   0xB980             CBNZ.N   R0,??R3_1_Init_16
   \      0x1DC   0x7808             LDRB     R0,[R1, #+0]
   \      0x1DE   0x2801             CMP      R0,#+1
   \      0x1E0   0xD103             BNE.N    ??R3_1_Init_17
   \                     ??R3_1_Init_15: (+1)
   \      0x1E2   0x8C50             LDRH     R0,[R2, #+34]
   \      0x1E4   0x1E40             SUBS     R0,R0,#+1
   \      0x1E6   0x6268             STR      R0,[R5, #+36]
   \      0x1E8   0xE009             B.N      ??R3_1_Init_16
   \                     ??R3_1_Init_17: (+1)
   \      0x1EA   0x2803             CMP      R0,#+3
   \      0x1EC   0xD107             BNE.N    ??R3_1_Init_16
   \      0x1EE   0x2001             MOVS     R0,#+1
   \      0x1F0   0x6328             STR      R0,[R5, #+48]
   \      0x1F2   0x2003             MOVS     R0,#+3
   \      0x1F4   0x696A             LDR      R2,[R5, #+20]
   \      0x1F6   0xF042 0x0201      ORR      R2,R2,#0x1
   \      0x1FA   0x616A             STR      R2,[R5, #+20]
   \      0x1FC   0x6328             STR      R0,[R5, #+48]
   \                     ??R3_1_Init_16: (+1)
   \      0x1FE   0xF06F 0x0280      MVN      R2,#+128
   \      0x202   0x612A             STR      R2,[R5, #+16]
   \      0x204   0x7848             LDRB     R0,[R1, #+1]
   \      0x206   0xB920             CBNZ.N   R0,??R3_1_Init_18
   \      0x208   0xE008             B.N      ??R3_1_Init_19
   \                     ??R3_1_Init_20: (+1)
   \      0x20A   0xF46F 0x7180      MVN      R1,#+256
   \      0x20E   0x6129             STR      R1,[R5, #+16]
   \      0x210   0x1E64             SUBS     R4,R4,#+1
   \                     ??R3_1_Init_18: (+1)
   \      0x212   0x6928             LDR      R0,[R5, #+16]
   \      0x214   0x05C1             LSLS     R1,R0,#+23
   \      0x216   0xD501             BPL.N    ??R3_1_Init_19
   \      0x218   0x2C00             CMP      R4,#+0
   \      0x21A   0xD1F6             BNE.N    ??R3_1_Init_20
   \                     ??R3_1_Init_19: (+1)
   \      0x21C   0x68E8             LDR      R0,[R5, #+12]
   \      0x21E   0xF040 0x0080      ORR      R0,R0,#0x80
   \      0x222   0x60E8             STR      R0,[R5, #+12]
   \      0x224   0xF240 0x5055      MOVW     R0,#+1365
   \      0x228   0x6A29             LDR      R1,[R5, #+32]
   \      0x22A   0x4301             ORRS     R1,R0,R1
   \      0x22C   0x6229             STR      R1,[R5, #+32]
    191            }
    192          }
   \      0x22E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   \      0x232   0xBF00             Nop
   \                     ??R3_1_Init_0:
   \      0x234   0x4001'2C00        DC32     0x40012c00
   \      0x238   0xE004'200C        DC32     0xe004200c
   \      0x23C   0x0210'0001        DC32     0x2100001
   \      0x240   0x7FFF'FFC0        DC32     0x7fffffc0
   \      0x244   0x....'....        DC32     SystemCoreClock
   \      0x248   0x0003'0D40        DC32     0x30d40
   \      0x24C   0x3FFF'FFC0        DC32     0x3fffffc0
    193          
    194          static void R3_1_ADCxInit( ADC_TypeDef * ADCx )
    195          {
    196               
    197            if ( LL_ADC_IsInternalRegulatorEnabled(ADCx) == 0u)
    198            {
    199              /* Enable ADC internal voltage regulator */
    200              LL_ADC_EnableInternalRegulator(ADCx);
    201            
    202              /* Wait for Regulator Startup time */
    203              /* Note: Variable divided by 2 to compensate partially              */
    204              /*       CPU processing cycles, scaling in us split to not          */
    205              /*       exceed 32 bits register capacity and handle low frequency. */
    206              volatile uint32_t wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));      
    207              while(wait_loop_index != 0UL)
    208              {
    209                wait_loop_index--;
    210              }
    211            }
    212            
    213            LL_ADC_StartCalibration( ADCx, LL_ADC_SINGLE_ENDED );
    214            while ( LL_ADC_IsCalibrationOnGoing( ADCx) == 1u) 
    215            {}
    216            /* ADC Enable (must be done after calibration) */
    217            /* ADC5-140924: Enabling the ADC by setting ADEN bit soon after polling ADCAL=0 
    218            * following a calibration phase, could have no effect on ADC 
    219            * within certain AHB/ADC clock ratio.
    220            */
    221            while (  LL_ADC_IsActiveFlag_ADRDY( ADCx ) == 0u)  
    222            { 
    223              LL_ADC_Enable(  ADCx );
    224            }
    225            /* Clear JSQR from CubeMX setting to avoid not wanting conversion*/
    226            LL_ADC_INJ_StartConversion( ADCx ); 
    227            LL_ADC_INJ_StopConversion(ADCx);
    228            /* TODO: check if not already done by MX */
    229            LL_ADC_INJ_SetQueueMode( ADCx, LL_ADC_INJ_QUEUE_2CONTEXTS_END_EMPTY );
    230           }
    231          
    232          /**
    233            * @brief  It initializes TIMx peripheral for PWM generation
    234            * @param TIMx: Timer to be initialized
    235            * @param pHandle: handler of the current instance of the PWM component
    236            * @retval none
    237            */
    238          static void R3_1_TIMxInit( TIM_TypeDef * TIMx, PWMC_Handle_t * pHdl )
    239          {
    240          #if defined (__ICCARM__)
    241            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    242          #endif /* __ICCARM__ */
    243            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    244          #if defined (__ICCARM__)
    245            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    246          #endif /* __ICCARM__ */
    247            uint32_t Brk2Timeout = 1000;
    248          
    249            /* disable main TIM counter to ensure
    250             * a synchronous start by TIM2 trigger */
    251            LL_TIM_DisableCounter( TIMx );
    252            
    253            LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);
    254          
    255            /* Enables the TIMx Preload on CC1 Register */
    256            LL_TIM_OC_EnablePreload( TIMx, LL_TIM_CHANNEL_CH1 );
    257            /* Enables the TIMx Preload on CC2 Register */
    258            LL_TIM_OC_EnablePreload( TIMx, LL_TIM_CHANNEL_CH2 );
    259            /* Enables the TIMx Preload on CC3 Register */
    260            LL_TIM_OC_EnablePreload( TIMx, LL_TIM_CHANNEL_CH3 );
    261            /* Enables the TIMx Preload on CC4 Register */
    262            LL_TIM_OC_EnablePreload( TIMx, LL_TIM_CHANNEL_CH4 );
    263            /* Prepare timer for synchronization */
    264            LL_TIM_GenerateEvent_UPDATE( TIMx );
    265            if ( pHandle->pParams_str->FreqRatio == 2u )
    266            {
    267              if ( pHandle->pParams_str->IsHigherFreqTim == HIGHER_FREQ )
    268              {
    269                if ( pHandle->pParams_str->RepetitionCounter == 3u )
    270                {
    271                  /* Set TIMx repetition counter to 1 */
    272                  LL_TIM_SetRepetitionCounter( TIMx, 1 );
    273                  LL_TIM_GenerateEvent_UPDATE( TIMx );
    274                  /* Repetition counter will be set to 3 at next Update */
    275                  LL_TIM_SetRepetitionCounter( TIMx, 3 );
    276                }
    277              }
    278              LL_TIM_SetCounter( TIMx, ( uint32_t )( pHandle->Half_PWMPeriod ) - 1u );
    279            }
    280            else /* bFreqRatio equal to 1 or 3 */
    281            {
    282              if ( pHandle->_Super.Motor == M1 )
    283              {
    284                if ( pHandle->pParams_str->RepetitionCounter == 1u )
    285                {
    286                  LL_TIM_SetCounter( TIMx, ( uint32_t )( pHandle->Half_PWMPeriod ) - 1u );
    287                }
    288                else if ( pHandle->pParams_str->RepetitionCounter == 3u )
    289                {
    290                  /* Set TIMx repetition counter to 1 */
    291                  LL_TIM_SetRepetitionCounter( TIMx, 1 );
    292                  LL_TIM_GenerateEvent_UPDATE( TIMx );
    293                  /* Repetition counter will be set to 3 at next Update */
    294                  LL_TIM_SetRepetitionCounter( TIMx, 3 );
    295                }
    296                else
    297                {
    298                }
    299              }
    300              else
    301              {
    302              }
    303            }
    304            LL_TIM_ClearFlag_BRK( TIMx );
    305            
    306            if ( ( pHandle->pParams_str->BKIN2Mode ) != NONE )
    307            {
    308              while ((LL_TIM_IsActiveFlag_BRK2 (TIMx) == 1u) && (Brk2Timeout != 0u) )
    309              {
    310                LL_TIM_ClearFlag_BRK2( TIMx );
    311                Brk2Timeout--;
    312              }   
    313            }
    314            LL_TIM_EnableIT_BRK( TIMx );
    315          
    316            /* Enable PWM channel */
    317            LL_TIM_CC_EnableChannel( TIMx, TIMxCCER_MASK_CH123 );
    318          }
    319          
    320          /**
    321            * @brief  It stores into the component the voltage present on Ia and
    322            *         Ib current feedback analog channels when no current is flowin into the
    323            *         motor
    324            * @param  pHandle: handler of the current instance of the PWM component
    325            * @retval none
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void R3_1_CurrentReadingPolarization( PWMC_Handle_t * pHdl )
    328          {
   \                     R3_1_CurrentReadingPolarization: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    329          #if defined (__ICCARM__)
    330            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    331          #endif /* __ICCARM__ */
    332            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    333          #if defined (__ICCARM__)
    334            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    335          #endif /* __ICCARM__ */
    336            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x4   0xF104 0x055C      ADD      R5,R4,#+92
    337            ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    338          
    339            pHandle->PhaseAOffset = 0u;
    340            pHandle->PhaseBOffset = 0u;
    341            pHandle->PhaseCOffset = 0u;
    342          
    343            pHandle->PolarizationCounter = 0u;
    344          
    345            /* It forces inactive level on TIMx CHy and CHyN */
    346            LL_TIM_CC_DisableChannel(TIMx, TIMxCCER_MASK_CH123);
    347          
    348            /* Offset calibration for all phases */
    349            /* Change function to be executed in ADCx_ISR */
    350            pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationAB;
   \        0x8   0x....'....        ADR.W    R2,R3_1_HFCurrentsPolarizationAB
   \        0xC   0x69A8             LDR      R0,[R5, #+24]
   \        0xE   0x6846             LDR      R6,[R0, #+4]
   \       0x10   0x6807             LDR      R7,[R0, #+0]
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6028             STR      R0,[R5, #+0]
   \       0x16   0x6068             STR      R0,[R5, #+4]
   \       0x18   0x60A8             STR      R0,[R5, #+8]
   \       0x1A   0x74A8             STRB     R0,[R5, #+18]
   \       0x1C   0x6A31             LDR      R1,[R6, #+32]
   \       0x1E   0x....'....        LDR.W    R0,??DataTable8_2  ;; 0xfffffaaa
   \       0x22   0x4001             ANDS     R1,R0,R1
   \       0x24   0x6231             STR      R1,[R6, #+32]
   \       0x26   0x6062             STR      R2,[R4, #+4]
    351            pHandle->_Super.pFctSetADCSampPointSectX = &R3_1_SetADCSampPointPolarization;
    352            pHandle->ADC_ExternalPolarityInjected = (uint16_t) LL_ADC_INJ_TRIG_EXT_RISING;
   \       0x28   0x2140             MOVS     R1,#+64
   \       0x2A   0x....'....        ADR.W    R0,R3_1_SetADCSampPointPolarization
   \       0x2E   0x61A0             STR      R0,[R4, #+24]
    353               
    354            /* We want to polarize calibration Phase A and Phase B, so we select SECTOR_5 */
    355            pHandle->PolarizationSector=SECTOR_5;
   \       0x30   0x2204             MOVS     R2,#+4
   \       0x32   0x8229             STRH     R1,[R5, #+16]
   \       0x34   0x74EA             STRB     R2,[R5, #+19]
    356            /* Required to force first polarization conversion on SECTOR_5*/
    357            pHandle->_Super.Sector = SECTOR_5;   
   \       0x36   0xF884 0x203A      STRB     R2,[R4, #+58]
    358            R3_1_SwitchOnPWM( &pHandle->_Super );
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x....'....        BL       R3_1_SwitchOnPWM
    359            
    360            /* IF CH4 is enabled, it means that JSQR is now configured to sample polarization current*/
    361            //while ( LL_TIM_CC_IsEnabledChannel(TIMx, LL_TIM_CHANNEL_CH4) == 0u )
    362            //{
    363            //}
    364            while ( ((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_OC4REF )
   \                     ??R3_1_CurrentReadingPolarization_0: (+1)
   \       0x40   0x6870             LDR      R0,[R6, #+4]
   \       0x42   0xF000 0x0070      AND      R0,R0,#0x70
   \       0x46   0x2870             CMP      R0,#+112
   \       0x48   0xD1FA             BNE.N    ??R3_1_CurrentReadingPolarization_0
    365            {
    366            }
    367            /* It is the right time to start the ADC without unwanted conversion */
    368            /* Start ADC to wait for external trigger. This is series dependant*/
    369            LL_ADC_INJ_StartConversion( ADCx );
   \       0x4A   0x68B9             LDR      R1,[R7, #+8]
   \       0x4C   0x....'....        LDR.W    R0,??DataTable8  ;; 0x7fffffc0
   \       0x50   0x4001             ANDS     R1,R0,R1
   \       0x52   0xF041 0x0108      ORR      R1,R1,#0x8
   \       0x56   0x60B9             STR      R1,[R7, #+8]
    370            
    371            /* Wait for NB_CONVERSIONS to be executed */
    372            waitForPolarizationEnd( TIMx,
    373            		                  &pHandle->_Super.SWerror,
    374            						  pHandle->pParams_str->RepetitionCounter,
    375            						  &pHandle->PolarizationCounter );
   \       0x58   0xF104 0x036E      ADD      R3,R4,#+110
   \       0x5C   0x69A8             LDR      R0,[R5, #+24]
   \       0x5E   0xF890 0x207B      LDRB     R2,[R0, #+123]
   \       0x62   0x....'....        BL       ?Subroutine3
    376          
    377            R3_1_SwitchOffPWM( &pHandle->_Super );
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x....'....        BL       R3_1_SwitchOffPWM
    378            
    379            /* Offset calibration for C phase */
    380            pHandle->PolarizationCounter = 0u;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x74A8             STRB     R0,[R5, #+18]
    381            
    382            /* Change function to be executed in ADCx_ISR */
    383            pHandle->_Super.pFctGetPhaseCurrents = &R3_1_HFCurrentsPolarizationC;
   \       0x70   0x....'....        ADR.W    R1,R3_1_HFCurrentsPolarizationC
   \       0x74   0x6061             STR      R1,[R4, #+4]
    384            /* We want to polarize Phase C, so we select SECTOR_1 */
    385            pHandle->PolarizationSector=SECTOR_1;
   \       0x76   0x74E8             STRB     R0,[R5, #+19]
    386            /* Required to force first polarization conversion on SECTOR_1*/
    387            pHandle->_Super.Sector = SECTOR_1; 
   \       0x78   0xF884 0x003A      STRB     R0,[R4, #+58]
    388            R3_1_SwitchOnPWM( &pHandle->_Super );
   \       0x7C   0x4620             MOV      R0,R4
   \       0x7E   0x....'....        BL       R3_1_SwitchOnPWM
    389          
    390            /* Wait for NB_CONVERSIONS to be executed */
    391            waitForPolarizationEnd( TIMx,
    392            		                  &pHandle->_Super.SWerror,
    393            						  pHandle->pParams_str->RepetitionCounter,
    394            						  &pHandle->PolarizationCounter );
   \       0x82   0x69A8             LDR      R0,[R5, #+24]
   \       0x84   0xF890 0x207B      LDRB     R2,[R0, #+123]
   \       0x88   0xF104 0x036E      ADD      R3,R4,#+110
   \       0x8C   0x....'....        BL       ?Subroutine3
    395            
    396            R3_1_SwitchOffPWM( &pHandle->_Super );
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0x....'....        BL       R3_1_SwitchOffPWM
    397            pHandle->PhaseAOffset /= NB_CONVERSIONS;
   \       0x96   0x6828             LDR      R0,[R5, #+0]
    398            pHandle->PhaseBOffset /= NB_CONVERSIONS;
   \       0x98   0x6869             LDR      R1,[R5, #+4]
   \       0x9A   0x0900             LSRS     R0,R0,#+4
   \       0x9C   0x6028             STR      R0,[R5, #+0]
   \       0x9E   0x0909             LSRS     R1,R1,#+4
    399            pHandle->PhaseCOffset /= NB_CONVERSIONS;
   \       0xA0   0x68A8             LDR      R0,[R5, #+8]
   \       0xA2   0x6069             STR      R1,[R5, #+4]
   \       0xA4   0x0900             LSRS     R0,R0,#+4
   \       0xA6   0x60A8             STR      R0,[R5, #+8]
    400          
    401            /* Change back function to be executed in ADCx_ISR */
    402            pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
   \       0xA8   0x....'....        LDR.W    R1,??DataTable8_3
    403            pHandle->_Super.pFctSetADCSampPointSectX = &R3_1_SetADCSampPointSectX;
   \       0xAC   0x....'....        ADR.W    R0,R3_1_SetADCSampPointSectX
   \       0xB0   0x6061             STR      R1,[R4, #+4]
   \       0xB2   0x61A0             STR      R0,[R4, #+24]
    404          
    405            /* It over write TIMx CCRy wrongly written by FOC during calibration so as to
    406               force 50% duty cycle on the three inverer legs */
    407            /* Disable TIMx preload */
    408            LL_TIM_OC_DisablePreload(TIMx,  LL_TIM_CHANNEL_CH1);
   \       0xB4   0x2101             MOVS     R1,#+1
   \       0xB6   0x4630             MOV      R0,R6
   \       0xB8   0x....'....        BL       LL_TIM_OC_DisablePreload
    409            LL_TIM_OC_DisablePreload(TIMx,  LL_TIM_CHANNEL_CH2);  
   \       0xBC   0x2110             MOVS     R1,#+16
   \       0xBE   0x4630             MOV      R0,R6
   \       0xC0   0x....'....        BL       LL_TIM_OC_DisablePreload
    410            LL_TIM_OC_DisablePreload(TIMx,  LL_TIM_CHANNEL_CH3);
   \       0xC4   0xF44F 0x7180      MOV      R1,#+256
   \       0xC8   0x4630             MOV      R0,R6
   \       0xCA   0x....'....        BL       LL_TIM_OC_DisablePreload
    411            LL_TIM_OC_SetCompareCH1 (TIMx, pHandle->Half_PWMPeriod);
   \       0xCE   0x89A8             LDRH     R0,[R5, #+12]
   \       0xD0   0x6370             STR      R0,[R6, #+52]
    412            LL_TIM_OC_SetCompareCH2 (TIMx, pHandle->Half_PWMPeriod);
   \       0xD2   0x89A9             LDRH     R1,[R5, #+12]
   \       0xD4   0x63B1             STR      R1,[R6, #+56]
    413            LL_TIM_OC_SetCompareCH3 (TIMx, pHandle->Half_PWMPeriod);
    414            /* Enable TIMx preload */
    415            LL_TIM_OC_EnablePreload(TIMx,  LL_TIM_CHANNEL_CH1);
   \       0xD6   0x2101             MOVS     R1,#+1
   \       0xD8   0x89A8             LDRH     R0,[R5, #+12]
   \       0xDA   0x63F0             STR      R0,[R6, #+60]
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0x....'....        BL       LL_TIM_OC_EnablePreload
    416            LL_TIM_OC_EnablePreload(TIMx,  LL_TIM_CHANNEL_CH2);  
   \       0xE2   0x2110             MOVS     R1,#+16
   \       0xE4   0x4630             MOV      R0,R6
   \       0xE6   0x....'....        BL       LL_TIM_OC_EnablePreload
    417            LL_TIM_OC_EnablePreload(TIMx,  LL_TIM_CHANNEL_CH3);
   \       0xEA   0xF44F 0x7180      MOV      R1,#+256
   \       0xEE   0x4630             MOV      R0,R6
   \       0xF0   0x....'....        BL       LL_TIM_OC_EnablePreload
    418          
    419            /* It re-enable drive of TIMx CHy and CHyN by TIMx CHyRef*/
    420            LL_TIM_CC_EnableChannel(TIMx, TIMxCCER_MASK_CH123);
   \       0xF4   0x6A31             LDR      R1,[R6, #+32]
   \       0xF6   0xF240 0x5055      MOVW     R0,#+1365
   \       0xFA   0x4301             ORRS     R1,R0,R1
   \       0xFC   0x6231             STR      R1,[R6, #+32]
    421            
    422            /* At the end of calibration, all phases are at 50% we will sample A&B */
    423            pHandle->_Super.Sector=SECTOR_5;
   \       0xFE   0x2204             MOVS     R2,#+4
   \      0x100   0xF884 0x203A      STRB     R2,[R4, #+58]
    424            
    425            pHandle->BrakeActionLock = false;
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x75A8             STRB     R0,[R5, #+22]
    426          
    427          }
   \      0x108   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF104 0x0138      ADD      R1,R4,#+56
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....'....        B.W      waitForPolarizationEnd
    428          
    429          #if defined (CCMRAM)
    430          #if defined (__ICCARM__)
    431          #pragma location = ".ccmram"
    432          #elif defined (__CC_ARM)
    433          __attribute__( ( section ( ".ccmram" ) ) )
    434          #endif
    435          #endif
    436          /**
    437            * @brief  It computes and return latest converted motor phase currents motor
    438            * @param  pHandle: handler of the current instance of the PWM component
    439            * @retval Ia and Ib current in Curr_Components format
    440            */ 

   \                                 In section .text, align 4
    441          __weak void R3_1_GetPhaseCurrents( PWMC_Handle_t * pHdl, ab_t * Iab )
    442          {
   \                     R3_1_GetPhaseCurrents: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    443          #if defined (__ICCARM__)
    444            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    445          #endif /* __ICCARM__ */
    446            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;  
    447          #if defined (__ICCARM__)
    448            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    449          #endif /* __ICCARM__ */
    450            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
    451          
    452            uint8_t Sector;
    453            int32_t Aux;
    454            uint32_t ADCDataReg1;
    455            uint32_t ADCDataReg2;
    456            
    457            Sector = ( uint8_t )pHandle->_Super.Sector;
   \        0x4   0xF100 0x023A      ADD      R2,R0,#+58
    458            ADCDataReg1 = *pHandle->pParams_str->ADCDataReg1[Sector];
   \        0x8   0x305C             ADDS     R0,R0,#+92
   \        0xA   0x7816             LDRB     R6,[R2, #+0]
   \        0xC   0xF8D0 0xC018      LDR      R12,[R0, #+24]
   \       0x10   0xF9B1 0x3000      LDRSH    R3,[R1, #+0]
   \       0x14   0xF9B1 0x4002      LDRSH    R4,[R1, #+2]
    459            ADCDataReg2 = *pHandle->pParams_str->ADCDataReg2[Sector];
    460            
    461            /* disable ADC trigger source */
    462            //LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4);  
    463            LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);
    464            
    465            switch ( Sector )
   \       0x18   0xF8DF 0x80C4      LDR.W    R8,??R3_1_GetPhaseCurrents_1  ;; 0xffff8001
   \       0x1C   0xEB0C 0x0586      ADD      R5,R12,R6, LSL #+2
   \       0x20   0x2E05             CMP      R6,#+5
   \       0x22   0x6A6F             LDR      R7,[R5, #+36]
   \       0x24   0x683F             LDR      R7,[R7, #+0]
   \       0x26   0x6BED             LDR      R5,[R5, #+60]
   \       0x28   0x682D             LDR      R5,[R5, #+0]
   \       0x2A   0xF8DC 0xC004      LDR      R12,[R12, #+4]
   \       0x2E   0xF8DC 0xE004      LDR      LR,[R12, #+4]
   \       0x32   0xF02E 0x0E70      BIC      LR,LR,#0x70
   \       0x36   0xF8CC 0xE004      STR      LR,[R12, #+4]
   \       0x3A   0xF647 0x7EFF      MOVW     LR,#+32767
   \       0x3E   0xD842             BHI.N    ??R3_1_GetPhaseCurrents_2
   \       0x40   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??R3_1_GetPhaseCurrents_0:
   \       0x44   0x15 0x2B          DC8      0x15,0x2B,0x2B,0x3

   \              0x2B 0x03
   \       0x48   0x03 0x15          DC8      0x3,0x15
    466            {
    467              case SECTOR_4:
    468              case SECTOR_5:
    469                /* Current on Phase C is not accessible     */
    470                /* Ia = PhaseAOffset - ADC converted value) */
    471                Aux = ( int32_t )( pHandle->PhaseAOffset ) - ( int32_t )( ADCDataReg1 );
   \                     ??R3_1_GetPhaseCurrents_3: (+1)
   \       0x4A   0x6804             LDR      R4,[R0, #+0]
   \       0x4C   0x1BE3             SUBS     R3,R4,R7
    472          
    473                /* Saturation of Ia */
    474                if ( Aux < -INT16_MAX )
   \       0x4E   0x4543             CMP      R3,R8
   \       0x50   0xBFB8             IT       LT
   \       0x52   0x4643             MOVLT    R3,R8
    475                {
    476                  Iab->a = -INT16_MAX;
   \       0x54   0xDB03             BLT.N    ??R3_1_GetPhaseCurrents_4
    477                }
    478                else  if ( Aux > INT16_MAX )
   \       0x56   0xF5B3 0x4F00      CMP      R3,#+32768
   \       0x5A   0xBFA8             IT       GE
   \       0x5C   0x4673             MOVGE    R3,LR
    479                {
    480                  Iab->a = INT16_MAX;
    481                }
    482                else
    483                {
    484                  Iab->a = ( int16_t )Aux;
    485                }
    486          
    487                /* Ib = PhaseBOffset - ADC converted value) */
    488                Aux = ( int32_t )( pHandle->PhaseBOffset ) - ( int32_t )( ADCDataReg2 );
   \                     ??R3_1_GetPhaseCurrents_4: (+1)
   \       0x5E   0x6840             LDR      R0,[R0, #+4]
   \       0x60   0x1B44             SUBS     R4,R0,R5
    489          
    490                /* Saturation of Ib */
    491                if ( Aux < -INT16_MAX )
   \       0x62   0x4544             CMP      R4,R8
   \       0x64   0xDB2E             BLT.N    ??R3_1_GetPhaseCurrents_5
    492                {
    493                  Iab->b = -INT16_MAX;
    494                }
    495                else  if ( Aux > INT16_MAX )
   \       0x66   0xF5B4 0x4F00      CMP      R4,#+32768
   \       0x6A   0xDB2C             BLT.N    ??R3_1_GetPhaseCurrents_2
    496                {
    497                  Iab->b = INT16_MAX;
   \       0x6C   0xE026             B.N      ??R3_1_GetPhaseCurrents_6
    498                }
    499                else
    500                {
    501                  Iab->b = ( int16_t )Aux;
    502                }
    503                break;
    504          
    505              case SECTOR_6:
    506              case SECTOR_1:
    507                /* Current on Phase A is not accessible     */
    508                /* Ib = PhaseBOffset - ADC converted value) */
    509                Aux = ( int32_t )( pHandle->PhaseBOffset ) - ( int32_t )( ADCDataReg1 );
   \                     ??R3_1_GetPhaseCurrents_7: (+1)
   \       0x6E   0x6843             LDR      R3,[R0, #+4]
   \       0x70   0x1BDC             SUBS     R4,R3,R7
    510          
    511                /* Saturation of Ib */
    512                if ( Aux < -INT16_MAX )
   \       0x72   0x4544             CMP      R4,R8
   \       0x74   0xBFB8             IT       LT
   \       0x76   0x4644             MOVLT    R4,R8
    513                {
    514                  Iab->b = -INT16_MAX;
   \       0x78   0xDB03             BLT.N    ??R3_1_GetPhaseCurrents_8
    515                }
    516                else  if ( Aux > INT16_MAX )
   \       0x7A   0xF5B4 0x4F00      CMP      R4,#+32768
   \       0x7E   0xBFA8             IT       GE
   \       0x80   0x4674             MOVGE    R4,LR
    517                {
    518                  Iab->b = INT16_MAX;
    519                }
    520                else
    521                {
    522                  Iab->b = ( int16_t )Aux;
    523                }
    524          
    525                /* Ia = -Ic -Ib */
    526                Aux = ( int32_t )( ADCDataReg2 ) - ( int32_t )( pHandle->PhaseCOffset ); /* -Ic */
    527                Aux -= ( int32_t )Iab->b;             /* Ia  */
   \                     ??R3_1_GetPhaseCurrents_8: (+1)
   \       0x82   0x6880             LDR      R0,[R0, #+8]
   \       0x84   0x1A2D             SUBS     R5,R5,R0
   \       0x86   0xB223             SXTH     R3,R4
   \       0x88   0x1AEB             SUBS     R3,R5,R3
    528          
    529                /* Saturation of Ia */
    530                if ( Aux > INT16_MAX )
   \       0x8A   0xF5B3 0x4F00      CMP      R3,#+32768
   \       0x8E   0xBFAC             ITE      GE
   \       0x90   0x4673             MOVGE    R3,LR
   \       0x92   0x4543             CMPLT    R3,R8
    531                {
    532                  Iab->a = INT16_MAX;
    533                }
    534                else  if ( Aux < -INT16_MAX )
   \       0x94   0xDA17             BGE.N    ??R3_1_GetPhaseCurrents_2
    535                {
    536                  Iab->a = -INT16_MAX;
   \       0x96   0x4643             MOV      R3,R8
   \       0x98   0xE015             B.N      ??R3_1_GetPhaseCurrents_2
    537                }
    538                else
    539                {
    540                  Iab->a = ( int16_t )Aux;
    541                }
    542                break;
    543          
    544              case SECTOR_2:
    545              case SECTOR_3:
    546                /* Current on Phase B is not accessible     */
    547                /* Ia = PhaseAOffset - ADC converted value) */
    548                Aux = ( int32_t )( pHandle->PhaseAOffset ) - ( int32_t )( ADCDataReg1 );
   \                     ??R3_1_GetPhaseCurrents_9: (+1)
   \       0x9A   0x6804             LDR      R4,[R0, #+0]
   \       0x9C   0x1BE3             SUBS     R3,R4,R7
    549          
    550                /* Saturation of Ia */
    551                if ( Aux < -INT16_MAX )
   \       0x9E   0x4543             CMP      R3,R8
   \       0xA0   0xBFB8             IT       LT
   \       0xA2   0x4643             MOVLT    R3,R8
    552                {
    553                  Iab->a = -INT16_MAX;
   \       0xA4   0xDB03             BLT.N    ??R3_1_GetPhaseCurrents_10
    554                }
    555                else  if ( Aux > INT16_MAX )
   \       0xA6   0xF5B3 0x4F00      CMP      R3,#+32768
   \       0xAA   0xBFA8             IT       GE
   \       0xAC   0x4673             MOVGE    R3,LR
    556                {
    557                  Iab->a = INT16_MAX;
    558                }
    559                else
    560                {
    561                  Iab->a = ( int16_t )Aux;
    562                }
    563          
    564                /* Ib = -Ic -Ia */
    565                Aux = ( int32_t )( ADCDataReg2 ) - ( int32_t )( pHandle->PhaseCOffset ); /* -Ic */
    566                Aux -= ( int32_t )Iab->a;             /* Ib */
   \                     ??R3_1_GetPhaseCurrents_10: (+1)
   \       0xAE   0x6880             LDR      R0,[R0, #+8]
   \       0xB0   0x1A2D             SUBS     R5,R5,R0
   \       0xB2   0xB21C             SXTH     R4,R3
   \       0xB4   0x1B2C             SUBS     R4,R5,R4
    567          
    568                /* Saturation of Ib */
    569                if ( Aux > INT16_MAX )
   \       0xB6   0xF5B4 0x4F00      CMP      R4,#+32768
   \       0xBA   0xDB01             BLT.N    ??R3_1_GetPhaseCurrents_11
    570                {
    571                  Iab->b = INT16_MAX;
   \                     ??R3_1_GetPhaseCurrents_6: (+1)
   \       0xBC   0x4674             MOV      R4,LR
   \       0xBE   0xE002             B.N      ??R3_1_GetPhaseCurrents_2
    572                }
    573                else  if ( Aux < -INT16_MAX )
   \                     ??R3_1_GetPhaseCurrents_11: (+1)
   \       0xC0   0x4544             CMP      R4,R8
   \       0xC2   0xDA00             BGE.N    ??R3_1_GetPhaseCurrents_2
    574                {
    575                  Iab->b = -INT16_MAX;
   \                     ??R3_1_GetPhaseCurrents_5: (+1)
   \       0xC4   0x4644             MOV      R4,R8
    576                }
    577                else
    578                {
    579                  Iab->b = ( int16_t )Aux;
    580                }
    581                break;
    582          
    583              default:
    584                break;
    585            }
    586          
    587            pHandle->_Super.Ia = Iab->a;
   \                     ??R3_1_GetPhaseCurrents_2: (+1)
   \       0xC6   0x804C             STRH     R4,[R1, #+2]
   \       0xC8   0x800B             STRH     R3,[R1, #+0]
   \       0xCA   0x81D3             STRH     R3,[R2, #+14]
    588            pHandle->_Super.Ib = Iab->b;
   \       0xCC   0x8848             LDRH     R0,[R1, #+2]
   \       0xCE   0x8210             STRH     R0,[R2, #+16]
    589            pHandle->_Super.Ic = -Iab->a - Iab->b;
   \       0xD0   0xF9B1 0x3000      LDRSH    R3,[R1, #+0]
   \       0xD4   0x8848             LDRH     R0,[R1, #+2]
   \       0xD6   0x425B             RSBS     R3,R3,#+0
   \       0xD8   0x1A1B             SUBS     R3,R3,R0
   \       0xDA   0x8253             STRH     R3,[R2, #+18]
    590          }
   \       0xDC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??R3_1_GetPhaseCurrents_1:
   \       0xE0   0xFFFF'8001        DC32     0xffff8001
    591          
    592          #if defined (CCMRAM)
    593          #if defined (__ICCARM__)
    594          #pragma location = ".ccmram"
    595          #elif defined (__CC_ARM)
    596          __attribute__( ( section ( ".ccmram" ) ) )
    597          #endif
    598          #endif
    599          /**
    600           * @brief  Configure the ADC for the current sampling during calibration.
    601           *         It means set the sampling point via TIMx_Ch4 value and polarity
    602           *         ADC sequence length and channels.
    603           *         And call the WriteTIMRegisters method.
    604           * @param  pHandle: handler of the current instance of the PWM component
    605           * @retval none
    606           */

   \                                 In section .text, align 4, keep-with-next
    607          uint16_t R3_1_SetADCSampPointPolarization( PWMC_Handle_t * pHdl )
    608          {
    609          #if defined (__ICCARM__)
    610            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    611          #endif /* __ICCARM__ */
    612            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    613          #if defined (__ICCARM__)
    614            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    615          #endif /* __ICCARM__ */
    616            pHandle->_Super.Sector = pHandle->PolarizationSector;
   \                     R3_1_SetADCSampPointPolarization: (+1)
   \        0x0   0xF100 0x013A      ADD      R1,R0,#+58
   \        0x4   0xF890 0x206F      LDRB     R2,[R0, #+111]
   \        0x8   0x700A             STRB     R2,[R1, #+0]
    617          
    618            return R3_1_WriteTIMRegisters( &pHandle->_Super, ( pHandle->Half_PWMPeriod - (uint16_t) 1 ) );
   \        0xA   0x8DC9             LDRH     R1,[R1, #+46]
   \        0xC   0x1E49             SUBS     R1,R1,#+1
   \        0xE   0x....             B.N      ?Subroutine1
    619          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB289             UXTH     R1,R1
   \        0x2                      REQUIRE R3_1_WriteTIMRegisters
   \        0x2                      ;; // Fall through to label R3_1_WriteTIMRegisters
    620          
    621          #if defined (CCMRAM)
    622          #if defined (__ICCARM__)
    623          #pragma location = ".ccmram"
    624          #elif defined (__CC_ARM)
    625          __attribute__( ( section ( ".ccmram" ) ) )
    626          #endif
    627          #endif
    628          /**
    629            * @brief  Configure the ADC for the current sampling related to sector 1.
    630            *         It means set the sampling point via TIMx_Ch4 value and polarity
    631            *         ADC sequence length and channels.
    632            *         And call the WriteTIMRegisters method.
    633            * @param  pHandle Pointer on the target component instance
    634            * @retval none
    635            */

   \                                 In section .text, align 4, keep-with-next
    636          uint16_t R3_1_SetADCSampPointSectX( PWMC_Handle_t * pHdl )
    637          {
   \                     R3_1_SetADCSampPointSectX: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    638          #if defined (__ICCARM__)
    639            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    640          #endif /* __ICCARM__ */
    641            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    642          #if defined (__ICCARM__)
    643            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    644          #endif /* __ICCARM__ */
    645            uint16_t SamplingPoint;
    646            uint16_t DeltaDuty;
    647          
    648            /* Verify that sampling is possible in the middle of PWM by checking the smallest duty cycle */
    649             if ( ( uint16_t )( pHandle->Half_PWMPeriod - pHdl->lowDuty ) > pHandle->pParams_str->Tafter )
   \        0x2   0xF100 0x023A      ADD      R2,R0,#+58
   \        0x6   0x6F45             LDR      R5,[R0, #+116]
   \        0x8   0x8851             LDRH     R1,[R2, #+2]
   \        0xA   0x8DD3             LDRH     R3,[R2, #+46]
   \        0xC   0xF835 0x6F72      LDRH     R6,[R5, #+114]!
   \       0x10   0x1A5C             SUBS     R4,R3,R1
   \       0x12   0xB2A7             UXTH     R7,R4
   \       0x14   0x42BE             CMP      R6,R7
   \       0x16   0xD204             BCS.N    ??R3_1_SetADCSampPointSectX_0
    650            {
    651              /* When it is possible to sample in the middle of the PWM period, always sample the same phases
    652               * (AB are chosen) for all sectors in order to not induce current discontinuities when there are differences
    653               * between offsets */
    654          
    655              /* sector number needed by GetPhaseCurrent, phase A and B are sampled which corresponds
    656               * to sector 4 or 5  */
    657              pHandle->_Super.Sector = SECTOR_5;
   \       0x18   0x2104             MOVS     R1,#+4
   \       0x1A   0x7011             STRB     R1,[R2, #+0]
    658          
    659              /* set sampling  point trigger in the middle of PWM period */
    660              SamplingPoint =  pHandle->Half_PWMPeriod - (uint16_t) 1;
   \       0x1C   0x8DD2             LDRH     R2,[R2, #+46]
   \       0x1E   0x1E51             SUBS     R1,R2,#+1
   \       0x20   0xE013             B.N      ??R3_1_SetADCSampPointSectX_1
    661            }
    662            else
    663            {
    664              /* In this case it is necessary to convert phases with Maximum and variable complementary duty cycle.*/
    665          
    666              /* ADC Injected sequence configuration. The stator phase with minimum value of complementary
    667                  duty cycle is set as first. In every sector there is always one phase with maximum complementary duty,
    668                  one with minimum complementary duty and one with variable complementary duty. In this case, phases
    669                  with variable complementary duty and with maximum duty are converted and the first will be always
    670                  the phase with variable complementary duty cycle */
    671              DeltaDuty = ( uint16_t )( pHdl->lowDuty - pHdl->midDuty );
    672          
    673              /* Definition of crossing point */
    674              if ( DeltaDuty > ( uint16_t )( pHandle->Half_PWMPeriod - pHdl->lowDuty ) * 2u )
   \                     ??R3_1_SetADCSampPointSectX_0: (+1)
   \       0x22   0x8897             LDRH     R7,[R2, #+4]
   \       0x24   0x0424             LSLS     R4,R4,#+16
   \       0x26   0x1BCF             SUBS     R7,R1,R7
   \       0x28   0x0BE4             LSRS     R4,R4,#+15
   \       0x2A   0xB2BF             UXTH     R7,R7
   \       0x2C   0x42BC             CMP      R4,R7
   \       0x2E   0xD202             BCS.N    ??R3_1_SetADCSampPointSectX_2
    675              {
    676                SamplingPoint = pHdl->lowDuty - pHandle->pParams_str->Tbefore;
   \       0x30   0x886A             LDRH     R2,[R5, #+2]
   \       0x32   0x1A89             SUBS     R1,R1,R2
   \       0x34   0xE009             B.N      ??R3_1_SetADCSampPointSectX_1
    677              }
    678              else
    679              {
    680                SamplingPoint = pHdl->lowDuty + pHandle->pParams_str->Tafter;
   \                     ??R3_1_SetADCSampPointSectX_2: (+1)
   \       0x36   0x1871             ADDS     R1,R6,R1
    681          
    682                if ( SamplingPoint >= pHandle->Half_PWMPeriod )
   \       0x38   0xB28C             UXTH     R4,R1
   \       0x3A   0x429C             CMP      R4,R3
   \       0x3C   0xD305             BCC.N    ??R3_1_SetADCSampPointSectX_1
    683                {
    684                   /* ADC trigger edge must be changed from positive to negative */
    685                  pHandle->ADC_ExternalPolarityInjected = (uint16_t) LL_ADC_INJ_TRIG_EXT_FALLING;
   \       0x3E   0x2380             MOVS     R3,#+128
   \       0x40   0x8653             STRH     R3,[R2, #+50]
    686                  SamplingPoint = ( 2u * pHandle->Half_PWMPeriod ) - SamplingPoint - (uint16_t) 1;
   \       0x42   0x8DD2             LDRH     R2,[R2, #+46]
   \       0x44   0xEBC1 0x0142      RSB      R1,R1,R2, LSL #+1
   \       0x48   0x1E49             SUBS     R1,R1,#+1
    687                }
    688              }
    689            }
    690            return R3_1_WriteTIMRegisters( &pHandle->_Super, SamplingPoint );
   \                     ??R3_1_SetADCSampPointSectX_1: (+1)
   \       0x4A   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x4E   0xBF00             Nop
   \       0x50                      REQUIRE ?Subroutine1
   \       0x50                      ;; // Fall through to label ?Subroutine1
    691          }
    692          
    693          
    694          #if defined (CCMRAM)
    695          #if defined (__ICCARM__)
    696          #pragma location = ".ccmram"
    697          #elif defined (__CC_ARM)
    698          __attribute__( ( section ( ".ccmram" ) ) )
    699          #endif
    700          #endif
    701          /**
    702            * @brief  Stores into the component's handle the voltage present on Ia and
    703            *         Ib current feedback analog channels when no current is flowin into the
    704            *         motor
    705            * @param  pHandle handler of the current instance of the PWM component
    706            * @retval none
    707            */

   \                                 In section .text, align 2, keep-with-next
    708          __STATIC_INLINE uint16_t R3_1_WriteTIMRegisters( PWMC_Handle_t * pHdl, uint16_t SamplingPoint )
    709          {
   \                     R3_1_WriteTIMRegisters: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    710          #if defined (__ICCARM__)
    711            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    712          #endif /* __ICCARM__ */
    713            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    714          #if defined (__ICCARM__)
    715            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    716          #endif /* __ICCARM__ */
    717            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x6   0x6F60             LDR      R0,[R4, #+116]
   \        0x8   0x6846             LDR      R6,[R0, #+4]
    718            uint16_t Aux;
    719          
    720          
    721            LL_TIM_OC_SetCompareCH1 ( TIMx, (uint32_t) pHandle->_Super.CntPhA );
   \        0xA   0x8E61             LDRH     R1,[R4, #+50]
   \        0xC   0x4630             MOV      R0,R6
   \        0xE   0x....'....        BL       LL_TIM_OC_SetCompareCH1
    722            LL_TIM_OC_SetCompareCH2 ( TIMx, (uint32_t) pHandle->_Super.CntPhB );
   \       0x12   0x8EA1             LDRH     R1,[R4, #+52]
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x....'....        BL       LL_TIM_OC_SetCompareCH2
    723            LL_TIM_OC_SetCompareCH3 ( TIMx, (uint32_t) pHandle->_Super.CntPhC );
   \       0x1A   0x8EE1             LDRH     R1,[R4, #+54]
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x....'....        BL       LL_TIM_OC_SetCompareCH3
    724            LL_TIM_OC_SetCompareCH4( TIMx, (uint32_t) SamplingPoint );
   \       0x22   0x4629             MOV      R1,R5
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x....'....        BL       LL_TIM_OC_SetCompareCH4
    725          
    726            /* Limit for update event */
    727          
    728          //  if ( LL_TIM_CC_IsEnabledChannel(TIMx, LL_TIM_CHANNEL_CH4) == 1u )
    729            if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET )
   \       0x2A   0x6870             LDR      R0,[R6, #+4]
   \       0x2C   0xF010 0x0070      ANDS     R0,R0,#0x70
   \       0x30   0xBF18             IT       NE
   \       0x32   0x2001             MOVNE    R0,#+1
    730            {
    731              Aux = MC_FOC_DURATION;
    732            }
    733            else
    734            {
    735              Aux = MC_NO_ERROR;
    736            }
    737            return Aux;
   \       0x34   0xBD70             POP      {R4-R6,PC}       ;; return
    738          }
    739          /**
    740            * @brief  Implementaion of PWMC_GetPhaseCurrents to be performed during
    741            *         calibration. It sum up injected conversion data into PhaseAOffset and
    742            *         PhaseBOffset to compute the offset introduced in the current feedback
    743            *         network. It is requied to proper configure ADC inputs before to enable
    744            *         the offset computation.
    745            * @param  pHandle Pointer on the target component instance
    746            * @retval It always returns {0,0} in Curr_Components format
    747            */

   \                                 In section .text, align 4, keep-with-next
    748          static void R3_1_HFCurrentsPolarizationAB( PWMC_Handle_t * pHdl, ab_t * Iab )
    749          {
   \                     R3_1_HFCurrentsPolarizationAB: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
    750          #if defined (__ICCARM__)
    751            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    752          #endif /* __ICCARM__ */
    753            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    754          #if defined (__ICCARM__)
    755            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    756          #endif /* __ICCARM__ */
    757            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
    758            uint32_t ADCDataReg1 = *pHandle->pParams_str->ADCDataReg1[pHandle->PolarizationSector];
   \        0x6   0xF104 0x066E      ADD      R6,R4,#+110
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x6F60             LDR      R0,[R4, #+116]
   \        0xE   0x7871             LDRB     R1,[R6, #+1]
   \       0x10   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \       0x14   0x6A4A             LDR      R2,[R1, #+36]
   \       0x16   0x6817             LDR      R7,[R2, #+0]
    759            uint32_t ADCDataReg2 = *pHandle->pParams_str->ADCDataReg2[pHandle->PolarizationSector];
   \       0x18   0x6BCB             LDR      R3,[R1, #+60]
   \       0x1A   0xF8D3 0x8000      LDR      R8,[R3, #+0]
    760             
    761            /* disable ADC trigger source */
    762            //LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4);
    763              LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);
   \       0x1E   0x6840             LDR      R0,[R0, #+4]
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x....'....        BL       LL_TIM_SetTriggerOutput
    764          
    765            if ( pHandle->PolarizationCounter < NB_CONVERSIONS )
   \       0x26   0x7831             LDRB     R1,[R6, #+0]
   \       0x28   0x2910             CMP      R1,#+16
   \       0x2A   0xD209             BCS.N    ??R3_1_HFCurrentsPolarizationAB_0
    766            {
    767              pHandle-> PhaseAOffset += ADCDataReg1;
   \       0x2C   0x6DE0             LDR      R0,[R4, #+92]
    768              pHandle-> PhaseBOffset += ADCDataReg2;
   \       0x2E   0x6E21             LDR      R1,[R4, #+96]
   \       0x30   0x183F             ADDS     R7,R7,R0
   \       0x32   0x4488             ADD      R8,R8,R1
   \       0x34   0x65E7             STR      R7,[R4, #+92]
   \       0x36   0xF8C4 0x8060      STR      R8,[R4, #+96]
    769              pHandle->PolarizationCounter++;
   \       0x3A   0x7830             LDRB     R0,[R6, #+0]
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x7030             STRB     R0,[R6, #+0]
    770            }
    771          
    772            /* during offset calibration no current is flowing in the phases */
    773            Iab->a = 0;
   \                     ??R3_1_HFCurrentsPolarizationAB_0: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x8029             STRH     R1,[R5, #+0]
    774            Iab->b = 0;
   \       0x44   0x8069             STRH     R1,[R5, #+2]
    775          }
   \       0x46   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    776          
    777          /**
    778            * @brief  Implementaion of PWMC_GetPhaseCurrents to be performed during
    779            *         calibration. It sum up injected conversion data into PhaseAOffset and
    780            *         PhaseBOffset to compute the offset introduced in the current feedback
    781            *         network. It is requied to proper configure ADC inputs before to enable
    782            *         the offset computation.
    783            * @param  pHandle Pointer on the target component instance
    784            * @retval It always returns {0,0} in Curr_Components format
    785            */

   \                                 In section .text, align 4, keep-with-next
    786          static void R3_1_HFCurrentsPolarizationC( PWMC_Handle_t * pHdl, ab_t * Iab )
    787          {
   \                     R3_1_HFCurrentsPolarizationC: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    788          #if defined (__ICCARM__)
    789            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    790          #endif /* __ICCARM__ */
    791            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    792          #if defined (__ICCARM__)
    793            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    794          #endif /* __ICCARM__ */
    795            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
    796            uint32_t ADCDataReg2 = *pHandle->pParams_str->ADCDataReg2[pHandle->PolarizationSector];
   \        0x2   0xF100 0x0564      ADD      R5,R0,#+100
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x6928             LDR      R0,[R5, #+16]
   \        0xA   0x7AE9             LDRB     R1,[R5, #+11]
   \        0xC   0xEB00 0x0281      ADD      R2,R0,R1, LSL #+2
    797          
    798            /* disable ADC trigger source */
    799            //LL_TIM_CC_DisableChannel(TIMx, LL_TIM_CHANNEL_CH4);
    800              LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x6BD3             LDR      R3,[R2, #+60]
   \       0x14   0x681E             LDR      R6,[R3, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0x....'....        BL       LL_TIM_SetTriggerOutput
    801          
    802            if ( pHandle->PolarizationCounter < NB_CONVERSIONS )
   \       0x1C   0x7AA8             LDRB     R0,[R5, #+10]
   \       0x1E   0x2810             CMP      R0,#+16
   \       0x20   0xD205             BCS.N    ??R3_1_HFCurrentsPolarizationC_0
    803            {
    804              /* Phase C is read from SECTOR_1, second value */
    805              pHandle-> PhaseCOffset += ADCDataReg2;    
   \       0x22   0x6829             LDR      R1,[R5, #+0]
    806              pHandle->PolarizationCounter++;
   \       0x24   0x7AA8             LDRB     R0,[R5, #+10]
   \       0x26   0x1876             ADDS     R6,R6,R1
   \       0x28   0x1C40             ADDS     R0,R0,#+1
   \       0x2A   0x602E             STR      R6,[R5, #+0]
   \       0x2C   0x72A8             STRB     R0,[R5, #+10]
    807            }
    808          
    809            /* during offset calibration no current is flowing in the phases */
    810            Iab->a = 0;
   \                     ??R3_1_HFCurrentsPolarizationC_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x....             B.N      ?Subroutine0
    811            Iab->b = 0;
    812          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x8020             STRH     R0,[R4, #+0]
   \        0x2   0x8060             STRH     R0,[R4, #+2]
   \        0x4   0xBD70             POP      {R4-R6,PC}       ;; return
    813          /**
    814            * @brief  It turns on low sides switches. This function is intended to be
    815            *         used for charging boot capacitors of driving section. It has to be
    816            *         called each motor start-up when using high voltage drivers
    817            * @param  pHandle: handler of the current instance of the PWM component
    818            * @retval none
    819            */

   \                                 In section .text, align 2
    820          __weak void R3_1_TurnOnLowSides( PWMC_Handle_t * pHdl )
    821          {
   \                     R3_1_TurnOnLowSides: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    822          #if defined (__ICCARM__)
    823            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    824          #endif /* __ICCARM__ */
    825            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    826          #if defined (__ICCARM__)
    827            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    828          #endif /* __ICCARM__ */
    829            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x2   0x6F41             LDR      R1,[R0, #+116]
   \        0x4   0x6849             LDR      R1,[R1, #+4]
    830          
    831            pHandle->_Super.TurnOnLowSidesAction = true;
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0xF880 0x2042      STRB     R2,[R0, #+66]
    832          
    833            /* Clear Update Flag */
    834            LL_TIM_ClearFlag_UPDATE( pHandle->pParams_str->TIMx );
   \        0xC   0xF06F 0x0301      MVN      R3,#+1
   \       0x10   0x6F42             LDR      R2,[R0, #+116]
   \       0x12   0x6854             LDR      R4,[R2, #+4]
   \       0x14   0x6123             STR      R3,[R4, #+16]
    835          
    836            /*Turn on the three low side switches */
    837            LL_TIM_OC_SetCompareCH1( TIMx, 0u );
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x634A             STR      R2,[R1, #+52]
    838            LL_TIM_OC_SetCompareCH2( TIMx, 0u );
   \       0x1A   0x638A             STR      R2,[R1, #+56]
    839            LL_TIM_OC_SetCompareCH3( TIMx, 0u );
   \       0x1C   0x63CA             STR      R2,[R1, #+60]
    840          
    841            /* Wait until next update */
    842            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0u )
   \                     ??R3_1_TurnOnLowSides_0: (+1)
   \       0x1E   0x690A             LDR      R2,[R1, #+16]
   \       0x20   0x07D3             LSLS     R3,R2,#+31
   \       0x22   0xD5FC             BPL.N    ??R3_1_TurnOnLowSides_0
    843            {}
    844          
    845            /* Main PWM Output Enable */
    846            LL_TIM_EnableAllOutputs( TIMx );
   \       0x24   0x6C4A             LDR      R2,[R1, #+68]
   \       0x26   0xF442 0x4200      ORR      R2,R2,#0x8000
   \       0x2A   0x644A             STR      R2,[R1, #+68]
    847          
    848            if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x2C   0x6F41             LDR      R1,[R0, #+116]
   \       0x2E   0xF101 0x026C      ADD      R2,R1,#+108
   \       0x32   0x7B93             LDRB     R3,[R2, #+14]
   \       0x34   0x2B02             CMP      R3,#+2
   \       0x36   0xD10C             BNE.N    ??R3_1_TurnOnLowSides_1
    849            {
    850              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x38   0x6989             LDR      R1,[R1, #+24]
   \       0x3A   0x8812             LDRH     R2,[R2, #+0]
   \       0x3C   0x618A             STR      R2,[R1, #+24]
    851              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x3E   0x6F41             LDR      R1,[R0, #+116]
   \       0x40   0xF8B1 0x206E      LDRH     R2,[R1, #+110]
   \       0x44   0x69C9             LDR      R1,[R1, #+28]
   \       0x46   0x618A             STR      R2,[R1, #+24]
    852              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x48   0x6F40             LDR      R0,[R0, #+116]
   \       0x4A   0xF8B0 0x1070      LDRH     R1,[R0, #+112]
   \       0x4E   0x6A00             LDR      R0,[R0, #+32]
   \       0x50   0x6181             STR      R1,[R0, #+24]
    853            }
    854            return;
   \                     ??R3_1_TurnOnLowSides_1: (+1)
   \       0x52   0xBD10             POP      {R4,PC}          ;; return
    855          }
    856          
    857          
    858          /**
    859            * @brief  It enables PWM generation on the proper Timer peripheral acting on MOE
    860            *         bit
    861            * @param  pHandle: handler of the current instance of the PWM component
    862            * @retval none
    863            */

   \                                 In section .text, align 2
    864          __weak void R3_1_SwitchOnPWM( PWMC_Handle_t * pHdl )
    865          {
   \                     R3_1_SwitchOnPWM: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    866          #if defined (__ICCARM__)
    867            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    868          #endif /* __ICCARM__ */
    869            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    870          #if defined (__ICCARM__)
    871            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    872          #endif /* __ICCARM__ */
    873            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x2   0x6F41             LDR      R1,[R0, #+116]
   \        0x4   0x6849             LDR      R1,[R1, #+4]
    874          
    875            pHandle->_Super.TurnOnLowSidesAction = false;
   \        0x6   0xF100 0x0242      ADD      R2,R0,#+66
   \        0xA   0x2300             MOVS     R3,#+0
    876          
    877            /* Set all duty to 50% */
    878            LL_TIM_OC_SetCompareCH1(TIMx, ((uint32_t) pHandle->Half_PWMPeriod / (uint32_t) 2));
   \        0xC   0x8CD4             LDRH     R4,[R2, #+38]
   \        0xE   0x7013             STRB     R3,[R2, #+0]
   \       0x10   0x0864             LSRS     R4,R4,#+1
   \       0x12   0x634C             STR      R4,[R1, #+52]
    879            LL_TIM_OC_SetCompareCH2(TIMx, ((uint32_t) pHandle->Half_PWMPeriod / (uint32_t) 2));
   \       0x14   0x8CD3             LDRH     R3,[R2, #+38]
   \       0x16   0x085B             LSRS     R3,R3,#+1
   \       0x18   0x638B             STR      R3,[R1, #+56]
    880            LL_TIM_OC_SetCompareCH3(TIMx, ((uint32_t) pHandle->Half_PWMPeriod / (uint32_t) 2));
   \       0x1A   0x8CD3             LDRH     R3,[R2, #+38]
   \       0x1C   0x085B             LSRS     R3,R3,#+1
   \       0x1E   0x63CB             STR      R3,[R1, #+60]
    881            LL_TIM_OC_SetCompareCH4(TIMx, ((uint32_t) pHandle->Half_PWMPeriod - (uint32_t) 5));
   \       0x20   0x8CD2             LDRH     R2,[R2, #+38]
   \       0x22   0x1F52             SUBS     R2,R2,#+5
   \       0x24   0x640A             STR      R2,[R1, #+64]
    882          
    883            /* wait for a new PWM period */
    884            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x26   0xF06F 0x0201      MVN      R2,#+1
   \       0x2A   0x610A             STR      R2,[R1, #+16]
    885            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0u )
   \                     ??R3_1_SwitchOnPWM_0: (+1)
   \       0x2C   0x690B             LDR      R3,[R1, #+16]
   \       0x2E   0x07DC             LSLS     R4,R3,#+31
   \       0x30   0xD5FC             BPL.N    ??R3_1_SwitchOnPWM_0
    886            {}
    887            /* Clear Update Flag */
    888            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x32   0x610A             STR      R2,[R1, #+16]
    889          
    890            /* Main PWM Output Enable */
    891            TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
   \       0x34   0x6C4B             LDR      R3,[R1, #+68]
   \       0x36   0xF443 0x6380      ORR      R3,R3,#0x400
   \       0x3A   0x644B             STR      R3,[R1, #+68]
    892            LL_TIM_EnableAllOutputs ( TIMx );
   \       0x3C   0x6C4B             LDR      R3,[R1, #+68]
   \       0x3E   0xF443 0x4300      ORR      R3,R3,#0x8000
   \       0x42   0x644B             STR      R3,[R1, #+68]
    893          
    894            if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x44   0x6F43             LDR      R3,[R0, #+116]
   \       0x46   0xF103 0x046C      ADD      R4,R3,#+108
   \       0x4A   0x7BA5             LDRB     R5,[R4, #+14]
   \       0x4C   0x2D02             CMP      R5,#+2
   \       0x4E   0xD11D             BNE.N    ??R3_1_SwitchOnPWM_1
    895            {
    896              if ( ( TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0u )
   \       0x50   0x8824             LDRH     R4,[R4, #+0]
   \       0x52   0x699B             LDR      R3,[R3, #+24]
   \       0x54   0x6A0D             LDR      R5,[R1, #+32]
   \       0x56   0xF240 0x5655      MOVW     R6,#+1365
   \       0x5A   0x4235             TST      R5,R6
   \       0x5C   0xD00B             BEQ.N    ??R3_1_SwitchOnPWM_2
    897              {
    898                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x5E   0x619C             STR      R4,[R3, #+24]
    899                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x60   0x6F43             LDR      R3,[R0, #+116]
   \       0x62   0xF8B3 0x406E      LDRH     R4,[R3, #+110]
   \       0x66   0x69DB             LDR      R3,[R3, #+28]
   \       0x68   0x619C             STR      R4,[R3, #+24]
    900                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x6A   0x6F40             LDR      R0,[R0, #+116]
   \       0x6C   0xF8B0 0x3070      LDRH     R3,[R0, #+112]
   \       0x70   0x6A00             LDR      R0,[R0, #+32]
   \       0x72   0x6183             STR      R3,[R0, #+24]
    901              }
   \       0x74   0xE00A             B.N      ??R3_1_SwitchOnPWM_1
    902              else
    903              {
    904                /* It is executed during calibration phase the EN signal shall stay off */
    905                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \                     ??R3_1_SwitchOnPWM_2: (+1)
   \       0x76   0x629C             STR      R4,[R3, #+40]
    906                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x78   0x6F43             LDR      R3,[R0, #+116]
   \       0x7A   0xF8B3 0x406E      LDRH     R4,[R3, #+110]
   \       0x7E   0x69DB             LDR      R3,[R3, #+28]
   \       0x80   0x629C             STR      R4,[R3, #+40]
    907                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x82   0x6F40             LDR      R0,[R0, #+116]
   \       0x84   0xF8B0 0x3070      LDRH     R3,[R0, #+112]
   \       0x88   0x6A00             LDR      R0,[R0, #+32]
   \       0x8A   0x6283             STR      R3,[R0, #+40]
    908              }
    909            }
    910            /* Clear Update Flag */
    911            LL_TIM_ClearFlag_UPDATE( TIMx );
   \                     ??R3_1_SwitchOnPWM_1: (+1)
   \       0x8C   0x610A             STR      R2,[R1, #+16]
    912            /* Enable Update IRQ */
    913            LL_TIM_EnableIT_UPDATE( TIMx );
   \       0x8E   0x68C8             LDR      R0,[R1, #+12]
   \       0x90   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x94   0x60C8             STR      R0,[R1, #+12]
    914          }
   \       0x96   0xBD70             POP      {R4-R6,PC}       ;; return
    915          
    916          
    917          /**
    918           * @brief  Disables PWM generation on the proper Timer peripheral acting on  MOE bit
    919           * @param pHdl handler of the current instance of the PWM component
    920           */

   \                                 In section .text, align 2
    921          __weak void R3_1_SwitchOffPWM( PWMC_Handle_t * pHdl )
    922          {
   \                     R3_1_SwitchOffPWM: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    923          #if defined (__ICCARM__)
    924            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
    925          #endif /* __ICCARM__ */
    926            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
    927          #if defined (__ICCARM__)
    928            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
    929          #endif /* __ICCARM__ */
    930            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x2   0x6F41             LDR      R1,[R0, #+116]
   \        0x4   0x6849             LDR      R1,[R1, #+4]
    931          
    932            /* Disable UPDATE ISR */
    933            LL_TIM_DisableIT_UPDATE( TIMx );
   \        0x6   0x68CA             LDR      R2,[R1, #+12]
   \        0x8   0x0852             LSRS     R2,R2,#+1
   \        0xA   0x0052             LSLS     R2,R2,#+1
   \        0xC   0x60CA             STR      R2,[R1, #+12]
    934          
    935            pHandle->_Super.TurnOnLowSidesAction = false;
   \        0xE   0x2300             MOVS     R3,#+0
   \       0x10   0xF880 0x3042      STRB     R3,[R0, #+66]
    936            
    937            /* Main PWM Output Disable */
    938            LL_TIM_DisableAllOutputs( TIMx );
   \       0x14   0x6C4A             LDR      R2,[R1, #+68]
   \       0x16   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x1A   0x644A             STR      R2,[R1, #+68]
    939            if ( pHandle->BrakeActionLock == true )
   \       0x1C   0xF890 0x2072      LDRB     R2,[R0, #+114]
   \       0x20   0x2A01             CMP      R2,#+1
   \       0x22   0xD012             BEQ.N    ??R3_1_SwitchOffPWM_0
    940            {
    941            }
    942            else
    943            {
    944              if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x24   0x6F42             LDR      R2,[R0, #+116]
   \       0x26   0xF102 0x036C      ADD      R3,R2,#+108
   \       0x2A   0x7B9C             LDRB     R4,[R3, #+14]
   \       0x2C   0x2C02             CMP      R4,#+2
   \       0x2E   0xD10C             BNE.N    ??R3_1_SwitchOffPWM_0
    945              {
    946                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x30   0x6992             LDR      R2,[R2, #+24]
   \       0x32   0x881B             LDRH     R3,[R3, #+0]
   \       0x34   0x6293             STR      R3,[R2, #+40]
    947                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x36   0x6F42             LDR      R2,[R0, #+116]
   \       0x38   0xF8B2 0x306E      LDRH     R3,[R2, #+110]
   \       0x3C   0x69D2             LDR      R2,[R2, #+28]
   \       0x3E   0x6293             STR      R3,[R2, #+40]
    948                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x40   0x6F40             LDR      R0,[R0, #+116]
   \       0x42   0xF8B0 0x2070      LDRH     R2,[R0, #+112]
   \       0x46   0x6A00             LDR      R0,[R0, #+32]
   \       0x48   0x6282             STR      R2,[R0, #+40]
    949              }
    950            }
    951          
    952            /* wait for a new PWM period to flush last HF task */
    953            LL_TIM_ClearFlag_UPDATE( TIMx );
   \                     ??R3_1_SwitchOffPWM_0: (+1)
   \       0x4A   0xF06F 0x0001      MVN      R0,#+1
   \       0x4E   0x6108             STR      R0,[R1, #+16]
    954            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0u )
   \                     ??R3_1_SwitchOffPWM_1: (+1)
   \       0x50   0x690A             LDR      R2,[R1, #+16]
   \       0x52   0x07D3             LSLS     R3,R2,#+31
   \       0x54   0xD5FC             BPL.N    ??R3_1_SwitchOffPWM_1
    955            {}
    956            /* Clear Update Flag */
    957            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x56   0x6108             STR      R0,[R1, #+16]
    958          
    959          }
   \       0x58   0xBD10             POP      {R4,PC}          ;; return
    960          
    961          
    962          
    963          
    964          #if defined (CCMRAM)
    965          #if defined (__ICCARM__)
    966          #pragma location = ".ccmram"
    967          #elif defined (__CC_ARM)
    968          __attribute__( ( section ( ".ccmram" ) ) )
    969          #endif
    970          #endif
    971          /**
    972            * @brief  writes into peripheral registers the new duty cycles and
    973            *        sampling point
    974            * @param  pHandle: handler of the current instance of the PWM component
    975            * @retval none
    976            */

   \                                 In section .text, align 2
    977          __weak void * R3_1_TIMx_UP_IRQHandler( PWMC_R3_1_Handle_t * pHandle )
    978          {
   \                     R3_1_TIMx_UP_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    979            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
    980            ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
    981            
    982            ADCx->JSQR = pHandle->pParams_str->ADCConfig[pHandle->_Super.Sector] | (uint32_t) pHandle->ADC_ExternalPolarityInjected;
   \        0x2   0xF100 0x043A      ADD      R4,R0,#+58
   \        0x6   0x6F42             LDR      R2,[R0, #+116]
   \        0x8   0x7821             LDRB     R1,[R4, #+0]
   \        0xA   0x6853             LDR      R3,[R2, #+4]
   \        0xC   0xEB02 0x0581      ADD      R5,R2,R1, LSL #+2
   \       0x10   0x8E61             LDRH     R1,[R4, #+50]
   \       0x12   0x6D6E             LDR      R6,[R5, #+84]
   \       0x14   0x6812             LDR      R2,[R2, #+0]
   \       0x16   0x430E             ORRS     R6,R1,R6
   \       0x18   0x64D6             STR      R6,[R2, #+76]
    983            
    984            /* enable ADC trigger source */
    985              //LL_TIM_CC_EnableChannel(TIMx, LL_TIM_CHANNEL_CH4);
    986            LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_OC4REF);
    987              
    988            pHandle->ADC_ExternalPolarityInjected = (uint16_t)LL_ADC_INJ_TRIG_EXT_RISING;
   \       0x1A   0x2240             MOVS     R2,#+64
   \       0x1C   0x6859             LDR      R1,[R3, #+4]
   \       0x1E   0xF041 0x0170      ORR      R1,R1,#0x70
   \       0x22   0x6059             STR      R1,[R3, #+4]
   \       0x24   0x8662             STRH     R2,[R4, #+50]
    989          
    990            return &( pHandle->_Super.Motor );
   \       0x26   0x3046             ADDS     R0,R0,#+70
   \       0x28   0xBD70             POP      {R4-R6,PC}       ;; return
    991          }
    992          
    993          #if defined (CCMRAM)
    994          #if defined (__ICCARM__)
    995          #pragma location = ".ccmram"
    996          #elif defined (__CC_ARM)
    997          __attribute__( ( section ( ".ccmram" ) ) )
    998          #endif
    999          #endif
   1000          /**
   1001            * @brief  It contains the TIMx Break2 event interrupt
   1002            * @param  pHandle: handler of the current instance of the PWM component
   1003            * @retval none
   1004            */

   \                                 In section .text, align 2
   1005          __weak void * R3_1_BRK2_IRQHandler( PWMC_R3_1_Handle_t * pHandle )
   1006          {
   \                     R3_1_BRK2_IRQHandler: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1007            if ( pHandle->BrakeActionLock == false )
   \        0x2   0xF100 0x0270      ADD      R2,R0,#+112
   \        0x6   0x7891             LDRB     R1,[R2, #+2]
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xBF01             ITTTT    EQ
   \        0xC   0x6851             LDREQ    R1,[R2, #+4]
   \        0xE   0xF101 0x036C      ADDEQ    R3,R1,#+108
   \       0x12   0x7B9C             LDRBEQ   R4,[R3, #+14]
   \       0x14   0x2C02             CMPEQ    R4,#+2
   1008            {
   1009              if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x16   0xD108             BNE.N    ??R3_1_BRK2_IRQHandler_0
   1010              {
   1011                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x18   0x698C             LDR      R4,[R1, #+24]
   \       0x1A   0x881D             LDRH     R5,[R3, #+0]
   \       0x1C   0x62A5             STR      R5,[R4, #+40]
   1012                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x1E   0x69CC             LDR      R4,[R1, #+28]
   \       0x20   0x885D             LDRH     R5,[R3, #+2]
   \       0x22   0x62A5             STR      R5,[R4, #+40]
   1013                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x24   0x6A09             LDR      R1,[R1, #+32]
   \       0x26   0x889B             LDRH     R3,[R3, #+4]
   \       0x28   0x628B             STR      R3,[R1, #+40]
   1014              }
   1015            }
   1016            pHandle->OverCurrentFlag = true;
   \                     ??R3_1_BRK2_IRQHandler_0: (+1)
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0x7013             STRB     R3,[R2, #+0]
   1017          
   1018            return &( pHandle->_Super.Motor );
   \       0x2E   0x3046             ADDS     R0,R0,#+70
   \       0x30   0xBD30             POP      {R4,R5,PC}       ;; return
   1019          }
   1020          
   1021          #if defined (CCMRAM)
   1022          #if defined (__ICCARM__)
   1023          #pragma location = ".ccmram"
   1024          #elif defined (__CC_ARM)
   1025          __attribute__( ( section ( ".ccmram" ) ) )
   1026          #endif
   1027          #endif
   1028          /**
   1029            * @brief  It contains the TIMx Break1 event interrupt
   1030            * @param  pHandle: handler of the current instance of the PWM component
   1031            * @retval none
   1032            */

   \                                 In section .text, align 2
   1033          __weak void * R3_1_BRK_IRQHandler( PWMC_R3_1_Handle_t * pHandle )
   1034          {
   1035          
   1036            pHandle->pParams_str->TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
   \                     R3_1_BRK_IRQHandler: (+1)
   \        0x0   0x6F41             LDR      R1,[R0, #+116]
   \        0x2   0x6849             LDR      R1,[R1, #+4]
   \        0x4   0x6C4A             LDR      R2,[R1, #+68]
   \        0x6   0xF442 0x6280      ORR      R2,R2,#0x400
   \        0xA   0x644A             STR      R2,[R1, #+68]
   1037            pHandle->OverVoltageFlag = true;
   \        0xC   0xF100 0x0171      ADD      R1,R0,#+113
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x700A             STRB     R2,[R1, #+0]
   1038            pHandle->BrakeActionLock = true;
   \       0x14   0x704A             STRB     R2,[R1, #+1]
   1039          
   1040            return &( pHandle->_Super.Motor );
   \       0x16   0x3046             ADDS     R0,R0,#+70
   \       0x18   0x4770             BX       LR               ;; return
   1041          }
   1042          
   1043          
   1044          /**
   1045            * @brief  It is used to check if an overcurrent occurred since last call.
   1046            * @param  pHandle Pointer on the target component instance
   1047            * @retval uint16_t It returns MC_BREAK_IN whether an overcurrent has been
   1048            *                  detected since last method call, MC_NO_FAULTS otherwise.
   1049            */

   \                                 In section .text, align 2
   1050          __weak uint16_t R3_1_IsOverCurrentOccurred( PWMC_Handle_t * pHdl )
   1051          {
   \                     R3_1_IsOverCurrentOccurred: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1052          #if defined (__ICCARM__)
   1053            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1054          #endif /* __ICCARM__ */
   1055            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1056          #if defined (__ICCARM__)
   1057            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1058          #endif /* __ICCARM__ */
   1059            uint16_t retVal = MC_NO_FAULTS;
   1060          
   1061            if ( pHandle->OverVoltageFlag == true )
   \        0x2   0x3170             ADDS     R1,R1,#+112
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x784A             LDRB     R2,[R1, #+1]
   \        0x8   0x2A01             CMP      R2,#+1
   \        0xA   0xD102             BNE.N    ??R3_1_IsOverCurrentOccurred_0
   1062            {
   1063              retVal = MC_OVER_VOLT;
   1064              pHandle->OverVoltageFlag = false;
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x704A             STRB     R2,[R1, #+1]
   1065            }
   1066          
   1067            if ( pHandle->OverCurrentFlag == true )
   \                     ??R3_1_IsOverCurrentOccurred_0: (+1)
   \       0x12   0x780B             LDRB     R3,[R1, #+0]
   \       0x14   0x2B01             CMP      R3,#+1
   \       0x16   0xD103             BNE.N    ??R3_1_IsOverCurrentOccurred_1
   1068            {
   1069              retVal |= MC_BREAK_IN;
   1070              pHandle->OverCurrentFlag = false;
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x1E   0x700A             STRB     R2,[R1, #+0]
   1071            }
   1072          
   1073            return retVal;
   \                     ??R3_1_IsOverCurrentOccurred_1: (+1)
   \       0x20   0x4770             BX       LR               ;; return
   1074          }
   1075          
   1076          /**
   1077            * @brief  It is used to configure the analog output used for protection
   1078            *         thresholds.
   1079            * @param  DAC_Channel: the selected DAC channel.
   1080            *          This parameter can be:
   1081            *            @arg DAC_Channel_1: DAC Channel1 selected
   1082            *            @arg DAC_Channel_2: DAC Channel2 selected
   1083            * @param  hDACVref Value of DAC reference expressed as 16bit unsigned integer.
   1084            *         Ex. 0 = 0V 65536 = VDD_DAC.
   1085            * @retval none
   1086            */

   \                                 In section .text, align 2, keep-with-next
   1087          static void R3_1_SetAOReferenceVoltage( uint32_t DAC_Channel, uint16_t hDACVref )
   1088          {
   1089            LL_DAC_ConvertData12LeftAligned ( DAC1, DAC_Channel, hDACVref );
   \                     R3_1_SetAOReferenceVoltage: (+1)
   \        0x0   0x0C83             LSRS     R3,R0,#+18
   \        0x2   0xB510             PUSH     {R4,LR}
   \        0x4   0xF003 0x033C      AND      R3,R3,#0x3C
   \        0x8   0x....             LDR.N    R2,??DataTable8_4  ;; 0x40007408
   \        0xA   0x18D3             ADDS     R3,R2,R3
   1090          
   1091            /* Enable DAC Channel */
   1092            LL_DAC_TrigSWConversion ( DAC1, DAC_Channel );
   \        0xC   0x....             LDR.N    R2,??DataTable8_5  ;; 0x40007400
   \        0xE   0x681C             LDR      R4,[R3, #+0]
   \       0x10   0xF36F 0x140F      BFC      R4,#+4,#+12
   \       0x14   0x4321             ORRS     R1,R1,R4
   \       0x16   0x6019             STR      R1,[R3, #+0]
   \       0x18   0xF000 0x0101      AND      R1,R0,#0x1
   \       0x1C   0x6853             LDR      R3,[R2, #+4]
   \       0x1E   0x430B             ORRS     R3,R1,R3
   \       0x20   0x6053             STR      R3,[R2, #+4]
   1093            
   1094            if (LL_DAC_IsEnabled ( DAC1, DAC_Channel ) == 1u ) 
   \       0x22   0x2401             MOVS     R4,#+1
   \       0x24   0xF000 0x0010      AND      R0,R0,#0x10
   \       0x28   0x6813             LDR      R3,[R2, #+0]
   \       0x2A   0x....             LDR.N    R1,??DataTable8_6
   \       0x2C   0xFA04 0xF000      LSL      R0,R4,R0
   \       0x30   0x4003             ANDS     R3,R0,R3
   \       0x32   0x4283             CMP      R3,R0
   \       0x34   0xD10A             BNE.N    ??R3_1_SetAOReferenceVoltage_0
   1095            { /* If DAC is already enable, we wait LL_DAC_DELAY_VOLTAGE_SETTLING_US*/
   1096              uint32_t wait_loop_index = ((LL_DAC_DELAY_VOLTAGE_SETTLING_US) * (SystemCoreClock / (1000000UL * 2UL)));      
   \       0x36   0x6808             LDR      R0,[R1, #+0]
   \       0x38   0x....             LDR.N    R2,??DataTable8_7  ;; 0x1e8480
   \       0x3A   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x3E   0x210C             MOVS     R1,#+12
   \       0x40   0x4348             MULS     R0,R1,R0
   1097              while(wait_loop_index != 0UL)
   \                     ??R3_1_SetAOReferenceVoltage_1: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xBF18             IT       NE
   \       0x46   0x1E40             SUBNE    R0,R0,#+1
   1098              {
   1099                wait_loop_index--;
   \       0x48   0xD1FB             BNE.N    ??R3_1_SetAOReferenceVoltage_1
   \       0x4A   0xBD10             POP      {R4,PC}
   1100              }
   1101            }
   1102            else
   1103            {
   1104              /* If DAC is not enabled, we must wait LL_DAC_DELAY_STARTUP_VOLTAGE_SETTLING_US*/
   1105              LL_DAC_Enable ( DAC1, DAC_Channel );
   \                     ??R3_1_SetAOReferenceVoltage_0: (+1)
   \       0x4C   0x6813             LDR      R3,[R2, #+0]
   \       0x4E   0x4318             ORRS     R0,R0,R3
   \       0x50   0x6010             STR      R0,[R2, #+0]
   1106              uint32_t wait_loop_index = ((LL_DAC_DELAY_STARTUP_VOLTAGE_SETTLING_US) * (SystemCoreClock / (1000000UL * 2UL)));      
   \       0x52   0x6808             LDR      R0,[R1, #+0]
   \       0x54   0x....             LDR.N    R1,??DataTable8_7  ;; 0x1e8480
   \       0x56   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x5A   0xEBC0 0x1000      RSB      R0,R0,R0, LSL #+4
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xE000             B.N      ??R3_1_SetAOReferenceVoltage_2
   1107              while(wait_loop_index != 0UL)
   1108              {
   1109                wait_loop_index--;
   \                     ??R3_1_SetAOReferenceVoltage_3: (+1)
   \       0x62   0x1E40             SUBS     R0,R0,#+1
   1110              }    
   \                     ??R3_1_SetAOReferenceVoltage_2: (+1)
   \       0x64   0xD1FD             BNE.N    ??R3_1_SetAOReferenceVoltage_3
   1111            }
   1112          }
   \       0x66   0xBD10             POP      {R4,PC}          ;; return
   1113          
   1114          /**
   1115            * @brief  It is used to set the PWM mode for R/L detection.
   1116            * @param  pHandle: handler of the current instance of the PWM component
   1117            * @param  hDuty to be applied in uint16_t
   1118            * @retval none
   1119            */

   \                                 In section .text, align 2, keep-with-next
   1120          void R3_1_RLDetectionModeEnable( PWMC_Handle_t * pHdl )
   1121          {
   \                     R3_1_RLDetectionModeEnable: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1122          #if defined (__ICCARM__)
   1123            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1124          #endif /* __ICCARM__ */
   1125            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1126          #if defined (__ICCARM__)
   1127            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1128          #endif /* __ICCARM__ */
   1129            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x4   0x6F60             LDR      R0,[R4, #+116]
   \        0x6   0x6845             LDR      R5,[R0, #+4]
   1130            
   1131            if ( pHandle->_Super.RLDetectionMode == false )
   \        0x8   0xF894 0x0047      LDRB     R0,[R4, #+71]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD137             BNE.N    ??R3_1_RLDetectionModeEnable_0
   1132            {
   1133              /*  Channel1 configuration */
   1134              LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH1, LL_TIM_OCMODE_PWM1 );
   \       0x10   0x2260             MOVS     R2,#+96
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x....'....        BL       ??Subroutine5_0
   1135              LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH1 );
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x18   0x6A28             LDR      R0,[R5, #+32]
   \       0x1A   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x1E   0x6228             STR      R0,[R5, #+32]
   1136              LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH1N );
   1137              LL_TIM_OC_SetCompareCH1( TIMx, 0u );
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6A28             LDR      R0,[R5, #+32]
   \       0x24   0xF020 0x0004      BIC      R0,R0,#0x4
   \       0x28   0x6228             STR      R0,[R5, #+32]
   \       0x2A   0x6369             STR      R1,[R5, #+52]
   1138          
   1139              /*  Channel2 configuration */
   1140              if ( ( pHandle->pParams_str->LowSideOutputs ) == LS_PWM_TIMER )
   \       0x2C   0x6F60             LDR      R0,[R4, #+116]
   \       0x2E   0xF890 0x007A      LDRB     R0,[R0, #+122]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD10A             BNE.N    ??R3_1_RLDetectionModeEnable_1
   1141              {
   1142                LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH2, LL_TIM_OCMODE_ACTIVE );
   \       0x36   0x2210             MOVS     R2,#+16
   \       0x38   0x....'....        BL       ?Subroutine5
   1143                LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH2 );
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x3C   0x6A28             LDR      R0,[R5, #+32]
   \       0x3E   0xF020 0x0010      BIC      R0,R0,#0x10
   \       0x42   0x6228             STR      R0,[R5, #+32]
   1144                LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH2N );
   \       0x44   0x6A28             LDR      R0,[R5, #+32]
   \       0x46   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x4A   0xE00B             B.N      ??R3_1_RLDetectionModeEnable_2
   1145              }
   1146              else if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \                     ??R3_1_RLDetectionModeEnable_1: (+1)
   \       0x4C   0x2802             CMP      R0,#+2
   \       0x4E   0xD10A             BNE.N    ??R3_1_RLDetectionModeEnable_3
   1147              {
   1148                LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH2, LL_TIM_OCMODE_INACTIVE );
   \       0x50   0x2220             MOVS     R2,#+32
   \       0x52   0x....'....        BL       ?Subroutine5
   1149                LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH2 );
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x56   0x6A28             LDR      R0,[R5, #+32]
   \       0x58   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x5C   0x6228             STR      R0,[R5, #+32]
   1150                LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH2N );
   \       0x5E   0x6A28             LDR      R0,[R5, #+32]
   \       0x60   0xF020 0x0040      BIC      R0,R0,#0x40
   \                     ??R3_1_RLDetectionModeEnable_2: (+1)
   \       0x64   0x6228             STR      R0,[R5, #+32]
   1151              }
   1152              else
   1153              {
   1154              }
   1155          
   1156              /*  Channel3 configuration */
   1157              LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH3, LL_TIM_OCMODE_PWM2 );
   \                     ??R3_1_RLDetectionModeEnable_3: (+1)
   \       0x66   0x2270             MOVS     R2,#+112
   \       0x68   0xF44F 0x7180      MOV      R1,#+256
   \       0x6C   0x....'....        BL       ??Subroutine5_0
   1158              LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH3 );
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x70   0x6A28             LDR      R0,[R5, #+32]
   \       0x72   0xF420 0x7080      BIC      R0,R0,#0x100
   \       0x76   0x6228             STR      R0,[R5, #+32]
   1159              LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH3N );
   \       0x78   0x6A28             LDR      R0,[R5, #+32]
   \       0x7A   0xF420 0x6080      BIC      R0,R0,#0x400
   \       0x7E   0x6228             STR      R0,[R5, #+32]
   1160             
   1161            }
   1162          
   1163            pHandle->_Super.pFctGetPhaseCurrents = &R3_1_RLGetPhaseCurrents;
   \                     ??R3_1_RLDetectionModeEnable_0: (+1)
   \       0x80   0x....'....        ADR.W    R0,R3_1_RLGetPhaseCurrents
   1164            pHandle->_Super.pFctTurnOnLowSides = &R3_1_RLTurnOnLowSides;
   \       0x84   0x....'....        ADR.W    R1,R3_1_RLTurnOnLowSides
   \       0x88   0x6060             STR      R0,[R4, #+4]
   \       0x8A   0x6161             STR      R1,[R4, #+20]
   1165            pHandle->_Super.pFctSwitchOnPwm = &R3_1_RLSwitchOnPWM;
   \       0x8C   0x....'....        ADR.W    R0,R3_1_RLSwitchOnPWM
   1166            pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
   \       0x90   0x....             LDR.N    R1,??DataTable8_8
   \       0x92   0x60E0             STR      R0,[R4, #+12]
   \       0x94   0x60A1             STR      R1,[R4, #+8]
   1167          
   1168            pHandle->_Super.RLDetectionMode = true;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xF884 0x0047      STRB     R0,[R4, #+71]
   1169          }
   \       0x9C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2110             MOVS     R1,#+16
   \                     ??Subroutine5_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....             B.N      LL_TIM_OC_SetMode
   1170          
   1171          /**
   1172           * @brief  It is used to disable the PWM mode for R/L detection.
   1173           * @param  pHdl: handler of the current instance of the PWM component
   1174           * @retval none
   1175           */

   \                                 In section .text, align 2, keep-with-next
   1176          void R3_1_RLDetectionModeDisable( PWMC_Handle_t * pHdl )
   1177          {
   \                     R3_1_RLDetectionModeDisable: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1178          #if defined (__ICCARM__)
   1179            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1180          #endif /* __ICCARM__ */
   1181            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1182          #if defined (__ICCARM__)
   1183            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1184          #endif /* __ICCARM__ */
   1185            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x4   0xF104 0x0568      ADD      R5,R4,#+104
   \        0x8   0x68E8             LDR      R0,[R5, #+12]
   \        0xA   0x6846             LDR      R6,[R0, #+4]
   1186          
   1187            if ( pHandle->_Super.RLDetectionMode == true )
   \        0xC   0xF894 0x0047      LDRB     R0,[R4, #+71]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD15F             BNE.N    ??R3_1_RLDetectionModeDisable_0
   1188            {
   1189              /* Repetition Counter of TIM1 User value reactivation BEGIN*/
   1190          
   1191              /* The folowing while cycles ensure the identification of the positive counting mode of TIM1
   1192               * for correct reactivation of Repetition Counter value of TIM1.*/
   1193          
   1194              /* Wait the change of Counter Direction of TIM1 from Up-Direction to Down-Direction*/
   1195              while ( ( TIMx->CR1 & TIM_CR1_DIR_Msk ) == LL_TIM_COUNTERMODE_UP )
   \                     ??R3_1_RLDetectionModeDisable_1: (+1)
   \       0x14   0x6831             LDR      R1,[R6, #+0]
   \       0x16   0x06C8             LSLS     R0,R1,#+27
   \       0x18   0xD5FC             BPL.N    ??R3_1_RLDetectionModeDisable_1
   1196              {
   1197              }
   1198              /* Wait the change of Counter Direction of TIM1 from Down-Direction to Up-Direction.*/
   1199              while ( ( TIMx->CR1 & TIM_CR1_DIR_Msk ) == LL_TIM_COUNTERMODE_DOWN )
   \                     ??R3_1_RLDetectionModeDisable_2: (+1)
   \       0x1A   0x6831             LDR      R1,[R6, #+0]
   \       0x1C   0x06CB             LSLS     R3,R1,#+27
   \       0x1E   0xD4FC             BMI.N    ??R3_1_RLDetectionModeDisable_2
   1200              {
   1201              } 
   1202          
   1203              /* Repetition Counter of TIM1 User value reactivation END*/    /*  Channel1 configuration */
   1204              LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH1, LL_TIM_OCMODE_PWM1 );
   \       0x20   0x2260             MOVS     R2,#+96
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x4630             MOV      R0,R6
   \       0x26   0x....'....        BL       LL_TIM_OC_SetMode
   1205              LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH1 );
   \       0x2A   0x6A30             LDR      R0,[R6, #+32]
   \       0x2C   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x30   0x....'....        BL       ?Subroutine8
   1206          
   1207              if ( ( pHandle->pParams_str->LowSideOutputs ) == LS_PWM_TIMER )
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x34   0xD103             BNE.N    ??R3_1_RLDetectionModeDisable_3
   1208              {
   1209                LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH1N );
   \       0x36   0x6A30             LDR      R0,[R6, #+32]
   \       0x38   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x3C   0xE004             B.N      ??R3_1_RLDetectionModeDisable_4
   1210              }
   1211              else if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \                     ??R3_1_RLDetectionModeDisable_3: (+1)
   \       0x3E   0x2802             CMP      R0,#+2
   \       0x40   0xD103             BNE.N    ??R3_1_RLDetectionModeDisable_5
   1212              {
   1213                LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH1N );
   \       0x42   0x6A30             LDR      R0,[R6, #+32]
   \       0x44   0xF020 0x0004      BIC      R0,R0,#0x4
   \                     ??R3_1_RLDetectionModeDisable_4: (+1)
   \       0x48   0x6230             STR      R0,[R6, #+32]
   1214              }
   1215              else
   1216              {
   1217              }
   1218          
   1219              LL_TIM_OC_SetCompareCH1( TIMx, ( uint32_t )( pHandle->Half_PWMPeriod ) >> 1 );
   \                     ??R3_1_RLDetectionModeDisable_5: (+1)
   \       0x4A   0x8828             LDRH     R0,[R5, #+0]
   \       0x4C   0x0840             LSRS     R0,R0,#+1
   \       0x4E   0x6370             STR      R0,[R6, #+52]
   1220          
   1221              /*  Channel2 configuration */
   1222              LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH2, LL_TIM_OCMODE_PWM1 );
   \       0x50   0x2260             MOVS     R2,#+96
   \       0x52   0x2110             MOVS     R1,#+16
   \       0x54   0x4630             MOV      R0,R6
   \       0x56   0x....'....        BL       LL_TIM_OC_SetMode
   1223              LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH2 );
   \       0x5A   0x6A30             LDR      R0,[R6, #+32]
   \       0x5C   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x60   0x....'....        BL       ?Subroutine8
   1224          
   1225              if ( ( pHandle->pParams_str->LowSideOutputs ) == LS_PWM_TIMER )
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x64   0xD103             BNE.N    ??R3_1_RLDetectionModeDisable_6
   1226              {
   1227                LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH2N );
   \       0x66   0x6A30             LDR      R0,[R6, #+32]
   \       0x68   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x6C   0xE004             B.N      ??R3_1_RLDetectionModeDisable_7
   1228              }
   1229              else if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \                     ??R3_1_RLDetectionModeDisable_6: (+1)
   \       0x6E   0x2802             CMP      R0,#+2
   \       0x70   0xD103             BNE.N    ??R3_1_RLDetectionModeDisable_8
   1230              {
   1231                LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH2N );
   \       0x72   0x6A30             LDR      R0,[R6, #+32]
   \       0x74   0xF020 0x0040      BIC      R0,R0,#0x40
   \                     ??R3_1_RLDetectionModeDisable_7: (+1)
   \       0x78   0x6230             STR      R0,[R6, #+32]
   1232              }
   1233              else
   1234              {
   1235              }
   1236          
   1237              LL_TIM_OC_SetCompareCH2( TIMx, ( uint32_t )( pHandle->Half_PWMPeriod ) >> 1 );
   \                     ??R3_1_RLDetectionModeDisable_8: (+1)
   \       0x7A   0x8828             LDRH     R0,[R5, #+0]
   \       0x7C   0x0840             LSRS     R0,R0,#+1
   \       0x7E   0x63B0             STR      R0,[R6, #+56]
   1238          
   1239              /*  Channel3 configuration */
   1240              LL_TIM_OC_SetMode ( TIMx, LL_TIM_CHANNEL_CH3, LL_TIM_OCMODE_PWM1 );
   \       0x80   0x2260             MOVS     R2,#+96
   \       0x82   0xF44F 0x7180      MOV      R1,#+256
   \       0x86   0x4630             MOV      R0,R6
   \       0x88   0x....'....        BL       LL_TIM_OC_SetMode
   1241              LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH3 );
   \       0x8C   0x6A30             LDR      R0,[R6, #+32]
   \       0x8E   0xF440 0x7080      ORR      R0,R0,#0x100
   \       0x92   0x....'....        BL       ?Subroutine8
   1242          
   1243              if ( ( pHandle->pParams_str->LowSideOutputs ) == LS_PWM_TIMER )
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x96   0xD103             BNE.N    ??R3_1_RLDetectionModeDisable_9
   1244              {
   1245                LL_TIM_CC_EnableChannel( TIMx, LL_TIM_CHANNEL_CH3N );
   \       0x98   0x6A30             LDR      R0,[R6, #+32]
   \       0x9A   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x9E   0xE004             B.N      ??R3_1_RLDetectionModeDisable_10
   1246              }
   1247              else if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \                     ??R3_1_RLDetectionModeDisable_9: (+1)
   \       0xA0   0x2802             CMP      R0,#+2
   \       0xA2   0xD103             BNE.N    ??R3_1_RLDetectionModeDisable_11
   1248              {
   1249                LL_TIM_CC_DisableChannel( TIMx, LL_TIM_CHANNEL_CH3N );
   \       0xA4   0x6A30             LDR      R0,[R6, #+32]
   \       0xA6   0xF420 0x6080      BIC      R0,R0,#0x400
   \                     ??R3_1_RLDetectionModeDisable_10: (+1)
   \       0xAA   0x6230             STR      R0,[R6, #+32]
   1250              }
   1251              else
   1252              {
   1253              }
   1254          
   1255              LL_TIM_OC_SetCompareCH3( TIMx, ( uint32_t )( pHandle->Half_PWMPeriod ) >> 1 );
   \                     ??R3_1_RLDetectionModeDisable_11: (+1)
   \       0xAC   0x8828             LDRH     R0,[R5, #+0]
   \       0xAE   0x0840             LSRS     R0,R0,#+1
   \       0xB0   0x63F0             STR      R0,[R6, #+60]
   1256              
   1257              /* ADCx Injected discontinuous mode disable */
   1258              LL_ADC_INJ_SetSequencerDiscont( pHandle->pParams_str->ADCx,
   1259                                              LL_ADC_INJ_SEQ_DISCONT_DISABLE );
   \       0xB2   0x68E8             LDR      R0,[R5, #+12]
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0x68C1             LDR      R1,[R0, #+12]
   \       0xB8   0xF421 0x1180      BIC      R1,R1,#0x100000
   \       0xBC   0x60C1             STR      R1,[R0, #+12]
   1260          
   1261              pHandle->_Super.pFctGetPhaseCurrents = &R3_1_GetPhaseCurrents;
   \       0xBE   0x....             LDR.N    R0,??DataTable8_3
   1262              pHandle->_Super.pFctTurnOnLowSides = &R3_1_TurnOnLowSides;
   \       0xC0   0x....             LDR.N    R1,??DataTable8_9
   \       0xC2   0x6060             STR      R0,[R4, #+4]
   \       0xC4   0x6161             STR      R1,[R4, #+20]
   1263              pHandle->_Super.pFctSwitchOnPwm = &R3_1_SwitchOnPWM;
   \       0xC6   0x....             LDR.N    R0,??DataTable8_10
   1264              pHandle->_Super.pFctSwitchOffPwm = &R3_1_SwitchOffPWM;
   \       0xC8   0x....             LDR.N    R1,??DataTable8_8
   \       0xCA   0x60E0             STR      R0,[R4, #+12]
   \       0xCC   0x60A1             STR      R1,[R4, #+8]
   1265          
   1266              pHandle->_Super.RLDetectionMode = false;
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0xF884 0x0047      STRB     R0,[R4, #+71]
   1267            }
   1268          }
   \                     ??R3_1_RLDetectionModeDisable_0: (+1)
   \       0xD4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x6230             STR      R0,[R6, #+32]
   \        0x2   0x68E8             LDR      R0,[R5, #+12]
   \        0x4   0xF890 0x007A      LDRB     R0,[R0, #+122]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0x4770             BX       LR
   1269          
   1270          /**
   1271           * @brief  It is used to set the PWM dutycycle for R/L detection.
   1272           * @param  pHdl: handler of the current instance of the PWM component
   1273           * @param  hDuty to be applied in uint16_t
   1274           * @retval It returns the code error 'MC_FOC_DURATION' if any, 'MC_NO_ERROR'
   1275           *         otherwise. These error codes are defined in mc_type.h
   1276           */

   \                                 In section .text, align 2, keep-with-next
   1277          uint16_t R3_1_RLDetectionModeSetDuty( PWMC_Handle_t * pHdl, uint16_t hDuty )
   1278          {
   \                     R3_1_RLDetectionModeSetDuty: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4602             MOV      R2,R0
   1279          #if defined (__ICCARM__)
   1280            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1281          #endif /* __ICCARM__ */
   1282            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1283          #if defined (__ICCARM__)
   1284            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1285          #endif /* __ICCARM__ */
   1286            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   1287            uint32_t val;
   1288            uint16_t hAux;
   1289          
   1290          
   1291            val = ( ( uint32_t )( pHandle->Half_PWMPeriod ) * ( uint32_t )( hDuty ) ) >> 16;
   1292            pHandle->_Super.CntPhA = ( uint16_t )( val );
   \        0x4   0xF102 0x033A      ADD      R3,R2,#+58
   \        0x8   0x6F50             LDR      R0,[R2, #+116]
   \        0xA   0x8DDC             LDRH     R4,[R3, #+46]
   \        0xC   0x6840             LDR      R0,[R0, #+4]
   \        0xE   0x4361             MULS     R1,R1,R4
   \       0x10   0x0C09             LSRS     R1,R1,#+16
   \       0x12   0x8651             STRH     R1,[R2, #+50]
   1293            
   1294            /* set sector in order to sample phase B */
   1295            pHandle->_Super.Sector = SECTOR_4;
   \       0x14   0x2103             MOVS     R1,#+3
   \       0x16   0x7019             STRB     R1,[R3, #+0]
   1296            
   1297            /* TIM1 Channel 1 Duty Cycle configuration.
   1298             * In RL Detection mode only the Up-side device of Phase A are controlled*/
   1299            LL_TIM_OC_SetCompareCH1(TIMx, ( uint32_t )pHandle->_Super.CntPhA);
   \       0x18   0x8E53             LDRH     R3,[R2, #+50]
   \       0x1A   0x6343             STR      R3,[R0, #+52]
   1300          
   1301          
   1302            /* Limit for update event */
   1303            /*  If an update event has occurred before to set new
   1304            values of regs the FOC rate is too high */
   1305            if (((TIMx->CR2) & TIM_CR2_MMS_Msk) != LL_TIM_TRGO_RESET )
   \       0x1C   0x6840             LDR      R0,[R0, #+4]
   1306            {
   1307              hAux = MC_FOC_DURATION;
   1308            }
   1309            else
   1310            {
   1311              hAux = MC_NO_ERROR;
   1312            }
   1313            if ( pHandle->_Super.SWerror == 1u )
   \       0x1E   0x8F11             LDRH     R1,[R2, #+56]
   \       0x20   0xF010 0x0070      ANDS     R0,R0,#0x70
   \       0x24   0xBF18             IT       NE
   \       0x26   0x2001             MOVNE    R0,#+1
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0xD102             BNE.N    ??R3_1_RLDetectionModeSetDuty_0
   1314            {
   1315              hAux = MC_FOC_DURATION;
   1316              pHandle->_Super.SWerror = 0u;
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x8711             STRH     R1,[R2, #+56]
   1317            }
   1318            return hAux;
   \                     ??R3_1_RLDetectionModeSetDuty_0: (+1)
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
   1319          }
   1320          
   1321          #if defined (CCMRAM)
   1322          #if defined (__ICCARM__)
   1323          #pragma location = ".ccmram"
   1324          #elif defined (__CC_ARM) || defined(__GNUC__)
   1325          __attribute__( ( section ( ".ccmram" ) ) )
   1326          #endif
   1327          #endif
   1328          /**
   1329            * @brief  It computes and return latest converted motor phase currents motor
   1330            *         during RL detection phase
   1331            * @param pHdl: handler of the current instance of the PWM component
   1332            * @retval Ia and Ib current in ab_t format
   1333            */

   \                                 In section .text, align 4, keep-with-next
   1334          static void R3_1_RLGetPhaseCurrents( PWMC_Handle_t * pHdl, ab_t * pStator_Currents )
   1335          {
   \                     R3_1_RLGetPhaseCurrents: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   1336          #if defined (__ICCARM__)
   1337            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1338          #endif /* __ICCARM__ */
   1339            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1340          #if defined (__ICCARM__)
   1341            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1342          #endif /* __ICCARM__ */
   1343            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   1344            int32_t wAux;
   1345            
   1346            /* disable ADC trigger source */
   1347            LL_TIM_SetTriggerOutput(TIMx, LL_TIM_TRGO_RESET);
   \        0x4   0xF105 0x0660      ADD      R6,R5,#+96
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x6972             LDR      R2,[R6, #+20]
   \        0xC   0x6850             LDR      R0,[R2, #+4]
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x....'....        BL       LL_TIM_SetTriggerOutput
   1348          
   1349            wAux = (int32_t)( pHandle->PhaseBOffset ) - (int32_t)*pHandle->pParams_str->ADCDataReg2[pHandle->_Super.Sector];
   \       0x14   0x6970             LDR      R0,[R6, #+20]
   \       0x16   0xF895 0x203A      LDRB     R2,[R5, #+58]
   \       0x1A   0x6831             LDR      R1,[R6, #+0]
   \       0x1C   0xEB00 0x0382      ADD      R3,R0,R2, LSL #+2
   \       0x20   0x6BD8             LDR      R0,[R3, #+60]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x1A08             SUBS     R0,R1,R0
   1350          
   1351            /* Check saturation */
   1352            if ( wAux > -INT16_MAX )
   \       0x26   0x....             LDR.N    R1,??DataTable8_11  ;; 0xffff8001
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0xDD03             BLE.N    ??R3_1_RLGetPhaseCurrents_0
   1353            {
   1354              if ( wAux < INT16_MAX )
   \       0x2C   0xF647 0x71FF      MOVW     R1,#+32767
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xDB00             BLT.N    ??R3_1_RLGetPhaseCurrents_1
   1355              {
   1356              }
   1357              else
   1358              {
   1359                wAux = INT16_MAX;
   1360              }
   1361            }
   1362            else
   1363            {
   1364              wAux = -INT16_MAX;
   \                     ??R3_1_RLGetPhaseCurrents_0: (+1)
   \       0x34   0x4608             MOV      R0,R1
   1365            }
   1366          
   1367            pStator_Currents->a = (int16_t)wAux;
   \                     ??R3_1_RLGetPhaseCurrents_1: (+1)
   \       0x36   0xBF00             Nop
   \       0x38                      REQUIRE ?Subroutine0
   \       0x38                      ;; // Fall through to label ?Subroutine0
   1368            pStator_Currents->b = (int16_t)wAux;
   1369          }
   1370          
   1371          /**
   1372            * @brief  It turns on low sides switches. This function is intended to be
   1373            *         used for charging boot capacitors of driving section. It has to be
   1374            *         called each motor start-up when using high voltage drivers.
   1375            *         This function is specific for RL detection phase.
   1376            * @param pHdl: handler of the current instance of the PWM component
   1377            * @retval none
   1378            */

   \                                 In section .text, align 4, keep-with-next
   1379          static void R3_1_RLTurnOnLowSides( PWMC_Handle_t * pHdl )
   1380          {
   \                     R3_1_RLTurnOnLowSides: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1381          #if defined (__ICCARM__)
   1382            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1383          #endif /* __ICCARM__ */
   1384            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1385          #if defined (__ICCARM__)
   1386            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1387          #endif /* __ICCARM__ */
   1388            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   1389          
   1390            /*Turn on the phase A low side switch */
   1391            LL_TIM_OC_SetCompareCH1 ( TIMx, 0u );
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6F60             LDR      R0,[R4, #+116]
   \        0x8   0x6845             LDR      R5,[R0, #+4]
   \        0xA   0x6369             STR      R1,[R5, #+52]
   1392          
   1393            /* Clear Update Flag */
   1394            LL_TIM_ClearFlag_UPDATE( TIMx );
   \        0xC   0x....'....        BL       ?Subroutine6
   1395          
   1396            /* Wait until next update */
   1397            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0 )
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        BL       LL_TIM_IsActiveFlag_UPDATE
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD0FA             BEQ.N    ??CrossCallReturnLabel_13
   1398            {}
   1399            /* Clear Update Flag */
   1400            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x1A   0x....'....        BL       ?Subroutine6
   1401            
   1402            /* Main PWM Output Enable */
   1403            LL_TIM_EnableAllOutputs( TIMx );
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       LL_TIM_EnableAllOutputs
   1404          
   1405            if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x24   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x28   0xD10C             BNE.N    ??R3_1_RLTurnOnLowSides_0
   1406            {
   1407              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x2A   0x8809             LDRH     R1,[R1, #+0]
   \       0x2C   0x6980             LDR      R0,[R0, #+24]
   \       0x2E   0x....'....        BL       LL_GPIO_SetOutputPin
   1408              LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x32   0x....'....        BL       ?Subroutine4
   1409              LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x36   0x6F60             LDR      R0,[R4, #+116]
   \       0x38   0xF8B0 0x1070      LDRH     R1,[R0, #+112]
   \       0x3C   0x6A00             LDR      R0,[R0, #+32]
   \       0x3E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x42   0x....             B.N      LL_GPIO_ResetOutputPin
   1410            }
   1411            return;
   \                     ??R3_1_RLTurnOnLowSides_0: (+1)
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1412          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x6F60             LDR      R0,[R4, #+116]
   \        0x2   0xF100 0x016C      ADD      R1,R0,#+108
   \        0x6   0x7B8A             LDRB     R2,[R1, #+14]
   \        0x8   0x2A02             CMP      R2,#+2
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x....             B.N      LL_TIM_ClearFlag_UPDATE

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x6F60             LDR      R0,[R4, #+116]
   \        0x2   0xF8B0 0x106E      LDRH     R1,[R0, #+110]
   \        0x6   0x69C0             LDR      R0,[R0, #+28]
   \        0x8   0x....             B.N      LL_GPIO_ResetOutputPin
   1413          
   1414          
   1415          /**
   1416           * @brief  It enables PWM generation on the proper Timer peripheral
   1417           *         This function is specific for RL detection phase.
   1418           * @param pHdl: handler of the current instance of the PWM component
   1419           * @retval none
   1420           */

   \                                 In section .text, align 4, keep-with-next
   1421          static void R3_1_RLSwitchOnPWM( PWMC_Handle_t * pHdl )
   1422          {
   \                     R3_1_RLSwitchOnPWM: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   1423          #if defined (__ICCARM__)
   1424            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1425          #endif /* __ICCARM__ */
   1426            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1427          #if defined (__ICCARM__)
   1428            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1429          #endif /* __ICCARM__ */
   1430            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   1431            ADC_TypeDef * ADCx = pHandle->pParams_str->ADCx;
   1432            
   1433            pHandle->_Super.TurnOnLowSidesAction = false;
   \        0x4   0xF104 0x073A      ADD      R7,R4,#+58
   \        0x8   0x6F60             LDR      R0,[R4, #+116]
   \        0xA   0x6845             LDR      R5,[R0, #+4]
   \        0xC   0x6806             LDR      R6,[R0, #+0]
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x7238             STRB     R0,[R7, #+8]
   1434            /* The folowing while cycles ensure the identification of the nergative counting mode of TIM1
   1435             * for correct modification of Repetition Counter value of TIM1.*/
   1436          
   1437             /* Wait the change of Counter Direction of TIM1 from Down-Direction to Up-Direction*/
   1438            while ( ( TIMx->CR1 & TIM_CR1_DIR_Msk ) == LL_TIM_COUNTERMODE_DOWN )
   \                     ??R3_1_RLSwitchOnPWM_0: (+1)
   \       0x12   0x6829             LDR      R1,[R5, #+0]
   \       0x14   0x06C8             LSLS     R0,R1,#+27
   \       0x16   0xD4FC             BMI.N    ??R3_1_RLSwitchOnPWM_0
   1439            {
   1440            }
   1441            /* Wait the change of Counter Direction of TIM1 from Up-Direction to Down-Direction*/
   1442            while ( ( TIMx->CR1 & TIM_CR1_DIR_Msk ) == LL_TIM_COUNTERMODE_UP )
   \                     ??R3_1_RLSwitchOnPWM_1: (+1)
   \       0x18   0x6829             LDR      R1,[R5, #+0]
   \       0x1A   0x06C8             LSLS     R0,R1,#+27
   \       0x1C   0xD5FC             BPL.N    ??R3_1_RLSwitchOnPWM_1
   1443            {
   1444            }
   1445          
   1446            /* Set channel 1 Compare/Capture register to 1 */
   1447            LL_TIM_OC_SetCompareCH1(TIMx, 1u);
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0x6369             STR      R1,[R5, #+52]
   1448          
   1449            /* Set channel 4 Compare/Capture register to trig ADC in the middle 
   1450               of the PWM period */
   1451            LL_TIM_OC_SetCompareCH4(TIMx,(( uint32_t )( pHandle->Half_PWMPeriod ) - 5u));
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0x8DF9             LDRH     R1,[R7, #+46]
   \       0x26   0x1F49             SUBS     R1,R1,#+5
   \       0x28   0x....'....        BL       LL_TIM_OC_SetCompareCH4
   1452            
   1453          
   1454            LL_TIM_ClearFlag_UPDATE( TIMx ); /* Clear flag to wait next update */
   \       0x2C   0x....'....        BL       ?Subroutine6
   1455          
   1456            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0 )
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       LL_TIM_IsActiveFlag_UPDATE
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD0FA             BEQ.N    ??CrossCallReturnLabel_11
   1457            {}
   1458            /* Clear Update Flag */
   1459            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x3A   0x....'....        BL       ?Subroutine6
   1460            
   1461            /* Main PWM Output Enable */
   1462            TIMx->BDTR |= LL_TIM_OSSI_ENABLE;
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x3E   0x6C68             LDR      R0,[R5, #+68]
   \       0x40   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x44   0x6468             STR      R0,[R5, #+68]
   1463            LL_TIM_EnableAllOutputs(TIMx);
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x....'....        BL       LL_TIM_EnableAllOutputs
   1464          
   1465            if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x4C   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x50   0xD119             BNE.N    ??R3_1_RLSwitchOnPWM_2
   1466            {
   1467              if ( ( TIMx->CCER & TIMxCCER_MASK_CH123 ) != 0u )
   \       0x52   0x8809             LDRH     R1,[R1, #+0]
   \       0x54   0x6980             LDR      R0,[R0, #+24]
   \       0x56   0x6A2A             LDR      R2,[R5, #+32]
   \       0x58   0xF240 0x5355      MOVW     R3,#+1365
   \       0x5C   0x421A             TST      R2,R3
   \       0x5E   0xD008             BEQ.N    ??R3_1_RLSwitchOnPWM_3
   1468              {
   1469                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x60   0x....'....        BL       LL_GPIO_SetOutputPin
   1470                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x64   0x6F60             LDR      R0,[R4, #+116]
   \       0x66   0xF8B0 0x106E      LDRH     R1,[R0, #+110]
   \       0x6A   0x69C0             LDR      R0,[R0, #+28]
   \       0x6C   0x....'....        BL       LL_GPIO_SetOutputPin
   1471                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x70   0xE003             B.N      ??CrossCallReturnLabel_4
   1472              }
   1473              else
   1474              {
   1475                /* It is executed during calibration phase the EN signal shall stay off */
   1476                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \                     ??R3_1_RLSwitchOnPWM_3: (+1)
   \       0x72   0x....'....        BL       LL_GPIO_ResetOutputPin
   1477                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x76   0x....'....        BL       ?Subroutine4
   1478                LL_GPIO_ResetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x7A   0x6F60             LDR      R0,[R4, #+116]
   \       0x7C   0xF8B0 0x1070      LDRH     R1,[R0, #+112]
   \       0x80   0x6A00             LDR      R0,[R0, #+32]
   \       0x82   0x....'....        BL       LL_GPIO_ResetOutputPin
   1479              }
   1480            }
   1481          
   1482            /* set the sector that correspond to Phase A and B sampling
   1483             * B will be sampled by ADCx_1 */
   1484            pHdl->Sector = SECTOR_4;
   \                     ??R3_1_RLSwitchOnPWM_2: (+1)
   \       0x86   0x2003             MOVS     R0,#+3
   \       0x88   0x7038             STRB     R0,[R7, #+0]
   1485            LL_ADC_INJ_StartConversion( ADCx );
   \       0x8A   0x4630             MOV      R0,R6
   \       0x8C   0x....'....        BL       LL_ADC_INJ_StartConversion
   1486          
   1487            /* enable TIMx update interrupt*/
   1488            LL_TIM_EnableIT_UPDATE( TIMx );
   \       0x90   0x4628             MOV      R0,R5
   \       0x92   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x96   0x....             B.N      LL_TIM_EnableIT_UPDATE
   1489          
   1490          
   1491          
   1492            return;
   1493          }
   1494          
   1495          /**
   1496           * @brief  It turns on low sides switches and start ADC triggering.
   1497           *         This function is specific for MP phase.
   1498           * @param  pHandle Pointer on the target component instance
   1499           * @retval none
   1500           */

   \                                 In section .text, align 2, keep-with-next
   1501          void RLTurnOnLowSidesAndStart( PWMC_Handle_t * pHdl )
   1502          {
   \                     RLTurnOnLowSidesAndStart: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1503          #if defined (__ICCARM__)
   1504            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1505          #endif /* __ICCARM__ */
   1506            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1507          #if defined (__ICCARM__)
   1508            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1509          #endif /* __ICCARM__ */
   1510            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x2   0x6F41             LDR      R1,[R0, #+116]
   \        0x4   0x684A             LDR      R2,[R1, #+4]
   1511          
   1512            /* Clear Update Flag */
   1513            LL_TIM_ClearFlag_UPDATE( TIMx );
   \        0x6   0xF06F 0x0101      MVN      R1,#+1
   \        0xA   0x6111             STR      R1,[R2, #+16]
   1514          
   1515            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0 )
   \                     ??RLTurnOnLowSidesAndStart_0: (+1)
   \        0xC   0x6913             LDR      R3,[R2, #+16]
   \        0xE   0x07DC             LSLS     R4,R3,#+31
   \       0x10   0xD5FC             BPL.N    ??RLTurnOnLowSidesAndStart_0
   1516            {}
   1517            /* Clear Update Flag */
   1518            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x12   0x6111             STR      R1,[R2, #+16]
   1519          
   1520            LL_TIM_OC_SetCompareCH1( TIMx, 0x0u );
   \       0x14   0x2300             MOVS     R3,#+0
   \       0x16   0x6353             STR      R3,[R2, #+52]
   1521            LL_TIM_OC_SetCompareCH2( TIMx, 0x0u );
   \       0x18   0x6393             STR      R3,[R2, #+56]
   1522            LL_TIM_OC_SetCompareCH3( TIMx, 0x0u );
   \       0x1A   0x63D3             STR      R3,[R2, #+60]
   1523            LL_TIM_OC_SetCompareCH4( TIMx, ( pHandle->Half_PWMPeriod - 5u));
   \       0x1C   0xF100 0x033A      ADD      R3,R0,#+58
   \       0x20   0x8DDC             LDRH     R4,[R3, #+46]
   \       0x22   0x1F64             SUBS     R4,R4,#+5
   \       0x24   0x6414             STR      R4,[R2, #+64]
   1524          
   1525            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0 )
   \                     ??RLTurnOnLowSidesAndStart_1: (+1)
   \       0x26   0x6914             LDR      R4,[R2, #+16]
   \       0x28   0x07E5             LSLS     R5,R4,#+31
   \       0x2A   0xD5FC             BPL.N    ??RLTurnOnLowSidesAndStart_1
   1526            {}
   1527          
   1528            /* Main PWM Output Enable */
   1529            TIMx->BDTR |= LL_TIM_OSSI_ENABLE ;
   \       0x2C   0x6C54             LDR      R4,[R2, #+68]
   \       0x2E   0xF444 0x6480      ORR      R4,R4,#0x400
   \       0x32   0x6454             STR      R4,[R2, #+68]
   1530            LL_TIM_EnableAllOutputs ( TIMx );
   \       0x34   0x6C54             LDR      R4,[R2, #+68]
   \       0x36   0xF444 0x4400      ORR      R4,R4,#0x8000
   \       0x3A   0x6454             STR      R4,[R2, #+68]
   1531          
   1532            if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x3C   0x6F44             LDR      R4,[R0, #+116]
   \       0x3E   0xF104 0x056C      ADD      R5,R4,#+108
   \       0x42   0x7BAE             LDRB     R6,[R5, #+14]
   \       0x44   0x2E02             CMP      R6,#+2
   \       0x46   0xD10C             BNE.N    ??RLTurnOnLowSidesAndStart_2
   1533            {
   1534                /* It is executed during calibration phase the EN signal shall stay off */
   1535                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x48   0x69A4             LDR      R4,[R4, #+24]
   \       0x4A   0x882D             LDRH     R5,[R5, #+0]
   \       0x4C   0x61A5             STR      R5,[R4, #+24]
   1536                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x4E   0x6F44             LDR      R4,[R0, #+116]
   \       0x50   0xF8B4 0x506E      LDRH     R5,[R4, #+110]
   \       0x54   0x69E4             LDR      R4,[R4, #+28]
   \       0x56   0x61A5             STR      R5,[R4, #+24]
   1537                LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x58   0x6F40             LDR      R0,[R0, #+116]
   \       0x5A   0xF8B0 0x4070      LDRH     R4,[R0, #+112]
   \       0x5E   0x6A00             LDR      R0,[R0, #+32]
   \       0x60   0x6184             STR      R4,[R0, #+24]
   1538            }
   1539          
   1540          
   1541            pHdl->Sector = SECTOR_5;
   \                     ??RLTurnOnLowSidesAndStart_2: (+1)
   \       0x62   0x2404             MOVS     R4,#+4
   \       0x64   0x701C             STRB     R4,[R3, #+0]
   1542            
   1543            /* Clear Update Flag */
   1544            LL_TIM_ClearFlag_UPDATE( TIMx );
   \       0x66   0x6111             STR      R1,[R2, #+16]
   1545            /* Enable Update IRQ */
   1546            LL_TIM_EnableIT_UPDATE( TIMx );
   \       0x68   0x68D0             LDR      R0,[R2, #+12]
   \       0x6A   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x6E   0x60D0             STR      R0,[R2, #+12]
   1547            
   1548          
   1549            return;
   \       0x70   0xBD70             POP      {R4-R6,PC}       ;; return
   1550          }
   1551          
   1552          
   1553          /**
   1554            * @brief  Generate DC break signal
   1555            * @param  pHandle: handler of the current instance of the PWM component
   1556            * @retval none
   1557            */

   \                                 In section .text, align 2
   1558          __weak void DC_BreakSignal_PAM( PWMC_Handle_t * pHdl )
   1559          {
   \                     DC_BreakSignal_PAM: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1560          #if defined (__ICCARM__)
   1561            #pragma cstat_disable = "MISRAC2012-Rule-11.3"
   1562          #endif /* __ICCARM__ */
   1563            PWMC_R3_1_Handle_t * pHandle = ( PWMC_R3_1_Handle_t * )pHdl;
   1564          #if defined (__ICCARM__)
   1565            #pragma cstat_restore = "MISRAC2012-Rule-11.3"
   1566          #endif /* __ICCARM__ */
   1567            TIM_TypeDef * TIMx = pHandle->pParams_str->TIMx;
   \        0x2   0x6F41             LDR      R1,[R0, #+116]
   \        0x4   0x6849             LDR      R1,[R1, #+4]
   1568          
   1569            pHandle->_Super.TurnOnLowSidesAction = false;
   \        0x6   0xF100 0x0242      ADD      R2,R0,#+66
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x7013             STRB     R3,[R2, #+0]
   1570          
   1571            /* Clear Update Flag */
   1572            LL_TIM_ClearFlag_UPDATE( pHandle->pParams_str->TIMx );
   \        0xE   0xF06F 0x0401      MVN      R4,#+1
   \       0x12   0x6F45             LDR      R5,[R0, #+116]
   \       0x14   0x686B             LDR      R3,[R5, #+4]
   \       0x16   0x611C             STR      R4,[R3, #+16]
   1573          
   1574            /*Turn on the three low side switches */
   1575            LL_TIM_OC_SetCompareCH1( TIMx, ((uint32_t) pHandle->Half_PWMPeriod / (uint32_t) 32) );
   \       0x18   0x8CD4             LDRH     R4,[R2, #+38]
   \       0x1A   0x0964             LSRS     R4,R4,#+5
   \       0x1C   0x634C             STR      R4,[R1, #+52]
   1576            LL_TIM_OC_SetCompareCH2( TIMx, ((uint32_t) pHandle->Half_PWMPeriod / (uint32_t) 32));
   \       0x1E   0x8CD3             LDRH     R3,[R2, #+38]
   \       0x20   0x095B             LSRS     R3,R3,#+5
   \       0x22   0x638B             STR      R3,[R1, #+56]
   1577            LL_TIM_OC_SetCompareCH3( TIMx, ((uint32_t) pHandle->Half_PWMPeriod / (uint32_t) 32) );
   \       0x24   0x8CD2             LDRH     R2,[R2, #+38]
   \       0x26   0x0952             LSRS     R2,R2,#+5
   \       0x28   0x63CA             STR      R2,[R1, #+60]
   1578          
   1579            /* Wait until next update */
   1580            while ( LL_TIM_IsActiveFlag_UPDATE( TIMx ) == 0u )
   \                     ??DC_BreakSignal_PAM_0: (+1)
   \       0x2A   0x690A             LDR      R2,[R1, #+16]
   \       0x2C   0x07D3             LSLS     R3,R2,#+31
   \       0x2E   0xD5FC             BPL.N    ??DC_BreakSignal_PAM_0
   1581            {}
   1582          
   1583            /* Main PWM Output Enable */
   1584            LL_TIM_EnableAllOutputs( TIMx );
   \       0x30   0x6C4A             LDR      R2,[R1, #+68]
   \       0x32   0xF442 0x4200      ORR      R2,R2,#0x8000
   \       0x36   0x644A             STR      R2,[R1, #+68]
   1585          
   1586            if ( ( pHandle->pParams_str->LowSideOutputs ) == ES_GPIO )
   \       0x38   0x6F41             LDR      R1,[R0, #+116]
   \       0x3A   0xF101 0x026C      ADD      R2,R1,#+108
   \       0x3E   0x7B93             LDRB     R3,[R2, #+14]
   \       0x40   0x2B02             CMP      R3,#+2
   \       0x42   0xD10C             BNE.N    ??DC_BreakSignal_PAM_1
   1587            {
   1588              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_u_port, pHandle->pParams_str->pwm_en_u_pin );
   \       0x44   0x6989             LDR      R1,[R1, #+24]
   \       0x46   0x8812             LDRH     R2,[R2, #+0]
   \       0x48   0x618A             STR      R2,[R1, #+24]
   1589              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_v_port, pHandle->pParams_str->pwm_en_v_pin );
   \       0x4A   0x6F41             LDR      R1,[R0, #+116]
   \       0x4C   0xF8B1 0x206E      LDRH     R2,[R1, #+110]
   \       0x50   0x69C9             LDR      R1,[R1, #+28]
   \       0x52   0x618A             STR      R2,[R1, #+24]
   1590              LL_GPIO_SetOutputPin( pHandle->pParams_str->pwm_en_w_port, pHandle->pParams_str->pwm_en_w_pin );
   \       0x54   0x6F40             LDR      R0,[R0, #+116]
   \       0x56   0xF8B0 0x1070      LDRH     R1,[R0, #+112]
   \       0x5A   0x6A00             LDR      R0,[R0, #+32]
   \       0x5C   0x6181             STR      R1,[R0, #+24]
   1591            }
   1592            return;
   \                     ??DC_BreakSignal_PAM_1: (+1)
   \       0x5E   0xBD30             POP      {R4,R5,PC}       ;; return
   1593          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x7FFF'FFC0        DC32     0x7fffffc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0001'0073        DC32     0x10073

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xFFFF'FAAA        DC32     0xfffffaaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     R3_1_GetPhaseCurrents

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x4000'7408        DC32     0x40007408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x4000'7400        DC32     0x40007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     R3_1_SwitchOffPWM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     R3_1_TurnOnLowSides

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     R3_1_SwitchOnPWM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0xFFFF'8001        DC32     0xffff8001
   1594          
   1595          
   1596          /**
   1597           * @}
   1598           */
   1599          
   1600          /**
   1601           * @}
   1602           */
   1603          
   1604          /**
   1605           * @}
   1606           */
   1607          
   1608          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   DC_BreakSignal_PAM
       0   LL_ADC_INJ_StartConversion
       0   LL_GPIO_ResetOutputPin
       0   LL_GPIO_SetOutputPin
       0   LL_TIM_ClearFlag_UPDATE
       0   LL_TIM_EnableAllOutputs
       0   LL_TIM_EnableIT_UPDATE
       0   LL_TIM_IsActiveFlag_UPDATE
      16   LL_TIM_OC_DisablePreload
      16   LL_TIM_OC_EnablePreload
       0   LL_TIM_OC_SetCompareCH1
       0   LL_TIM_OC_SetCompareCH2
       0   LL_TIM_OC_SetCompareCH3
       0   LL_TIM_OC_SetCompareCH4
      12   LL_TIM_OC_SetMode
       0   LL_TIM_SetTriggerOutput
      12   R3_1_BRK2_IRQHandler
       0   R3_1_BRK_IRQHandler
      24   R3_1_CurrentReadingPolarization
        24   -> LL_TIM_OC_DisablePreload
        24   -> LL_TIM_OC_EnablePreload
        24   -> R3_1_SwitchOffPWM
        24   -> R3_1_SwitchOnPWM
        24   -> waitForPolarizationEnd
      24   R3_1_GetPhaseCurrents
      24   R3_1_HFCurrentsPolarizationAB
        24   -> LL_TIM_SetTriggerOutput
      16   R3_1_HFCurrentsPolarizationC
        16   -> LL_TIM_SetTriggerOutput
      40   R3_1_Init
        40   -> LL_TIM_OC_EnablePreload
        40   -> R3_1_SetAOReferenceVoltage
       0   R3_1_IsOverCurrentOccurred
      16   R3_1_RLDetectionModeDisable
        16   -> LL_TIM_OC_SetMode
      16   R3_1_RLDetectionModeEnable
        16   -> LL_TIM_OC_SetMode
       8   R3_1_RLDetectionModeSetDuty
      16   R3_1_RLGetPhaseCurrents
        16   -> LL_TIM_SetTriggerOutput
      24   R3_1_RLSwitchOnPWM
        24   -> LL_ADC_INJ_StartConversion
        24   -> LL_GPIO_ResetOutputPin
        24   -> LL_GPIO_SetOutputPin
        24   -> LL_TIM_ClearFlag_UPDATE
        24   -> LL_TIM_EnableAllOutputs
         0   -> LL_TIM_EnableIT_UPDATE
        24   -> LL_TIM_IsActiveFlag_UPDATE
        24   -> LL_TIM_OC_SetCompareCH4
      16   R3_1_RLTurnOnLowSides
         0   -> LL_GPIO_ResetOutputPin
        16   -> LL_GPIO_ResetOutputPin
        16   -> LL_GPIO_SetOutputPin
        16   -> LL_TIM_ClearFlag_UPDATE
        16   -> LL_TIM_EnableAllOutputs
        16   -> LL_TIM_IsActiveFlag_UPDATE
       0   R3_1_SetADCSampPointPolarization
         0   -> R3_1_WriteTIMRegisters
      24   R3_1_SetADCSampPointSectX
         0   -> R3_1_WriteTIMRegisters
       8   R3_1_SetAOReferenceVoltage
       8   R3_1_SwitchOffPWM
      16   R3_1_SwitchOnPWM
      16   R3_1_TIMx_UP_IRQHandler
       8   R3_1_TurnOnLowSides
      16   R3_1_WriteTIMRegisters
        16   -> LL_TIM_OC_SetCompareCH1
        16   -> LL_TIM_OC_SetCompareCH2
        16   -> LL_TIM_OC_SetCompareCH3
        16   -> LL_TIM_OC_SetCompareCH4
      16   RLTurnOnLowSidesAndStart


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       6  ?Subroutine0
       2  ?Subroutine1
      24  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
       6  ?Subroutine5
       4  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      96  DC_BreakSignal_PAM
      16  LL_ADC_INJ_StartConversion
       4  LL_GPIO_ResetOutputPin
       4  LL_GPIO_SetOutputPin
       8  LL_TIM_ClearFlag_UPDATE
      10  LL_TIM_EnableAllOutputs
      10  LL_TIM_EnableIT_UPDATE
       8  LL_TIM_IsActiveFlag_UPDATE
      84  LL_TIM_OC_DisablePreload
      84  LL_TIM_OC_EnablePreload
       4  LL_TIM_OC_SetCompareCH1
       4  LL_TIM_OC_SetCompareCH2
       4  LL_TIM_OC_SetCompareCH3
       4  LL_TIM_OC_SetCompareCH4
     108  LL_TIM_OC_SetMode
      12  LL_TIM_SetTriggerOutput
      12  OFFSET_TAB_CCMRx
      50  R3_1_BRK2_IRQHandler
      26  R3_1_BRK_IRQHandler
     266  R3_1_CurrentReadingPolarization
     228  R3_1_GetPhaseCurrents
      74  R3_1_HFCurrentsPolarizationAB
      50  R3_1_HFCurrentsPolarizationC
     592  R3_1_Init
      34  R3_1_IsOverCurrentOccurred
     214  R3_1_RLDetectionModeDisable
     158  R3_1_RLDetectionModeEnable
      52  R3_1_RLDetectionModeSetDuty
      56  R3_1_RLGetPhaseCurrents
     152  R3_1_RLSwitchOnPWM
      70  R3_1_RLTurnOnLowSides
      16  R3_1_SetADCSampPointPolarization
      80  R3_1_SetADCSampPointSectX
     104  R3_1_SetAOReferenceVoltage
      90  R3_1_SwitchOffPWM
     152  R3_1_SwitchOnPWM
      42  R3_1_TIMx_UP_IRQHandler
      84  R3_1_TurnOnLowSides
      54  R3_1_WriteTIMRegisters
     114  RLTurnOnLowSidesAndStart
      12  SHIFT_TAB_OCxx

 
 3'376 bytes in section .text
 
 1'982 bytes of CODE memory (+ 1'394 bytes shared)

Errors: none
Warnings: none
