###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:17
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_dma.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW6086.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_dma.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\stm32f3xx_ll_dma.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\stm32f3xx_ll_dma.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_ll_dma.c
      4            * @author  MCD Application Team
      5            * @brief   DMA LL module driver.
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          #if defined(USE_FULL_LL_DRIVER)
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f3xx_ll_dma.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute uint8_t const CHANNEL_OFFSET_TAB[7]
   \                     CHANNEL_OFFSET_TAB:
   \        0x0   0x08 0x1C          DC8 8, 28, 48, 68, 88, 108, 128

   \              0x30 0x44    

   \              0x58 0x6C    

   \              0x80
   \        0x7                      DS8 1
     23          #include "stm32f3xx_ll_bus.h"
     24          #ifdef  USE_FULL_ASSERT
     25          #include "stm32_assert.h"
     26          #else
     27          #define assert_param(expr) ((void)0U)
     28          #endif
     29          
     30          /** @addtogroup STM32F3xx_LL_Driver
     31            * @{
     32            */
     33          
     34          #if defined (DMA1) || defined (DMA2)
     35          
     36          /** @defgroup DMA_LL DMA
     37            * @{
     38            */
     39          
     40          /* Private types -------------------------------------------------------------*/
     41          /* Private variables ---------------------------------------------------------*/
     42          /* Private constants ---------------------------------------------------------*/
     43          /* Private macros ------------------------------------------------------------*/
     44          /** @addtogroup DMA_LL_Private_Macros
     45            * @{
     46            */
     47          #define IS_LL_DMA_DIRECTION(__VALUE__)          (((__VALUE__) == LL_DMA_DIRECTION_PERIPH_TO_MEMORY) || \
     48                                                           ((__VALUE__) == LL_DMA_DIRECTION_MEMORY_TO_PERIPH) || \
     49                                                           ((__VALUE__) == LL_DMA_DIRECTION_MEMORY_TO_MEMORY))
     50          
     51          #define IS_LL_DMA_MODE(__VALUE__)               (((__VALUE__) == LL_DMA_MODE_NORMAL) || \
     52                                                           ((__VALUE__) == LL_DMA_MODE_CIRCULAR))
     53          
     54          #define IS_LL_DMA_PERIPHINCMODE(__VALUE__)      (((__VALUE__) == LL_DMA_PERIPH_INCREMENT) || \
     55                                                           ((__VALUE__) == LL_DMA_PERIPH_NOINCREMENT))
     56          
     57          #define IS_LL_DMA_MEMORYINCMODE(__VALUE__)      (((__VALUE__) == LL_DMA_MEMORY_INCREMENT) || \
     58                                                           ((__VALUE__) == LL_DMA_MEMORY_NOINCREMENT))
     59          
     60          #define IS_LL_DMA_PERIPHDATASIZE(__VALUE__)     (((__VALUE__) == LL_DMA_PDATAALIGN_BYTE)      || \
     61                                                           ((__VALUE__) == LL_DMA_PDATAALIGN_HALFWORD)  || \
     62                                                           ((__VALUE__) == LL_DMA_PDATAALIGN_WORD))
     63          
     64          #define IS_LL_DMA_MEMORYDATASIZE(__VALUE__)     (((__VALUE__) == LL_DMA_MDATAALIGN_BYTE)      || \
     65                                                           ((__VALUE__) == LL_DMA_MDATAALIGN_HALFWORD)  || \
     66                                                           ((__VALUE__) == LL_DMA_MDATAALIGN_WORD))
     67          
     68          #define IS_LL_DMA_NBDATA(__VALUE__)             ((__VALUE__)  <= 0x0000FFFFU)
     69          
     70          
     71          #define IS_LL_DMA_PRIORITY(__VALUE__)           (((__VALUE__) == LL_DMA_PRIORITY_LOW)    || \
     72                                                           ((__VALUE__) == LL_DMA_PRIORITY_MEDIUM) || \
     73                                                           ((__VALUE__) == LL_DMA_PRIORITY_HIGH)   || \
     74                                                           ((__VALUE__) == LL_DMA_PRIORITY_VERYHIGH))
     75          
     76          #if defined (DMA2)
     77          #if defined (DMA2_Channel6) && defined (DMA2_Channel7)
     78          #define IS_LL_DMA_ALL_CHANNEL_INSTANCE(INSTANCE, CHANNEL)  ((((INSTANCE) == DMA1) && \
     79                                                                   (((CHANNEL) == LL_DMA_CHANNEL_1) || \
     80                                                                    ((CHANNEL) == LL_DMA_CHANNEL_2) || \
     81                                                                    ((CHANNEL) == LL_DMA_CHANNEL_3) || \
     82                                                                    ((CHANNEL) == LL_DMA_CHANNEL_4) || \
     83                                                                    ((CHANNEL) == LL_DMA_CHANNEL_5) || \
     84                                                                    ((CHANNEL) == LL_DMA_CHANNEL_6) || \
     85                                                                    ((CHANNEL) == LL_DMA_CHANNEL_7))) || \
     86                                                                   (((INSTANCE) == DMA2) && \
     87                                                                   (((CHANNEL) == LL_DMA_CHANNEL_1) || \
     88                                                                    ((CHANNEL) == LL_DMA_CHANNEL_2) || \
     89                                                                    ((CHANNEL) == LL_DMA_CHANNEL_3) || \
     90                                                                    ((CHANNEL) == LL_DMA_CHANNEL_4) || \
     91                                                                    ((CHANNEL) == LL_DMA_CHANNEL_5) || \
     92                                                                    ((CHANNEL) == LL_DMA_CHANNEL_6) || \
     93                                                                    ((CHANNEL) == LL_DMA_CHANNEL_7))))
     94          #else
     95          #define IS_LL_DMA_ALL_CHANNEL_INSTANCE(INSTANCE, CHANNEL)  ((((INSTANCE) == DMA1) && \
     96                                                                   (((CHANNEL) == LL_DMA_CHANNEL_1) || \
     97                                                                    ((CHANNEL) == LL_DMA_CHANNEL_2) || \
     98                                                                    ((CHANNEL) == LL_DMA_CHANNEL_3) || \
     99                                                                    ((CHANNEL) == LL_DMA_CHANNEL_4) || \
    100                                                                    ((CHANNEL) == LL_DMA_CHANNEL_5) || \
    101                                                                    ((CHANNEL) == LL_DMA_CHANNEL_6) || \
    102                                                                    ((CHANNEL) == LL_DMA_CHANNEL_7))) || \
    103                                                                   (((INSTANCE) == DMA2) && \
    104                                                                   (((CHANNEL) == LL_DMA_CHANNEL_1) || \
    105                                                                    ((CHANNEL) == LL_DMA_CHANNEL_2) || \
    106                                                                    ((CHANNEL) == LL_DMA_CHANNEL_3) || \
    107                                                                    ((CHANNEL) == LL_DMA_CHANNEL_4) || \
    108                                                                    ((CHANNEL) == LL_DMA_CHANNEL_5))))
    109          #endif
    110          #else
    111          #define IS_LL_DMA_ALL_CHANNEL_INSTANCE(INSTANCE, CHANNEL)  ((((INSTANCE) == DMA1) && \
    112                                                                      (((CHANNEL) == LL_DMA_CHANNEL_1)|| \
    113                                                                      ((CHANNEL) == LL_DMA_CHANNEL_2) || \
    114                                                                      ((CHANNEL) == LL_DMA_CHANNEL_3) || \
    115                                                                      ((CHANNEL) == LL_DMA_CHANNEL_4) || \
    116                                                                      ((CHANNEL) == LL_DMA_CHANNEL_5) || \
    117                                                                      ((CHANNEL) == LL_DMA_CHANNEL_6) || \
    118                                                                      ((CHANNEL) == LL_DMA_CHANNEL_7))))
    119          #endif
    120          /**
    121            * @}
    122            */
    123          
    124          /* Private function prototypes -----------------------------------------------*/
    125          
    126          /* Exported functions --------------------------------------------------------*/
    127          /** @addtogroup DMA_LL_Exported_Functions
    128            * @{
    129            */
    130          
    131          /** @addtogroup DMA_LL_EF_Init
    132            * @{
    133            */
    134          
    135          /**
    136            * @brief  De-initialize the DMA registers to their default reset values.
    137            * @param  DMAx DMAx Instance
    138            * @param  Channel This parameter can be one of the following values:
    139            *         @arg @ref LL_DMA_CHANNEL_1
    140            *         @arg @ref LL_DMA_CHANNEL_2
    141            *         @arg @ref LL_DMA_CHANNEL_3
    142            *         @arg @ref LL_DMA_CHANNEL_4
    143            *         @arg @ref LL_DMA_CHANNEL_5
    144            *         @arg @ref LL_DMA_CHANNEL_6
    145            *         @arg @ref LL_DMA_CHANNEL_7
    146            * @retval An ErrorStatus enumeration value:
    147            *          - SUCCESS: DMA registers are de-initialized
    148            *          - ERROR: DMA registers are not de-initialized
    149            */

   \                                 In section .text, align 2, keep-with-next
    150          uint32_t LL_DMA_DeInit(DMA_TypeDef *DMAx, uint32_t Channel)
    151          {
   \                     LL_DMA_DeInit: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    152            DMA_Channel_TypeDef *tmp = (DMA_Channel_TypeDef *)DMA1_Channel1;
    153            ErrorStatus status = SUCCESS;
   \        0x2   0x2200             MOVS     R2,#+0
    154          
    155            /* Check the DMA Instance DMAx and Channel parameters*/
    156            assert_param(IS_LL_DMA_ALL_CHANNEL_INSTANCE(DMAx, Channel));
    157          
    158              tmp = (DMA_Channel_TypeDef *)(__LL_DMA_GET_CHANNEL_INSTANCE(DMAx, Channel));
   \        0x4   0x....             LDR.N    R5,??DataTable1  ;; 0x40020000
   \        0x6   0x....             LDR.N    R3,??DataTable1_1  ;; 0x40020008
   \        0x8   0x42A8             CMP      R0,R5
   \        0xA   0x461C             MOV      R4,R3
   \        0xC   0xD11A             BNE.N    ??LL_DMA_DeInit_0
   \        0xE   0x2901             CMP      R1,#+1
   \       0x10   0xD01A             BEQ.N    ??LL_DMA_DeInit_1
   \       0x12   0x2902             CMP      R1,#+2
   \       0x14   0xBF08             IT       EQ
   \       0x16   0xF103 0x0414      ADDEQ    R4,R3,#+20
   \       0x1A   0xD015             BEQ.N    ??LL_DMA_DeInit_1
   \       0x1C   0x2903             CMP      R1,#+3
   \       0x1E   0xBF08             IT       EQ
   \       0x20   0xF103 0x0428      ADDEQ    R4,R3,#+40
   \       0x24   0xD010             BEQ.N    ??LL_DMA_DeInit_1
   \       0x26   0x2904             CMP      R1,#+4
   \       0x28   0xBF08             IT       EQ
   \       0x2A   0xF103 0x043C      ADDEQ    R4,R3,#+60
   \       0x2E   0xD00B             BEQ.N    ??LL_DMA_DeInit_1
   \       0x30   0x2905             CMP      R1,#+5
   \       0x32   0xBF08             IT       EQ
   \       0x34   0xF103 0x0450      ADDEQ    R4,R3,#+80
   \       0x38   0xD006             BEQ.N    ??LL_DMA_DeInit_1
   \       0x3A   0x2906             CMP      R1,#+6
   \       0x3C   0xBF08             IT       EQ
   \       0x3E   0xF103 0x0464      ADDEQ    R4,R3,#+100
   \       0x42   0xD001             BEQ.N    ??LL_DMA_DeInit_1
   \                     ??LL_DMA_DeInit_0: (+1)
   \       0x44   0xF103 0x0478      ADD      R4,R3,#+120
    159          
    160              /* Disable the selected DMAx_Channely */
    161              CLEAR_BIT(tmp->CCR, DMA_CCR_EN);
   \                     ??LL_DMA_DeInit_1: (+1)
   \       0x48   0x6823             LDR      R3,[R4, #+0]
   \       0x4A   0x085B             LSRS     R3,R3,#+1
   \       0x4C   0x005B             LSLS     R3,R3,#+1
   \       0x4E   0x6023             STR      R3,[R4, #+0]
    162          
    163              /* Reset DMAx_Channely control register */
    164              LL_DMA_WriteReg(tmp, CCR, 0U);
   \       0x50   0x6022             STR      R2,[R4, #+0]
    165          
    166              /* Reset DMAx_Channely remaining bytes register */
    167              LL_DMA_WriteReg(tmp, CNDTR, 0U);
   \       0x52   0x6062             STR      R2,[R4, #+4]
    168          
    169              /* Reset DMAx_Channely peripheral address register */
    170              LL_DMA_WriteReg(tmp, CPAR, 0U);
   \       0x54   0x60A2             STR      R2,[R4, #+8]
    171          
    172              /* Reset DMAx_Channely memory address register */
    173              LL_DMA_WriteReg(tmp, CMAR, 0U);
    174          
    175          
    176              if (Channel == LL_DMA_CHANNEL_1)
   \       0x56   0x2901             CMP      R1,#+1
   \       0x58   0x60E2             STR      R2,[R4, #+12]
   \       0x5A   0xD01B             BEQ.N    ??LL_DMA_DeInit_2
    177              {
    178                /* Reset interrupt pending bits for DMAx Channel1 */
    179                LL_DMA_ClearFlag_GI1(DMAx);
    180              }
    181              else if (Channel == LL_DMA_CHANNEL_2)
   \       0x5C   0x2902             CMP      R1,#+2
   \       0x5E   0xBF08             IT       EQ
   \       0x60   0x2110             MOVEQ    R1,#+16
    182              {
    183                /* Reset interrupt pending bits for DMAx Channel2 */
    184                LL_DMA_ClearFlag_GI2(DMAx);
   \       0x62   0xD017             BEQ.N    ??LL_DMA_DeInit_2
    185              }
    186              else if (Channel == LL_DMA_CHANNEL_3)
   \       0x64   0x2903             CMP      R1,#+3
   \       0x66   0xBF08             IT       EQ
   \       0x68   0xF44F 0x7180      MOVEQ    R1,#+256
    187              {
    188                /* Reset interrupt pending bits for DMAx Channel3 */
    189                LL_DMA_ClearFlag_GI3(DMAx);
   \       0x6C   0xD012             BEQ.N    ??LL_DMA_DeInit_2
    190              }
    191              else if (Channel == LL_DMA_CHANNEL_4)
   \       0x6E   0x2904             CMP      R1,#+4
   \       0x70   0xBF08             IT       EQ
   \       0x72   0xF44F 0x5180      MOVEQ    R1,#+4096
    192              {
    193                /* Reset interrupt pending bits for DMAx Channel4 */
    194                LL_DMA_ClearFlag_GI4(DMAx);
   \       0x76   0xD00D             BEQ.N    ??LL_DMA_DeInit_2
    195              }
    196              else if (Channel == LL_DMA_CHANNEL_5)
   \       0x78   0x2905             CMP      R1,#+5
   \       0x7A   0xBF08             IT       EQ
   \       0x7C   0xF44F 0x3180      MOVEQ    R1,#+65536
    197              {
    198                /* Reset interrupt pending bits for DMAx Channel5 */
    199                LL_DMA_ClearFlag_GI5(DMAx);
   \       0x80   0xD008             BEQ.N    ??LL_DMA_DeInit_2
    200              }
    201          
    202              else if (Channel == LL_DMA_CHANNEL_6)
   \       0x82   0x2906             CMP      R1,#+6
   \       0x84   0xBF08             IT       EQ
   \       0x86   0xF44F 0x1180      MOVEQ    R1,#+1048576
    203              {
    204                /* Reset interrupt pending bits for DMAx Channel6 */
    205                LL_DMA_ClearFlag_GI6(DMAx);
   \       0x8A   0xD003             BEQ.N    ??LL_DMA_DeInit_2
    206              }
    207              else if (Channel == LL_DMA_CHANNEL_7)
   \       0x8C   0x2907             CMP      R1,#+7
   \       0x8E   0xD103             BNE.N    ??LL_DMA_DeInit_3
    208              {
    209                /* Reset interrupt pending bits for DMAx Channel7 */
    210                LL_DMA_ClearFlag_GI7(DMAx);
   \       0x90   0xF04F 0x7180      MOV      R1,#+16777216
   \                     ??LL_DMA_DeInit_2: (+1)
   \       0x94   0x6041             STR      R1,[R0, #+4]
    211              }
   \       0x96   0xE000             B.N      ??LL_DMA_DeInit_4
    212              else
    213              {
    214                status = ERROR;
   \                     ??LL_DMA_DeInit_3: (+1)
   \       0x98   0x2201             MOVS     R2,#+1
    215              }
    216          
    217            return status;
   \                     ??LL_DMA_DeInit_4: (+1)
   \       0x9A   0x4610             MOV      R0,R2
   \       0x9C   0xBD30             POP      {R4,R5,PC}       ;; return
    218          }
    219          
    220          /**
    221            * @brief  Initialize the DMA registers according to the specified parameters in DMA_InitStruct.
    222            * @note   To convert DMAx_Channely Instance to DMAx Instance and Channely, use helper macros :
    223            *         @arg @ref __LL_DMA_GET_INSTANCE
    224            *         @arg @ref __LL_DMA_GET_CHANNEL
    225            * @param  DMAx DMAx Instance
    226            * @param  Channel This parameter can be one of the following values:
    227            *         @arg @ref LL_DMA_CHANNEL_1
    228            *         @arg @ref LL_DMA_CHANNEL_2
    229            *         @arg @ref LL_DMA_CHANNEL_3
    230            *         @arg @ref LL_DMA_CHANNEL_4
    231            *         @arg @ref LL_DMA_CHANNEL_5
    232            *         @arg @ref LL_DMA_CHANNEL_6
    233            *         @arg @ref LL_DMA_CHANNEL_7
    234            * @param  DMA_InitStruct pointer to a @ref LL_DMA_InitTypeDef structure.
    235            * @retval An ErrorStatus enumeration value:
    236            *          - SUCCESS: DMA registers are initialized
    237            *          - ERROR: Not applicable
    238            */

   \                                 In section .text, align 4, keep-with-next
    239          uint32_t LL_DMA_Init(DMA_TypeDef *DMAx, uint32_t Channel, LL_DMA_InitTypeDef *DMA_InitStruct)
    240          {
   \                     LL_DMA_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    241            /* Check the DMA Instance DMAx and Channel parameters*/
    242            assert_param(IS_LL_DMA_ALL_CHANNEL_INSTANCE(DMAx, Channel));
    243          
    244            /* Check the DMA parameters from DMA_InitStruct */
    245            assert_param(IS_LL_DMA_DIRECTION(DMA_InitStruct->Direction));
    246            assert_param(IS_LL_DMA_MODE(DMA_InitStruct->Mode));
    247            assert_param(IS_LL_DMA_PERIPHINCMODE(DMA_InitStruct->PeriphOrM2MSrcIncMode));
    248            assert_param(IS_LL_DMA_MEMORYINCMODE(DMA_InitStruct->MemoryOrM2MDstIncMode));
    249            assert_param(IS_LL_DMA_PERIPHDATASIZE(DMA_InitStruct->PeriphOrM2MSrcDataSize));
    250            assert_param(IS_LL_DMA_MEMORYDATASIZE(DMA_InitStruct->MemoryOrM2MDstDataSize));
    251            assert_param(IS_LL_DMA_NBDATA(DMA_InitStruct->NbData));
    252            assert_param(IS_LL_DMA_PRIORITY(DMA_InitStruct->Priority));
    253          
    254            /*---------------------------- DMAx CCR Configuration ------------------------
    255             * Configure DMAx_Channely: data transfer direction, data transfer mode,
    256             *                          peripheral and memory increment mode,
    257             *                          data size alignment and  priority level with parameters :
    258             * - Direction:      DMA_CCR_DIR and DMA_CCR_MEM2MEM bits
    259             * - Mode:           DMA_CCR_CIRC bit
    260             * - PeriphOrM2MSrcIncMode:  DMA_CCR_PINC bit
    261             * - MemoryOrM2MDstIncMode:  DMA_CCR_MINC bit
    262             * - PeriphOrM2MSrcDataSize: DMA_CCR_PSIZE[1:0] bits
    263             * - MemoryOrM2MDstDataSize: DMA_CCR_MSIZE[1:0] bits
    264             * - Priority:               DMA_CCR_PL[1:0] bits
    265             */
    266            LL_DMA_ConfigTransfer(DMAx, Channel, DMA_InitStruct->Direction              | \
    267                                  DMA_InitStruct->Mode                   | \
    268                                  DMA_InitStruct->PeriphOrM2MSrcIncMode  | \
    269                                  DMA_InitStruct->MemoryOrM2MDstIncMode  | \
    270                                  DMA_InitStruct->PeriphOrM2MSrcDataSize | \
    271                                  DMA_InitStruct->MemoryOrM2MDstDataSize | \
    272                                  DMA_InitStruct->Priority);
   \        0x2   0xBF00             Nop
   \        0x4   0x....             ADR.N    R3,CHANNEL_OFFSET_TAB
   \        0x6   0x4419             ADD      R1,R3,R1
   \        0x8   0xF811 0x4C01      LDRB     R4,[R1, #-1]
   \        0xC   0x1903             ADDS     R3,R0,R4
   \        0xE   0x681D             LDR      R5,[R3, #+0]
   \       0x10   0x6890             LDR      R0,[R2, #+8]
   \       0x12   0x68D1             LDR      R1,[R2, #+12]
   \       0x14   0xF36F 0x150E      BFC      R5,#+4,#+11
   \       0x18   0x4305             ORRS     R5,R0,R5
   \       0x1A   0x6910             LDR      R0,[R2, #+16]
   \       0x1C   0x430D             ORRS     R5,R1,R5
   \       0x1E   0x6951             LDR      R1,[R2, #+20]
   \       0x20   0x4305             ORRS     R5,R0,R5
   \       0x22   0x6990             LDR      R0,[R2, #+24]
   \       0x24   0x430D             ORRS     R5,R1,R5
   \       0x26   0x69D1             LDR      R1,[R2, #+28]
   \       0x28   0x4305             ORRS     R5,R0,R5
   \       0x2A   0x6A50             LDR      R0,[R2, #+36]
   \       0x2C   0x430D             ORRS     R5,R1,R5
   \       0x2E   0x4305             ORRS     R5,R0,R5
   \       0x30   0x601D             STR      R5,[R3, #+0]
    273          
    274            /*-------------------------- DMAx CMAR Configuration -------------------------
    275             * Configure the memory or destination base address with parameter :
    276             * - MemoryOrM2MDstAddress: DMA_CMAR_MA[31:0] bits
    277             */
    278            LL_DMA_SetMemoryAddress(DMAx, Channel, DMA_InitStruct->MemoryOrM2MDstAddress);
   \       0x32   0x6850             LDR      R0,[R2, #+4]
   \       0x34   0x60D8             STR      R0,[R3, #+12]
    279          
    280            /*-------------------------- DMAx CPAR Configuration -------------------------
    281             * Configure the peripheral or source base address with parameter :
    282             * - PeriphOrM2MSrcAddress: DMA_CPAR_PA[31:0] bits
    283             */
    284            LL_DMA_SetPeriphAddress(DMAx, Channel, DMA_InitStruct->PeriphOrM2MSrcAddress);
   \       0x36   0x6810             LDR      R0,[R2, #+0]
   \       0x38   0x6098             STR      R0,[R3, #+8]
    285          
    286            /*--------------------------- DMAx CNDTR Configuration -----------------------
    287             * Configure the peripheral base address with parameter :
    288             * - NbData: DMA_CNDTR_NDT[15:0] bits
    289             */
    290            LL_DMA_SetDataLength(DMAx, Channel, DMA_InitStruct->NbData);
   \       0x3A   0x6859             LDR      R1,[R3, #+4]
   \       0x3C   0x6A10             LDR      R0,[R2, #+32]
   \       0x3E   0x0C09             LSRS     R1,R1,#+16
   \       0x40   0xEA40 0x4101      ORR      R1,R0,R1, LSL #+16
   \       0x44   0x6059             STR      R1,[R3, #+4]
    291          
    292          
    293            return SUCCESS;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xBD30             POP      {R4,R5,PC}       ;; return
    294          }
    295          
    296          /**
    297            * @brief  Set each @ref LL_DMA_InitTypeDef field to default value.
    298            * @param  DMA_InitStruct Pointer to a @ref LL_DMA_InitTypeDef structure.
    299            * @retval None
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          void LL_DMA_StructInit(LL_DMA_InitTypeDef *DMA_InitStruct)
    302          {
    303            /* Set DMA_InitStruct fields to default values */
    304            DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;
   \                     LL_DMA_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    305            DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    306            DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    307            DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    308            DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
   \        0xA   0x6101             STR      R1,[R0, #+16]
    309            DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;
   \        0xC   0x6141             STR      R1,[R0, #+20]
    310            DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;
   \        0xE   0x6181             STR      R1,[R0, #+24]
    311            DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;
   \       0x10   0x61C1             STR      R1,[R0, #+28]
    312            DMA_InitStruct->NbData                 = 0x00000000U;
   \       0x12   0x6201             STR      R1,[R0, #+32]
    313            DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;
   \       0x14   0x6241             STR      R1,[R0, #+36]
    314          }
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x4002'0008        DC32     0x40020008
    315          
    316          /**
    317            * @}
    318            */
    319          
    320          /**
    321            * @}
    322            */
    323          
    324          /**
    325            * @}
    326            */
    327          
    328          #endif /* DMA1 || DMA2 */
    329          
    330          /**
    331            * @}
    332            */
    333          
    334          #endif /* USE_FULL_LL_DRIVER */
    335          
    336          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   LL_DMA_DeInit
      12   LL_DMA_Init
       0   LL_DMA_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       8  CHANNEL_OFFSET_TAB
     158  LL_DMA_DeInit
      74  LL_DMA_Init
      24  LL_DMA_StructInit

 
 272 bytes in section .text
 
 272 bytes of CODE memory

Errors: none
Warnings: none
