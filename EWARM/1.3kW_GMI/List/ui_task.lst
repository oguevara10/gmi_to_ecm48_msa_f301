###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:16
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\ui_task.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW62D0.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\ui_task.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\ui_task.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\ui_task.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\ui_task.c
      1          /**
      2            ******************************************************************************
      3            * @file    ui_task.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file implementes user interface tasks definition
      6            *
      7            ******************************************************************************
      8            * @attention
      9            *
     10            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     11            * All rights reserved.</center></h2>
     12            *
     13            * This software component is licensed by ST under Ultimate Liberty license
     14            * SLA0044, the "License"; You may not use this file except in compliance with
     15            * the License. You may obtain a copy of the License at:
     16            *                             www.st.com/SLA0044
     17            *
     18            ******************************************************************************
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          /* Pre-compiler coherency check */
     23          
     24          #include "ui_task.h"
     25          #include "mc_config.h"
     26          #include "parameters_conversion.h"
     27          
     28          #define OPT_DACX  0x20 /*!<Bit field indicating that the UI uses SPI AD7303 DAC.*/
     29          

   \                                 In section .bss, align 4
     30          DAC_UI_Handle_t * pDAC = MC_NULL;
   \                     pDAC:
   \        0x0                      DS8 4
     31          extern DAC_UI_Handle_t DAC_UI_Params;
     32          
     33          MCP_Handle_t * pMCP = MC_NULL;
   \                     pMCP:
   \        0x4                      DS8 4

   \                                 In section .bss, align 4
     34          MCP_Handle_t MCP_UI_Params; 
   \                     MCP_UI_Params:
   \        0x0                      DS8 204
     35          

   \                                 In section .data, align 2
     36          static volatile uint16_t  bUITaskCounter;
   \                     bUITaskCounter:
   \        0x0                      DS8 2
   \        0x2                      DS8 2
   \        0x4   0x0027             DC16 39
     37          static volatile uint16_t  bCOMTimeoutCounter;
     38          static volatile uint16_t  bCOMATRTimeCounter = SERIALCOM_ATR_TIME_TICKS;
     39          

   \                                 In section .text, align 4, keep-with-next
     40          void UI_TaskInit( uint32_t* pUICfg, uint8_t bMCNum, MCI_Handle_t* pMCIList[],
     41                            MCT_Handle_t* pMCTList[],const char* s_fwVer )
     42          {
   \                     UI_TaskInit: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
     43                pDAC = &DAC_UI_Params;      
   \        0x4   0x4E20             LDR.N    R6,??UI_TaskInit_0
   \        0x6   0x4F21             LDR.N    R7,??UI_TaskInit_0+0x4
     44                pDAC->_Super = UI_Params;
   \        0x8   0xF8DF 0xA084      LDR.W    R10,??UI_TaskInit_0+0x8
   \        0xC   0x4604             MOV      R4,R0
   \        0xE   0x460D             MOV      R5,R1
   \       0x10   0x4690             MOV      R8,R2
   \       0x12   0x4699             MOV      R9,R3
   \       0x14   0x6037             STR      R7,[R6, #+0]
   \       0x16   0x4638             MOV      R0,R7
   \       0x18   0x4651             MOV      R1,R10
   \       0x1A   0x2230             MOVS     R2,#+48
   \       0x1C   0x....'....        BL       __aeabi_memcpy4
     45          
     46                UI_Init( &pDAC->_Super, bMCNum, pMCIList, pMCTList, pUICfg ); /* Init UI and link MC obj */
   \       0x20   0x9400             STR      R4,[SP, #+0]
   \       0x22   0x464B             MOV      R3,R9
   \       0x24   0x4642             MOV      R2,R8
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0x....'....        BL       UI_Init
     47                UI_DACInit( &pDAC->_Super ); /* Init DAC */
   \       0x2E   0x6830             LDR      R0,[R6, #+0]
   \       0x30   0x4F18             LDR.N    R7,??UI_TaskInit_0+0xC
   \       0x32   0x....'....        BL       UI_DACInit
     48                UI_SetDAC( &pDAC->_Super, DAC_CH0, MC_PROTOCOL_REG_MEAS_EL_ANGLE );
   \       0x36   0x6830             LDR      R0,[R6, #+0]
   \       0x38   0x222F             MOVS     R2,#+47
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x....'....        BL       UI_SetDAC
     49                UI_SetDAC( &pDAC->_Super, DAC_CH1, MC_PROTOCOL_REG_I_B );
   \       0x40   0x6830             LDR      R0,[R6, #+0]
   \       0x42   0x2224             MOVS     R2,#+36
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x....'....        BL       UI_SetDAC
     50          
     51              pMCP = &MCP_UI_Params;
   \       0x4A   0x4813             LDR.N    R0,??UI_TaskInit_0+0x10
   \       0x4C   0x6070             STR      R0,[R6, #+4]
     52              pMCP->_Super = UI_Params;
   \       0x4E   0x4651             MOV      R1,R10
   \       0x50   0x2230             MOVS     R2,#+48
   \       0x52   0x....'....        BL       __aeabi_memcpy4
     53          
     54              UFCP_Init( & pUSART );
   \       0x56   0x4638             MOV      R0,R7
   \       0x58   0x....'....        BL       UFCP_Init
     55              MCP_Init(pMCP, (FCP_Handle_t *) & pUSART, & UFCP_Send, & UFCP_Receive, & UFCP_AbortReceive, pDAC, s_fwVer);
   \       0x5C   0x980C             LDR      R0,[SP, #+48]
   \       0x5E   0x4A0F             LDR.N    R2,??UI_TaskInit_0+0x14
   \       0x60   0x4B0F             LDR.N    R3,??UI_TaskInit_0+0x18
   \       0x62   0x9002             STR      R0,[SP, #+8]
   \       0x64   0x6831             LDR      R1,[R6, #+0]
   \       0x66   0x9101             STR      R1,[SP, #+4]
   \       0x68   0x9200             STR      R2,[SP, #+0]
   \       0x6A   0x4639             MOV      R1,R7
   \       0x6C   0x6870             LDR      R0,[R6, #+4]
   \       0x6E   0x4A0D             LDR.N    R2,??UI_TaskInit_0+0x1C
   \       0x70   0x....'....        BL       MCP_Init
     56              UI_Init( &pMCP->_Super, bMCNum, pMCIList, pMCTList, pUICfg ); /* Initialize UI and link MC components */
   \       0x74   0x9400             STR      R4,[SP, #+0]
   \       0x76   0x464B             MOV      R3,R9
   \       0x78   0x6870             LDR      R0,[R6, #+4]
   \       0x7A   0x4642             MOV      R2,R8
   \       0x7C   0x4629             MOV      R1,R5
   \       0x7E   0x....'....        BL       UI_Init
     57          
     58          }
   \       0x82   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \       0x86   0xBF00             Nop
   \                     ??UI_TaskInit_0:
   \       0x88   0x....'....        DC32     pDAC
   \       0x8C   0x....'....        DC32     DAC_UI_Params
   \       0x90   0x....'....        DC32     UI_Params
   \       0x94   0x....'....        DC32     pUSART
   \       0x98   0x....'....        DC32     MCP_UI_Params
   \       0x9C   0x....'....        DC32     UFCP_AbortReceive
   \       0xA0   0x....'....        DC32     UFCP_Receive
   \       0xA4   0x....'....        DC32     UFCP_Send
     59          

   \                                 In section .text, align 4
     60          __weak void UI_Scheduler(void)
     61          {
     62            if(bUITaskCounter > 0u)
   \                     UI_Scheduler: (+1)
   \        0x0   0x4909             LDR.N    R1,??UI_Scheduler_0
   \        0x2   0x8808             LDRH     R0,[R1, #+0]
   \        0x4   0xB110             CBZ.N    R0,??UI_Scheduler_1
     63            {
     64              bUITaskCounter--;
   \        0x6   0x880A             LDRH     R2,[R1, #+0]
   \        0x8   0x1E50             SUBS     R0,R2,#+1
   \        0xA   0x8008             STRH     R0,[R1, #+0]
     65            }
     66          
     67            if(bCOMTimeoutCounter > 1u)
   \                     ??UI_Scheduler_1: (+1)
   \        0xC   0x884A             LDRH     R2,[R1, #+2]
   \        0xE   0x2A02             CMP      R2,#+2
   \       0x10   0xD302             BCC.N    ??UI_Scheduler_2
     68            {
     69              bCOMTimeoutCounter--;
   \       0x12   0x8848             LDRH     R0,[R1, #+2]
   \       0x14   0x1E42             SUBS     R2,R0,#+1
   \       0x16   0x804A             STRH     R2,[R1, #+2]
     70            }
     71          
     72            if(bCOMATRTimeCounter > 1u)
   \                     ??UI_Scheduler_2: (+1)
   \       0x18   0x8888             LDRH     R0,[R1, #+4]
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD302             BCC.N    ??UI_Scheduler_3
     73            {
     74              bCOMATRTimeCounter--;
   \       0x1E   0x8888             LDRH     R0,[R1, #+4]
   \       0x20   0x1E42             SUBS     R2,R0,#+1
   \       0x22   0x808A             STRH     R2,[R1, #+4]
     75            }
     76          }
   \                     ??UI_Scheduler_3: (+1)
   \       0x24   0x4770             BX       LR               ;; return
   \       0x26   0xBF00             Nop
   \                     ??UI_Scheduler_0:
   \       0x28   0x....'....        DC32     bUITaskCounter
     77          

   \                                 In section .text, align 4
     78          __weak void UI_DACUpdate(uint8_t bMotorNbr)
     79          {
   \                     UI_DACUpdate: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     80            if (UI_GetSelectedMC(&pDAC->_Super) == bMotorNbr)
   \        0x2   0x4D06             LDR.N    R5,??UI_DACUpdate_0
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x....'....        BL       UI_GetSelectedMC
   \        0xC   0x42A0             CMP      R0,R4
   \        0xE   0xD104             BNE.N    ??UI_DACUpdate_1
     81            {  
     82              UI_DACExec(&pDAC->_Super); /* Exec DAC update */
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x16   0x....'....        B.W      UI_DACExec
     83            }
     84          }
   \                     ??UI_DACUpdate_1: (+1)
   \       0x1A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??UI_DACUpdate_0:
   \       0x1C   0x....'....        DC32     pDAC
     85          

   \                                 In section .text, align 4
     86          __weak void MC_SetDAC(DAC_Channel_t bChannel, MC_Protocol_REG_t bVariable)
     87          {
   \                     MC_SetDAC: (+1)
   \        0x0   0x460A             MOV      R2,R1
     88            UI_SetDAC(&pDAC->_Super, bChannel, bVariable);
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0x4801             LDR.N    R0,??MC_SetDAC_0
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x....'....        B.W      UI_SetDAC
   \                     ??MC_SetDAC_0:
   \        0xC   0x....'....        DC32     pDAC
     89          }
     90          

   \                                 In section .text, align 4
     91          __weak void MC_SetUserDAC(DAC_UserChannel_t bUserChNumber, int16_t hValue)
     92          {
   \                     MC_SetUserDAC: (+1)
   \        0x0   0x460A             MOV      R2,R1
     93            UI_SetUserDAC(&pDAC->_Super, bUserChNumber, hValue);
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0x4801             LDR.N    R0,??MC_SetUserDAC_0
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x....'....        B.W      UI_SetUserDAC
   \                     ??MC_SetUserDAC_0:
   \        0xC   0x....'....        DC32     pDAC
     94          }
     95          

   \                                 In section .text, align 4
     96          __weak UI_Handle_t * GetDAC(void)
     97          {
     98            return &pDAC->_Super;
   \                     GetDAC: (+1)
   \        0x0   0x4801             LDR.N    R0,??GetDAC_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??GetDAC_0:
   \        0x8   0x....'....        DC32     pDAC
     99          }
    100          

   \                                 In section .text, align 4
    101          __weak MCP_Handle_t * GetMCP(void)
    102          {
    103            return pMCP;
   \                     GetMCP: (+1)
   \        0x0   0x4801             LDR.N    R0,??GetMCP_0
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??GetMCP_0:
   \        0x8   0x....'....        DC32     pDAC
    104          }
    105          

   \                                 In section .text, align 4
    106          __weak bool UI_IdleTimeHasElapsed(void)
    107          {
    108            bool retVal = false;
    109            if (bUITaskCounter == 0u)
   \                     UI_IdleTimeHasElapsed: (+1)
   \        0x0   0x4A02             LDR.N    R2,??UI_IdleTimeHasElapsed_0
   \        0x2   0x8811             LDRH     R1,[R2, #+0]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xB901             CBNZ.N   R1,??UI_IdleTimeHasElapsed_1
    110            {
    111              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    112            }
    113            return (retVal);
   \                     ??UI_IdleTimeHasElapsed_1: (+1)
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??UI_IdleTimeHasElapsed_0:
   \        0xC   0x....'....        DC32     bUITaskCounter
    114          }
    115          

   \                                 In section .text, align 4
    116          __weak void UI_SetIdleTime(uint16_t SysTickCount)
    117          {
    118            bUITaskCounter = SysTickCount;
   \                     UI_SetIdleTime: (+1)
   \        0x0   0x4901             LDR.N    R1,??UI_SetIdleTime_0
   \        0x2   0x8008             STRH     R0,[R1, #+0]
    119          }
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??UI_SetIdleTime_0:
   \        0x8   0x....'....        DC32     bUITaskCounter
    120          

   \                                 In section .text, align 4
    121          __weak bool UI_SerialCommunicationTimeOutHasElapsed(void)
    122          {
    123            bool retVal = false;
    124            if (bCOMTimeoutCounter == 1u)
   \                     UI_SerialCommunicationTimeOutHasElapsed: (+1)
   \        0x0   0x4903             LDR.N    R1,??UI_SerialCommunicationTimeOutHasElapsed_0
   \        0x2   0x884A             LDRH     R2,[R1, #+2]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xBF04             ITT      EQ
   \        0xA   0x8048             STRHEQ   R0,[R1, #+2]
   \        0xC   0x2001             MOVEQ    R0,#+1
    125            {
    126              bCOMTimeoutCounter = 0u;
    127              retVal = true;
    128            }
    129            return (retVal);
   \        0xE   0x4770             BX       LR               ;; return
   \                     ??UI_SerialCommunicationTimeOutHasElapsed_0:
   \       0x10   0x....'....        DC32     bUITaskCounter
    130          }
    131          

   \                                 In section .text, align 4
    132          __weak bool UI_SerialCommunicationATRTimeHasElapsed(void)
    133          {
    134            bool retVal = false;
    135            if (bCOMATRTimeCounter == 1u)
   \                     UI_SerialCommunicationATRTimeHasElapsed: (+1)
   \        0x0   0x4903             LDR.N    R1,??UI_SerialCommunicationATRTimeHasElapsed_0
   \        0x2   0x888A             LDRH     R2,[R1, #+4]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xBF04             ITT      EQ
   \        0xA   0x8088             STRHEQ   R0,[R1, #+4]
   \        0xC   0x2001             MOVEQ    R0,#+1
    136            {
    137              bCOMATRTimeCounter = 0u;
    138              retVal = true;
    139            }
    140            return (retVal);
   \        0xE   0x4770             BX       LR               ;; return
   \                     ??UI_SerialCommunicationATRTimeHasElapsed_0:
   \       0x10   0x....'....        DC32     bUITaskCounter
    141          }
    142          

   \                                 In section .text, align 4
    143          __weak void UI_SerialCommunicationTimeOutStop(void)
    144          {
    145            bCOMTimeoutCounter = 0u;
   \                     UI_SerialCommunicationTimeOutStop: (+1)
   \        0x0   0x4901             LDR.N    R1,??UI_SerialCommunicationTimeOutStop_0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x8048             STRH     R0,[R1, #+2]
    146          }
   \        0x6   0x4770             BX       LR               ;; return
   \                     ??UI_SerialCommunicationTimeOutStop_0:
   \        0x8   0x....'....        DC32     bUITaskCounter
    147          

   \                                 In section .text, align 4
    148          __weak void UI_SerialCommunicationTimeOutStart(void)
    149          {
    150            bCOMTimeoutCounter = SERIALCOM_TIMEOUT_OCCURENCE_TICKS;
   \                     UI_SerialCommunicationTimeOutStart: (+1)
   \        0x0   0x4901             LDR.N    R1,??UI_SerialCommunicationTimeOutStart_0
   \        0x2   0x204F             MOVS     R0,#+79
   \        0x4   0x8048             STRH     R0,[R1, #+2]
    151          }
   \        0x6   0x4770             BX       LR               ;; return
   \                     ??UI_SerialCommunicationTimeOutStart_0:
   \        0x8   0x....'....        DC32     bUITaskCounter
    152          
    153          
    154          #if ENABLE_DEBUG_OUTPUT_VIA_STMC_PORT >= 1
    155          void Regal_SendDebugMessage(uint8_t *buffer, uint8_t size) {
    156            MCP_Handle_t *pHandle = GetMCP();
    157            pHandle->fFcpSend(pHandle->pFCP, REGAL_DEBUG_MESSAGE_ID, buffer, size);
    158          }
    159          #endif
    160          
    161          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GetDAC
       0   GetMCP
       0   MC_SetDAC
         0   -> UI_SetDAC
       0   MC_SetUserDAC
         0   -> UI_SetUserDAC
      16   UI_DACUpdate
         0   -> UI_DACExec
        16   -> UI_GetSelectedMC
       0   UI_IdleTimeHasElapsed
       0   UI_Scheduler
       0   UI_SerialCommunicationATRTimeHasElapsed
       0   UI_SerialCommunicationTimeOutHasElapsed
       0   UI_SerialCommunicationTimeOutStart
       0   UI_SerialCommunicationTimeOutStop
       0   UI_SetIdleTime
      48   UI_TaskInit
        48   -> MCP_Init
        48   -> UFCP_Init
        48   -> UI_DACInit
        48   -> UI_Init
        48   -> UI_SetDAC
        48   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  GetDAC
      12  GetMCP
     204  MCP_UI_Params
      16  MC_SetDAC
      16  MC_SetUserDAC
      32  UI_DACUpdate
      16  UI_IdleTimeHasElapsed
      44  UI_Scheduler
      20  UI_SerialCommunicationATRTimeHasElapsed
      20  UI_SerialCommunicationTimeOutHasElapsed
      12  UI_SerialCommunicationTimeOutStart
      12  UI_SerialCommunicationTimeOutStop
      12  UI_SetIdleTime
     168  UI_TaskInit
       6  bUITaskCounter
          bCOMTimeoutCounter
          bCOMATRTimeCounter
       8  pDAC
          pMCP

 
 212 bytes in section .bss
   6 bytes in section .data
 392 bytes in section .text
 
 168 bytes of CODE memory (+ 224 bytes shared)
 218 bytes of DATA memory

Errors: none
Warnings: none
