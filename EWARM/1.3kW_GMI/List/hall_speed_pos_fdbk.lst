###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:28
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\hall_speed_pos_fdbk.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW356B.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\hall_speed_pos_fdbk.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\hall_speed_pos_fdbk.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\hall_speed_pos_fdbk.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\hall_speed_pos_fdbk.c
      1          /**
      2            ******************************************************************************
      3            * @file    hall_speed_pos_fdbk.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features of
      6            *          the Hall Speed & Position Feedback component of the Motor Control SDK.
      7            ******************************************************************************
      8            * @attention
      9            *
     10            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     11            * All rights reserved.</center></h2>
     12            *
     13            * This software component is licensed by ST under Ultimate Liberty license
     14            * SLA0044, the "License"; You may not use this file except in compliance with
     15            * the License. You may obtain a copy of the License at:
     16            *                             www.st.com/SLA0044
     17            *
     18            ******************************************************************************
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "speed_pos_fdbk.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp uint32_t LL_GPIO_IsInputPinSet(GPIO_TypeDef *, uint32_t)
   \                     LL_GPIO_IsInputPinSet: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0x4008             ANDS     R0,R1,R0
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD101             BNE.N    ??LL_GPIO_IsInputPinSet_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??LL_GPIO_IsInputPinSet_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
     23          #include "hall_speed_pos_fdbk.h"
     24          #include "mc_type.h"
     25          
     26          /** @addtogroup MCSDK
     27            * @{
     28            */
     29          
     30          /** @addtogroup SpeednPosFdbk
     31            * @{
     32            */
     33          
     34          /**
     35           * @defgroup hall_speed_pos_fdbk Hall Speed & Position Feedback
     36           *
     37           * @brief Hall Sensor based Speed & Position Feedback implementation
     38           *
     39            * This component is used in applications controlling a motor equipped with Hall effect sensors.
     40            *
     41            * This component uses the output of two Hall effects sensors to provide a measure of the speed
     42            * and the position of the rotor of the motor.
     43            *
     44           * @todo Document the Hall Speed & Position Feedback "module".
     45           *
     46           * @{
     47           */
     48          
     49          /* Private defines -----------------------------------------------------------*/
     50          
     51          /* Lower threshold to reques a decrease of clock prescaler */
     52          #define LOW_RES_THRESHOLD   ((uint16_t)0x5500u)
     53          
     54          #define HALL_COUNTER_RESET  ((uint16_t) 0u)
     55          
     56          #define S16_120_PHASE_SHIFT (int16_t)(65536/3)
     57          #define S16_60_PHASE_SHIFT  (int16_t)(65536/6)
     58          
     59          #define STATE_0 (uint8_t)0
     60          #define STATE_1 (uint8_t)1
     61          #define STATE_2 (uint8_t)2
     62          #define STATE_3 (uint8_t)3
     63          #define STATE_4 (uint8_t)4
     64          #define STATE_5 (uint8_t)5
     65          #define STATE_6 (uint8_t)6
     66          #define STATE_7 (uint8_t)7
     67          
     68          #define NEGATIVE          (int8_t)-1
     69          #define POSITIVE          (int8_t)1
     70          
     71          /* With digit-per-PWM unit (here 2*PI rad = 0xFFFF): */
     72          #define HALL_MAX_PSEUDO_SPEED        ((int16_t)0x7FFF)
     73          
     74          #define CCER_CC1E_Set               ((uint16_t)0x0001)
     75          #define CCER_CC1E_Reset             ((uint16_t)0xFFFE)
     76          
     77          static void HALL_Init_Electrical_Angle( HALL_Handle_t * pHandle );
     78          
     79          /**
     80            * @brief  It initializes the hardware peripherals (TIMx, GPIO and NVIC)
     81                      required for the speed position sensor management using HALL
     82                      sensors.
     83            * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component
     84            * @retval none
     85            */

   \                                 In section .text, align 2
     86          __weak void HALL_Init( HALL_Handle_t * pHandle )
     87          {
   \                     HALL_Init: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
     88            TIM_TypeDef * TIMx = pHandle->TIMx;
   \        0x2   0xF100 0x0528      ADD      R5,R0,#+40
     89          
     90            uint16_t hMinReliableElSpeedUnit = pHandle->_Super.hMinReliableMecSpeedUnit *
     91                                               pHandle->_Super.bElToMecRatio;
     92            uint16_t hMaxReliableElSpeedUnit = pHandle->_Super.hMaxReliableMecSpeedUnit *
     93                                               pHandle->_Super.bElToMecRatio;
     94            uint8_t bSpeedBufferSize;
     95            uint8_t bIndex;
     96          
     97            /* Adjustment factor: minimum measurable speed is x time less than the minimum
     98            reliable speed */
     99            hMinReliableElSpeedUnit /= 4u;
   \        0x6   0x7843             LDRB     R3,[R0, #+1]
   \        0x8   0x8AC1             LDRH     R1,[R0, #+22]
    100          
    101            /* Adjustment factor: maximum measurable speed is x time greater than the
    102            maximum reliable speed */
    103            hMaxReliableElSpeedUnit *= 2u;
   \        0xA   0x8A86             LDRH     R6,[R0, #+20]
    104          
    105            pHandle->OvfFreq = ( uint16_t )( pHandle->TIMClockFreq / 65536u );
   \        0xC   0x682A             LDR      R2,[R5, #+0]
   \        0xE   0x686C             LDR      R4,[R5, #+4]
   \       0x10   0x4359             MULS     R1,R1,R3
   \       0x12   0x0409             LSLS     R1,R1,#+16
   \       0x14   0xFB16 0xF603      SMULBB   R6,R6,R3
   \       0x18   0xF100 0x03B4      ADD      R3,R0,#+180
   \       0x1C   0x0C12             LSRS     R2,R2,#+16
   \       0x1E   0x0C89             LSRS     R1,R1,#+18
   \       0x20   0x0076             LSLS     R6,R6,#+1
   \       0x22   0x81DA             STRH     R2,[R3, #+14]
    106          
    107            /* SW Init */
    108            if ( hMinReliableElSpeedUnit == 0u )
   \       0x24   0xB909             CBNZ.N   R1,??HALL_Init_0
    109            {
    110              /* Set fixed to 150 ms */
    111              pHandle->HallTimeout = 150u;
   \       0x26   0x2196             MOVS     R1,#+150
   \       0x28   0xE005             B.N      ??HALL_Init_1
    112            }
    113            else
    114            {
    115              /* Set accordingly the min reliable speed */
    116              /* 1000 comes from mS 
    117              * 6 comes from the fact that sensors are toggling each 60 deg = 360/6 deg */
    118              pHandle->HallTimeout = 1000*SPEED_UNIT / ( 6u * hMinReliableElSpeedUnit );
   \                     ??HALL_Init_0: (+1)
   \       0x2A   0x2206             MOVS     R2,#+6
   \       0x2C   0xF242 0x7710      MOVW     R7,#+10000
   \       0x30   0x4351             MULS     R1,R2,R1
   \       0x32   0xFBB7 0xF1F1      UDIV     R1,R7,R1
   \                     ??HALL_Init_1: (+1)
   \       0x36   0x8199             STRH     R1,[R3, #+12]
    119            }
    120          
    121            /* Compute the prescaler to the closet value of the TimeOut (in mS )*/
    122            pHandle->HALLMaxRatio = ( pHandle->HallTimeout * pHandle->OvfFreq ) / 1000 ;
   \       0x38   0xF100 0x07AE      ADD      R7,R0,#+174
   \       0x3C   0x899A             LDRH     R2,[R3, #+12]
   \       0x3E   0x89D9             LDRH     R1,[R3, #+14]
   \       0x40   0x434A             MULS     R2,R1,R2
   \       0x42   0xF44F 0x7C7A      MOV      R12,#+1000
   \       0x46   0xFB92 0xFCFC      SDIV     R12,R2,R12
   \       0x4A   0xF8A7 0xC000      STRH     R12,[R7, #+0]
    123          
    124            /* Align MaxPeriod to a multiple of Overflow.*/
    125            pHandle->MaxPeriod = ( pHandle->HALLMaxRatio ) * 65536uL;
   \       0x4E   0x883A             LDRH     R2,[R7, #+0]
   \       0x50   0x0412             LSLS     R2,R2,#+16
   \       0x52   0x605A             STR      R2,[R3, #+4]
    126          
    127            pHandle->SatSpeed = hMaxReliableElSpeedUnit;
   \       0x54   0x807E             STRH     R6,[R7, #+2]
    128          
    129            pHandle->PseudoFreqConv = ( ( pHandle->TIMClockFreq / 6u )
    130                                        / ( pHandle->_Super.hMeasurementFrequency ) ) * ( pHandle->_Super.DPPConvFactor);
   \       0x56   0x2206             MOVS     R2,#+6
   \       0x58   0x6829             LDR      R1,[R5, #+0]
   \       0x5A   0xF8B0 0xC01A      LDRH     R12,[R0, #+26]
   \       0x5E   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \       0x62   0xFBB2 0xFCFC      UDIV     R12,R2,R12
   \       0x66   0x69C2             LDR      R2,[R0, #+28]
   \       0x68   0xFB02 0xF10C      MUL      R1,R2,R12
   \       0x6C   0x6019             STR      R1,[R3, #+0]
    131          
    132            pHandle->MinPeriod = ( ( SPEED_UNIT * ( pHandle->TIMClockFreq /6uL) ) 
    133                                 / hMaxReliableElSpeedUnit);
   \       0x6E   0xF04F 0x0C06      MOV      R12,#+6
   \       0x72   0x682D             LDR      R5,[R5, #+0]
   \       0x74   0xFBB5 0xFCFC      UDIV     R12,R5,R12
   \       0x78   0x210A             MOVS     R1,#+10
   \       0x7A   0xFB01 0xF20C      MUL      R2,R1,R12
   \       0x7E   0xB2B6             UXTH     R6,R6
   \       0x80   0xFBB2 0xF1F6      UDIV     R1,R2,R6
   \       0x84   0x6099             STR      R1,[R3, #+8]
    134          
    135            pHandle->PWMNbrPSamplingFreq = ( (pHandle->_Super.hMeasurementFrequency * pHandle->PWMFreqScaling) /
    136                                             pHandle->SpeedSamplingFreqHz ) - 1u;
   \       0x86   0x8B42             LDRH     R2,[R0, #+26]
   \       0x88   0x7C99             LDRB     R1,[R3, #+18]
   \       0x8A   0x8C85             LDRH     R5,[R0, #+36]
   \       0x8C   0x434A             MULS     R2,R1,R2
   \       0x8E   0xFB92 0xF2F5      SDIV     R2,R2,R5
   \       0x92   0x1E56             SUBS     R6,R2,#+1
    137          
    138            /* Reset speed reliability */
    139            pHandle->SensorIsReliable = true;
   \       0x94   0xF100 0x0148      ADD      R1,R0,#+72
   \       0x98   0x821E             STRH     R6,[R3, #+16]
   \       0x9A   0x2201             MOVS     R2,#+1
   \       0x9C   0x704A             STRB     R2,[R1, #+1]
    140          
    141            /* Set IC filter for Channel 1 (ICF1) */
    142            LL_TIM_IC_SetFilter(TIMx, LL_TIM_CHANNEL_CH1, ( uint32_t )(pHandle->ICx_Filter) << 20);
   \       0x9E   0xF104 0x0218      ADD      R2,R4,#+24
   \       0xA2   0x7809             LDRB     R1,[R1, #+0]
   \       0xA4   0x6815             LDR      R5,[R2, #+0]
   \       0xA6   0x0509             LSLS     R1,R1,#+20
   \       0xA8   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \       0xAC   0xEA45 0x4511      ORR      R5,R5,R1, LSR #+16
   \       0xB0   0x6015             STR      R5,[R2, #+0]
    143          
    144            /* Force the TIMx prescaler with immediate access (gen update event)
    145            */
    146            LL_TIM_SetPrescaler ( TIMx, pHandle->HALLMaxRatio );
   \       0xB2   0x8839             LDRH     R1,[R7, #+0]
   \       0xB4   0x62A1             STR      R1,[R4, #+40]
    147            LL_TIM_GenerateEvent_UPDATE ( TIMx );
    148          
    149          
    150            /* Clear the TIMx's pending flags */
    151            WRITE_REG (TIMx->SR, 0);
   \       0xB6   0x2100             MOVS     R1,#+0
   \       0xB8   0x6962             LDR      R2,[R4, #+20]
   \       0xBA   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0xBE   0x6162             STR      R2,[R4, #+20]
   \       0xC0   0x6121             STR      R1,[R4, #+16]
    152          
    153            /* Selected input capture and Update (overflow) events generate interrupt */
    154          
    155            /* Source of Update event is only counter overflow/underflow */
    156            LL_TIM_SetUpdateSource ( TIMx, LL_TIM_UPDATESOURCE_COUNTER );
   \       0xC2   0x6822             LDR      R2,[R4, #+0]
   \       0xC4   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0xC8   0x6022             STR      R2,[R4, #+0]
    157          
    158            LL_TIM_EnableIT_CC1 ( TIMx );
    159            LL_TIM_EnableIT_UPDATE ( TIMx );
    160            LL_TIM_SetCounter ( TIMx, HALL_COUNTER_RESET );
   \       0xCA   0x2200             MOVS     R2,#+0
   \       0xCC   0x68E1             LDR      R1,[R4, #+12]
   \       0xCE   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0xD2   0x60E1             STR      R1,[R4, #+12]
   \       0xD4   0x68E1             LDR      R1,[R4, #+12]
   \       0xD6   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0xDA   0x60E1             STR      R1,[R4, #+12]
   \       0xDC   0x6262             STR      R2,[R4, #+36]
    161          
    162            LL_TIM_CC_EnableChannel  ( TIMx, LL_TIM_CHANNEL_CH1 );
   \       0xDE   0x6A21             LDR      R1,[R4, #+32]
   \       0xE0   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0xE4   0x6221             STR      R1,[R4, #+32]
    163            LL_TIM_EnableCounter ( TIMx );
   \       0xE6   0x6822             LDR      R2,[R4, #+0]
   \       0xE8   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0xEC   0x6022             STR      R2,[R4, #+0]
    164          
    165          
    166            /* Erase speed buffer */
    167            bSpeedBufferSize = pHandle->SpeedBufferSize;
    168          
    169            for ( bIndex = 0u; bIndex < bSpeedBufferSize; bIndex++ )
   \       0xEE   0x2200             MOVS     R2,#+0
   \       0xF0   0xF890 0x1026      LDRB     R1,[R0, #+38]
   \       0xF4   0xE004             B.N      ??HALL_Init_2
    170            {
    171              pHandle->SensorPeriod[bIndex]  = pHandle->MaxPeriod;
   \                     ??HALL_Init_3: (+1)
   \       0xF6   0x685D             LDR      R5,[R3, #+4]
   \       0xF8   0xEB00 0x0484      ADD      R4,R0,R4, LSL #+2
    172            }
   \       0xFC   0x1C52             ADDS     R2,R2,#+1
   \       0xFE   0x6525             STR      R5,[R4, #+80]
   \                     ??HALL_Init_2: (+1)
   \      0x100   0xB2D4             UXTB     R4,R2
   \      0x102   0x428C             CMP      R4,R1
   \      0x104   0xDBF7             BLT.N    ??HALL_Init_3
    173          }
   \      0x106   0xBDF0             POP      {R4-R7,PC}       ;; return
    174          
    175          /**
    176          * @brief  Clear software FIFO where are "pushed" latest speed information
    177          *         This function must be called before starting the motor to initialize
    178          *         the speed measurement process.
    179          * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component*
    180          * @retval none
    181          */

   \                                 In section .text, align 2
    182          __weak void HALL_Clear( HALL_Handle_t * pHandle )
    183          {
   \                     HALL_Clear: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    184            TIM_TypeDef * TIMx = pHandle->TIMx;
   \        0x2   0x6AC1             LDR      R1,[R0, #+44]
    185          
    186            /* Mask interrupts to insure a clean intialization */
    187            LL_TIM_DisableIT_CC1 ( TIMx );
   \        0x4   0x68CA             LDR      R2,[R1, #+12]
   \        0x6   0xF022 0x0202      BIC      R2,R2,#0x2
   \        0xA   0x60CA             STR      R2,[R1, #+12]
    188          
    189            pHandle->RatioDec = false;
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0xF100 0x0249      ADD      R2,R0,#+73
    190            pHandle->RatioInc = false;
   \       0x12   0x2400             MOVS     R4,#+0
   \       0x14   0x7053             STRB     R3,[R2, #+1]
   \       0x16   0x7094             STRB     R4,[R2, #+2]
    191          
    192            /* Reset speed reliability */
    193            pHandle->SensorIsReliable = true;
   \       0x18   0x2301             MOVS     R3,#+1
   \       0x1A   0x7013             STRB     R3,[R2, #+0]
    194          
    195            /* Acceleration measurement not implemented.*/
    196            pHandle->_Super.hMecAccelUnitP = 0;
   \       0x1C   0x2500             MOVS     R5,#+0
   \       0x1E   0x8245             STRH     R5,[R0, #+18]
    197          
    198            pHandle->FirstCapt = 0u;
   \       0x20   0x70D4             STRB     R4,[R2, #+3]
    199            pHandle->BufferFilled = 0u;
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0x7113             STRB     R3,[R2, #+4]
    200            pHandle->OVFCounter = 0u;
   \       0x26   0x7154             STRB     R4,[R2, #+5]
    201          
    202            pHandle->CompSpeed = 0;
   \       0x28   0xF100 0x0298      ADD      R2,R0,#+152
    203          
    204            pHandle->Direction = POSITIVE;
   \       0x2C   0x2401             MOVS     R4,#+1
   \       0x2E   0x8293             STRH     R3,[R2, #+20]
   \       0x30   0x7294             STRB     R4,[R2, #+10]
    205          
    206            /* Initialize speed buffer index */
    207            pHandle->SpeedFIFOIdx = 0u;
   \       0x32   0x7013             STRB     R3,[R2, #+0]
    208          
    209          
    210            /* Clear speed error counter */
    211            pHandle->_Super.bSpeedErrorNumber = 0;
   \       0x34   0x7005             STRB     R5,[R0, #+0]
    212            
    213            /* Re-initialize partly the timer */
    214            LL_TIM_SetPrescaler ( TIMx, pHandle->HALLMaxRatio );
   \       0x36   0x8AD2             LDRH     R2,[R2, #+22]
   \       0x38   0x628A             STR      R2,[R1, #+40]
    215          
    216            LL_TIM_SetCounter ( TIMx, HALL_COUNTER_RESET );
   \       0x3A   0x624B             STR      R3,[R1, #+36]
    217          
    218            LL_TIM_EnableCounter ( TIMx );
   \       0x3C   0x680A             LDR      R2,[R1, #+0]
   \       0x3E   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x42   0x600A             STR      R2,[R1, #+0]
    219          
    220            LL_TIM_EnableIT_CC1 ( TIMx );
   \       0x44   0x68CB             LDR      R3,[R1, #+12]
   \       0x46   0xF043 0x0302      ORR      R3,R3,#0x2
   \       0x4A   0x60CB             STR      R3,[R1, #+12]
    221          
    222            HALL_Init_Electrical_Angle( pHandle );
   \       0x4C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x50   0x....'....        B.W      HALL_Init_Electrical_Angle
    223          }
    224          
    225          #if defined (CCMRAM)
    226          #if defined (__ICCARM__)
    227          #pragma location = ".ccmram"
    228          #elif defined (__CC_ARM) || defined(__GNUC__)
    229          __attribute__( ( section ( ".ccmram" ) ) )
    230          #endif
    231          #endif
    232          /**
    233          * @brief  Update the rotor electrical angle integrating the last measured
    234          *         instantaneous electrical speed express in dpp.
    235          * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component
    236          * @retval int16_t Measured electrical angle in s16degree format.
    237          */

   \                                 In section .text, align 2
    238          __weak int16_t HALL_CalcElAngle( HALL_Handle_t * pHandle )
    239          {
   \                     HALL_CalcElAngle: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x4601             MOV      R1,R0
    240          
    241            if ( pHandle->_Super.hElSpeedDpp != HALL_MAX_PSEUDO_SPEED )
   \        0x4   0xF647 0x73FF      MOVW     R3,#+32767
   \        0x8   0xF9B1 0x200E      LDRSH    R2,[R1, #+14]
   \        0xC   0xF9B1 0x0004      LDRSH    R0,[R1, #+4]
   \       0x10   0x429A             CMP      R2,R3
   \       0x12   0xF101 0x04A0      ADD      R4,R1,#+160
   \       0x16   0xD007             BEQ.N    ??HALL_CalcElAngle_0
    242            {
    243              pHandle->MeasuredElAngle += pHandle->_Super.hElSpeedDpp;
   \       0x18   0x8965             LDRH     R5,[R4, #+10]
    244              pHandle->_Super.hElAngle += pHandle->_Super.hElSpeedDpp + pHandle->CompSpeed;
   \       0x1A   0x89A3             LDRH     R3,[R4, #+12]
   \       0x1C   0x1955             ADDS     R5,R2,R5
   \       0x1E   0x1810             ADDS     R0,R2,R0
   \       0x20   0x8165             STRH     R5,[R4, #+10]
   \       0x22   0x1818             ADDS     R0,R3,R0
    245              pHandle->PrevRotorFreq = pHandle->_Super.hElSpeedDpp;
   \       0x24   0x8022             STRH     R2,[R4, #+0]
   \       0x26   0xE001             B.N      ??HALL_CalcElAngle_1
    246            }
    247            else
    248            {
    249              pHandle->_Super.hElAngle += pHandle->PrevRotorFreq;
   \                     ??HALL_CalcElAngle_0: (+1)
   \       0x28   0x8822             LDRH     R2,[R4, #+0]
   \       0x2A   0x1810             ADDS     R0,R2,R0
    250            }
    251          
    252            return pHandle->_Super.hElAngle;
   \                     ??HALL_CalcElAngle_1: (+1)
   \       0x2C   0x8088             STRH     R0,[R1, #+4]
   \       0x2E   0xB200             SXTH     R0,R0
   \       0x30   0xBD30             POP      {R4,R5,PC}       ;; return
    253          }
    254          
    255          
    256          /**
    257            * @brief  This method must be called - at least - with the same periodicity
    258            *         on which speed control is executed.
    259            *         This method compute and store rotor istantaneous el speed (express
    260            *         in dpp considering the measurement frequency) in order to provide it
    261            *         to HALL_CalcElAngle function and SPD_GetElAngle.
    262            *         Then compute rotor average el speed (express in dpp considering the
    263            *         measurement frequency) based on the buffer filled by IRQ, then - as
    264            *         a consequence - compute, store and return - through parameter
    265            *         hMecSpeedUnit - the rotor average mech speed, expressed in Unit.
    266            *         Then check, store and return the reliability state of
    267            *         the sensor; in this function the reliability is measured with
    268            *         reference to specific parameters of the derived
    269            *         sensor (HALL) through internal variables managed by IRQ.
    270            * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component
    271            * @param  hMecSpeedUnit pointer to int16_t, used to return the rotor average
    272            *         mechanical speed (expressed in the unit defined by #SPEED_UNIT)
    273            * @retval true = sensor information is reliable
    274            *         false = sensor information is not reliable
    275            */

   \                                 In section .text, align 2
    276          __weak bool HALL_CalcAvrgMecSpeedUnit( HALL_Handle_t * pHandle, int16_t * hMecSpeedUnit )
    277          {
   \                     HALL_CalcAvrgMecSpeedUnit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    278            TIM_TypeDef * TIMx = pHandle->TIMx;
    279            bool bReliability;
    280          
    281            if ( pHandle->SensorIsReliable )
   \        0x6   0xF894 0x0049      LDRB     R0,[R4, #+73]
   \        0xA   0xB3A0             CBZ.N    R0,??HALL_CalcAvrgMecSpeedUnit_0
    282            {
    283              /* No errors have been detected during rotor speed information
    284              extrapolation */
    285              if ( LL_TIM_GetPrescaler ( TIMx ) >= pHandle->HALLMaxRatio )
   \        0xC   0x6AE0             LDR      R0,[R4, #+44]
   \        0xE   0x6A80             LDR      R0,[R0, #+40]
   \       0x10   0xF104 0x01A4      ADD      R1,R4,#+164
   \       0x14   0x894A             LDRH     R2,[R1, #+10]
   \       0x16   0x4290             CMP      R0,R2
   \       0x18   0xD302             BCC.N    ??HALL_CalcAvrgMecSpeedUnit_1
    286              {
    287                /* At start-up or very low freq */
    288                /* Based on current prescaler value only */
    289                pHandle->_Super.hElSpeedDpp = 0;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x81E0             STRH     R0,[R4, #+14]
    290                *hMecSpeedUnit = 0;
   \       0x1E   0xE024             B.N      ??HALL_CalcAvrgMecSpeedUnit_2
    291              }
    292              else
    293              {
    294                pHandle->_Super.hElSpeedDpp =  pHandle->AvrElSpeedDpp;
   \                     ??HALL_CalcAvrgMecSpeedUnit_1: (+1)
   \       0x20   0xF9B1 0x0000      LDRSH    R0,[R1, #+0]
   \       0x24   0x81E0             STRH     R0,[R4, #+14]
    295                if (  pHandle->AvrElSpeedDpp == 0 )
   \       0x26   0xB300             CBZ.N    R0,??HALL_CalcAvrgMecSpeedUnit_2
    296                {
    297                  /* Speed is too low */
    298                  *hMecSpeedUnit = 0;
    299                }
    300                else
    301                {
    302                  /* Check if speed is not to fast */
    303                  if (  pHandle->AvrElSpeedDpp != HALL_MAX_PSEUDO_SPEED )
   \       0x28   0xF647 0x72FF      MOVW     R2,#+32767
   \       0x2C   0x4290             CMP      R0,R2
   \       0x2E   0xD01A             BEQ.N    ??HALL_CalcAvrgMecSpeedUnit_3
    304                  {
    305                    if (pHandle->HallMtpa == true)
   \       0x30   0xF894 0x00C7      LDRB     R0,[R4, #+199]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xBF08             IT       EQ
   \       0x38   0x2000             MOVEQ    R0,#+0
    306                    {
    307                      pHandle->CompSpeed = 0;
   \       0x3A   0xD007             BEQ.N    ??HALL_CalcAvrgMecSpeedUnit_4
    308                    }
    309                    else  
    310                    {
    311                      pHandle->DeltaAngle = pHandle->MeasuredElAngle - pHandle->_Super.hElAngle;
   \       0x3C   0x88CA             LDRH     R2,[R1, #+6]
   \       0x3E   0x88A0             LDRH     R0,[R4, #+4]
   \       0x40   0x1A10             SUBS     R0,R2,R0
   \       0x42   0x8088             STRH     R0,[R1, #+4]
    312                      pHandle->CompSpeed = ( int16_t )
    313                      ( ( int32_t )( pHandle->DeltaAngle ) /
    314                        ( int32_t )( pHandle->PWMNbrPSamplingFreq ) );
   \       0x44   0xB200             SXTH     R0,R0
   \       0x46   0x8C0A             LDRH     R2,[R1, #+32]
   \       0x48   0xFB90 0xF0F2      SDIV     R0,R0,R2
    315                    }
    316                    /* Convert el_dpp to MecUnit */
    317                    *hMecSpeedUnit = ( int16_t )( (  pHandle->AvrElSpeedDpp * 
    318                                                  ( int32_t )pHandle->_Super.hMeasurementFrequency * (int32_t) SPEED_UNIT ) /
    319                                                  (( int32_t ) pHandle->_Super.DPPConvFactor * ( int32_t )pHandle->_Super.bElToMecRatio ) );
   \                     ??HALL_CalcAvrgMecSpeedUnit_4: (+1)
   \       0x4C   0xF9B1 0x3000      LDRSH    R3,[R1, #+0]
   \       0x50   0x8108             STRH     R0,[R1, #+8]
   \       0x52   0x200A             MOVS     R0,#+10
   \       0x54   0x8B61             LDRH     R1,[R4, #+26]
   \       0x56   0x69E2             LDR      R2,[R4, #+28]
   \       0x58   0x434B             MULS     R3,R1,R3
   \       0x5A   0x4343             MULS     R3,R0,R3
   \       0x5C   0x7860             LDRB     R0,[R4, #+1]
   \       0x5E   0x4342             MULS     R2,R0,R2
   \       0x60   0xFB93 0xF0F2      SDIV     R0,R3,R2
   \       0x64   0xE001             B.N      ??HALL_CalcAvrgMecSpeedUnit_2
    320                  }
    321                  else
    322                  {
    323                    *hMecSpeedUnit = ( int16_t )pHandle->SatSpeed;
   \                     ??HALL_CalcAvrgMecSpeedUnit_3: (+1)
   \       0x66   0xF9B1 0x000C      LDRSH    R0,[R1, #+12]
   \                     ??HALL_CalcAvrgMecSpeedUnit_2: (+1)
   \       0x6A   0x8028             STRH     R0,[R5, #+0]
    324                  }
    325                }
    326              }
    327              bReliability = SPD_IsMecSpeedReliable( &pHandle->_Super, hMecSpeedUnit );
   \       0x6C   0x4629             MOV      R1,R5
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0x....'....        BL       SPD_IsMecSpeedReliable
   \       0x74   0xE004             B.N      ??HALL_CalcAvrgMecSpeedUnit_5
    328            }
    329            else
    330            {
    331              bReliability = false;
    332              pHandle->_Super.bSpeedErrorNumber = pHandle->_Super.bMaximumSpeedErrorsNumber;
   \                     ??HALL_CalcAvrgMecSpeedUnit_0: (+1)
   \       0x76   0x78E1             LDRB     R1,[R4, #+3]
   \       0x78   0x7021             STRB     R1,[R4, #+0]
    333              /* If speed is not reliable the El and Mec speed is set to 0 */
    334              pHandle->_Super.hElSpeedDpp = 0;
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x81E2             STRH     R2,[R4, #+14]
    335              *hMecSpeedUnit = 0;
   \       0x7E   0x802A             STRH     R2,[R5, #+0]
    336            }
    337          
    338            pHandle->_Super.hAvrMecSpeedUnit = *hMecSpeedUnit;
   \                     ??HALL_CalcAvrgMecSpeedUnit_5: (+1)
   \       0x80   0x8829             LDRH     R1,[R5, #+0]
   \       0x82   0x81A1             STRH     R1,[R4, #+12]
    339          
    340            return ( bReliability );
   \       0x84   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    341          }
    342          
    343          #if defined (CCMRAM)
    344          #if defined (__ICCARM__)
    345          #pragma location = ".ccmram"
    346          #elif defined (__CC_ARM) || defined(__GNUC__)
    347          __attribute__( ( section ( ".ccmram" ) ) )
    348          #endif
    349          #endif
    350          /**
    351          * @brief  Example of private method of the class HALL to implement an MC IRQ function
    352          *         to be called when TIMx capture event occurs
    353          * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component
    354          * @retval none
    355          */

   \                                 In section .text, align 4
    356          __weak void * HALL_TIMx_CC_IRQHandler( void * pHandleVoid )
    357          {
   \                     HALL_TIMx_CC_IRQHandler: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
    358            HALL_Handle_t * pHandle = ( HALL_Handle_t * ) pHandleVoid;
    359            TIM_TypeDef * TIMx = pHandle->TIMx;
   \        0x6   0xF104 0x052C      ADD      R5,R4,#+44
    360            uint8_t bPrevHallState;
    361            int8_t PrevDirection;
    362            uint32_t wCaptBuf;
    363            uint16_t hPrscBuf;
    364            uint16_t hHighSpeedCapture;
    365          
    366            if ( pHandle->SensorIsReliable )
   \        0xA   0x7F68             LDRB     R0,[R5, #+29]
   \        0xC   0x682E             LDR      R6,[R5, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xF000 0x814D      BEQ.W    ??HALL_TIMx_CC_IRQHandler_2
    367            {
    368              /* A capture event generated this interrupt */
    369              bPrevHallState = pHandle->HallState;
   \       0x14   0xF104 0x0798      ADD      R7,R4,#+152
    370              PrevDirection = pHandle->Direction;
    371          
    372              if ( pHandle->SensorPlacement == DEGREES_120 )
   \       0x18   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \       0x1C   0xF897 0x800E      LDRB     R8,[R7, #+14]
   \       0x20   0xF997 0x900A      LDRSB    R9,[R7, #+10]
   \       0x24   0xB990             CBNZ.N   R0,??HALL_TIMx_CC_IRQHandler_3
    373              {
    374                pHandle->HallState  =(uint8_t) ((LL_GPIO_IsInputPinSet( pHandle->H3Port, pHandle->H3Pin ) << 2)
    375                                      | (LL_GPIO_IsInputPinSet( pHandle->H2Port, pHandle->H2Pin ) << 1)
    376                                      | LL_GPIO_IsInputPinSet( pHandle->H1Port, pHandle->H1Pin ) );
   \       0x26   0x69A9             LDR      R1,[R5, #+24]
   \       0x28   0x6968             LDR      R0,[R5, #+20]
   \       0x2A   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x2E   0x4682             MOV      R10,R0
   \       0x30   0x6929             LDR      R1,[R5, #+16]
   \       0x32   0x68E8             LDR      R0,[R5, #+12]
   \       0x34   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x38   0x0040             LSLS     R0,R0,#+1
   \       0x3A   0xEA40 0x0B8A      ORR      R11,R0,R10, LSL #+2
   \       0x3E   0x68A9             LDR      R1,[R5, #+8]
   \       0x40   0x6868             LDR      R0,[R5, #+4]
   \       0x42   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x46   0xEA40 0x000B      ORR      R0,R0,R11
   \       0x4A   0xE012             B.N      ??HALL_TIMx_CC_IRQHandler_4
    377              }
    378              else
    379              {
    380                pHandle->HallState  = (uint8_t) ((( LL_GPIO_IsInputPinSet( pHandle->H2Port, pHandle->H2Pin ) ^ 1 ) << 2)
    381                                      | (LL_GPIO_IsInputPinSet( pHandle->H3Port, pHandle->H3Pin ) << 1)
    382                                      | LL_GPIO_IsInputPinSet( pHandle->H1Port, pHandle->H1Pin ) );
   \                     ??HALL_TIMx_CC_IRQHandler_3: (+1)
   \       0x4C   0x6929             LDR      R1,[R5, #+16]
   \       0x4E   0x68E8             LDR      R0,[R5, #+12]
   \       0x50   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x54   0x0080             LSLS     R0,R0,#+2
   \       0x56   0xF080 0x0A04      EOR      R10,R0,#0x4
   \       0x5A   0x69A9             LDR      R1,[R5, #+24]
   \       0x5C   0x6968             LDR      R0,[R5, #+20]
   \       0x5E   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x62   0xEA4A 0x0A40      ORR      R10,R10,R0, LSL #+1
   \       0x66   0x68A9             LDR      R1,[R5, #+8]
   \       0x68   0x6868             LDR      R0,[R5, #+4]
   \       0x6A   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x6E   0xEA40 0x000A      ORR      R0,R0,R10
   \                     ??HALL_TIMx_CC_IRQHandler_4: (+1)
   \       0x72   0x73B8             STRB     R0,[R7, #+14]
    383              }
    384          
    385              switch ( pHandle->HallState )
   \       0x74   0xF642 0x20AA      MOVW     R0,#+10922
   \       0x78   0xF897 0xB00E      LDRB     R11,[R7, #+14]
   \       0x7C   0x4B8D             LDR.N    R3,??HALL_TIMx_CC_IRQHandler_1  ;; 0xffffaaab
   \       0x7E   0xF8DF 0xE238      LDR.W    LR,??HALL_TIMx_CC_IRQHandler_1+0x4  ;; 0xffffd556
   \       0x82   0xF1AB 0x0B01      SUB      R11,R11,#+1
   \       0x86   0xF1BB 0x0F05      CMP      R11,#+5
   \       0x8A   0xF245 0x5155      MOVW     R1,#+21845
   \       0x8E   0xF647 0x72FF      MOVW     R2,#+32767
   \       0x92   0xF04F 0x3AFF      MOV      R10,#-1
   \       0x96   0xD868             BHI.N    ??HALL_TIMx_CC_IRQHandler_5
   \       0x98   0xE8DF 0xF00B      TBB      [PC, R11]
   \                     ??HALL_TIMx_CC_IRQHandler_0:
   \       0x9C   0x12 0x33          DC8      0x12,0x33,0x22,0x55

   \              0x22 0x55
   \       0xA0   0x03 0x44          DC8      0x3,0x44
    386              {
    387                case STATE_5:
    388                  if ( bPrevHallState == STATE_4 )
   \                     ??HALL_TIMx_CC_IRQHandler_6: (+1)
   \       0xA2   0xF1B8 0x0F04      CMP      R8,#+4
   \       0xA6   0xD103             BNE.N    ??HALL_TIMx_CC_IRQHandler_7
    389                  {
    390                    pHandle->Direction = POSITIVE;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x72B8             STRB     R0,[R7, #+10]
    391                    pHandle->MeasuredElAngle = pHandle->PhaseShift;
   \       0xAC   0x8C61             LDRH     R1,[R4, #+34]
   \       0xAE   0xE01E             B.N      ??HALL_TIMx_CC_IRQHandler_8
    392                  }
    393                  else if ( bPrevHallState == STATE_1 )
   \                     ??HALL_TIMx_CC_IRQHandler_7: (+1)
   \       0xB0   0xF1B8 0x0F01      CMP      R8,#+1
   \       0xB4   0xD15B             BNE.N    ??HALL_TIMx_CC_IRQHandler_9
    394                  {
    395                    pHandle->Direction = NEGATIVE;
   \       0xB6   0xF887 0xA00A      STRB     R10,[R7, #+10]
    396                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift + S16_60_PHASE_SHIFT );
   \       0xBA   0x8C61             LDRH     R1,[R4, #+34]
   \       0xBC   0x1840             ADDS     R0,R0,R1
   \       0xBE   0xE052             B.N      ??HALL_TIMx_CC_IRQHandler_10
    397                  }
    398                  else
    399                  {
    400                  }
    401                  break;
    402          
    403                case STATE_1:
    404                  if ( bPrevHallState == STATE_5 )
   \                     ??HALL_TIMx_CC_IRQHandler_11: (+1)
   \       0xC0   0xF1B8 0x0F05      CMP      R8,#+5
   \       0xC4   0xD104             BNE.N    ??HALL_TIMx_CC_IRQHandler_12
    405                  {
    406                    pHandle->Direction = POSITIVE;
   \       0xC6   0x2101             MOVS     R1,#+1
   \       0xC8   0x72B9             STRB     R1,[R7, #+10]
    407                    pHandle->MeasuredElAngle = pHandle->PhaseShift + S16_60_PHASE_SHIFT;
   \       0xCA   0x8C62             LDRH     R2,[R4, #+34]
   \       0xCC   0x1880             ADDS     R0,R0,R2
   \       0xCE   0xE04A             B.N      ??HALL_TIMx_CC_IRQHandler_10
    408                  }
    409                  else if ( bPrevHallState == STATE_3 )
   \                     ??HALL_TIMx_CC_IRQHandler_12: (+1)
   \       0xD0   0xF1B8 0x0F03      CMP      R8,#+3
   \       0xD4   0xD14B             BNE.N    ??HALL_TIMx_CC_IRQHandler_9
    410                  {
    411                    pHandle->Direction = NEGATIVE;
   \       0xD6   0xF887 0xA00A      STRB     R10,[R7, #+10]
    412                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift + S16_120_PHASE_SHIFT );
   \       0xDA   0x8C60             LDRH     R0,[R4, #+34]
   \       0xDC   0x1809             ADDS     R1,R1,R0
   \       0xDE   0xE006             B.N      ??HALL_TIMx_CC_IRQHandler_8
    413                  }
    414                  else
    415                  {
    416                  }
    417                  break;
    418          
    419                case STATE_3:
    420                  if ( bPrevHallState == STATE_1 )
   \                     ??HALL_TIMx_CC_IRQHandler_13: (+1)
   \       0xE0   0xF1B8 0x0F01      CMP      R8,#+1
   \       0xE4   0xD105             BNE.N    ??HALL_TIMx_CC_IRQHandler_14
    421                  {
    422                    pHandle->Direction = POSITIVE;
   \       0xE6   0x2001             MOVS     R0,#+1
   \       0xE8   0x72B8             STRB     R0,[R7, #+10]
    423                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift + S16_120_PHASE_SHIFT );
   \       0xEA   0x8C62             LDRH     R2,[R4, #+34]
   \       0xEC   0x1889             ADDS     R1,R1,R2
   \                     ??HALL_TIMx_CC_IRQHandler_8: (+1)
   \       0xEE   0x8279             STRH     R1,[R7, #+18]
   \       0xF0   0xE03D             B.N      ??HALL_TIMx_CC_IRQHandler_9
    424                  }
    425                  else if ( bPrevHallState == STATE_2 )
   \                     ??HALL_TIMx_CC_IRQHandler_14: (+1)
   \       0xF2   0xF1B8 0x0F02      CMP      R8,#+2
   \       0xF6   0xD13A             BNE.N    ??HALL_TIMx_CC_IRQHandler_9
    426                  {
    427                    pHandle->Direction = NEGATIVE;
   \       0xF8   0xF887 0xA00A      STRB     R10,[R7, #+10]
    428                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift + S16_120_PHASE_SHIFT +
    429                                                            S16_60_PHASE_SHIFT );
   \       0xFC   0x8C60             LDRH     R0,[R4, #+34]
   \       0xFE   0x1812             ADDS     R2,R2,R0
   \      0x100   0xE006             B.N      ??HALL_TIMx_CC_IRQHandler_15
    430                  }
    431                  else
    432                  {
    433                  }
    434          
    435                  break;
    436          
    437                case STATE_2:
    438                  if ( bPrevHallState == STATE_3 )
   \                     ??HALL_TIMx_CC_IRQHandler_16: (+1)
   \      0x102   0xF1B8 0x0F03      CMP      R8,#+3
   \      0x106   0xD105             BNE.N    ??HALL_TIMx_CC_IRQHandler_17
    439                  {
    440                    pHandle->Direction = POSITIVE;
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0x72B8             STRB     R0,[R7, #+10]
    441                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift + S16_120_PHASE_SHIFT
    442                                                            + S16_60_PHASE_SHIFT );
   \      0x10C   0x8C61             LDRH     R1,[R4, #+34]
   \      0x10E   0x1852             ADDS     R2,R2,R1
   \                     ??HALL_TIMx_CC_IRQHandler_15: (+1)
   \      0x110   0x827A             STRH     R2,[R7, #+18]
   \      0x112   0xE02C             B.N      ??HALL_TIMx_CC_IRQHandler_9
    443                  }
    444                  else if ( bPrevHallState == STATE_6 )
   \                     ??HALL_TIMx_CC_IRQHandler_17: (+1)
   \      0x114   0xF1B8 0x0F06      CMP      R8,#+6
   \      0x118   0xD129             BNE.N    ??HALL_TIMx_CC_IRQHandler_9
    445                  {
    446                    pHandle->Direction = NEGATIVE;
   \      0x11A   0xF887 0xA00A      STRB     R10,[R7, #+10]
    447                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift - S16_120_PHASE_SHIFT );
   \      0x11E   0x8C60             LDRH     R0,[R4, #+34]
   \      0x120   0x181B             ADDS     R3,R3,R0
   \      0x122   0xE006             B.N      ??HALL_TIMx_CC_IRQHandler_18
    448                  }
    449                  else
    450                  {
    451                  }
    452                  break;
    453          
    454                case STATE_6:
    455                  if ( bPrevHallState == STATE_2 )
   \                     ??HALL_TIMx_CC_IRQHandler_19: (+1)
   \      0x124   0xF1B8 0x0F02      CMP      R8,#+2
   \      0x128   0xD105             BNE.N    ??HALL_TIMx_CC_IRQHandler_20
    456                  {
    457                    pHandle->Direction = POSITIVE;
   \      0x12A   0x2001             MOVS     R0,#+1
   \      0x12C   0x72B8             STRB     R0,[R7, #+10]
    458                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift - S16_120_PHASE_SHIFT );
   \      0x12E   0x8C61             LDRH     R1,[R4, #+34]
   \      0x130   0x185B             ADDS     R3,R3,R1
   \                     ??HALL_TIMx_CC_IRQHandler_18: (+1)
   \      0x132   0x827B             STRH     R3,[R7, #+18]
   \      0x134   0xE01B             B.N      ??HALL_TIMx_CC_IRQHandler_9
    459                  }
    460                  else if ( bPrevHallState == STATE_4 )
   \                     ??HALL_TIMx_CC_IRQHandler_20: (+1)
   \      0x136   0xF1B8 0x0F04      CMP      R8,#+4
   \      0x13A   0xD118             BNE.N    ??HALL_TIMx_CC_IRQHandler_9
    461                  {
    462                    pHandle->Direction = NEGATIVE;
   \      0x13C   0xF887 0xA00A      STRB     R10,[R7, #+10]
    463                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift - S16_60_PHASE_SHIFT );
   \      0x140   0x8C60             LDRH     R0,[R4, #+34]
   \      0x142   0x4470             ADD      R0,LR,R0
   \      0x144   0xE00F             B.N      ??HALL_TIMx_CC_IRQHandler_10
    464                  }
    465                  else
    466                  {
    467                  }
    468                  break;
    469          
    470                case STATE_4:
    471                  if ( bPrevHallState == STATE_6 )
   \                     ??HALL_TIMx_CC_IRQHandler_21: (+1)
   \      0x146   0xF1B8 0x0F06      CMP      R8,#+6
   \      0x14A   0xD106             BNE.N    ??HALL_TIMx_CC_IRQHandler_22
    472                  {
    473                    pHandle->Direction = POSITIVE;
   \      0x14C   0x2001             MOVS     R0,#+1
   \      0x14E   0x72B8             STRB     R0,[R7, #+10]
    474                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift - S16_60_PHASE_SHIFT );
   \      0x150   0x8C61             LDRH     R1,[R4, #+34]
   \      0x152   0x448E             ADD      LR,LR,R1
   \      0x154   0xF8A7 0xE012      STRH     LR,[R7, #+18]
   \      0x158   0xE009             B.N      ??HALL_TIMx_CC_IRQHandler_9
    475                  }
    476                  else if ( bPrevHallState == STATE_5 )
   \                     ??HALL_TIMx_CC_IRQHandler_22: (+1)
   \      0x15A   0xF1B8 0x0F05      CMP      R8,#+5
   \      0x15E   0xD106             BNE.N    ??HALL_TIMx_CC_IRQHandler_9
    477                  {
    478                    pHandle->Direction = NEGATIVE;
   \      0x160   0xF887 0xA00A      STRB     R10,[R7, #+10]
    479                    pHandle->MeasuredElAngle = ( int16_t )( pHandle->PhaseShift );
   \      0x164   0x8C60             LDRH     R0,[R4, #+34]
   \                     ??HALL_TIMx_CC_IRQHandler_10: (+1)
   \      0x166   0x8278             STRH     R0,[R7, #+18]
   \      0x168   0xE001             B.N      ??HALL_TIMx_CC_IRQHandler_9
    480                  }
    481                  else
    482                  {
    483                  }
    484                  break;
    485          
    486                default:
    487                  /* Bad hall sensor configutarion so update the speed reliability */
    488                  pHandle->SensorIsReliable = false;
   \                     ??HALL_TIMx_CC_IRQHandler_5: (+1)
   \      0x16A   0x2100             MOVS     R1,#+0
   \      0x16C   0x7769             STRB     R1,[R5, #+29]
    489          
    490                  break;
    491              }
    492              /* We need to check that the direction has not changed.
    493                 If it is the case, the sign of the current speed can be the opposite of the
    494                 average speed, and the average time can be close to 0 which lead to a 
    495                 computed speed close to the infinite, and bring instability. */
    496              if (pHandle->Direction != PrevDirection)
   \                     ??HALL_TIMx_CC_IRQHandler_9: (+1)
   \      0x16E   0xF104 0x014C      ADD      R1,R4,#+76
   \      0x172   0xF997 0x000A      LDRSB    R0,[R7, #+10]
   \      0x176   0x4548             CMP      R0,R9
   \      0x178   0xD002             BEQ.N    ??HALL_TIMx_CC_IRQHandler_23
    497              {
    498                /* Setting BufferFilled to 0 will prevent to compute the average speed based
    499                 on the SpeedPeriod buffer values */
    500                pHandle->BufferFilled = 0 ;
   \      0x17A   0x2200             MOVS     R2,#+0
   \      0x17C   0x704A             STRB     R2,[R1, #+1]
    501                pHandle->SpeedFIFOIdx = 0;
   \      0x17E   0x703A             STRB     R2,[R7, #+0]
    502              }
    503          
    504              if (pHandle->HallMtpa == true)
   \                     ??HALL_TIMx_CC_IRQHandler_23: (+1)
   \      0x180   0xF894 0x20C7      LDRB     R2,[R4, #+199]
   \      0x184   0x2A01             CMP      R2,#+1
   \      0x186   0xBF04             ITT      EQ
   \      0x188   0x8A7A             LDRHEQ   R2,[R7, #+18]
   \      0x18A   0x80A2             STRHEQ   R2,[R4, #+4]
    505              {
    506                pHandle->_Super.hElAngle = pHandle->MeasuredElAngle;
    507              }
    508              else
    509              {
    510                /* Nothing to do */
    511              }
    512          
    513              /* Discard first capture */
    514              if ( pHandle->FirstCapt == 0u )
   \      0x18C   0x7808             LDRB     R0,[R1, #+0]
   \      0x18E   0xB920             CBNZ.N   R0,??HALL_TIMx_CC_IRQHandler_24
    515              {
    516                pHandle->FirstCapt++;
   \      0x190   0x780A             LDRB     R2,[R1, #+0]
   \      0x192   0x1C52             ADDS     R2,R2,#+1
   \      0x194   0x700A             STRB     R2,[R1, #+0]
    517                LL_TIM_IC_GetCaptureCH1( TIMx );
   \      0x196   0x6B70             LDR      R0,[R6, #+52]
    518              }
   \      0x198   0xE089             B.N      ??HALL_TIMx_CC_IRQHandler_2
    519              else
    520              {
    521                /* used to validate the average speed measurement */
    522                if ( pHandle->BufferFilled < pHandle->SpeedBufferSize )
   \                     ??HALL_TIMx_CC_IRQHandler_24: (+1)
   \      0x19A   0x784A             LDRB     R2,[R1, #+1]
   \      0x19C   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \      0x1A0   0x4282             CMP      R2,R0
   \      0x1A2   0xD202             BCS.N    ??HALL_TIMx_CC_IRQHandler_25
    523                {
    524                  pHandle->BufferFilled++;
   \      0x1A4   0x784A             LDRB     R2,[R1, #+1]
   \      0x1A6   0x1C52             ADDS     R2,R2,#+1
   \      0x1A8   0x704A             STRB     R2,[R1, #+1]
    525                }
    526          
    527                /* Store the latest speed acquisition */
    528                hHighSpeedCapture = LL_TIM_IC_GetCaptureCH1( TIMx );
   \                     ??HALL_TIMx_CC_IRQHandler_25: (+1)
   \      0x1AA   0x6B73             LDR      R3,[R6, #+52]
    529                wCaptBuf = ( uint32_t )hHighSpeedCapture;
    530                hPrscBuf =  LL_TIM_GetPrescaler ( TIMx );
   \      0x1AC   0x6AB2             LDR      R2,[R6, #+40]
    531          
    532                /* Add the numbers of overflow to the counter */
    533                wCaptBuf += ( uint32_t )pHandle->OVFCounter * 0x10000uL;
   \      0x1AE   0x7888             LDRB     R0,[R1, #+2]
   \      0x1B0   0xB29B             UXTH     R3,R3
   \      0x1B2   0xB292             UXTH     R2,R2
   \      0x1B4   0xEB03 0x4C00      ADD      R12,R3,R0, LSL #+16
    534          
    535                if ( pHandle->OVFCounter != 0u )
   \      0x1B8   0x1C50             ADDS     R0,R2,#+1
   \      0x1BA   0xB280             UXTH     R0,R0
   \      0x1BC   0xFB00 0xFE0C      MUL      LR,R0,R12
   \      0x1C0   0x7888             LDRB     R0,[R1, #+2]
   \      0x1C2   0xB170             CBZ.N    R0,??HALL_TIMx_CC_IRQHandler_26
    536                {
    537                  /* Adjust the capture using prescaler */
    538                  uint16_t hAux;
    539                  hAux = hPrscBuf + 1u;
    540                  wCaptBuf *= hAux;
    541          
    542                  if ( pHandle->RatioInc )
   \      0x1C4   0x7FE8             LDRB     R0,[R5, #+31]
   \      0x1C6   0x4672             MOV      R2,LR
   \      0x1C8   0xB108             CBZ.N    R0,??HALL_TIMx_CC_IRQHandler_27
    543                  {
    544                    pHandle->RatioInc = false;  /* Previous capture caused overflow */
   \      0x1CA   0x2300             MOVS     R3,#+0
   \      0x1CC   0xE007             B.N      ??HALL_TIMx_CC_IRQHandler_28
    545                    /* Don't change prescaler (delay due to preload/update mechanism) */
    546                  }
    547                  else
    548                  {
    549                    if ( LL_TIM_GetPrescaler ( TIMx ) < pHandle->HALLMaxRatio ) /* Avoid OVF w/ very low freq */
   \                     ??HALL_TIMx_CC_IRQHandler_27: (+1)
   \      0x1CE   0x6AB0             LDR      R0,[R6, #+40]
   \      0x1D0   0x8AFB             LDRH     R3,[R7, #+22]
   \      0x1D2   0x4298             CMP      R0,R3
   \      0x1D4   0xD219             BCS.N    ??HALL_TIMx_CC_IRQHandler_29
    550                    {
    551                      LL_TIM_SetPrescaler ( TIMx, LL_TIM_GetPrescaler ( TIMx ) + 1 ); /* To avoid OVF during speed decrease */
   \      0x1D6   0x6AB0             LDR      R0,[R6, #+40]
   \      0x1D8   0x1C40             ADDS     R0,R0,#+1
   \      0x1DA   0x62B0             STR      R0,[R6, #+40]
    552                      pHandle->RatioInc = true;   /* new prsc value updated at next capture only */
   \      0x1DC   0x2301             MOVS     R3,#+1
   \                     ??HALL_TIMx_CC_IRQHandler_28: (+1)
   \      0x1DE   0x77EB             STRB     R3,[R5, #+31]
   \      0x1E0   0xE013             B.N      ??HALL_TIMx_CC_IRQHandler_29
    553                    }
    554                  }
    555                }
    556                else
    557                {
    558                  /* If prsc preload reduced in last capture, store current register + 1 */
    559                  if ( pHandle->RatioDec ) /* and don't decrease it again */
   \                     ??HALL_TIMx_CC_IRQHandler_26: (+1)
   \      0x1E2   0x7FA8             LDRB     R0,[R5, #+30]
   \      0x1E4   0xB130             CBZ.N    R0,??HALL_TIMx_CC_IRQHandler_30
    560                  {
    561                    /* Adjust the capture using prescaler */
    562                    uint16_t hAux;
    563                    hAux = hPrscBuf + 2u;
    564                    wCaptBuf *= hAux;
   \      0x1E6   0x1C92             ADDS     R2,R2,#+2
   \      0x1E8   0xB292             UXTH     R2,R2
    565          
    566                    pHandle->RatioDec = false;
   \      0x1EA   0x2000             MOVS     R0,#+0
   \      0x1EC   0xFB02 0xF20C      MUL      R2,R2,R12
   \      0x1F0   0x77A8             STRB     R0,[R5, #+30]
   \      0x1F2   0xE00A             B.N      ??HALL_TIMx_CC_IRQHandler_29
    567                  }
    568                  else  /* If prescaler was not modified on previous capture */
    569                  {
    570                    /* Adjust the capture using prescaler */
    571                    uint16_t hAux = hPrscBuf + 1u;
    572                    wCaptBuf *= hAux;
    573          
    574                    if ( hHighSpeedCapture < LOW_RES_THRESHOLD ) /* If capture range correct */
   \                     ??HALL_TIMx_CC_IRQHandler_30: (+1)
   \      0x1F4   0xF5B3 0x4FAA      CMP      R3,#+21760
   \      0x1F8   0x4672             MOV      R2,LR
   \      0x1FA   0xDA06             BGE.N    ??HALL_TIMx_CC_IRQHandler_29
    575                    {
    576                      if ( LL_TIM_GetPrescaler ( TIMx ) > 0u ) /* or prescaler cannot be further reduced */
   \      0x1FC   0x6AB0             LDR      R0,[R6, #+40]
   \      0x1FE   0xB120             CBZ.N    R0,??HALL_TIMx_CC_IRQHandler_29
    577                      {
    578                        LL_TIM_SetPrescaler ( TIMx, LL_TIM_GetPrescaler ( TIMx ) - 1 ); /* Increase accuracy by decreasing prsc */
   \      0x200   0x6AB0             LDR      R0,[R6, #+40]
   \      0x202   0x1E40             SUBS     R0,R0,#+1
   \      0x204   0x62B0             STR      R0,[R6, #+40]
    579                        /* Avoid decrementing again in next capt.(register preload delay) */
    580                        pHandle->RatioDec = true;
   \      0x206   0x2301             MOVS     R3,#+1
   \      0x208   0x77AB             STRB     R3,[R5, #+30]
    581                      }
    582                    }
    583                  }
    584                }
    585          
    586                /* Filtering to fast speed... could be a glitch  ? */
    587                /* the HALL_MAX_PSEUDO_SPEED is temporary in the buffer, and never included in average computation*/
    588                  if ( wCaptBuf < pHandle->MinPeriod )
   \                     ??HALL_TIMx_CC_IRQHandler_29: (+1)
   \      0x20A   0x6A78             LDR      R0,[R7, #+36]
   \      0x20C   0x4282             CMP      R2,R0
   \      0x20E   0xD34C             BCC.N    ??HALL_TIMx_CC_IRQHandler_31
    589                  {
    590                     /* pHandle->AvrElSpeedDpp = HALL_MAX_PSEUDO_SPEED; */
    591                  }
    592                  else
    593                  {
    594                    pHandle->ElPeriodSum -= pHandle->SensorPeriod[pHandle->SpeedFIFOIdx]; /* value we gonna removed from the accumulator */
   \      0x210   0xF104 0x0650      ADD      R6,R4,#+80
   \      0x214   0xF897 0xC000      LDRB     R12,[R7, #+0]
   \      0x218   0x687B             LDR      R3,[R7, #+4]
   \      0x21A   0xF856 0x002C      LDR      R0,[R6, R12, LSL #+2]
    595                    if ( wCaptBuf >= pHandle->MaxPeriod )
   \      0x21E   0x6A3E             LDR      R6,[R7, #+32]
   \      0x220   0x1A1B             SUBS     R3,R3,R0
   \      0x222   0x607B             STR      R3,[R7, #+4]
   \      0x224   0x42B2             CMP      R2,R6
   \      0x226   0x783B             LDRB     R3,[R7, #+0]
   \      0x228   0xD307             BCC.N    ??HALL_TIMx_CC_IRQHandler_32
    596                    {
    597                      pHandle->SensorPeriod[pHandle->SpeedFIFOIdx] = pHandle->MaxPeriod*pHandle->Direction; 
   \      0x22A   0xF997 0x000A      LDRSB    R0,[R7, #+10]
   \      0x22E   0x4346             MULS     R6,R0,R6
   \      0x230   0xF104 0x0050      ADD      R0,R4,#+80
   \      0x234   0xF840 0x6023      STR      R6,[R0, R3, LSL #+2]
   \      0x238   0xE015             B.N      ??HALL_TIMx_CC_IRQHandler_33
    598                    }
    599                    else
    600                    {
    601                      pHandle->SensorPeriod[pHandle->SpeedFIFOIdx] = wCaptBuf ;
   \                     ??HALL_TIMx_CC_IRQHandler_32: (+1)
   \      0x23A   0xF104 0x0050      ADD      R0,R4,#+80
    602                      pHandle->SensorPeriod[pHandle->SpeedFIFOIdx] *= pHandle->Direction;
   \      0x23E   0xF104 0x0650      ADD      R6,R4,#+80
   \      0x242   0xF840 0x2023      STR      R2,[R0, R3, LSL #+2]
   \      0x246   0x783B             LDRB     R3,[R7, #+0]
   \      0x248   0xF856 0xC023      LDR      R12,[R6, R3, LSL #+2]
   \      0x24C   0xF997 0x000A      LDRSB    R0,[R7, #+10]
   \      0x250   0xFB00 0xF00C      MUL      R0,R0,R12
   \      0x254   0xF846 0x0023      STR      R0,[R6, R3, LSL #+2]
    603                      pHandle->ElPeriodSum += pHandle->SensorPeriod[pHandle->SpeedFIFOIdx];
   \      0x258   0xF897 0xC000      LDRB     R12,[R7, #+0]
   \      0x25C   0x687B             LDR      R3,[R7, #+4]
   \      0x25E   0xF856 0x002C      LDR      R0,[R6, R12, LSL #+2]
   \      0x262   0x18C3             ADDS     R3,R0,R3
   \      0x264   0x607B             STR      R3,[R7, #+4]
    604                    }
    605                    /* Update pointers to speed buffer */
    606                    pHandle->SpeedFIFOIdx++;
   \                     ??HALL_TIMx_CC_IRQHandler_33: (+1)
   \      0x266   0x7838             LDRB     R0,[R7, #+0]
   \      0x268   0x1C40             ADDS     R0,R0,#+1
   \      0x26A   0x7038             STRB     R0,[R7, #+0]
    607                    if ( pHandle->SpeedFIFOIdx == pHandle->SpeedBufferSize )
   \      0x26C   0xB2C0             UXTB     R0,R0
   \      0x26E   0xF894 0x3026      LDRB     R3,[R4, #+38]
   \      0x272   0x4298             CMP      R0,R3
   \      0x274   0xBF04             ITT      EQ
   \      0x276   0x2600             MOVEQ    R6,#+0
   \      0x278   0x703E             STRBEQ   R6,[R7, #+0]
    608                    {
    609                      pHandle->SpeedFIFOIdx = 0u;
    610                    }
    611                    if ( pHandle->SensorIsReliable) 
   \      0x27A   0x7F68             LDRB     R0,[R5, #+29]
   \      0x27C   0xB198             CBZ.N    R0,??HALL_TIMx_CC_IRQHandler_34
    612                    {
    613                      if ( pHandle->BufferFilled < pHandle->SpeedBufferSize )
   \      0x27E   0x69F8             LDR      R0,[R7, #+28]
   \      0x280   0xF894 0x3026      LDRB     R3,[R4, #+38]
   \      0x284   0x784C             LDRB     R4,[R1, #+1]
   \      0x286   0x429C             CMP      R4,R3
   \      0x288   0xD206             BCS.N    ??HALL_TIMx_CC_IRQHandler_35
    614                      {
    615                        pHandle->AvrElSpeedDpp = ( int16_t ) (( pHandle->PseudoFreqConv / wCaptBuf )*pHandle->Direction);
   \      0x28A   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \      0x28E   0xF997 0x200A      LDRSB    R2,[R7, #+10]
   \      0x292   0xFB10 0xF002      SMULBB   R0,R0,R2
   \      0x296   0xE004             B.N      ??HALL_TIMx_CC_IRQHandler_36
    616                      }
    617                      else 
    618                      { /* Average speed allow to smooth the mechanical sensors misalignement */
    619                        pHandle->AvrElSpeedDpp = ( int16_t )((int32_t) pHandle->PseudoFreqConv / ( pHandle->ElPeriodSum / pHandle->SpeedBufferSize )); /* Average value */
   \                     ??HALL_TIMx_CC_IRQHandler_35: (+1)
   \      0x298   0x687A             LDR      R2,[R7, #+4]
   \      0x29A   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \      0x29E   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \                     ??HALL_TIMx_CC_IRQHandler_36: (+1)
   \      0x2A2   0x81B8             STRH     R0,[R7, #+12]
   \      0x2A4   0xE001             B.N      ??HALL_TIMx_CC_IRQHandler_31
    620          
    621                      }
    622                    }
    623                    else /* Sensor is not reliable */
    624                    {
    625                      pHandle->AvrElSpeedDpp = 0;
   \                     ??HALL_TIMx_CC_IRQHandler_34: (+1)
   \      0x2A6   0x2300             MOVS     R3,#+0
   \      0x2A8   0x81BB             STRH     R3,[R7, #+12]
    626                    }
    627                  }
    628                /* Reset the number of overflow occurred */
    629                pHandle->OVFCounter = 0u;
   \                     ??HALL_TIMx_CC_IRQHandler_31: (+1)
   \      0x2AA   0x2000             MOVS     R0,#+0
   \      0x2AC   0x7088             STRB     R0,[R1, #+2]
    630              }
    631            }
    632            return MC_NULL;
   \                     ??HALL_TIMx_CC_IRQHandler_2: (+1)
   \      0x2AE   0x2000             MOVS     R0,#+0
   \      0x2B0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??HALL_TIMx_CC_IRQHandler_1:
   \      0x2B4   0xFFFF'AAAB        DC32     0xffffaaab
   \      0x2B8   0xFFFF'D556        DC32     0xffffd556
    633          }
    634          
    635          #if defined (CCMRAM)
    636          #if defined (__ICCARM__)
    637          #pragma location = ".ccmram"
    638          #elif defined (__CC_ARM) || defined(__GNUC__)
    639          __attribute__( ( section ( ".ccmram" ) ) )
    640          #endif
    641          #endif
    642          /**
    643          * @brief  Example of private method of the class HALL to implement an MC IRQ function
    644          *         to be called when TIMx update event occurs
    645          * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component
    646          * @retval none
    647          */

   \                                 In section .text, align 2
    648          __weak void * HALL_TIMx_UP_IRQHandler( void * pHandleVoid )
    649          {
   \                     HALL_TIMx_UP_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    650            HALL_Handle_t * pHandle = ( HALL_Handle_t * ) pHandleVoid;
    651            TIM_TypeDef * TIMx = pHandle->TIMx;
   \        0x4   0xF104 0x002C      ADD      R0,R4,#+44
   \        0x8   0x6801             LDR      R1,[R0, #+0]
    652          
    653            if ( pHandle->SensorIsReliable )
   \        0xA   0x7F40             LDRB     R0,[R0, #+29]
   \        0xC   0xB390             CBZ.N    R0,??HALL_TIMx_UP_IRQHandler_0
    654            {
    655              uint16_t hMaxTimerOverflow;
    656              /* an update event occured for this interrupt request generation */
    657              pHandle->OVFCounter++;
   \        0xE   0xF104 0x054C      ADD      R5,R4,#+76
    658          
    659              hMaxTimerOverflow = ( uint16_t )( ( ( uint32_t )pHandle->HallTimeout * pHandle->OvfFreq )
    660                                                / ( ( LL_TIM_GetPrescaler ( TIMx ) + 1 ) * 1000u ) );
    661              if ( pHandle->OVFCounter >= hMaxTimerOverflow )
   \       0x12   0xF104 0x0698      ADD      R6,R4,#+152
   \       0x16   0x78A8             LDRB     R0,[R5, #+2]
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0x70A8             STRB     R0,[R5, #+2]
   \       0x1C   0xF44F 0x707A      MOV      R0,#+1000
   \       0x20   0x6A8A             LDR      R2,[R1, #+40]
   \       0x22   0x8D33             LDRH     R3,[R6, #+40]
   \       0x24   0x8D71             LDRH     R1,[R6, #+42]
   \       0x26   0x1C52             ADDS     R2,R2,#+1
   \       0x28   0x434B             MULS     R3,R1,R3
   \       0x2A   0x4342             MULS     R2,R0,R2
   \       0x2C   0xFBB3 0xF0F2      UDIV     R0,R3,R2
   \       0x30   0x78A9             LDRB     R1,[R5, #+2]
   \       0x32   0xB280             UXTH     R0,R0
   \       0x34   0x4281             CMP      R1,R0
   \       0x36   0xD31D             BCC.N    ??HALL_TIMx_UP_IRQHandler_0
    662              {
    663                /* Set rotor speed to zero */
    664                pHandle->_Super.hElSpeedDpp = 0;
   \       0x38   0xF104 0x070E      ADD      R7,R4,#+14
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x8038             STRH     R0,[R7, #+0]
    665          
    666                /* Reset the electrical angle according the hall sensor configuration */
    667                HALL_Init_Electrical_Angle( pHandle );
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       HALL_Init_Electrical_Angle
    668          
    669                /* Reset the overflow counter */
    670                pHandle->OVFCounter = 0u;
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x70A9             STRB     R1,[R5, #+2]
    671          
    672                /* Reset first capture flag */
    673                pHandle->FirstCapt = 0u;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x7028             STRB     R0,[R5, #+0]
    674          
    675                /* Reset the SensorSpeed buffer*/
    676                uint8_t bIndex;
    677                for ( bIndex = 0u; bIndex < pHandle->SpeedBufferSize; bIndex++ )
   \       0x4E   0xE005             B.N      ??HALL_TIMx_UP_IRQHandler_1
    678                {
    679                  pHandle->SensorPeriod[bIndex]  = pHandle->MaxPeriod;
   \                     ??HALL_TIMx_UP_IRQHandler_2: (+1)
   \       0x50   0xB2C2             UXTB     R2,R0
   \       0x52   0x6A31             LDR      R1,[R6, #+32]
   \       0x54   0xEB04 0x0382      ADD      R3,R4,R2, LSL #+2
    680                }
   \       0x58   0x1C40             ADDS     R0,R0,#+1
   \       0x5A   0x6519             STR      R1,[R3, #+80]
   \                     ??HALL_TIMx_UP_IRQHandler_1: (+1)
   \       0x5C   0xB2C1             UXTB     R1,R0
   \       0x5E   0x7E3A             LDRB     R2,[R7, #+24]
   \       0x60   0x4291             CMP      R1,R2
   \       0x62   0xD3F5             BCC.N    ??HALL_TIMx_UP_IRQHandler_2
    681                pHandle->BufferFilled = 0 ;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x7068             STRB     R0,[R5, #+1]
    682                pHandle->AvrElSpeedDpp = 0;
   \       0x68   0x81B0             STRH     R0,[R6, #+12]
    683                pHandle->SpeedFIFOIdx = 0;
   \       0x6A   0x7030             STRB     R0,[R6, #+0]
    684                pHandle->ElPeriodSum =pHandle->MaxPeriod * pHandle->SpeedBufferSize;
   \       0x6C   0x6A31             LDR      R1,[R6, #+32]
   \       0x6E   0x7E38             LDRB     R0,[R7, #+24]
   \       0x70   0x4341             MULS     R1,R0,R1
   \       0x72   0x6071             STR      R1,[R6, #+4]
    685              }
    686            }
    687            return MC_NULL;
   \                     ??HALL_TIMx_UP_IRQHandler_0: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    688          }
    689          
    690          /**
    691          * @brief  Read the logic level of the three Hall sensor and individuates in this
    692          *         way the position of the rotor (+/- 30). Electrical angle is then
    693          *         initialized.
    694          * @param  pHandle: handler of the current instance of the hall_speed_pos_fdbk component
    695          * @retval none
    696          */

   \                                 In section .text, align 4, keep-with-next
    697          static void HALL_Init_Electrical_Angle( HALL_Handle_t * pHandle )
    698          {
   \                     HALL_Init_Electrical_Angle: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    699          
    700            if ( pHandle->SensorPlacement == DEGREES_120 )
   \        0x4   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \        0x8   0xB960             CBNZ.N   R0,??HALL_Init_Electrical_Angle_1
    701            {
    702              pHandle->HallState  = LL_GPIO_IsInputPinSet( pHandle->H3Port, pHandle->H3Pin ) << 2
    703                                    | LL_GPIO_IsInputPinSet( pHandle->H2Port, pHandle->H2Pin ) << 1
    704                                    | LL_GPIO_IsInputPinSet( pHandle->H1Port, pHandle->H1Pin );
   \        0xA   0x6C61             LDR      R1,[R4, #+68]
   \        0xC   0x6C20             LDR      R0,[R4, #+64]
   \        0xE   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x12   0x4606             MOV      R6,R0
   \       0x14   0x6BE1             LDR      R1,[R4, #+60]
   \       0x16   0x6BA0             LDR      R0,[R4, #+56]
   \       0x18   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x1C   0x0045             LSLS     R5,R0,#+1
   \       0x1E   0xEA45 0x0586      ORR      R5,R5,R6, LSL #+2
   \       0x22   0xE00C             B.N      ??HALL_Init_Electrical_Angle_2
    705            }
    706            else
    707            {
    708              pHandle->HallState  = ( LL_GPIO_IsInputPinSet( pHandle->H2Port, pHandle->H2Pin ) ^ 1 ) << 2
    709                                    | LL_GPIO_IsInputPinSet( pHandle->H3Port, pHandle->H3Pin ) << 1
    710                                    | LL_GPIO_IsInputPinSet( pHandle->H1Port, pHandle->H1Pin );
   \                     ??HALL_Init_Electrical_Angle_1: (+1)
   \       0x24   0x6BE1             LDR      R1,[R4, #+60]
   \       0x26   0x6BA0             LDR      R0,[R4, #+56]
   \       0x28   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x2C   0x6C61             LDR      R1,[R4, #+68]
   \       0x2E   0x0085             LSLS     R5,R0,#+2
   \       0x30   0x6C20             LDR      R0,[R4, #+64]
   \       0x32   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x36   0xF085 0x0504      EOR      R5,R5,#0x4
   \       0x3A   0xEA45 0x0540      ORR      R5,R5,R0, LSL #+1
   \                     ??HALL_Init_Electrical_Angle_2: (+1)
   \       0x3E   0x6B61             LDR      R1,[R4, #+52]
   \       0x40   0x6B20             LDR      R0,[R4, #+48]
   \       0x42   0x....'....        BL       LL_GPIO_IsInputPinSet
   \       0x46   0x4305             ORRS     R5,R0,R5
   \       0x48   0xF104 0x00A6      ADD      R0,R4,#+166
   \       0x4C   0x7005             STRB     R5,[R0, #+0]
    711            }
    712          
    713            switch ( pHandle->HallState )
   \       0x4E   0x7802             LDRB     R2,[R0, #+0]
   \       0x50   0xF9B4 0x1004      LDRSH    R1,[R4, #+4]
   \       0x54   0x1E52             SUBS     R2,R2,#+1
   \       0x56   0x2A05             CMP      R2,#+5
   \       0x58   0xD820             BHI.N    ??HALL_Init_Electrical_Angle_3
   \       0x5A   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HALL_Init_Electrical_Angle_0:
   \       0x5E   0x08 0x12          DC8      0x8,0x12,0xD,0x1A

   \              0x0D 0x1A
   \       0x62   0x03 0x16          DC8      0x3,0x16
    714            {
    715              case STATE_5:
    716                pHandle->_Super.hElAngle = ( int16_t )( pHandle->PhaseShift + S16_60_PHASE_SHIFT / 2 );
   \                     ??HALL_Init_Electrical_Angle_4: (+1)
   \       0x64   0x8C61             LDRH     R1,[R4, #+34]
   \       0x66   0xF501 0x51A8      ADD      R1,R1,#+5376
   \       0x6A   0x3155             ADDS     R1,R1,#+85
    717                break;
   \       0x6C   0xE019             B.N      ??HALL_Init_Electrical_Angle_5
    718              case STATE_1:
    719                pHandle->_Super.hElAngle = ( int16_t )( pHandle->PhaseShift + S16_60_PHASE_SHIFT +
    720                                                        S16_60_PHASE_SHIFT / 2 );
   \                     ??HALL_Init_Electrical_Angle_6: (+1)
   \       0x6E   0x8C61             LDRH     R1,[R4, #+34]
   \       0x70   0xF501 0x517C      ADD      R1,R1,#+16128
   \       0x74   0x31FF             ADDS     R1,R1,#+255
    721                break;
   \       0x76   0xE014             B.N      ??HALL_Init_Electrical_Angle_5
    722              case STATE_3:
    723                pHandle->_Super.hElAngle = ( int16_t )( pHandle->PhaseShift + S16_120_PHASE_SHIFT +
    724                                                        S16_60_PHASE_SHIFT / 2 );
   \                     ??HALL_Init_Electrical_Angle_7: (+1)
   \       0x78   0x8C61             LDRH     R1,[R4, #+34]
   \       0x7A   0xF501 0x41D4      ADD      R1,R1,#+27136
   \       0x7E   0x31AA             ADDS     R1,R1,#+170
    725                break;
   \       0x80   0xE00F             B.N      ??HALL_Init_Electrical_Angle_5
    726              case STATE_2:
    727                pHandle->_Super.hElAngle = ( int16_t )( pHandle->PhaseShift - S16_120_PHASE_SHIFT -
    728                                                        S16_60_PHASE_SHIFT / 2 );
   \                     ??HALL_Init_Electrical_Angle_8: (+1)
   \       0x82   0x8C61             LDRH     R1,[R4, #+34]
   \       0x84   0xF646 0x22AA      MOVW     R2,#+27306
   \       0x88   0xE006             B.N      ??HALL_Init_Electrical_Angle_9
    729                break;
    730              case STATE_6:
    731                pHandle->_Super.hElAngle = ( int16_t )( pHandle->PhaseShift - S16_60_PHASE_SHIFT -
    732                                                        S16_60_PHASE_SHIFT / 2 );
   \                     ??HALL_Init_Electrical_Angle_10: (+1)
   \       0x8A   0x8C61             LDRH     R1,[R4, #+34]
   \       0x8C   0xF643 0x72FF      MOVW     R2,#+16383
   \       0x90   0xE002             B.N      ??HALL_Init_Electrical_Angle_9
    733                break;
    734              case STATE_4:
    735                pHandle->_Super.hElAngle = ( int16_t )( pHandle->PhaseShift - S16_60_PHASE_SHIFT / 2 );
   \                     ??HALL_Init_Electrical_Angle_11: (+1)
   \       0x92   0x8C61             LDRH     R1,[R4, #+34]
   \       0x94   0xF241 0x5255      MOVW     R2,#+5461
   \                     ??HALL_Init_Electrical_Angle_9: (+1)
   \       0x98   0x1A89             SUBS     R1,R1,R2
    736                break;
   \       0x9A   0xE002             B.N      ??HALL_Init_Electrical_Angle_5
    737              default:
    738                /* Bad hall sensor configutarion so update the speed reliability */
    739                pHandle->SensorIsReliable = false;
   \                     ??HALL_Init_Electrical_Angle_3: (+1)
   \       0x9C   0x2300             MOVS     R3,#+0
   \       0x9E   0xF884 0x3049      STRB     R3,[R4, #+73]
    740                break;
    741            }
    742          
    743            /* Initialize the measured angle */
    744            pHandle->MeasuredElAngle = pHandle->_Super.hElAngle;
   \                     ??HALL_Init_Electrical_Angle_5: (+1)
   \       0xA2   0x80A1             STRH     R1,[R4, #+4]
   \       0xA4   0x8081             STRH     R1,[R0, #+4]
    745          
    746          }
   \       0xA6   0xBD70             POP      {R4-R6,PC}       ;; return
    747          
    748          /**
    749            * @brief  It could be used to set istantaneous information on rotor mechanical
    750            *         angle.
    751            *         Note: Mechanical angle management is not implemented in this
    752            *         version of Hall sensor class.
    753            * @param  pHandle pointer on related component instance
    754            * @param  hMecAngle istantaneous measure of rotor mechanical angle
    755            * @retval none
    756            */

   \                                 In section .text, align 2
    757          __weak void HALL_SetMecAngle( HALL_Handle_t * pHandle, int16_t hMecAngle )
    758          {
    759          }
   \                     HALL_SetMecAngle: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    760          
    761          
    762          /**
    763            * @}
    764            */
    765          
    766          /**
    767            * @}
    768            */
    769          
    770          /** @} */
    771          
    772          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HALL_CalcAvrgMecSpeedUnit
        16   -> SPD_IsMecSpeedReliable
      12   HALL_CalcElAngle
      16   HALL_Clear
         0   -> HALL_Init_Electrical_Angle
      20   HALL_Init
      16   HALL_Init_Electrical_Angle
        16   -> LL_GPIO_IsInputPinSet
       0   HALL_SetMecAngle
      40   HALL_TIMx_CC_IRQHandler
        40   -> LL_GPIO_IsInputPinSet
      24   HALL_TIMx_UP_IRQHandler
        24   -> HALL_Init_Electrical_Angle
       0   LL_GPIO_IsInputPinSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     134  HALL_CalcAvrgMecSpeedUnit
      50  HALL_CalcElAngle
      84  HALL_Clear
     264  HALL_Init
     168  HALL_Init_Electrical_Angle
       2  HALL_SetMecAngle
     700  HALL_TIMx_CC_IRQHandler
     120  HALL_TIMx_UP_IRQHandler
      16  LL_GPIO_IsInputPinSet

 
 1'538 bytes in section .text
 
 184 bytes of CODE memory (+ 1'354 bytes shared)

Errors: none
Warnings: none
