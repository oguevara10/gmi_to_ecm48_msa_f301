###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:28
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\frame_communication_protocol.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW356D.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\frame_communication_protocol.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\frame_communication_protocol.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\frame_communication_protocol.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\frame_communication_protocol.c
      1          /**
      2            ******************************************************************************
      3            * @file    frame_communication_protocol.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Frame Communication Protocol component of the Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "user_interface.h"
     24          #include "motor_control_protocol.h"
     25          
     26          #include "frame_communication_protocol.h"
     27          
     28          /**
     29           * @addtogroup MCSDK
     30           * @{
     31           */
     32          
     33          /**
     34           * @addtogroup MCUI
     35           * @{
     36           */
     37          
     38          /**
     39           * @defgroup FCP Frame Communication Protocol
     40           *
     41           * @brief A Frame Oriented transmission protocol
     42           *
     43           * This protocol is designed to transport the messages of the Motor Control Protocol
     44           * across physical links such as UARTs.
     45           *
     46           * The Frame Communication Protocol component serves as a base to actual implementations
     47           * of the protocol that operate on specific physical links. So far, the only provided implementation
     48           * of the protocol uses the USARTs as the physical link.
     49           *
     50           * @todo Complete documentation
     51           * @{
     52           */
     53          

   \                                 In section .text, align 2
     54          __weak void FCP_Init( FCP_Handle_t * pHandle )
     55          {
     56            pHandle->RxTimeoutCountdown = 0;
   \                     FCP_Init: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8241             STRH     R1,[R0, #+18]
     57          
     58            pHandle->TxFrame.Code = 0x0;
     59            pHandle->TxFrame.Size = 0;
   \        0x4   0x7541             STRB     R1,[R0, #+21]
   \        0x6   0x2200             MOVS     R2,#+0
     60            pHandle->TxFrame.FrameCRC = 0;
   \        0x8   0xF100 0x0196      ADD      R1,R0,#+150
   \        0xC   0x7502             STRB     R2,[R0, #+20]
     61            pHandle->TxFrameState = FCP_TRANSFER_IDLE;
     62            pHandle->TxFrameLevel = 0;
     63          
     64            pHandle->RxFrame.Code = 0x0;
     65            pHandle->RxFrame.Size = 0;
     66            pHandle->RxFrame.FrameCRC = 0;
   \        0xE   0xF200 0x101B      ADDW     R0,R0,#+283
   \       0x12   0x700A             STRB     R2,[R1, #+0]
   \       0x14   0x704A             STRB     R2,[R1, #+1]
   \       0x16   0x708A             STRB     R2,[R1, #+2]
   \       0x18   0x70CA             STRB     R2,[R1, #+3]
   \       0x1A   0x710A             STRB     R2,[R1, #+4]
   \       0x1C   0x7002             STRB     R2,[R0, #+0]
     67            pHandle->RxFrameState = FCP_TRANSFER_IDLE;
   \       0x1E   0x7042             STRB     R2,[R0, #+1]
     68            pHandle->RxFrameLevel = 0;
   \       0x20   0x7082             STRB     R2,[R0, #+2]
     69          }
   \       0x22   0x4770             BX       LR               ;; return
     70          

   \                                 In section .text, align 2
     71          __weak void FCP_SetClient( FCP_Handle_t * pHandle,
     72                              struct MCP_Handle_s * pClient,
     73                              FCP_SentFrameCallback_t pSentFrameCb,
     74                              FCP_ReceivedFrameCallback_t pReceviedFrameCb,
     75                              FCP_RxTimeoutCallback_t pRxTimeoutCb )
     76          {
   \                     FCP_SetClient: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD100             BNE.N    ??FCP_SetClient_0
   \        0x4   0x4770             BX       LR
   \                     ??FCP_SetClient_0: (+1)
   \        0x6   0xB510             PUSH     {R4,LR}
     77            if ( MC_NULL != pHandle )
   \        0x8   0x9C02             LDR      R4,[SP, #+8]
     78            {
     79              pHandle->ClientEntity = pClient;
   \        0xA   0x6001             STR      R1,[R0, #+0]
     80              pHandle->ClientFrameSentCallback = pSentFrameCb;
     81              pHandle->ClientFrameReceivedCallback = pReceviedFrameCb;
     82              pHandle->ClientRxTimeoutCallback = pRxTimeoutCb;
   \        0xC   0x60C4             STR      R4,[R0, #+12]
   \        0xE   0x6042             STR      R2,[R0, #+4]
   \       0x10   0x6083             STR      R3,[R0, #+8]
     83            }
     84          }
   \       0x12   0xBD10             POP      {R4,PC}          ;; return
     85          

   \                                 In section .text, align 2
     86          __weak void FCP_SetTimeout( FCP_Handle_t * pHandle, uint16_t Timeout )
     87          {
     88            if ( MC_NULL != pHandle )
   \                     FCP_SetTimeout: (+1)
   \        0x0   0xB100             CBZ.N    R0,??FCP_SetTimeout_0
     89            {
     90              pHandle->RxTimeout = Timeout;
   \        0x2   0x8201             STRH     R1,[R0, #+16]
     91            }
     92          }
   \                     ??FCP_SetTimeout_0: (+1)
   \        0x4   0x4770             BX       LR               ;; return
     93          

   \                                 In section .text, align 2
     94          __weak uint8_t FCP_CalcCRC( FCP_Frame_t * pFrame )
     95          {
   \                     FCP_CalcCRC: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4601             MOV      R1,R0
     96            uint8_t nCRC = 0;
   \        0x4   0x2000             MOVS     R0,#+0
     97            uint16_t nSum = 0;
     98            uint8_t idx;
     99          
    100            if( MC_NULL != pFrame )
   \        0x6   0xB181             CBZ.N    R1,??FCP_CalcCRC_0
    101            {
    102              nSum += pFrame->Code;
    103              nSum += pFrame->Size;
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0x784A             LDRB     R2,[R1, #+1]
   \        0xC   0x1810             ADDS     R0,R2,R0
   \        0xE   0xB280             UXTH     R0,R0
    104          
    105              for ( idx = 0; idx < pFrame->Size; idx++ )
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0xE003             B.N      ??FCP_CalcCRC_1
    106              {
    107                nSum += pFrame->Buffer[idx];
   \                     ??FCP_CalcCRC_2: (+1)
   \       0x14   0x440B             ADD      R3,R1,R3
    108              }
   \       0x16   0x1C52             ADDS     R2,R2,#+1
   \       0x18   0x789B             LDRB     R3,[R3, #+2]
   \       0x1A   0x18C0             ADDS     R0,R0,R3
   \                     ??FCP_CalcCRC_1: (+1)
   \       0x1C   0x784C             LDRB     R4,[R1, #+1]
   \       0x1E   0xB2D3             UXTB     R3,R2
   \       0x20   0x42A3             CMP      R3,R4
   \       0x22   0xD3F7             BCC.N    ??FCP_CalcCRC_2
    109          
    110              nCRC = (uint8_t)(nSum & 0xFF) ; // Low Byte of nSum
    111              nCRC += (uint8_t) (nSum >> 8) ; // High Byte of nSum
   \       0x24   0x0401             LSLS     R1,R0,#+16
   \       0x26   0xEB00 0x6011      ADD      R0,R0,R1, LSR #+24
    112            }
    113          
    114            return nCRC ;
   \                     ??FCP_CalcCRC_0: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
    115          }
    116          

   \                                 In section .text, align 2
    117          __weak uint8_t FCP_IsFrameValid( FCP_Frame_t * pFrame )
    118          {
   \                     FCP_IsFrameValid: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    119            if ( MC_NULL != pFrame )
   \        0x4   0xD008             BEQ.N    ??FCP_IsFrameValid_0
    120              return FCP_CalcCRC(pFrame) == pFrame->Buffer[pFrame->Size];
   \        0x6   0x....'....        BL       FCP_CalcCRC
   \        0xA   0x7861             LDRB     R1,[R4, #+1]
   \        0xC   0x4421             ADD      R1,R4,R1
   \        0xE   0x788A             LDRB     R2,[R1, #+2]
   \       0x10   0x4290             CMP      R0,R2
   \       0x12   0xD101             BNE.N    ??FCP_IsFrameValid_0
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD10             POP      {R4,PC}
    121            else
    122              return 0;
   \                     ??FCP_IsFrameValid_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    123          }
    124          
    125          /**
    126           * @}
    127           */
    128          
    129          /**
    130           * @}
    131           */
    132          
    133          /**
    134           * @}
    135           */
    136          
    137          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FCP_CalcCRC
       0   FCP_Init
       8   FCP_IsFrameValid
         8   -> FCP_CalcCRC
       8   FCP_SetClient
       0   FCP_SetTimeout


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      46  FCP_CalcCRC
      36  FCP_Init
      28  FCP_IsFrameValid
      20  FCP_SetClient
       6  FCP_SetTimeout

 
 136 bytes in section .text
 
 0 bytes of CODE memory (+ 136 bytes shared)

Errors: none
Warnings: none
