###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:54
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\ntc_temperature_sensor.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EWB36.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\ntc_temperature_sensor.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\ntc_temperature_sensor.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\ntc_temperature_sensor.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\ntc_temperature_sensor.c
      1          /**
      2            ******************************************************************************
      3            * @file    ntc_temperature_sensor.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Temperature Sensor component of the Motor Control SDK.
      7            ******************************************************************************
      8            * @attention
      9            *
     10            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     11            * All rights reserved.</center></h2>
     12            *
     13            * This software component is licensed by ST under Ultimate Liberty license
     14            * SLA0044, the "License"; You may not use this file except in compliance with
     15            * the License. You may obtain a copy of the License at:
     16            *                             www.st.com/SLA0044
     17            *
     18            ******************************************************************************
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "ntc_temperature_sensor.h"
     23          
     24          /** @addtogroup MCSDK
     25            * @{
     26            */
     27          
     28          /** @defgroup TemperatureSensor NTC Temperature Sensor
     29            * @brief Allows to read the temperature of the heat sink
     30            *
     31            * This component implements both a virtual and a real temperature sensor,
     32            * depending on the sensor availability.
     33            *
     34            * Access to the MCU peripherals needed to acquire the temperature (GPIO and ADC
     35            * used for regular conversion) is managed by the PWM component used in the Motor
     36            * Control subsystem. As a consequence, this NTC temperature sensor implementation
     37            * is hardware-independent.
     38            *
     39            * If a real temperature sensor is available (Sensor Type = #REAL_SENSOR),
     40            * this component can handle NTC sensors or, more generally, analog temperature sensors
     41            * which output is related to the temperature by the following formula:
     42            *
     43            * @f[
     44            *               V_{out} = V_0 + \frac{dV}{dT} \cdot ( T - T_0)
     45            * @f]
     46            *
     47            * In case a real temperature sensor is not available (Sensor Type = #VIRTUAL_SENSOR),
     48            * This component will always returns a constant, programmable, temperature.
     49            *
     50            * @{
     51            */
     52          
     53          /* Private function prototypes -----------------------------------------------*/
     54          uint16_t NTC_SetFaultState( NTC_Handle_t * pHandle );
     55          
     56          /* Private functions ---------------------------------------------------------*/
     57          
     58          /**
     59            * @brief Returns fault when temperature exceeds the over voltage protection threshold
     60            *
     61            *  @p pHandle : Pointer on Handle structure of TemperatureSensor component
     62            *
     63            *  @r Fault status : Updated internal fault status
     64            */

   \                                 In section .text, align 2
     65          __weak uint16_t NTC_SetFaultState( NTC_Handle_t * pHandle )
     66          {
     67            uint16_t hFault;
     68          
     69            if ( pHandle->hAvTemp_d > pHandle->hOverTempThreshold )
   \                     NTC_SetFaultState: (+1)
   \        0x0   0x8A01             LDRH     R1,[R0, #+16]
   \        0x2   0x8B42             LDRH     R2,[R0, #+26]
   \        0x4   0x428A             CMP      R2,R1
   \        0x6   0xBF24             ITT      CS
   \        0x8   0x8B82             LDRHCS   R2,[R0, #+28]
   \        0xA   0x4291             CMPCS    R1,R2
     70            {
     71              //hFault = MC_OVER_TEMP;  MRMedit
     72              hFault = MC_NO_ERROR;	
     73            }
     74            else if ( pHandle->hAvTemp_d < pHandle->hOverTempDeactThreshold )
   \        0xC   0xD201             BCS.N    ??NTC_SetFaultState_0
     75            {
     76              hFault = MC_NO_ERROR;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR
     77            }
     78            else
     79            {
     80              hFault = pHandle->hFaultState;
   \                     ??NTC_SetFaultState_0: (+1)
   \       0x12   0x8AC0             LDRH     R0,[R0, #+22]
     81            }
     82            return hFault;
   \       0x14   0x4770             BX       LR               ;; return
     83          }
     84          
     85          /* Functions ---------------------------------------------------- */
     86          
     87          /**
     88           * @brief Initializes temperature sensing conversions
     89           *
     90           *  @p pHandle : Pointer on Handle structure of TemperatureSensor component
     91           *
     92           *  @p pPWMnCurrentSensor : Handle on the PWMC component to be used for regular conversions
     93           */

   \                                 In section .text, align 2
     94          __weak void NTC_Init( NTC_Handle_t * pHandle )
     95          {
   \                     NTC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     96          
     97            if ( pHandle->bSensorType == REAL_SENSOR )
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0xB948             CBNZ.N   R0,??NTC_Init_0
     98            {
     99              /* Need to be register with RegularConvManager */
    100              pHandle->convHandle = RCM_RegisterRegConv(&pHandle->TempRegConv);
   \        0x8   0x1D20             ADDS     R0,R4,#+4
   \        0xA   0x....'....        BL       RCM_RegisterRegConv
   \        0xE   0xF884 0x0026      STRB     R0,[R4, #+38]
    101              NTC_Clear( pHandle );
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x....'....        B.W      NTC_Clear
    102            }
    103            else  /* case VIRTUAL_SENSOR */
    104            {
    105              pHandle->hFaultState = MC_NO_ERROR;
    106              pHandle->hAvTemp_d = pHandle->hExpectedTemp_d;
   \                     ??NTC_Init_0: (+1)
   \       0x1C   0x8A61             LDRH     R1,[R4, #+18]
   \       0x1E   0x8221             STRH     R1,[R4, #+16]
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x82E0             STRH     R0,[R4, #+22]
    107            }
    108          
    109          }
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    110          
    111          /**
    112           * @brief Initializes internal average temperature computed value
    113           *
    114           *  @p pHandle : Pointer on Handle structure of TemperatureSensor component
    115           */

   \                                 In section .text, align 2
    116          __weak void NTC_Clear( NTC_Handle_t * pHandle )
    117          {
    118            pHandle->hAvTemp_d = 0u;
   \                     NTC_Clear: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8201             STRH     R1,[R0, #+16]
    119          }
   \        0x4   0x4770             BX       LR               ;; return
    120          
    121          /**
    122            * @brief Performs the temperature sensing average computation after an ADC conversion
    123            *
    124            *  @p pHandle : Pointer on Handle structure of TemperatureSensor component
    125            *
    126            *  @r Fault status : Error reported in case of an over temperature detection
    127            */

   \                                 In section .text, align 2
    128          __weak uint16_t NTC_CalcAvTemp( NTC_Handle_t * pHandle )
    129          {
   \                     NTC_CalcAvTemp: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    130            uint32_t wtemp;
    131            uint16_t hAux;
    132          
    133            if ( pHandle->bSensorType == REAL_SENSOR )
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0xB998             CBNZ.N   R0,??NTC_CalcAvTemp_0
    134            {
    135              hAux = RCM_ExecRegularConv(pHandle->convHandle);
   \        0x8   0xF894 0x0026      LDRB     R0,[R4, #+38]
   \        0xC   0x....'....        BL       RCM_ExecRegularConv
    136          
    137              if ( hAux != 0xFFFFu )
   \       0x10   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD007             BEQ.N    ??NTC_CalcAvTemp_1
    138              {
    139                wtemp =  ( uint32_t )( pHandle->hLowPassFilterBW ) - 1u;
    140                wtemp *= ( uint32_t ) ( pHandle->hAvTemp_d );
    141                wtemp += hAux;
    142                wtemp /= ( uint32_t )( pHandle->hLowPassFilterBW );
    143          
    144                pHandle->hAvTemp_d = ( uint16_t ) wtemp;
   \       0x18   0x8B21             LDRH     R1,[R4, #+24]
   \       0x1A   0x8A23             LDRH     R3,[R4, #+16]
   \       0x1C   0x1E4A             SUBS     R2,R1,#+1
   \       0x1E   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \       0x22   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x26   0x8220             STRH     R0,[R4, #+16]
    145              }
    146          
    147              pHandle->hFaultState = NTC_SetFaultState( pHandle );
   \                     ??NTC_CalcAvTemp_1: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       NTC_SetFaultState
   \       0x2E   0xE000             B.N      ??NTC_CalcAvTemp_2
    148            }
    149            else  /* case VIRTUAL_SENSOR */
    150            {
    151              pHandle->hFaultState = MC_NO_ERROR;
   \                     ??NTC_CalcAvTemp_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
    152            }
    153          
    154            return ( pHandle->hFaultState );
   \                     ??NTC_CalcAvTemp_2: (+1)
   \       0x32   0x82E0             STRH     R0,[R4, #+22]
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    155          }
    156          
    157          /**
    158            * @brief  Returns latest averaged temperature measured expressed in u16Celsius
    159            *
    160            * @p pHandle : Pointer on Handle structure of TemperatureSensor component
    161            *
    162            * @r AverageTemperature : Current averaged temperature measured (in u16Celsius)
    163            */

   \                                 In section .text, align 2
    164          __weak uint16_t NTC_GetAvTemp_d( NTC_Handle_t * pHandle )
    165          {
    166            return ( pHandle->hAvTemp_d );
   \                     NTC_GetAvTemp_d: (+1)
   \        0x0   0x8A00             LDRH     R0,[R0, #+16]
   \        0x2   0x4770             BX       LR               ;; return
    167          }
    168          
    169          /**
    170            * @brief  Returns latest averaged temperature expressed in Celsius degrees
    171            *
    172            * @p pHandle : Pointer on Handle structure of TemperatureSensor component
    173            *
    174            * @r AverageTemperature : Latest averaged temperature measured (in Celsius degrees)
    175            */

   \                                 In section .text, align 2
    176          __weak int16_t NTC_GetAvTemp_C( NTC_Handle_t * pHandle )
    177          {
    178            int32_t wTemp;
    179          
    180            if ( pHandle->bSensorType == REAL_SENSOR )
   \                     NTC_GetAvTemp_C: (+1)
   \        0x0   0x7801             LDRB     R1,[R0, #+0]
   \        0x2   0xB961             CBNZ.N   R1,??NTC_GetAvTemp_C_0
    181            {
    182              wTemp = ( int32_t )( pHandle->hAvTemp_d );
    183              wTemp -= ( int32_t )( pHandle->wV0 );
    184              wTemp *= pHandle->hSensitivity;
    185              wTemp = wTemp / 65536 + ( int32_t )( pHandle->hT0 );
   \        0x4   0x8A01             LDRH     R1,[R0, #+16]
   \        0x6   0x6A02             LDR      R2,[R0, #+32]
   \        0x8   0x1A8A             SUBS     R2,R1,R2
   \        0xA   0xF9B0 0x101E      LDRSH    R1,[R0, #+30]
   \        0xE   0x8C80             LDRH     R0,[R0, #+36]
   \       0x10   0x434A             MULS     R2,R1,R2
   \       0x12   0x13D3             ASRS     R3,R2,#+15
   \       0x14   0xEB02 0x4213      ADD      R2,R2,R3, LSR #+16
   \       0x18   0xEB00 0x4022      ADD      R0,R0,R2, ASR #+16
   \       0x1C   0xE000             B.N      ??NTC_GetAvTemp_C_1
    186            }
    187            else
    188            {
    189              wTemp = pHandle->hExpectedTemp_C;
   \                     ??NTC_GetAvTemp_C_0: (+1)
   \       0x1E   0x8A80             LDRH     R0,[R0, #+20]
    190            }
    191            return ( ( int16_t )wTemp );
   \                     ??NTC_GetAvTemp_C_1: (+1)
   \       0x20   0xB200             SXTH     R0,R0
   \       0x22   0x4770             BX       LR               ;; return
    192          }
    193          
    194          /**
    195            * @brief  Returns Temperature measurement fault status
    196            *
    197            * Fault status can be either MC_OVER_TEMP when measure exceeds the protection threshold values or
    198            * MC_NO_ERROR if it is inside authorized range.
    199            *
    200            * @p pHandle: Pointer on Handle structure of TemperatureSensor component.
    201            *
    202            *  @r Fault status : read internal fault state
    203            */

   \                                 In section .text, align 2
    204          __weak uint16_t NTC_CheckTemp( NTC_Handle_t * pHandle )
    205          {
    206            return ( pHandle->hFaultState );
   \                     NTC_CheckTemp: (+1)
   \        0x0   0x8AC0             LDRH     R0,[R0, #+22]
   \        0x2   0x4770             BX       LR               ;; return
    207          }
    208          
    209          /**
    210            * @}
    211            */
    212          
    213          /**
    214            * @}
    215            */
    216          
    217          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   NTC_CalcAvTemp
         8   -> NTC_SetFaultState
         8   -> RCM_ExecRegularConv
       0   NTC_CheckTemp
       0   NTC_Clear
       0   NTC_GetAvTemp_C
       0   NTC_GetAvTemp_d
       8   NTC_Init
         0   -> NTC_Clear
         8   -> RCM_RegisterRegConv
       0   NTC_SetFaultState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      54  NTC_CalcAvTemp
       4  NTC_CheckTemp
       6  NTC_Clear
      36  NTC_GetAvTemp_C
       4  NTC_GetAvTemp_d
      38  NTC_Init
      22  NTC_SetFaultState

 
 164 bytes in section .text
 
 0 bytes of CODE memory (+ 164 bytes shared)

Errors: none
Warnings: none
