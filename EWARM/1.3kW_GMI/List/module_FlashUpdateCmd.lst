###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:36
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_FlashUpdateCmd.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW5576.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_FlashUpdateCmd.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\module_FlashUpdateCmd.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\module_FlashUpdateCmd.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_FlashUpdateCmd.c
      1          /**
      2            ***************************************************************************************************
      3            * @file    module_FlashUpdateCmd.c 
      4            * @author  Regal Pamela Lee
      5            * @version V1.0
      6            * @date    10-DEC-2020
      7            * @brief   Decode and perform group 4 CMD
      8            * @note    This App decode Group4 CMD in Universal protocol for all flash/setting update
      9            *          Flash Block mode: User should update the whole page of setting in a single/multi Page. 
     10            *                            when transfer a page of setting will be divided into 32bytes per block
     11            *                            always end with block0 (when receive block0 will finialize the whole update) 
     12            *                            and can start with any other blockx, 
     13            *                            @caution transfer must alsway contain the last block of the page for CRC  
     14            ***************************************************************************************************
     15            */
     16          #include "pmsm_motor_parameters.h"
     17          #include "module_FlashUpdateCmd.h"
     18          #include "zz_module_flash.h"

   \                                 In section .rodata, at 0x800f000
   \   __absolute uint16_t const A_POLE_PAIR_NUM
   \                     A_POLE_PAIR_NUM:
   \        0x0   0x0005             DC16 5

   \                                 In section .rodata, at 0x800f002
   \   __absolute uint16_t const A_RS
   \                     A_RS:
   \        0x0   0x0258             DC16 600

   \                                 In section .rodata, at 0x800f004
   \   __absolute uint16_t const A_LS
   \                     A_LS:
   \        0x0   0x0010             DC16 16

   \                                 In section .rodata, at 0x800f006
   \   __absolute uint16_t const A_NOMINAL_CURRENT
   \                     A_NOMINAL_CURRENT:
   \        0x0   0x6A1E             DC16 27'166

   \                                 In section .rodata, at 0x800f008
   \   __absolute uint16_t const A_MAX_APPLICATION_SPEED_RPM
   \                     A_MAX_APPLICATION_SPEED_RPM:
   \        0x0   0x08CA             DC16 2'250

   \                                 In section .rodata, at 0x800f00a
   \   __absolute uint16_t const A_MIN_APPLICATION_SPEED_RPM
   \                     A_MIN_APPLICATION_SPEED_RPM:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f00c
   \   __absolute uint16_t const A_PLL_KP_GAIN
   \                     A_PLL_KP_GAIN:
   \        0x0   0x0214             DC16 532

   \                                 In section .rodata, at 0x800f00e
   \   __absolute uint16_t const A_PLL_KI_GAIN
   \                     A_PLL_KI_GAIN:
   \        0x0   0x0025             DC16 37

   \                                 In section .rodata, at 0x800f010
   \   __absolute uint16_t const A_PWM_FREQUENCY
   \                     A_PWM_FREQUENCY:
   \        0x0   0x2710             DC16 10'000

   \                                 In section .rodata, at 0x800f012
   \   __absolute uint16_t const A_PID_TORQUE_KP_DEFAULT
   \                     A_PID_TORQUE_KP_DEFAULT:
   \        0x0   0x0ECF             DC16 3'791

   \                                 In section .rodata, at 0x800f014
   \   __absolute uint16_t const A_PID_TORQUE_KI_DEFAULT
   \                     A_PID_TORQUE_KI_DEFAULT:
   \        0x0   0x0038             DC16 56

   \                                 In section .rodata, at 0x800f016
   \   __absolute uint16_t const A_PID_FLUX_KP_DEFAULT
   \                     A_PID_FLUX_KP_DEFAULT:
   \        0x0   0x14B7             DC16 5'303

   \                                 In section .rodata, at 0x800f018
   \   __absolute uint16_t const A_PID_FLUX_KI_DEFAULT
   \                     A_PID_FLUX_KI_DEFAULT:
   \        0x0   0x0038             DC16 56

   \                                 In section .rodata, at 0x800f01a
   \   __absolute uint16_t const A_PID_SPEED_KP_DEFAULT
   \                     A_PID_SPEED_KP_DEFAULT:
   \        0x0   0x0064             DC16 100

   \                                 In section .rodata, at 0x800f01c
   \   __absolute uint16_t const A_PID_SPEED_KI_DEFAULT
   \                     A_PID_SPEED_KI_DEFAULT:
   \        0x0   0x03E8             DC16 1'000

   \                                 In section .rodata, at 0x800f01e
   \   __absolute uint16_t const A_IQMAX
   \                     A_IQMAX:
   \        0x0   0x6A1E             DC16 27'166

   \                                 In section .rodata, at 0x800f020
   \   __absolute uint16_t const A_DEFAULT_CONTROL_MODE
   \                     A_DEFAULT_CONTROL_MODE:
   \        0x0   0x0001             DC16 1

   \                                 In section .rodata, at 0x800f022
   \   __absolute uint16_t const A_OV_VOLTAGE_THRESHOLD_V
   \                     A_OV_VOLTAGE_THRESHOLD_V:
   \        0x0   0x01EC             DC16 492

   \                                 In section .rodata, at 0x800f024
   \   __absolute uint16_t const A_UD_VOLTAGE_THRESHOLD_V
   \                     A_UD_VOLTAGE_THRESHOLD_V:
   \        0x0   0x00AF             DC16 175

   \                                 In section .rodata, at 0x800f026
   \   __absolute uint16_t const A_OV_TEMPERATURE_THRESHOLD_C
   \                     A_OV_TEMPERATURE_THRESHOLD_C:
   \        0x0   0x005F             DC16 95

   \                                 In section .rodata, at 0x800f028
   \   __absolute uint16_t const A_OV_TEMPERATURE_HYSTERESIS_C
   \                     A_OV_TEMPERATURE_HYSTERESIS_C:
   \        0x0   0x000A             DC16 10

   \                                 In section .rodata, at 0x800f02a
   \   __absolute uint16_t const A_PHASE1_DURATION
   \                     A_PHASE1_DURATION:
   \        0x0   0x03E8             DC16 1'000

   \                                 In section .rodata, at 0x800f02c
   \   __absolute uint16_t const A_PHASE1_FINAL_SPEED_UNIT
   \                     A_PHASE1_FINAL_SPEED_UNIT:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f02e
   \   __absolute uint16_t const A_PHASE1_FINAL_CURRENT
   \                     A_PHASE1_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f030
   \   __absolute uint16_t const A_PHASE2_DURATION
   \                     A_PHASE2_DURATION:
   \        0x0   0x1770             DC16 6'000

   \                                 In section .rodata, at 0x800f032
   \   __absolute uint16_t const A_PHASE2_FINAL_SPEED_UNIT
   \                     A_PHASE2_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f034
   \   __absolute uint16_t const A_PHASE2_FINAL_CURRENT
   \                     A_PHASE2_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f036
   \   __absolute uint16_t const A_PHASE3_DURATION
   \                     A_PHASE3_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f038
   \   __absolute uint16_t const A_PHASE3_FINAL_SPEED_UNIT
   \                     A_PHASE3_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f03a
   \   __absolute uint16_t const A_PHASE3_FINAL_CURRENT
   \                     A_PHASE3_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f03c
   \   __absolute uint16_t const A_PHASE4_DURATION
   \                     A_PHASE4_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f03e
   \   __absolute uint16_t const A_PHASE4_FINAL_SPEED_UNIT
   \                     A_PHASE4_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f040
   \   __absolute uint16_t const A_PHASE4_FINAL_CURRENT
   \                     A_PHASE4_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f042
   \   __absolute uint16_t const A_PHASE5_DURATION
   \                     A_PHASE5_DURATION:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f044
   \   __absolute uint16_t const A_PHASE5_FINAL_SPEED_UNIT
   \                     A_PHASE5_FINAL_SPEED_UNIT:
   \        0x0   0x00A6             DC16 166

   \                                 In section .rodata, at 0x800f046
   \   __absolute uint16_t const A_PHASE5_FINAL_CURRENT
   \                     A_PHASE5_FINAL_CURRENT:
   \        0x0   0x14F1             DC16 5'361

   \                                 In section .rodata, at 0x800f048
   \   __absolute uint16_t const A_TRANSITION_DURATION
   \                     A_TRANSITION_DURATION:
   \        0x0   0x01F4             DC16 500

   \                                 In section .rodata, at 0x800f04a
   \   __absolute uint16_t const D_HALL_SENSORS_PLACEMENT
   \                     D_HALL_SENSORS_PLACEMENT:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, at 0x800f04c
   \   __absolute uint16_t const D_HALL_PHASE_SHIFT
   \                     D_HALL_PHASE_SHIFT:
   \        0x0   0x012C             DC16 300

   \                                 In section .rodata, at 0x800f04e
   \   __absolute uint16_t const D_M1_ENCODER_PPR
   \                     D_M1_ENCODER_PPR:
   \        0x0   0x0190             DC16 400

   \                                 In section .rodata, at 0x800f050
   \   __absolute int16_t const A_GAIN1
   \                     A_GAIN1:
   \        0x0   0xA02E             DC16 -24'530

   \                                 In section .rodata, at 0x800f052
   \   __absolute int16_t const A_GAIN2
   \                     A_GAIN2:
   \        0x0   0x5EA3             DC16 24'227

   \                                 In section .bss, align 8
     19          //#include "mc_api.h"
     20          #include "driver_usart1.h"
     21          //#include "mc_config.h"
     22          #include "ab_module_Mc_StateMachine.h"
     23          #include "mc_tasks.h"
     24          #include "mc_type.h"
     25          
     26          extern ProcessInfo processInfoTable[];
     27          
     28          
     29          Usart1_Control* usart1Control_FlashUpdateCmd;
     30          
     31          typedef enum                                                            //data request cmd list
     32          {   //match universal protocol (group4)                                 //please assign according to the universal protocol document
     33            FlashBlkWr = 0x78,
     34            FlashBlkRd,
     35            FlashBlkControl
     36          }FlashUpdateCMD;
     37          
     38          typedef enum
     39          {
     40              ACK,                        //(this block good) Acknowledge
     41              resend,                     //bad block request to resend
     42              clrBlkTransfer,             //clear block transfer
     43              blkOverRun,                 //block over-run
     44              blkFlashUpdateSuccess,      //blk flash update success and request to reboot
     45              blkFlashUpdateFail,         //blk flash update fail and request to reboot
     46              rebootAck,                  //premission of reboot acknowledge from master 
     47              reqFlashFormat,             //flash data fromat request, number of block per sector, number of sector
     48              flashFormatResponse         //response of total number of blocks and block  per page  
     49          }FlashControlCMD;
     50          
     51          /****************flash write local variable ********************************/
     52          #define flashBlockSize 32
     53          //#define FLASH_PAGE_SIZE 0x800
     54          #define FLASH_BLOCK_SETTING_PAGE ADDR_FLASH_PAGE_30
     55          #define MIRROR_FLASH_BLOCK_SETTING_PAGE ADDR_FLASH_PAGE_31
     56          
     57          typedef enum
     58          {
     59            idle,
     60            copyCurrentSetting,           //copy current valid setting to buffer, and erase the actural flash setting sector
     61            burnPayload2Flash,            //burn data into flash sector and send back Ack for next block of data
     62            wait4NextBlock,               //wait for next block, Check block CRC if new block arrive
     63            finalFullCRC,                 //whole flash sector validation and prepare to restart
     64            
     65            finalValidFail,               //copy back the last valid flash setting in buffer and prepare to restart  
     66            flashProgrammingFail,         //any flash programming error will come here 
     67            AppSideRebootAck,             //send message to app-side and wait for reboot acknowledgement
     68            SystemReboot                  //Warm boot the system
     69          }flashBlkWrState;
     70          
     71          /** Module control struct 
     72              uint16_t flashBlockPt;              //store the last received frame flash block page number;
     73              flashBlkWrState flashWrState;       //Flash Block mode statemachine state-pointer 
     74              uint16_t error;                     //Error code: 0x01=> FlashPageCRCFail
     75                                                  //            0x02=> FlashPageEraseError
     76                                                  //            0x03=> FlashPageDataProgrammingError
     77          **/
     78          typedef struct
     79          {
     80            uint16_t flashBlockPt;        //store the last received frame flash block page number;
     81            flashBlkWrState flashWrState; 
     82            uint16_t error;
     83          }flashBlockWr_control;
     84           
     85          uint64_t tt_FlashFrameTimeOut;                                //
     86          #define FlashFrameTimeOutValue 2000000                          //Time out value between the last block Flash frame to the next frame
     87          /****************flash write local variable end*****************************/
     88          
     89          typedef enum  
     90          {
     91              INIT_APP,
     92              RUN_APP,
     93              CMDreply,
     94              // additional states to be added here as necessary.
     95              IRQ_APP = DEFAULT_IRQ_STATE,
     96              STOP_APP = KILL_APP
     97          }AppStates;
     98          
     99          Module_StateMachineControl*  module_StateMachineControl_FlashUpdateCmd;
    100          flashBlockWr_control flashBlockWrDat;
   \                     flashBlockWrDat:
   \        0x0                      DS8 8
   \        0x8                      DS8 1
    101          unsigned char* protocolBuf_FlashUpdateCmd ;
    102          //uint16_t _uwCRCValue;  /**@pam testing **/
    103          uint16_t blkCalculatedCRC; /**@pam testing **/
    104          AppStates   returnStage = INIT_APP;  
   \                     returnStage:
   \        0x9                      DS8 1
   \                     blkCalculatedCRC:
   \        0xA                      DS8 2
   \        0xC                      DS8 4
   \                     tt_FlashFrameTimeOut:
   \       0x10                      DS8 8
   \                     usart1Control_FlashUpdateCmd:
   \       0x18                      DS8 4
   \                     module_StateMachineControl_FlashUpdateCmd:
   \       0x1C                      DS8 4
   \                     protocolBuf_FlashUpdateCmd:
   \       0x20                      DS8 4

   \                                 In section .text, align 4, keep-with-next
    105          uint8_t moduleFlashUpdateCmd_u32(uint8_t module_id_u8, uint8_t prev_state_u8, uint8_t next_State_u8, uint8_t irq_id_u8)                
    106          { 
   \                     moduleFlashUpdateCmd_u32: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4605             MOV      R5,R0
    107            switch (next_State_u8)
   \        0x6   0x....'....        LDR.W    R4,??DataTable7
   \        0xA   0xB13A             CBZ.N    R2,??moduleFlashUpdateCmd_u32_0
   \        0xC   0x2A01             CMP      R2,#+1
   \        0xE   0xD01E             BEQ.N    ??moduleFlashUpdateCmd_u32_1
   \       0x10   0x2AC8             CMP      R2,#+200
   \       0x12   0xD01B             BEQ.N    ??moduleFlashUpdateCmd_u32_2
   \       0x14   0x2AFF             CMP      R2,#+255
   \       0x16   0xF000 0x80C3      BEQ.W    ??moduleFlashUpdateCmd_u32_3
   \       0x1A   0xE0C3             B.N      ??moduleFlashUpdateCmd_u32_4
    108              {
    109                case INIT_APP:                                                              //initial stage
    110                  {     
    111                    /*Attach Uart2 shared memory into this App*/
    112                    uint8_t Usart1index  = getProcessInfoIndex(MODULE_USART1);              //return Process index from processInfo array with the Uart2 driver
   \                     ??moduleFlashUpdateCmd_u32_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x....'....        BL       getProcessInfoIndex
    113                    usart1Control_FlashUpdateCmd = (Usart1_Control*) ((*(processInfoTable[Usart1index].Sched_ModuleData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x22   0x2516             MOVS     R5,#+22
   \       0x24   0x....'....        LDR.W    R6,??DataTable7_1
   \       0x28   0xF106 0x020B      ADD      R2,R6,#+11
   \       0x2C   0x4368             MULS     R0,R5,R0
   \       0x2E   0x5811             LDR      R1,[R2, R0]
   \       0x30   0x6808             LDR      R0,[R1, #+0]
   \       0x32   0x61A0             STR      R0,[R4, #+24]
    114                    uint8_t Mc_StateMachineindex  = getProcessInfoIndex(MODULE_MC_STATEMACHINE);              //return Process index from processInfo array with the MC_statemachine module
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0x....'....        BL       getProcessInfoIndex
    115                    module_StateMachineControl_FlashUpdateCmd = (Module_StateMachineControl*) ((*(processInfoTable[Mc_StateMachineindex].Sched_ModuleData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x3A   0xF106 0x010B      ADD      R1,R6,#+11
   \       0x3E   0xFB15 0xF500      SMULBB   R5,R5,R0
   \       0x42   0x5948             LDR      R0,[R1, R5]
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0x61E0             STR      R0,[R4, #+28]
    116          
    117                    flashBlockWrDat.flashWrState = idle;
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x70A1             STRB     R1,[R4, #+2]
   \                     ??moduleFlashUpdateCmd_u32_2: (+1)
   \       0x4C   0xE0A6             B.N      ??moduleFlashUpdateCmd_u32_5
    118                    returnStage = RUN_APP ;
    119                    break;
    120                  }       
    121                case RUN_APP:
    122                  { 
    123                    unsigned int DataLen2 = (unsigned int)UniHeaderlen;
   \                     ??moduleFlashUpdateCmd_u32_1: (+1)
   \       0x4E   0x2007             MOVS     R0,#+7
    124                    if(RingBuf_GetUsedNumOfElements((*usart1Control_FlashUpdateCmd).seqMemRXG4H_u32) >= DataLen2 )
   \       0x50   0x69A1             LDR      R1,[R4, #+24]
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x68C8             LDR      R0,[R1, #+12]
   \       0x56   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x5A   0x9A00             LDR      R2,[SP, #+0]
   \       0x5C   0x4601             MOV      R1,R0
   \       0x5E   0x78A0             LDRB     R0,[R4, #+2]
   \       0x60   0x4291             CMP      R1,R2
   \       0x62   0xF0C0 0x8097      BCC.W    ??moduleFlashUpdateCmd_u32_6
    125                    {  
    126                     
    127                      
    128                      /***-------------------------- pre-determine what state is in for Rx data is valid or not valid between blockmode transfer ------------------------**/
    129                      switch(flashBlockWrDat.flashWrState)
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xBF1C             ITT      NE
   \       0x6A   0x2803             CMPNE    R0,#+3
   \       0x6C   0x2807             CMPNE    R0,#+7
   \       0x6E   0xD123             BNE.N    ??moduleFlashUpdateCmd_u32_7
    130                      {
    131                        case idle:
    132                        case wait4NextBlock: 
    133                        case AppSideRebootAck: 
    134                          {   //Error if new frame happen in between the stateMachine process!!!!!
    135                              if((protocolBuf_FlashUpdateCmd = (unsigned char*) realloc(protocolBuf_FlashUpdateCmd,DataLen2)) == NULL) reallocError++;     
   \       0x70   0x6A20             LDR      R0,[R4, #+32]
   \       0x72   0x4611             MOV      R1,R2
   \       0x74   0x....'....        BL       realloc
   \       0x78   0x0001             MOVS     R1,R0
   \       0x7A   0xD102             BNE.N    ??moduleFlashUpdateCmd_u32_8
   \       0x7C   0x7A20             LDRB     R0,[R4, #+8]
   \       0x7E   0x1C40             ADDS     R0,R0,#+1
   \       0x80   0x7220             STRB     R0,[R4, #+8]
    136                              RingBuf_Observe((*usart1Control_FlashUpdateCmd).seqMemRXG4H_u32, protocolBuf_FlashUpdateCmd, 0, &DataLen2);  
   \                     ??moduleFlashUpdateCmd_u32_8: (+1)
   \       0x82   0x6221             STR      R1,[R4, #+32]
   \       0x84   0x466B             MOV      R3,SP
   \       0x86   0x69A0             LDR      R0,[R4, #+24]
   \       0x88   0x68C0             LDR      R0,[R0, #+12]
   \       0x8A   0x2200             MOVS     R2,#+0
   \       0x8C   0x....'....        BL       RingBuf_Observe
    137                              //calculate the total number of frame
    138                              DataLen2 = ((unsigned int)protocolBuf_FlashUpdateCmd[1] & 0x3F) + (unsigned int)UniHeaderlen;
   \       0x90   0x6A20             LDR      R0,[R4, #+32]
   \       0x92   0x7841             LDRB     R1,[R0, #+1]
   \       0x94   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x98   0x1DC9             ADDS     R1,R1,#+7
   \       0x9A   0x9100             STR      R1,[SP, #+0]
    139                              if((protocolBuf_FlashUpdateCmd = (unsigned char*) realloc(protocolBuf_FlashUpdateCmd,DataLen2)) == NULL) reallocError++;     //allocate the right frame size of memory for buffer
   \       0x9C   0x....'....        BL       realloc
   \       0xA0   0xB910             CBNZ.N   R0,??moduleFlashUpdateCmd_u32_9
   \       0xA2   0x7A21             LDRB     R1,[R4, #+8]
   \       0xA4   0x1C49             ADDS     R1,R1,#+1
   \       0xA6   0x7221             STRB     R1,[R4, #+8]
    140                              RingBuf_ReadBlock((*usart1Control_FlashUpdateCmd).seqMemRXG4H_u32, protocolBuf_FlashUpdateCmd, &DataLen2); //extract the whole frame
   \                     ??moduleFlashUpdateCmd_u32_9: (+1)
   \       0xA8   0x6220             STR      R0,[R4, #+32]
   \       0xAA   0x4601             MOV      R1,R0
   \       0xAC   0x69A0             LDR      R0,[R4, #+24]
   \       0xAE   0x68C0             LDR      R0,[R0, #+12]
   \       0xB0   0x466A             MOV      R2,SP
   \       0xB2   0x....'....        BL       RingBuf_ReadBlock
    141                              break;
   \       0xB6   0xE00F             B.N      ??moduleFlashUpdateCmd_u32_10
    142                          }
    143                        
    144                        default:
    145                          {
    146                              RingBuf_ClearContents((*usart1Control_FlashUpdateCmd).seqMemRXG4H_u32); //clear all content in buffer   
   \                     ??moduleFlashUpdateCmd_u32_7: (+1)
   \       0xB8   0x69A0             LDR      R0,[R4, #+24]
   \       0xBA   0x68C0             LDR      R0,[R0, #+12]
   \       0xBC   0x....'....        BL       RingBuf_ClearContents
    147                              //send error message to sender
    148                              unsigned char FlashBlkErrorOverun[] = {0x55, 0x01, FlashBlkControl, 0x00, 0x00, 0x04, 0xCC, 0xCC}; //block over-run error
   \       0xC0   0x....'....        ADR.W    R1,?_1
   \       0xC4   0xA802             ADD      R0,SP,#+8
   \       0xC6   0x....'....        BL       ?Subroutine1
    149                              unsigned int TxLen = sizeof(FlashBlkErrorOverun);
    150                              RingBuf_WriteBlock((*usart1Control_FlashUpdateCmd).seqMemTX_u32, FlashBlkErrorOverun, &TxLen); 
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0xCA   0x2608             MOVS     R6,#+8
   \       0xCC   0x9601             STR      R6,[SP, #+4]
   \       0xCE   0xAA01             ADD      R2,SP,#+4
   \       0xD0   0x6900             LDR      R0,[R0, #+16]
   \       0xD2   0xA902             ADD      R1,SP,#+8
   \       0xD4   0x....'....        BL       RingBuf_WriteBlock
    151                              break;
    152                          }
    153                      }
    154                      /**-------------------------------------------- decode and perform the CMD function ------------------------------------------------**/
    155                      switch((FlashUpdateCMD)protocolBuf_FlashUpdateCmd[2])
   \                     ??moduleFlashUpdateCmd_u32_10: (+1)
   \       0xD8   0x6A22             LDR      R2,[R4, #+32]
   \       0xDA   0x7890             LDRB     R0,[R2, #+2]
   \       0xDC   0x2878             CMP      R0,#+120
   \       0xDE   0xD004             BEQ.N    ??moduleFlashUpdateCmd_u32_11
   \       0xE0   0xD35C             BCC.N    ??moduleFlashUpdateCmd_u32_5
   \       0xE2   0x287A             CMP      R0,#+122
   \       0xE4   0xD037             BEQ.N    ??moduleFlashUpdateCmd_u32_12
   \       0xE6   0xD32D             BCC.N    ??moduleFlashUpdateCmd_u32_13
   \       0xE8   0xE058             B.N      ??moduleFlashUpdateCmd_u32_5
    156                      {
    157                        case FlashBlkWr: 
    158                          { //Flash block write
    159                            if((flashBlockWrDat.flashWrState == idle) || ( flashBlockWrDat.flashWrState == wait4NextBlock)) { //not start                    
   \                     ??moduleFlashUpdateCmd_u32_11: (+1)
   \       0xEA   0x78A0             LDRB     R0,[R4, #+2]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xBF18             IT       NE
   \       0xF0   0x2803             CMPNE    R0,#+3
   \       0xF2   0xD153             BNE.N    ??moduleFlashUpdateCmd_u32_5
    160                              uint16_t BlkCRCValue = (((uint16_t)protocolBuf_FlashUpdateCmd[flashBlockSize+7]) << 8) + ((uint16_t)protocolBuf_FlashUpdateCmd[flashBlockSize+8]) ;
   \       0xF4   0xF102 0x0027      ADD      R0,R2,#+39
   \       0xF8   0x7801             LDRB     R1,[R0, #+0]
   \       0xFA   0x7840             LDRB     R0,[R0, #+1]
   \       0xFC   0xEB00 0x2601      ADD      R6,R0,R1, LSL #+8
    161                              blkCalculatedCRC = Calculate_CRC( flashBlockSize , (unsigned char*)&protocolBuf_FlashUpdateCmd[7]);                                       //Get calculated CRC of this block
   \      0x100   0x1DD1             ADDS     R1,R2,#+7
   \      0x102   0x2020             MOVS     R0,#+32
   \      0x104   0x....'....        BL       Calculate_CRC
    162                              if(blkCalculatedCRC != BlkCRCValue)
   \      0x108   0xB2B6             UXTH     R6,R6
   \      0x10A   0x6A21             LDR      R1,[R4, #+32]
   \      0x10C   0x8160             STRH     R0,[R4, #+10]
   \      0x10E   0x42B0             CMP      R0,R6
   \      0x110   0xD00D             BEQ.N    ??moduleFlashUpdateCmd_u32_14
    163                              { //CRC not match   means  error in receiving block, call for resend this block
    164                                unsigned char FlashBlkErrorResend[] = {0x55, 0x03, FlashBlkControl, 0x00, 0x00, 0x01, protocolBuf_FlashUpdateCmd[5], protocolBuf_FlashUpdateCmd[6], 0xCC, 0xCC}; //request resend the same block again
   \      0x112   0x....'....        ADR.W    R2,?_3
   \      0x116   0xE892 0x0068      LDM      R2,{R3,R5,R6}
   \      0x11A   0xA802             ADD      R0,SP,#+8
   \      0x11C   0xE880 0x0068      STM      R0,{R3,R5,R6}
   \      0x120   0x794F             LDRB     R7,[R1, #+5]
   \      0x122   0x7187             STRB     R7,[R0, #+6]
   \      0x124   0x7989             LDRB     R1,[R1, #+6]
   \      0x126   0x71C1             STRB     R1,[R0, #+7]
    165                                unsigned int TxLen = sizeof(FlashBlkErrorResend);
   \      0x128   0x200A             MOVS     R0,#+10
   \      0x12A   0x9001             STR      R0,[SP, #+4]
    166                                RingBuf_WriteBlock((*usart1Control_FlashUpdateCmd).seqMemTX_u32, FlashBlkErrorResend, &TxLen); 
   \      0x12C   0xE02B             B.N      ??moduleFlashUpdateCmd_u32_15
    167                              } 
    168                              else{
    169                                flashBlockWrDat.flashBlockPt = (((uint16_t) protocolBuf_FlashUpdateCmd[5]) << 8) + ((uint16_t)protocolBuf_FlashUpdateCmd[6]); //store the current block number
   \                     ??moduleFlashUpdateCmd_u32_14: (+1)
   \      0x12E   0x7948             LDRB     R0,[R1, #+5]
   \      0x130   0x7989             LDRB     R1,[R1, #+6]
   \      0x132   0xEB01 0x2100      ADD      R1,R1,R0, LSL #+8
    170                                flashBlockWrDat.flashWrState = copyCurrentSetting;                                      //prepare flash for new settings
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0x70A0             STRB     R0,[R4, #+2]
   \      0x13A   0x8021             STRH     R1,[R4, #+0]
    171                                (*module_StateMachineControl_FlashUpdateCmd).command_Speed = 0;                   //stop motor
   \      0x13C   0x2200             MOVS     R2,#+0
   \      0x13E   0x69E0             LDR      R0,[R4, #+28]
   \      0x140   0x6002             STR      R2,[R0, #+0]
    172                                flashBlkWriteStateMachine_Run(module_id_u8);                                      //start up block flash update stateMachine
   \      0x142   0xE028             B.N      ??moduleFlashUpdateCmd_u32_16
    173                              } 
    174                            }
    175          //                else {   //shouldn't run to this line, if so something wrong!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! }
    176                            break;
    177                          }
    178                        case FlashBlkRd: 
    179                          { //Flash block read
    180                            uint16_t flashBlkNum = ((uint16_t )protocolBuf_FlashUpdateCmd[5]) << 8 ;
    181                            unsigned char* rdFlashBuf = (unsigned char*)FLASH_BLOCK_SETTING_PAGE;
    182                            flashTxBlk(flashBlkNum + protocolBuf_FlashUpdateCmd[6], rdFlashBuf);
   \                     ??moduleFlashUpdateCmd_u32_13: (+1)
   \      0x144   0x7950             LDRB     R0,[R2, #+5]
   \      0x146   0x7992             LDRB     R2,[R2, #+6]
   \      0x148   0x....             LDR.N    R1,??DataTable7_2  ;; 0x800f000
   \      0x14A   0xEB02 0x2000      ADD      R0,R2,R0, LSL #+8
   \      0x14E   0xB280             UXTH     R0,R0
   \      0x150   0x....'....        BL       flashTxBlk
    183                                            
    184                            break;
   \      0x154   0xE022             B.N      ??moduleFlashUpdateCmd_u32_5
    185                          }
    186                        case FlashBlkControl: 
    187                          { 
    188                            switch((FlashControlCMD)protocolBuf_FlashUpdateCmd[5])
   \                     ??moduleFlashUpdateCmd_u32_12: (+1)
   \      0x156   0x7950             LDRB     R0,[R2, #+5]
   \      0x158   0x2806             CMP      R0,#+6
   \      0x15A   0xD002             BEQ.N    ??moduleFlashUpdateCmd_u32_17
   \      0x15C   0x2807             CMP      R0,#+7
   \      0x15E   0xD006             BEQ.N    ??moduleFlashUpdateCmd_u32_18
   \      0x160   0xE01C             B.N      ??moduleFlashUpdateCmd_u32_5
    189                            {
    190                              case rebootAck:                   //premission of reboot acknowledge from master 
    191                                { //Flash block Ack/Nack resend
    192                                  if(flashBlockWrDat.flashWrState == AppSideRebootAck) {
   \                     ??moduleFlashUpdateCmd_u32_17: (+1)
   \      0x162   0x78A1             LDRB     R1,[R4, #+2]
   \      0x164   0x2907             CMP      R1,#+7
   \      0x166   0xD119             BNE.N    ??moduleFlashUpdateCmd_u32_5
    193                                    flashBlockWrDat.flashWrState = SystemReboot; 
   \      0x168   0x2008             MOVS     R0,#+8
   \      0x16A   0x70A0             STRB     R0,[R4, #+2]
    194                                    flashBlkWriteStateMachine_Run(module_id_u8);
   \      0x16C   0xE013             B.N      ??moduleFlashUpdateCmd_u32_16
    195                                  }
    196                                  break;
    197                                }
    198                              case reqFlashFormat:              //flash data format request, number of block per sector, number of sector
    199                                { //Response for the flash data format 
    200                                  unsigned char blkPerSector = FLASH_PAGE_SIZE/flashBlockSize;
    201                                  unsigned char FlashBlkFormat[] = {0x55, 0x03, FlashBlkControl, 0x00, 0x00, 0x09, blkPerSector, 0x01, 0xcc, 0xcc};
   \                     ??moduleFlashUpdateCmd_u32_18: (+1)
   \      0x16E   0xBF00             Nop
   \      0x170   0x....             ADR.N    R1,?_4
   \      0x172   0xE891 0x002C      LDM      R1,{R2,R3,R5}
   \      0x176   0xA802             ADD      R0,SP,#+8
   \      0x178   0x2640             MOVS     R6,#+64
   \      0x17A   0xE880 0x002C      STM      R0,{R2,R3,R5}
    202                                  unsigned int TxLen = sizeof(FlashBlkFormat);
   \      0x17E   0x210A             MOVS     R1,#+10
   \      0x180   0xF88D 0x600E      STRB     R6,[SP, #+14]
   \      0x184   0x9101             STR      R1,[SP, #+4]
    203                                  RingBuf_WriteBlock((*usart1Control_FlashUpdateCmd).seqMemTX_u32, FlashBlkFormat, &TxLen); 
   \                     ??moduleFlashUpdateCmd_u32_15: (+1)
   \      0x186   0xAA01             ADD      R2,SP,#+4
   \      0x188   0x69A0             LDR      R0,[R4, #+24]
   \      0x18A   0x6900             LDR      R0,[R0, #+16]
   \      0x18C   0xA902             ADD      R1,SP,#+8
   \      0x18E   0x....'....        BL       RingBuf_WriteBlock
    204                                  break;
   \      0x192   0xE003             B.N      ??moduleFlashUpdateCmd_u32_5
    205                                }     
    206                            }
    207                            break;
    208                          }   
    209                        default:
    210                          break;
    211                      }
    212                    }
    213                    else
    214                    {
    215                      if(flashBlockWrDat.flashWrState != idle) flashBlkWriteStateMachine_Run(module_id_u8);  //still in block flash stateMachine 
   \                     ??moduleFlashUpdateCmd_u32_6: (+1)
   \      0x194   0xB110             CBZ.N    R0,??moduleFlashUpdateCmd_u32_5
   \                     ??moduleFlashUpdateCmd_u32_16: (+1)
   \      0x196   0x4628             MOV      R0,R5
   \      0x198   0x....'....        BL       flashBlkWriteStateMachine_Run
    216                    }
    217                //    if((protocolBuf_FlashUpdateCmd = (unsigned char*) realloc(protocolBuf_FlashUpdateCmd,1)) == NULL) reallocError++;  
    218                    returnStage = RUN_APP;
    219                    break;
    220                  }
    221                case IRQ_APP:
    222                  {
    223                    //if more than 1 driver interrupt attached to this APP
    224          //           uint8_t index = getProcessInfoIndex(interruptIdentfer);         //return Process index from processInfo array of the driver interrupt call, APP can response respectively
    225                    returnStage = RUN_APP;
   \                     ??moduleFlashUpdateCmd_u32_5: (+1)
   \      0x19C   0x2001             MOVS     R0,#+1
    226                    break;
   \      0x19E   0xE002             B.N      ??moduleFlashUpdateCmd_u32_19
    227                  }               
    228                case STOP_APP:
    229                  {
    230                    returnStage = INIT_APP;
   \                     ??moduleFlashUpdateCmd_u32_3: (+1)
   \      0x1A0   0x2000             MOVS     R0,#+0
    231                    break;
   \      0x1A2   0xE000             B.N      ??moduleFlashUpdateCmd_u32_19
    232                  }
    233                default:
    234                  returnStage = STOP_APP;   
   \                     ??moduleFlashUpdateCmd_u32_4: (+1)
   \      0x1A4   0x20FF             MOVS     R0,#+255
    235              }
    236            return returnStage;
   \                     ??moduleFlashUpdateCmd_u32_19: (+1)
   \      0x1A6   0x7260             STRB     R0,[R4, #+9]
   \      0x1A8   0xB005             ADD      SP,SP,#+20
   \      0x1AA   0xBDF0             POP      {R4-R7,PC}       ;; return
    237          }             

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \        0x4   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \        0x8   0x69A0             LDR      R0,[R4, #+24]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x55 0x03          DC8 85, 3, 122, 0, 0, 1, 0, 0, 204, 204

   \              0x7A 0x00    

   \              0x00 0x01    

   \              0x00 0x00    

   \              0xCC 0xCC
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x55 0x03          DC8 85, 3, 122, 0, 0, 9, 0, 1, 204, 204

   \              0x7A 0x00    

   \              0x00 0x09    

   \              0x00 0x01    

   \              0xCC 0xCC
   \        0xA                      DS8 2
    238          
    239          
    240          /** @section below -------------------------------------------------- All Local stateMachine functions (below this line)------------------------------------------------------------------
    241            * @author  Pamela Lee
    242            * @date    12 Jan 2021
    243            * @version 1.0
    244            * @brief   Contain all the stateMachine functions for each of the Flash setting and register mode
    245            *---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    246          **/

   \                                 In section .text, align 4, keep-with-next
    247          uint8_t flashBlkWriteStateMachine_Run(uint8_t _module_id_u8)                    
    248          {
   \                     flashBlkWriteStateMachine_Run: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    249            switch((flashBlkWrState)flashBlockWrDat.flashWrState)
   \        0x2   0x....             LDR.N    R4,??DataTable7
   \        0x4   0x....             LDR.N    R6,??DataTable7_2  ;; 0x800f000
   \        0x6   0x....             LDR.N    R7,??DataTable7_3  ;; 0x800f800
   \        0x8   0x4605             MOV      R5,R0
   \        0xA   0x78A0             LDRB     R0,[R4, #+2]
   \        0xC   0x1E40             SUBS     R0,R0,#+1
   \        0xE   0x2807             CMP      R0,#+7
   \       0x10   0xB084             SUB      SP,SP,#+16
   \       0x12   0xF200 0x809E      BHI.W    ??flashBlkWriteStateMachine_Run_1
   \       0x16   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??flashBlkWriteStateMachine_Run_0:
   \       0x1A   0x04 0x1F          DC8      0x4,0x1F,0x4E,0x60

   \              0x4E 0x60
   \       0x1E   0x79 0x8B          DC8      0x79,0x8B,0x72,0x8F

   \              0x72 0x8F
    250            {
    251              case copyCurrentSetting:
    252                { //copy current valid setting to buffer, and erase the actural flash setting sector
    253                  uint16_t tmprydat = ((((((uint16_t)protocolBuf_FlashUpdateCmd[5]) << 8) + protocolBuf_FlashUpdateCmd[6])+1) * flashBlockSize);
    254                  if ( tmprydat == FLASH_PAGE_SIZE)  //block flash will only erase the sector when receive the last block(so always start with the last block(in the 32byte per block of 2ksector size will be block63)
   \                     ??flashBlkWriteStateMachine_Run_2: (+1)
   \       0x22   0x6A20             LDR      R0,[R4, #+32]
   \       0x24   0x7941             LDRB     R1,[R0, #+5]
   \       0x26   0x7980             LDRB     R0,[R0, #+6]
   \       0x28   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \       0x2C   0x1C40             ADDS     R0,R0,#+1
   \       0x2E   0x0540             LSLS     R0,R0,#+21
   \       0x30   0x0C00             LSRS     R0,R0,#+16
   \       0x32   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x36   0xD10D             BNE.N    ??CrossCallReturnLabel_1
    255                  {
    256                    /*********************** backup the last known setting into the Mirror flash page *********************************/
    257                    if(!flashPageErase(_module_id_u8, MIRROR_FLASH_BLOCK_SETTING_PAGE))
   \       0x38   0x4639             MOV      R1,R7
   \       0x3A   0x....'....        BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine0
    258                    {  //Sector erase error
    259                        flashBlockWrDat.error = 0x02;                         //Error code: 0x02=> FlashPageEraseError
    260                        flashBlockWrDat.flashWrState = flashProgrammingFail;  //if error the Flash driver should already report it
    261                    }  
    262                    flashPageCopy(_module_id_u8, FLASH_BLOCK_SETTING_PAGE, MIRROR_FLASH_BLOCK_SETTING_PAGE);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x42   0x463A             MOV      R2,R7
   \       0x44   0x4631             MOV      R1,R6
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x....'....        BL       flashPageCopy
    263                    /** after backup the last known setting then erase the new setting page area **/
    264                    if(!flashPageErase(_module_id_u8, FLASH_BLOCK_SETTING_PAGE))
   \       0x4C   0x....'....        BL       ?Subroutine2
    265                    {  //Sector erase error
    266                        flashBlockWrDat.error = 0x02;                         //Error code: 0x02=> FlashPageEraseError
    267                        flashBlockWrDat.flashWrState = flashProgrammingFail;  //if error the Flash driver should already report it
    268                    }            
    269                  }
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x50   0x....'....        BL       ?Subroutine0
    270                  flashBlockWrDat.flashWrState = burnPayload2Flash;       //seccuss proceed to burn data into flash state
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0xE051             B.N      ??flashBlkWriteStateMachine_Run_3
    271                  break;
    272                }
    273              case burnPayload2Flash:
    274                { //burn data into flash sector and send back Ack for next block of data, and free up protocolBuf_FlashUpdateCmd for next block
    275                  uint32_t block_address = (FLASH_BLOCK_SETTING_PAGE+(flashBlockSize * ((((uint16_t)protocolBuf_FlashUpdateCmd[5]) << 8) + protocolBuf_FlashUpdateCmd[6]))) ;
    276                  if(!flashBlockProgram(_module_id_u8, block_address,  (uint8_t*)&protocolBuf_FlashUpdateCmd[7], flashBlockSize))
   \                     ??flashBlkWriteStateMachine_Run_4: (+1)
   \       0x58   0x6A20             LDR      R0,[R4, #+32]
   \       0x5A   0x7941             LDRB     R1,[R0, #+5]
   \       0x5C   0x1DC2             ADDS     R2,R0,#+7
   \       0x5E   0x7980             LDRB     R0,[R0, #+6]
   \       0x60   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \       0x64   0xEB06 0x1140      ADD      R1,R6,R0, LSL #+5
   \       0x68   0x2320             MOVS     R3,#+32
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x....'....        BL       flashBlockProgram
   \       0x70   0xB910             CBNZ.N   R0,??flashBlkWriteStateMachine_Run_5
    277                  {   //Block programming flash error
    278                      flashBlockWrDat.error = 0x03;                         //Error code: 0x03=> FlashPageDataProgrammingError
   \       0x72   0x2003             MOVS     R0,#+3
   \       0x74   0x80A0             STRH     R0,[R4, #+4]
    279                      flashBlockWrDat.flashWrState = flashProgrammingFail;  //if error the Flash driver should already report it
   \       0x76   0xE058             B.N      ??flashBlkWriteStateMachine_Run_6
    280                  }
    281                  else
    282                  {
    283                      unsigned char FlashBlkErrorResend[] = {0x55, 0x03, FlashBlkControl, 0x00, 0x00, 0x00, protocolBuf_FlashUpdateCmd[5], protocolBuf_FlashUpdateCmd[6], 0xCC, 0xCC}; //Ack the last block number to sender for requesting next block 
   \                     ??flashBlkWriteStateMachine_Run_5: (+1)
   \       0x78   0x....             ADR.N    R1,?_5
   \       0x7A   0xE891 0x002C      LDM      R1,{R2,R3,R5}
   \       0x7E   0xA801             ADD      R0,SP,#+4
   \       0x80   0xA901             ADD      R1,SP,#+4
   \       0x82   0xE880 0x002C      STM      R0,{R2,R3,R5}
   \       0x86   0x6A20             LDR      R0,[R4, #+32]
   \       0x88   0x7942             LDRB     R2,[R0, #+5]
   \       0x8A   0x718A             STRB     R2,[R1, #+6]
    284                      unsigned int TxLen = sizeof(FlashBlkErrorResend);
    285                      RingBuf_WriteBlock((*usart1Control_FlashUpdateCmd).seqMemTX_u32, FlashBlkErrorResend, &TxLen); 
   \       0x8C   0x466A             MOV      R2,SP
   \       0x8E   0x7980             LDRB     R0,[R0, #+6]
   \       0x90   0x71C8             STRB     R0,[R1, #+7]
   \       0x92   0x210A             MOVS     R1,#+10
   \       0x94   0x69A0             LDR      R0,[R4, #+24]
   \       0x96   0x9100             STR      R1,[SP, #+0]
   \       0x98   0xA901             ADD      R1,SP,#+4
   \       0x9A   0x6900             LDR      R0,[R0, #+16]
   \       0x9C   0x....'....        BL       RingBuf_WriteBlock
    286                      flashBlockWrDat.flashWrState = wait4NextBlock;     //all done with this block proceed to wait for next block
   \       0xA0   0x2003             MOVS     R0,#+3
   \       0xA2   0x70A0             STRB     R0,[R4, #+2]
    287                      tt_FlashFrameTimeOut = getSysCount() + FlashFrameTimeOutValue;                          //setup timeout period  **/
   \       0xA4   0x....'....        BL       getSysCount
   \       0xA8   0x....             LDR.N    R2,??DataTable7_4  ;; 0x1e8480
   \       0xAA   0x2300             MOVS     R3,#+0
   \       0xAC   0x1880             ADDS     R0,R0,R2
   \       0xAE   0x4159             ADCS     R1,R1,R3
   \       0xB0   0xE9C4 0x0104      STRD     R0,R1,[R4, #+16]
   \       0xB4   0xE023             B.N      ??flashBlkWriteStateMachine_Run_7
    288                  }
    289                  break;
    290                }
    291              case wait4NextBlock:
    292                { //wait for next block or the last block is block zero(final block) , Check block CRC if new block arrive
    293                  if (!(protocolBuf_FlashUpdateCmd[5] || protocolBuf_FlashUpdateCmd[6])) /** check this is the final block**/
   \                     ??flashBlkWriteStateMachine_Run_8: (+1)
   \       0xB6   0x6A21             LDR      R1,[R4, #+32]
   \       0xB8   0x7948             LDRB     R0,[R1, #+5]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xBF01             ITTTT    EQ
   \       0xBE   0x7988             LDRBEQ   R0,[R1, #+6]
   \       0xC0   0x2800             CMPEQ    R0,#+0
   \       0xC2   0x2104             MOVEQ    R1,#+4
   \       0xC4   0x70A1             STRBEQ   R1,[R4, #+2]
    294                  {       //final block
    295                    flashBlockWrDat.flashWrState = finalFullCRC;
    296                  }
    297                  //loop here and waiting for next block, if timeout then fault it
    298                  if (getSysCount() >= tt_FlashFrameTimeOut)   // for timeout check**/  
   \       0xC6   0x....'....        BL       getSysCount
   \       0xCA   0xE9D4 0x2304      LDRD     R2,R3,[R4, #+16]
   \       0xCE   0x4299             CMP      R1,R3
   \       0xD0   0xD315             BCC.N    ??flashBlkWriteStateMachine_Run_7
   \       0xD2   0xD819             BHI.N    ??flashBlkWriteStateMachine_Run_9
   \       0xD4   0x4290             CMP      R0,R2
   \       0xD6   0xD312             BCC.N    ??flashBlkWriteStateMachine_Run_7
    299                  {  //Flash frame waiting time out
    300                    flashBlockWrDat.flashWrState = flashProgrammingFail;          
   \       0xD8   0xE016             B.N      ??flashBlkWriteStateMachine_Run_9
    301                  }
    302                  //before timeout happen, just do nothing for the next flashBlockWrDat.flashWrState will remain the same to loop here
    303                  break;
    304                }
    305              case finalFullCRC:
    306                { //send flash block setting update successfully to app-side, whole flash sector validation and prepare to restart
    307                  if(isFlashCRCValid(FLASH_BLOCK_SETTING_PAGE, 1))
   \                     ??flashBlkWriteStateMachine_Run_10: (+1)
   \       0xDA   0x2101             MOVS     R1,#+1
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0x....'....        BL       isFlashCRCValid
   \       0xE2   0xB178             CBZ.N    R0,??flashBlkWriteStateMachine_Run_11
    308                  {   //send update successfully message to App-side
    309                      unsigned char FlashBlkSuccessRebootReq[] = {0x55, 0x01, FlashBlkControl, 0x00, 0x00, 0x05, 0xCC, 0xCC}; //setting update seccuss, request for reboot
   \       0xE4   0x....             ADR.N    R1,?_2
   \       0xE6   0xA801             ADD      R0,SP,#+4
   \       0xE8   0x....'....        BL       ?Subroutine1
    310                      unsigned int TxLen = sizeof(FlashBlkSuccessRebootReq);
    311                      RingBuf_WriteBlock((*usart1Control_FlashUpdateCmd).seqMemTX_u32, FlashBlkSuccessRebootReq, &TxLen); 
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xEC   0x2508             MOVS     R5,#+8
   \       0xEE   0x9500             STR      R5,[SP, #+0]
   \       0xF0   0x466A             MOV      R2,SP
   \       0xF2   0x6900             LDR      R0,[R0, #+16]
   \       0xF4   0xA901             ADD      R1,SP,#+4
   \       0xF6   0x....'....        BL       RingBuf_WriteBlock
    312                      flashBlockWrDat.flashWrState = AppSideRebootAck; //successfully update whole page and proceed to wait APP-Side to validate the reboot 
   \       0xFA   0x2007             MOVS     R0,#+7
   \                     ??flashBlkWriteStateMachine_Run_3: (+1)
   \       0xFC   0x70A0             STRB     R0,[R4, #+2]
    313                  }
    314                  else
    315                  {
    316                    flashBlockWrDat.error = 0x01;                        //Error code: 0x01=> FlashPageCRCFail
    317                    flashBlockWrDat.flashWrState = flashProgrammingFail; //fail the block CRC       
    318                  }
    319                  break;
    320                }
    321              case finalValidFail:  
    322                { //copy back the last valid flash setting in buffer and prepare to restart    
    323                  if(isFlashCRCValid(MIRROR_FLASH_BLOCK_SETTING_PAGE, 1))         //check the mirror/buffer is still valid or not 
    324                  {
    325                    if(flashPageErase(_module_id_u8, FLASH_BLOCK_SETTING_PAGE))           //Erase main setting flash page again
    326                    {  //copy Mirror page back to main flash page
    327                      flashPageCopy(_module_id_u8, MIRROR_FLASH_BLOCK_SETTING_PAGE, FLASH_BLOCK_SETTING_PAGE);
    328                      flashBlockWrDat.flashWrState = AppSideRebootAck;
    329                    } 
    330                  }
    331                  flashBlockWrDat.flashWrState = flashProgrammingFail;  //if error the Flash driver should already report it
    332                  break;
    333                }
    334              case flashProgrammingFail:
    335                { //any flash programming error that cannot recovered will come here 
    336                  /** Make sure the motor has stopped before disable the motor **/
    337                  (*module_StateMachineControl_FlashUpdateCmd).motorEnable = FALSE;       //disable the motor if flash setting completely fail 
    338                  
    339                  break;
    340                }
    341              case AppSideRebootAck:
    342                {
    343                  //this state just for loop aand wait for acknowledge!!
    344                  break;
    345                }
    346              case SystemReboot:
    347                {
    348                  /**@Caution System will be warm boot after this line, make sure store everything necessary before this line **/
    349                  __NVIC_SystemReset();     
    350                  break;
    351                }
    352              default:
    353                {
    354                  flashBlockWrDat.flashWrState = idle;
    355                  break;  
    356                }
    357            }  
    358            return 0;
   \                     ??flashBlkWriteStateMachine_Run_7: (+1)
   \       0xFE   0x2000             MOVS     R0,#+0
   \      0x100   0xB005             ADD      SP,SP,#+20
   \      0x102   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??flashBlkWriteStateMachine_Run_11: (+1)
   \      0x104   0x2001             MOVS     R0,#+1
   \      0x106   0x80A0             STRH     R0,[R4, #+4]
   \                     ??flashBlkWriteStateMachine_Run_9: (+1)
   \      0x108   0x2006             MOVS     R0,#+6
   \      0x10A   0xE7F7             B.N      ??flashBlkWriteStateMachine_Run_3
   \                     ??flashBlkWriteStateMachine_Run_12: (+1)
   \      0x10C   0x2101             MOVS     R1,#+1
   \      0x10E   0x4638             MOV      R0,R7
   \      0x110   0x....'....        BL       isFlashCRCValid
   \      0x114   0xB148             CBZ.N    R0,??flashBlkWriteStateMachine_Run_6
   \      0x116   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x11A   0xB130             CBZ.N    R0,??flashBlkWriteStateMachine_Run_6
   \      0x11C   0x4632             MOV      R2,R6
   \      0x11E   0x4639             MOV      R1,R7
   \      0x120   0x4628             MOV      R0,R5
   \      0x122   0x....'....        BL       flashPageCopy
   \      0x126   0x2007             MOVS     R0,#+7
   \      0x128   0x70A0             STRB     R0,[R4, #+2]
   \                     ??flashBlkWriteStateMachine_Run_6: (+1)
   \      0x12A   0x2106             MOVS     R1,#+6
   \                     ??flashBlkWriteStateMachine_Run_13: (+1)
   \      0x12C   0x70A1             STRB     R1,[R4, #+2]
   \      0x12E   0xE7E6             B.N      ??flashBlkWriteStateMachine_Run_7
   \                     ??flashBlkWriteStateMachine_Run_14: (+1)
   \      0x130   0x69E1             LDR      R1,[R4, #+28]
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x7148             STRB     R0,[R1, #+5]
   \      0x136   0xE7E2             B.N      ??flashBlkWriteStateMachine_Run_7
   \                     ??flashBlkWriteStateMachine_Run_15: (+1)
   \      0x138   0xF3BF 0x8F4F      DSB      SY
   \      0x13C   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000ed0c
   \      0x13E   0x....             LDR.N    R0,??DataTable7_6  ;; 0x5fa0004
   \      0x140   0x680A             LDR      R2,[R1, #+0]
   \      0x142   0xF402 0x62E0      AND      R2,R2,#0x700
   \      0x146   0x4302             ORRS     R2,R0,R2
   \      0x148   0x600A             STR      R2,[R1, #+0]
   \      0x14A   0xF3BF 0x8F4F      DSB      SY
   \                     ??flashBlkWriteStateMachine_Run_16: (+1)
   \      0x14E   0xBF00             Nop
   \      0x150   0xE7FD             B.N      ??flashBlkWriteStateMachine_Run_16
   \                     ??flashBlkWriteStateMachine_Run_1: (+1)
   \      0x152   0x2100             MOVS     R1,#+0
   \      0x154   0xE7EA             B.N      ??flashBlkWriteStateMachine_Run_13
    359          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x4631             MOV      R1,R6
   \                     ??Subroutine2_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....'....        B.W      flashPageErase

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB918             CBNZ.N   R0,??Subroutine0_0
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0x2106             MOVS     R1,#+6
   \        0x6   0x80A0             STRH     R0,[R4, #+4]
   \        0x8   0x70A1             STRB     R1,[R4, #+2]
   \                     ??Subroutine0_0: (+1)
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x55 0x03          DC8 85, 3, 122, 0, 0, 0, 0, 0, 204, 204

   \              0x7A 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0xCC 0xCC
   \        0xA                      DS8 2
    360          

   \                                 In section .text, align 2, keep-with-next
    361          uint8_t flashTxBlk(uint16_t _flashBlkNum, unsigned char* _buf)
    362          {
   \                     flashTxBlk: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
   \        0x4   0x460D             MOV      R5,R1
    363            uint16_t blkStartAddr = _flashBlkNum*flashBlockSize;
   \        0x6   0x017C             LSLS     R4,R7,#+5
    364            if ( _flashBlkNum > 0x8000) //if flashBlkNum > 0x8000 mean this is an absolute block number 
   \        0x8   0xF248 0x0101      MOVW     R1,#+32769
   \        0xC   0xB2A4             UXTH     R4,R4
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBFA4             ITT      GE
   \       0x12   0x2400             MOVGE    R4,#+0
   \       0x14   0xF3C7 0x070B      UBFXGE   R7,R7,#+0,#+12
   \       0x18   0xB08C             SUB      SP,SP,#+48
    365            {
    366              blkStartAddr = 0;
    367              _flashBlkNum &= 0xfff;
    368            }
    369            uint16_t uwCRCValue = Calculate_CRC(32, _buf + blkStartAddr);          //only flash data CRC, no block pointer.
   \       0x1A   0x1929             ADDS     R1,R5,R4
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0x....'....        BL       Calculate_CRC
   \       0x22   0x4606             MOV      R6,R0
    370            unsigned char blkSettingTx[] = {0x55, 0x24, FlashBlkRd, 0x00, 0x00, (_flashBlkNum & 0xff00) >> 8, _flashBlkNum & 0xff,\
    371                                            _buf[ 0 + blkStartAddr],  _buf[1 + blkStartAddr],  _buf[2 + blkStartAddr],  _buf[3 + blkStartAddr],  _buf[4 + blkStartAddr],  _buf[5 + blkStartAddr],  _buf[6 + blkStartAddr],  _buf[7 + blkStartAddr],  _buf[8 + blkStartAddr],  _buf[9 + blkStartAddr],\
    372                                            _buf[10 + blkStartAddr], _buf[11 + blkStartAddr], _buf[12 + blkStartAddr], _buf[13 + blkStartAddr], _buf[14 + blkStartAddr], _buf[15 + blkStartAddr], _buf[16 + blkStartAddr], _buf[17 + blkStartAddr], _buf[18 + blkStartAddr], _buf[19 + blkStartAddr],\
    373                                            _buf[20 + blkStartAddr], _buf[21 + blkStartAddr], _buf[22 + blkStartAddr], _buf[23 + blkStartAddr], _buf[24 + blkStartAddr], _buf[25 + blkStartAddr], _buf[26 + blkStartAddr], _buf[27 + blkStartAddr], _buf[28 + blkStartAddr], _buf[29 + blkStartAddr],\
    374                                            _buf[30 + blkStartAddr], _buf[31 + blkStartAddr],\
    375                                            (uwCRCValue & 0xff00) >> 8, uwCRCValue & 0xff, 0xCC, 0xCC};
   \       0x24   0xA801             ADD      R0,SP,#+4
   \       0x26   0x....             LDR.N    R1,??DataTable7_7
   \       0x28   0x222C             MOVS     R2,#+44
   \       0x2A   0x....'....        BL       __aeabi_memcpy4
   \       0x2E   0xA801             ADD      R0,SP,#+4
   \       0x30   0x0A39             LSRS     R1,R7,#+8
   \       0x32   0x7141             STRB     R1,[R0, #+5]
   \       0x34   0x7187             STRB     R7,[R0, #+6]
   \       0x36   0x1929             ADDS     R1,R5,R4
   \       0x38   0x5D2A             LDRB     R2,[R5, R4]
   \       0x3A   0x71C2             STRB     R2,[R0, #+7]
   \       0x3C   0x192A             ADDS     R2,R5,R4
   \       0x3E   0x784B             LDRB     R3,[R1, #+1]
   \       0x40   0x7203             STRB     R3,[R0, #+8]
   \       0x42   0x192B             ADDS     R3,R5,R4
   \       0x44   0x7891             LDRB     R1,[R2, #+2]
   \       0x46   0x7241             STRB     R1,[R0, #+9]
   \       0x48   0x1929             ADDS     R1,R5,R4
   \       0x4A   0x78DA             LDRB     R2,[R3, #+3]
   \       0x4C   0x7282             STRB     R2,[R0, #+10]
   \       0x4E   0x192A             ADDS     R2,R5,R4
   \       0x50   0x790B             LDRB     R3,[R1, #+4]
   \       0x52   0x72C3             STRB     R3,[R0, #+11]
   \       0x54   0x192B             ADDS     R3,R5,R4
   \       0x56   0x7951             LDRB     R1,[R2, #+5]
   \       0x58   0x7301             STRB     R1,[R0, #+12]
   \       0x5A   0x1929             ADDS     R1,R5,R4
   \       0x5C   0x799A             LDRB     R2,[R3, #+6]
   \       0x5E   0x7342             STRB     R2,[R0, #+13]
   \       0x60   0x192A             ADDS     R2,R5,R4
   \       0x62   0x79CB             LDRB     R3,[R1, #+7]
   \       0x64   0x7383             STRB     R3,[R0, #+14]
   \       0x66   0x192B             ADDS     R3,R5,R4
   \       0x68   0x7A11             LDRB     R1,[R2, #+8]
   \       0x6A   0x73C1             STRB     R1,[R0, #+15]
   \       0x6C   0x1929             ADDS     R1,R5,R4
   \       0x6E   0x7A5A             LDRB     R2,[R3, #+9]
   \       0x70   0x7402             STRB     R2,[R0, #+16]
   \       0x72   0x192A             ADDS     R2,R5,R4
   \       0x74   0x7A8B             LDRB     R3,[R1, #+10]
   \       0x76   0x7443             STRB     R3,[R0, #+17]
   \       0x78   0x192B             ADDS     R3,R5,R4
   \       0x7A   0x7AD1             LDRB     R1,[R2, #+11]
   \       0x7C   0x7481             STRB     R1,[R0, #+18]
   \       0x7E   0x1929             ADDS     R1,R5,R4
   \       0x80   0x7B1A             LDRB     R2,[R3, #+12]
   \       0x82   0x74C2             STRB     R2,[R0, #+19]
   \       0x84   0x192A             ADDS     R2,R5,R4
   \       0x86   0x7B4B             LDRB     R3,[R1, #+13]
   \       0x88   0x7503             STRB     R3,[R0, #+20]
   \       0x8A   0x192B             ADDS     R3,R5,R4
   \       0x8C   0x7B91             LDRB     R1,[R2, #+14]
   \       0x8E   0x7541             STRB     R1,[R0, #+21]
   \       0x90   0x1929             ADDS     R1,R5,R4
   \       0x92   0x7BDA             LDRB     R2,[R3, #+15]
   \       0x94   0x7582             STRB     R2,[R0, #+22]
   \       0x96   0x192A             ADDS     R2,R5,R4
   \       0x98   0x7C0B             LDRB     R3,[R1, #+16]
   \       0x9A   0x75C3             STRB     R3,[R0, #+23]
   \       0x9C   0x192B             ADDS     R3,R5,R4
   \       0x9E   0x7C51             LDRB     R1,[R2, #+17]
   \       0xA0   0x7601             STRB     R1,[R0, #+24]
   \       0xA2   0x1929             ADDS     R1,R5,R4
   \       0xA4   0x7C9A             LDRB     R2,[R3, #+18]
   \       0xA6   0x7642             STRB     R2,[R0, #+25]
   \       0xA8   0x192A             ADDS     R2,R5,R4
   \       0xAA   0x7CCB             LDRB     R3,[R1, #+19]
   \       0xAC   0x7683             STRB     R3,[R0, #+26]
   \       0xAE   0x192B             ADDS     R3,R5,R4
   \       0xB0   0x7D11             LDRB     R1,[R2, #+20]
   \       0xB2   0x76C1             STRB     R1,[R0, #+27]
   \       0xB4   0x1929             ADDS     R1,R5,R4
   \       0xB6   0x7D5A             LDRB     R2,[R3, #+21]
   \       0xB8   0x7702             STRB     R2,[R0, #+28]
   \       0xBA   0x192A             ADDS     R2,R5,R4
   \       0xBC   0x7D8B             LDRB     R3,[R1, #+22]
   \       0xBE   0x7743             STRB     R3,[R0, #+29]
   \       0xC0   0x192B             ADDS     R3,R5,R4
   \       0xC2   0x7DD1             LDRB     R1,[R2, #+23]
   \       0xC4   0x7781             STRB     R1,[R0, #+30]
   \       0xC6   0x1929             ADDS     R1,R5,R4
   \       0xC8   0x7E1A             LDRB     R2,[R3, #+24]
   \       0xCA   0x77C2             STRB     R2,[R0, #+31]
   \       0xCC   0x192A             ADDS     R2,R5,R4
   \       0xCE   0x7E4B             LDRB     R3,[R1, #+25]
   \       0xD0   0xF880 0x3020      STRB     R3,[R0, #+32]
   \       0xD4   0x192B             ADDS     R3,R5,R4
   \       0xD6   0x7E91             LDRB     R1,[R2, #+26]
   \       0xD8   0xF880 0x1021      STRB     R1,[R0, #+33]
   \       0xDC   0xF10D 0x0025      ADD      R0,SP,#+37
   \       0xE0   0x7ED1             LDRB     R1,[R2, #+27]
   \       0xE2   0x7041             STRB     R1,[R0, #+1]
   \       0xE4   0x1929             ADDS     R1,R5,R4
   \       0xE6   0x7F1A             LDRB     R2,[R3, #+28]
   \       0xE8   0x7082             STRB     R2,[R0, #+2]
   \       0xEA   0x192A             ADDS     R2,R5,R4
   \       0xEC   0x7F4B             LDRB     R3,[R1, #+29]
   \       0xEE   0x70C3             STRB     R3,[R0, #+3]
   \       0xF0   0x192B             ADDS     R3,R5,R4
   \       0xF2   0x7F91             LDRB     R1,[R2, #+30]
   \       0xF4   0x7101             STRB     R1,[R0, #+4]
   \       0xF6   0x0A31             LSRS     R1,R6,#+8
   \       0xF8   0x7FDA             LDRB     R2,[R3, #+31]
   \       0xFA   0x7142             STRB     R2,[R0, #+5]
   \       0xFC   0x7181             STRB     R1,[R0, #+6]
   \       0xFE   0x71C6             STRB     R6,[R0, #+7]
    376            
    377            unsigned int blkSettingLen = sizeof(blkSettingTx);
   \      0x100   0x202B             MOVS     R0,#+43
   \      0x102   0x9000             STR      R0,[SP, #+0]
    378            RingBuf_WriteBlock((*usart1Control_FlashUpdateCmd).seqMemTX_u32, blkSettingTx, &blkSettingLen);
   \      0x104   0x466A             MOV      R2,SP
   \      0x106   0x....             LDR.N    R0,??DataTable7
   \      0x108   0x6983             LDR      R3,[R0, #+24]
   \      0x10A   0x6918             LDR      R0,[R3, #+16]
   \      0x10C   0xA901             ADD      R1,SP,#+4
   \      0x10E   0x....'....        BL       RingBuf_WriteBlock
    379            
    380            return 0;
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0xB00D             ADD      SP,SP,#+52
   \      0x116   0xBDF0             POP      {R4-R7,PC}       ;; return
    381          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x55 0x24          DC8 85, 36, 121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

   \              0x79 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00
   \       0x15   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0xCC
   \       0x2A   0xCC               DC8 204
   \       0x2B                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     flashBlockWrDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x0800'F000        DC32     0x800f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x0800'F800        DC32     0x800f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0xE000'ED0C        DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x05FA'0004        DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x55 0x01          DC8 85, 1, 122, 0, 0, 4, 204, 204

   \              0x7A 0x00    

   \              0x00 0x04    

   \              0xCC 0xCC

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x55 0x01          DC8 85, 1, 122, 0, 0, 5, 204, 204

   \              0x7A 0x00    

   \              0x00 0x05    

   \              0xCC 0xCC

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   flashBlkWriteStateMachine_Run
        40   -> RingBuf_WriteBlock
        40   -> flashBlockProgram
        40   -> flashPageCopy
        40   -> flashPageErase
        40   -> getSysCount
        40   -> isFlashCRCValid
      72   flashTxBlk
        72   -> Calculate_CRC
        72   -> RingBuf_WriteBlock
        72   -> __aeabi_memcpy4
      40   moduleFlashUpdateCmd_u32
        40   -> Calculate_CRC
        40   -> RingBuf_ClearContents
        40   -> RingBuf_GetUsedNumOfElements
        40   -> RingBuf_Observe
        40   -> RingBuf_ReadBlock
        40   -> RingBuf_WriteBlock
        40   -> flashBlkWriteStateMachine_Run
        40   -> flashTxBlk
        40   -> getProcessInfoIndex
        40   -> realloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
      12  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
      44  ?_0
       8  ?_1
       8  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
       2  A_DEFAULT_CONTROL_MODE
       2  A_GAIN1
       2  A_GAIN2
       2  A_IQMAX
       2  A_LS
       2  A_MAX_APPLICATION_SPEED_RPM
       2  A_MIN_APPLICATION_SPEED_RPM
       2  A_NOMINAL_CURRENT
       2  A_OV_TEMPERATURE_HYSTERESIS_C
       2  A_OV_TEMPERATURE_THRESHOLD_C
       2  A_OV_VOLTAGE_THRESHOLD_V
       2  A_PHASE1_DURATION
       2  A_PHASE1_FINAL_CURRENT
       2  A_PHASE1_FINAL_SPEED_UNIT
       2  A_PHASE2_DURATION
       2  A_PHASE2_FINAL_CURRENT
       2  A_PHASE2_FINAL_SPEED_UNIT
       2  A_PHASE3_DURATION
       2  A_PHASE3_FINAL_CURRENT
       2  A_PHASE3_FINAL_SPEED_UNIT
       2  A_PHASE4_DURATION
       2  A_PHASE4_FINAL_CURRENT
       2  A_PHASE4_FINAL_SPEED_UNIT
       2  A_PHASE5_DURATION
       2  A_PHASE5_FINAL_CURRENT
       2  A_PHASE5_FINAL_SPEED_UNIT
       2  A_PID_FLUX_KI_DEFAULT
       2  A_PID_FLUX_KP_DEFAULT
       2  A_PID_SPEED_KI_DEFAULT
       2  A_PID_SPEED_KP_DEFAULT
       2  A_PID_TORQUE_KI_DEFAULT
       2  A_PID_TORQUE_KP_DEFAULT
       2  A_PLL_KI_GAIN
       2  A_PLL_KP_GAIN
       2  A_POLE_PAIR_NUM
       2  A_PWM_FREQUENCY
       2  A_RS
       2  A_TRANSITION_DURATION
       2  A_UD_VOLTAGE_THRESHOLD_V
       2  D_HALL_PHASE_SHIFT
       2  D_HALL_SENSORS_PLACEMENT
       2  D_M1_ENCODER_PPR
     342  flashBlkWriteStateMachine_Run
      36  flashBlockWrDat
          reallocError
          returnStage
          blkCalculatedCRC
          tt_FlashFrameTimeOut
          usart1Control_FlashUpdateCmd
          module_StateMachineControl_FlashUpdateCmd
          protocolBuf_FlashUpdateCmd
     280  flashTxBlk
     428  moduleFlashUpdateCmd_u32

 
    36 bytes in section .bss
    44 bytes in section .rodata
    84 bytes in section .rodata  (abs)
 1'166 bytes in section .text
 
 1'166 bytes of CODE  memory
    44 bytes of CONST memory (+ 84 bytes shared)
    36 bytes of DATA  memory

Errors: none
Warnings: 1
