###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:04:00
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\user_interface.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EWB1F9.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\user_interface.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\user_interface.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\user_interface.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\user_interface.c
      1          /**
      2            ******************************************************************************
      3            * @file    user_interface.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the following features
      6            *          of the user interface component of the Motor Control SDK.
      7            ******************************************************************************
      8            * @attention
      9            *
     10            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     11            * All rights reserved.</center></h2>
     12            *
     13            * This software component is licensed by ST under Ultimate Liberty license
     14            * SLA0044, the "License"; You may not use this file except in compliance with
     15            * the License. You may obtain a copy of the License at:
     16            *                             www.st.com/SLA0044
     17            *
     18            ******************************************************************************
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          /* Pre-compiler coherency check */
     23          #include "mc_type.h"
     24          #include "mc_math.h"
     25          #include "mc_config.h"
     26          #include "user_interface.h"
     27          
     28          /** @addtogroup MCSDK
     29            * @{
     30            */
     31          
     32          /** @defgroup MCUI Motor Control User Interface
     33            * @brief User Interface Components of the Motor Control SDK
     34            *
     35            * These components aim at connecting the Application with the outside. There are two categories
     36            * of UI Componentes:
     37            *
     38            * - Some connect the application with the Motor Conrol Monitor tool via a UART link. The Motor
     39            *   Control Monitor can control the motor(s) driven by the application and also read and write  
     40            *   internal variables of the Motor Control subsystem. 
     41            * - Others UI components allow for using the DAC(s) peripherals in 
     42            *   order to output internal variables of the Motor Control subsystem for debug purposes.
     43            *
     44            * @{
     45            */
     46          
     47          /**
     48            * @brief  Initialize the user interface component. 
     49            *
     50            * Perform the link between the UI, MC interface and MC tuning components.
     51          
     52            * @param  pHandle: Pointer on Handle structure of UI component.
     53            * @param  bMCNum  Number of MC instance present in the list.
     54            * @param  pMCI Pointer on the list of MC interface component to inked with UI.
     55            * @param  pMCT Pointer on the list of MC tuning component to inked with UI.
     56            * @param  pUICfg Pointer on the user interface configuration list. 
     57            *         Each element of the list must be a bit field containing one (or more) of
     58            *         the exported configuration option UI_CFGOPT_xxx (eventually OR-ed).
     59            * @retval none.
     60            */

   \                                 In section .text, align 2
     61          __weak void UI_Init(UI_Handle_t *pHandle, uint8_t bMCNum, MCI_Handle_t ** pMCI, MCT_Handle_t** pMCT, uint32_t* pUICfg)
     62          {
   \                     UI_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x9C02             LDR      R4,[SP, #+8]
     63            pHandle->bDriveNum = bMCNum;
   \        0x4   0x7701             STRB     R1,[R0, #+28]
     64            pHandle->pMCI = pMCI;
     65            pHandle->pMCT = pMCT;
     66            pHandle->bSelectedDrive = 0u;
     67            pHandle->pUICfg = pUICfg;
   \        0x6   0x6284             STR      R4,[R0, #+40]
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6202             STR      R2,[R0, #+32]
   \        0xC   0x6243             STR      R3,[R0, #+36]
   \        0xE   0xF880 0x102C      STRB     R1,[R0, #+44]
     68          }
   \       0x12   0xBD10             POP      {R4,PC}          ;; return
     69          
     70          /**
     71            * @brief  Allow to select the MC on which UI operates.
     72            * @param  pHandle: Pointer on Handle structure of UI component.
     73            * @param  bSelectMC: The new selected MC, zero based, on which UI operates.
     74            * @retval Boolean set to true if the bSelectMC is valid oterwise return false.
     75            */

   \                                 In section .text, align 2
     76          __weak bool UI_SelectMC(UI_Handle_t *pHandle,uint8_t bSelectMC)
     77          {
   \                     UI_SelectMC: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4602             MOV      R2,R0
     78            bool retVal = true;
   \        0x4   0x2001             MOVS     R0,#+1
     79            if (bSelectMC  >= pHandle->bDriveNum)
   \        0x6   0xF812 0x4F1C      LDRB     R4,[R2, #+28]!
   \        0xA   0x42A1             CMP      R1,R4
   \        0xC   0xD301             BCC.N    ??UI_SelectMC_0
     80            {
     81              retVal = false;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD10             POP      {R4,PC}
     82            }
     83            else
     84            {
     85              pHandle->bSelectedDrive = bSelectMC;
   \                     ??UI_SelectMC_0: (+1)
   \       0x12   0x7411             STRB     R1,[R2, #+16]
     86            }
     87            return retVal;
   \       0x14   0xBD10             POP      {R4,PC}          ;; return
     88          }
     89          
     90          /**
     91            * @brief  Allow to retrieve the MC on which UI currently operates.
     92            * @param  pHandle: Pointer on Handle structure of UI component.
     93            * @retval Return the currently selected MC, zero based, on which UI operates.
     94            */

   \                                 In section .text, align 2
     95          __weak uint8_t UI_GetSelectedMC(UI_Handle_t *pHandle)
     96          {
     97            return (pHandle->bSelectedDrive);
   \                     UI_GetSelectedMC: (+1)
   \        0x0   0xF890 0x002C      LDRB     R0,[R0, #+44]
   \        0x4   0x4770             BX       LR               ;; return
     98          }
     99          
    100          /**
    101            * @brief  Retrieve the configuration of the MC on which UI currently operates.
    102            * @param  pHandle: Pointer on Handle structure of UI component.
    103            * @retval Return the currently configuration of selected MC on which UI operates.
    104            *         It represents a bit field containing one (or more) of
    105            *         the exported configuration option UI_CFGOPT_xxx (eventually OR-ed).
    106            */

   \                                 In section .text, align 2
    107          __weak uint32_t UI_GetSelectedMCConfig(UI_Handle_t *pHandle)
    108          {
    109            return pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     UI_GetSelectedMCConfig: (+1)
   \        0x0   0xF850 0x1F28      LDR      R1,[R0, #+40]!
   \        0x4   0x7900             LDRB     R0,[R0, #+4]
   \        0x6   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0xA   0x4770             BX       LR               ;; return
    110          }
    111          
    112          /**
    113            * @brief  Allow to execute a SetReg command coming from the user.
    114            * @param  pHandle: Pointer on Handle structure of UI component.
    115            * @param  bRegID: Code of register to update.
    116            *         See MC_PROTOCOL_REG_xxx for code definition.
    117            * @param  wValue: New value to set.
    118            * @retval Return the currently selected MC, zero based, on which UI operates.
    119            */

   \                                 In section .text, align 2
    120          __weak bool UI_SetReg(UI_Handle_t *pHandle, MC_Protocol_REG_t bRegID, int32_t wValue)
    121          {
   \                     UI_SetReg: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4616             MOV      R6,R2
    122            MCI_Handle_t * pMCI = pHandle->pMCI[pHandle->bSelectedDrive];
   \        0x4   0x6A02             LDR      R2,[R0, #+32]
   \        0x6   0xF890 0x302C      LDRB     R3,[R0, #+44]
   \        0xA   0xF852 0x4023      LDR      R4,[R2, R3, LSL #+2]
    123            MCT_Handle_t * pMCT = pHandle->pMCT[pHandle->bSelectedDrive];
   \        0xE   0x6A42             LDR      R2,[R0, #+36]
   \       0x10   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
    124          
    125            bool retVal = true;
   \       0x14   0x2501             MOVS     R5,#+1
    126            switch (bRegID)
   \       0x16   0xB339             CBZ.N    R1,??UI_SetReg_0
   \       0x18   0x2903             CMP      R1,#+3
   \       0x1A   0xD038             BEQ.N    ??UI_SetReg_1
   \       0x1C   0x2905             CMP      R1,#+5
   \       0x1E   0xD030             BEQ.N    ??UI_SetReg_2
   \       0x20   0x2906             CMP      R1,#+6
   \       0x22   0xD030             BEQ.N    ??UI_SetReg_3
   \       0x24   0x2907             CMP      R1,#+7
   \       0x26   0xD030             BEQ.N    ??UI_SetReg_4
   \       0x28   0x2908             CMP      R1,#+8
   \       0x2A   0xD047             BEQ.N    ??UI_SetReg_5
   \       0x2C   0x2909             CMP      R1,#+9
   \       0x2E   0xD04C             BEQ.N    ??UI_SetReg_6
   \       0x30   0x290A             CMP      R1,#+10
   \       0x32   0xD04C             BEQ.N    ??UI_SetReg_7
   \       0x34   0x290B             CMP      R1,#+11
   \       0x36   0xD04C             BEQ.N    ??UI_SetReg_8
   \       0x38   0x290C             CMP      R1,#+12
   \       0x3A   0xD04C             BEQ.N    ??UI_SetReg_9
   \       0x3C   0x290D             CMP      R1,#+13
   \       0x3E   0xD055             BEQ.N    ??UI_SetReg_10
   \       0x40   0x290E             CMP      R1,#+14
   \       0x42   0xD058             BEQ.N    ??UI_SetReg_11
   \       0x44   0x290F             CMP      R1,#+15
   \       0x46   0xD05B             BEQ.N    ??UI_SetReg_12
   \       0x48   0x2910             CMP      R1,#+16
   \       0x4A   0xD05E             BEQ.N    ??UI_SetReg_13
   \       0x4C   0x2911             CMP      R1,#+17
   \       0x4E   0xD075             BEQ.N    ??UI_SetReg_14
   \       0x50   0x2914             CMP      R1,#+20
   \       0x52   0xF000 0x808F      BEQ.W    ??UI_SetReg_15
   \       0x56   0x2915             CMP      R1,#+21
   \       0x58   0xF000 0x80A4      BEQ.W    ??UI_SetReg_16
   \       0x5C   0x2941             CMP      R1,#+65
   \       0x5E   0xF000 0x80BC      BEQ.W    ??UI_SetReg_17
   \       0x62   0x295B             CMP      R1,#+91
   \       0x64   0xD005             BEQ.N    ??UI_SetReg_18
   \       0x66   0xE0BD             B.N      ??UI_SetReg_19
    127            {
    128            case MC_PROTOCOL_REG_TARGET_MOTOR:
    129              {
    130                retVal = UI_SelectMC(pHandle,(uint8_t)wValue);
   \                     ??UI_SetReg_0: (+1)
   \       0x68   0xB2F1             UXTB     R1,R6
   \       0x6A   0x....'....        BL       UI_SelectMC
   \       0x6E   0x4605             MOV      R5,R0
    131              }
    132              break;
   \       0x70   0xE0B9             B.N      ??UI_SetReg_20
    133          
    134            case MC_PROTOCOL_REG_RAMP_FINAL_SPEED:
    135              {
    136                MCI_ExecSpeedRamp(pMCI,(int16_t)((wValue*SPEED_UNIT)/_RPM),0);
   \                     ??UI_SetReg_18: (+1)
   \       0x72   0x200A             MOVS     R0,#+10
   \       0x74   0x4346             MULS     R6,R0,R6
   \       0x76   0x213C             MOVS     R1,#+60
   \       0x78   0xFB96 0xF1F1      SDIV     R1,R6,R1
   \       0x7C   0x2200             MOVS     R2,#+0
   \       0x7E   0xB209             SXTH     R1,R1
   \       0x80   0xE018             B.N      ??UI_SetReg_21
    137              }
    138              break;
    139          
    140            case MC_PROTOCOL_REG_SPEED_KP:
    141              {
    142                PID_SetKP(pMCT->pPIDSpeed,(int16_t)wValue);
   \                     ??UI_SetReg_2: (+1)
   \       0x82   0x6810             LDR      R0,[R2, #+0]
   \       0x84   0xE033             B.N      ??UI_SetReg_22
    143              }
    144              break;
    145          
    146            case MC_PROTOCOL_REG_SPEED_KI:
    147              {
    148                PID_SetKI(pMCT->pPIDSpeed,(int16_t)wValue);
   \                     ??UI_SetReg_3: (+1)
   \       0x86   0x6810             LDR      R0,[R2, #+0]
   \       0x88   0xE036             B.N      ??UI_SetReg_23
    149              }
    150              break;
    151          
    152            case MC_PROTOCOL_REG_SPEED_KD:
    153              {
    154                PID_SetKD(pMCT->pPIDSpeed,(int16_t)wValue);
   \                     ??UI_SetReg_4: (+1)
   \       0x8A   0x6810             LDR      R0,[R2, #+0]
   \       0x8C   0xE039             B.N      ??UI_SetReg_24
    155              }
    156              break;
    157          
    158            case MC_PROTOCOL_REG_CONTROL_MODE:
    159              {
    160                if ((STC_Modality_t)wValue == STC_TORQUE_MODE)
   \                     ??UI_SetReg_1: (+1)
   \       0x8E   0xB2F0             UXTB     R0,R6
   \       0x90   0xB940             CBNZ.N   R0,??UI_SetReg_25
    161                {
    162                  MCI_ExecTorqueRamp(pMCI, MCI_GetTeref(pMCI),0);
   \       0x92   0x4620             MOV      R0,R4
   \       0x94   0x....'....        BL       MCI_GetTeref
   \       0x98   0x4601             MOV      R1,R0
   \       0x9A   0x2200             MOVS     R2,#+0
   \       0x9C   0x4620             MOV      R0,R4
   \       0x9E   0x....'....        BL       MCI_ExecTorqueRamp
   \                     ??UI_SetReg_26: (+1)
   \       0xA2   0xE0A0             B.N      ??UI_SetReg_20
    163                }
    164                if ((STC_Modality_t)wValue == STC_SPEED_MODE)
   \                     ??UI_SetReg_25: (+1)
   \       0xA4   0xB2F6             UXTB     R6,R6
   \       0xA6   0x2E01             CMP      R6,#+1
   \       0xA8   0xD1FB             BNE.N    ??UI_SetReg_26
    165                {
    166                  MCI_ExecSpeedRamp(pMCI, MCI_GetMecSpeedRefUnit(pMCI),0);
   \       0xAA   0x4620             MOV      R0,R4
   \       0xAC   0x....'....        BL       MCI_GetMecSpeedRefUnit
   \       0xB0   0x2200             MOVS     R2,#+0
   \       0xB2   0x4601             MOV      R1,R0
   \                     ??UI_SetReg_21: (+1)
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0x....'....        BL       MCI_ExecSpeedRamp
   \       0xBA   0xE094             B.N      ??UI_SetReg_20
    167                }
    168              }
    169              break;
    170          
    171            case MC_PROTOCOL_REG_TORQUE_REF:
    172              {
    173                qd_t currComp;
    174                currComp = MCI_GetIqdref(pMCI);
   \                     ??UI_SetReg_5: (+1)
   \       0xBC   0x4620             MOV      R0,R4
   \       0xBE   0x....'....        BL       MCI_GetIqdref
   \       0xC2   0x9000             STR      R0,[SP, #+0]
    175                currComp.q = (int16_t)wValue;
   \       0xC4   0xF8AD 0x6000      STRH     R6,[SP, #+0]
    176                MCI_SetCurrentReferences(pMCI,currComp);
   \       0xC8   0xE00B             B.N      ??UI_SetReg_27
    177              }
    178              break;
    179          
    180            case MC_PROTOCOL_REG_TORQUE_KP:
    181              {
    182                PID_SetKP(pMCT->pPIDIq,(int16_t)wValue);
   \                     ??UI_SetReg_6: (+1)
   \       0xCA   0x6850             LDR      R0,[R2, #+4]
   \       0xCC   0xE00F             B.N      ??UI_SetReg_22
    183              }
    184              break;
    185          
    186            case MC_PROTOCOL_REG_TORQUE_KI:
    187              {
    188                PID_SetKI(pMCT->pPIDIq,(int16_t)wValue);
   \                     ??UI_SetReg_7: (+1)
   \       0xCE   0x6850             LDR      R0,[R2, #+4]
   \       0xD0   0xE012             B.N      ??UI_SetReg_23
    189              }
    190              break;
    191          
    192            case MC_PROTOCOL_REG_TORQUE_KD:
    193              {
    194                PID_SetKD(pMCT->pPIDIq,(int16_t)wValue);
   \                     ??UI_SetReg_8: (+1)
   \       0xD2   0x6850             LDR      R0,[R2, #+4]
   \       0xD4   0xE015             B.N      ??UI_SetReg_24
    195              }
    196              break;
    197          
    198            case MC_PROTOCOL_REG_FLUX_REF:
    199              {
    200                qd_t currComp;
    201                currComp = MCI_GetIqdref(pMCI);
   \                     ??UI_SetReg_9: (+1)
   \       0xD6   0x4620             MOV      R0,R4
   \       0xD8   0x....'....        BL       MCI_GetIqdref
   \       0xDC   0x9000             STR      R0,[SP, #+0]
    202                currComp.d = (int16_t)wValue;
   \       0xDE   0xF8AD 0x6002      STRH     R6,[SP, #+2]
    203                MCI_SetCurrentReferences(pMCI,currComp);
   \                     ??UI_SetReg_27: (+1)
   \       0xE2   0x4620             MOV      R0,R4
   \       0xE4   0x9900             LDR      R1,[SP, #+0]
   \       0xE6   0x....'....        BL       MCI_SetCurrentReferences
    204              }
    205              break;
   \       0xEA   0xE07C             B.N      ??UI_SetReg_20
    206          
    207            case MC_PROTOCOL_REG_FLUX_KP:
    208              {
    209                PID_SetKP(pMCT->pPIDId,(int16_t)wValue);
   \                     ??UI_SetReg_10: (+1)
   \       0xEC   0x6890             LDR      R0,[R2, #+8]
   \                     ??UI_SetReg_22: (+1)
   \       0xEE   0xB231             SXTH     R1,R6
   \       0xF0   0x....'....        BL       PID_SetKP
    210              }
    211              break;
   \       0xF4   0xE077             B.N      ??UI_SetReg_20
    212          
    213            case MC_PROTOCOL_REG_FLUX_KI:
    214              {
    215                PID_SetKI(pMCT->pPIDId,(int16_t)wValue);
   \                     ??UI_SetReg_11: (+1)
   \       0xF6   0x6890             LDR      R0,[R2, #+8]
   \                     ??UI_SetReg_23: (+1)
   \       0xF8   0xB231             SXTH     R1,R6
   \       0xFA   0x....'....        BL       PID_SetKI
    216              }
    217              break;
   \       0xFE   0xE072             B.N      ??UI_SetReg_20
    218          
    219            case MC_PROTOCOL_REG_FLUX_KD:
    220              {
    221                PID_SetKD(pMCT->pPIDId,(int16_t)wValue);
   \                     ??UI_SetReg_12: (+1)
   \      0x100   0x6890             LDR      R0,[R2, #+8]
   \                     ??UI_SetReg_24: (+1)
   \      0x102   0xB231             SXTH     R1,R6
   \      0x104   0x....'....        BL       PID_SetKD
    222              }
    223              break;
   \      0x108   0xE06D             B.N      ??UI_SetReg_20
    224          
    225            case MC_PROTOCOL_REG_OBSERVER_C1:
    226              {
    227                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_SetReg_13: (+1)
   \      0x10A   0x6A80             LDR      R0,[R0, #+40]
   \      0x10C   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
    228                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x110   0x2400             MOVS     R4,#+0
    229                int16_t hC1,hC2;
    230                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x112   0x0F01             LSRS     R1,R0,#+28
   \      0x114   0x2909             CMP      R1,#+9
   \      0x116   0xBF08             IT       EQ
   \      0x118   0x6994             LDREQ    R4,[R2, #+24]
    231                {
    232                  pSPD = pMCT->pSpeedSensorMain;
    233                }
    234                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x11A   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \      0x11E   0x2809             CMP      R0,#+9
   \      0x120   0xBF08             IT       EQ
   \      0x122   0x69D4             LDREQ    R4,[R2, #+28]
    235                {
    236                  pSPD = pMCT->pSpeedSensorAux;
    237                }
    238                if (pSPD != MC_NULL)
   \      0x124   0x2C00             CMP      R4,#+0
   \      0x126   0xD05E             BEQ.N    ??UI_SetReg_20
    239                {
    240                  STO_PLL_GetObserverGains((STO_PLL_Handle_t*)pSPD,&hC1,&hC2);
   \      0x128   0x466A             MOV      R2,SP
   \      0x12A   0xF10D 0x0102      ADD      R1,SP,#+2
   \      0x12E   0x4620             MOV      R0,R4
   \      0x130   0x....'....        BL       STO_PLL_GetObserverGains
    241                  STO_PLL_SetObserverGains((STO_PLL_Handle_t*)pSPD,(int16_t)wValue,hC2);
   \      0x134   0xF9BD 0x2000      LDRSH    R2,[SP, #+0]
   \      0x138   0xB231             SXTH     R1,R6
   \      0x13A   0xE017             B.N      ??UI_SetReg_28
    242                }
    243              }
    244              break;
    245          
    246            case MC_PROTOCOL_REG_OBSERVER_C2:
    247              {
    248                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_SetReg_14: (+1)
   \      0x13C   0x6A80             LDR      R0,[R0, #+40]
   \      0x13E   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
    249                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x142   0x2400             MOVS     R4,#+0
    250                int16_t hC1,hC2;
    251                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x144   0x0F01             LSRS     R1,R0,#+28
   \      0x146   0x2909             CMP      R1,#+9
   \      0x148   0xBF08             IT       EQ
   \      0x14A   0x6994             LDREQ    R4,[R2, #+24]
    252                {
    253                  pSPD = pMCT->pSpeedSensorMain;
    254                }
    255                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x14C   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \      0x150   0x2809             CMP      R0,#+9
   \      0x152   0xBF08             IT       EQ
   \      0x154   0x69D4             LDREQ    R4,[R2, #+28]
    256                {
    257                  pSPD = pMCT->pSpeedSensorAux;
    258                }
    259                if (pSPD != MC_NULL)
   \      0x156   0x2C00             CMP      R4,#+0
   \      0x158   0xD045             BEQ.N    ??UI_SetReg_20
    260                {
    261                  STO_PLL_GetObserverGains((STO_PLL_Handle_t*)pSPD,&hC1,&hC2);
   \      0x15A   0xF10D 0x0202      ADD      R2,SP,#+2
   \      0x15E   0x4669             MOV      R1,SP
   \      0x160   0x4620             MOV      R0,R4
   \      0x162   0x....'....        BL       STO_PLL_GetObserverGains
    262                  STO_PLL_SetObserverGains((STO_PLL_Handle_t*)pSPD,hC1,(int16_t)wValue);
   \      0x166   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \      0x16A   0xB232             SXTH     R2,R6
   \                     ??UI_SetReg_28: (+1)
   \      0x16C   0x4620             MOV      R0,R4
   \      0x16E   0x....'....        BL       STO_PLL_SetObserverGains
   \      0x172   0xE038             B.N      ??UI_SetReg_20
    263                }
    264              }
    265              break;
    266          
    267            case MC_PROTOCOL_REG_PLL_KI:
    268              {
    269                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_SetReg_15: (+1)
   \      0x174   0x6A80             LDR      R0,[R0, #+40]
   \      0x176   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
    270                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x17A   0x2400             MOVS     R4,#+0
    271                int16_t hPgain, hIgain;
    272                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x17C   0x0F01             LSRS     R1,R0,#+28
   \      0x17E   0x2909             CMP      R1,#+9
   \      0x180   0xBF08             IT       EQ
   \      0x182   0x6994             LDREQ    R4,[R2, #+24]
    273                {
    274                  pSPD = pMCT->pSpeedSensorMain;
    275                }
    276                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x184   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \      0x188   0x2809             CMP      R0,#+9
   \      0x18A   0xBF08             IT       EQ
   \      0x18C   0x69D4             LDREQ    R4,[R2, #+28]
    277                {
    278                  pSPD = pMCT->pSpeedSensorAux;
    279                }
    280                if (pSPD != MC_NULL)
   \      0x18E   0xB354             CBZ.N    R4,??UI_SetReg_20
    281                {
    282                  STO_GetPLLGains((STO_PLL_Handle_t*)pSPD,&hPgain,&hIgain);
   \      0x190   0xF10D 0x0202      ADD      R2,SP,#+2
   \      0x194   0x4669             MOV      R1,SP
   \      0x196   0x4620             MOV      R0,R4
   \      0x198   0x....'....        BL       STO_GetPLLGains
    283                  STO_SetPLLGains((STO_PLL_Handle_t*)pSPD,hPgain,(int16_t)wValue);
   \      0x19C   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \      0x1A0   0xB232             SXTH     R2,R6
   \      0x1A2   0xE016             B.N      ??UI_SetReg_29
    284                }
    285              }
    286              break;
    287          
    288            case MC_PROTOCOL_REG_PLL_KP:
    289          	{
    290                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_SetReg_16: (+1)
   \      0x1A4   0x6A80             LDR      R0,[R0, #+40]
   \      0x1A6   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
    291                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x1AA   0x2400             MOVS     R4,#+0
    292                int16_t hPgain, hIgain;
    293                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x1AC   0x0F01             LSRS     R1,R0,#+28
   \      0x1AE   0x2909             CMP      R1,#+9
   \      0x1B0   0xBF08             IT       EQ
   \      0x1B2   0x6994             LDREQ    R4,[R2, #+24]
    294                {
    295                  pSPD = pMCT->pSpeedSensorMain;
    296                }
    297                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x1B4   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \      0x1B8   0x2809             CMP      R0,#+9
   \      0x1BA   0xBF08             IT       EQ
   \      0x1BC   0x69D4             LDREQ    R4,[R2, #+28]
    298                {
    299                  pSPD = pMCT->pSpeedSensorAux;
    300                }
    301                if (pSPD != MC_NULL)
   \      0x1BE   0xB194             CBZ.N    R4,??UI_SetReg_20
    302                {
    303                  STO_GetPLLGains((STO_PLL_Handle_t*)pSPD,&hPgain,&hIgain);
   \      0x1C0   0x466A             MOV      R2,SP
   \      0x1C2   0xF10D 0x0102      ADD      R1,SP,#+2
   \      0x1C6   0x4620             MOV      R0,R4
   \      0x1C8   0x....'....        BL       STO_GetPLLGains
    304                  STO_SetPLLGains((STO_PLL_Handle_t*)pSPD,(int16_t)wValue,hIgain);
   \      0x1CC   0xF9BD 0x2000      LDRSH    R2,[SP, #+0]
   \      0x1D0   0xB231             SXTH     R1,R6
   \                     ??UI_SetReg_29: (+1)
   \      0x1D2   0x4620             MOV      R0,R4
   \      0x1D4   0x....'....        BL       STO_SetPLLGains
   \      0x1D8   0xE005             B.N      ??UI_SetReg_20
    305                }
    306              }
    307              break;
    308          
    309            case MC_PROTOCOL_REG_IQ_SPEEDMODE:
    310              {
    311                MCI_SetIdref(pMCI,(int16_t)wValue);
   \                     ??UI_SetReg_17: (+1)
   \      0x1DA   0xB231             SXTH     R1,R6
   \      0x1DC   0x4620             MOV      R0,R4
   \      0x1DE   0x....'....        BL       MCI_SetIdref
    312              }
    313              break;
   \      0x1E2   0xE000             B.N      ??UI_SetReg_20
    314          
    315            default:
    316              retVal = false;
   \                     ??UI_SetReg_19: (+1)
   \      0x1E4   0x2500             MOVS     R5,#+0
    317              break;
    318            }
    319          
    320            return retVal;
   \                     ??UI_SetReg_20: (+1)
   \      0x1E6   0x4628             MOV      R0,R5
   \      0x1E8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    321          }
    322          
    323          /* Used to execute a GetReg command coming from the user. */

   \                                 In section .text, align 4
    324          __weak int32_t UI_GetReg(UI_Handle_t *pHandle, MC_Protocol_REG_t bRegID, bool * success)
    325          {
   \                     UI_GetReg: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4603             MOV      R3,R0
    326            MCT_Handle_t* pMCT = pHandle->pMCT[pHandle->bSelectedDrive];
   \        0x4   0x6A5C             LDR      R4,[R3, #+36]
    327            MCI_Handle_t * pMCI = pHandle->pMCI[pHandle->bSelectedDrive];
   \        0x6   0x6A1D             LDR      R5,[R3, #+32]
   \        0x8   0xF893 0x002C      LDRB     R0,[R3, #+44]
   \        0xC   0xF854 0x4020      LDR      R4,[R4, R0, LSL #+2]
   \       0x10   0xF855 0x5020      LDR      R5,[R5, R0, LSL #+2]
    328          
    329            int32_t bRetVal = 0;
   \       0x14   0x2000             MOVS     R0,#+0
    330          
    331            if ( success != (bool *) 0 ) 
   \       0x16   0xB10A             CBZ.N    R2,??UI_GetReg_1
    332            {
    333              *success = true;
   \       0x18   0x2601             MOVS     R6,#+1
   \       0x1A   0x7016             STRB     R6,[R2, #+0]
    334            }
    335          
    336            switch (bRegID)
   \                     ??UI_GetReg_1: (+1)
   \       0x1C   0x263C             MOVS     R6,#+60
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xF000 0x80AF      BEQ.W    ??UI_GetReg_2
   \       0x24   0x2901             CMP      R1,#+1
   \       0x26   0xF000 0x80B0      BEQ.W    ??UI_GetReg_3
   \       0x2A   0x2902             CMP      R1,#+2
   \       0x2C   0xF000 0x80B1      BEQ.W    ??UI_GetReg_4
   \       0x30   0x2903             CMP      R1,#+3
   \       0x32   0xF000 0x80CB      BEQ.W    ??UI_GetReg_5
   \       0x36   0x2904             CMP      R1,#+4
   \       0x38   0xF000 0x80AF      BEQ.W    ??UI_GetReg_6
   \       0x3C   0x2905             CMP      R1,#+5
   \       0x3E   0xF000 0x80AE      BEQ.W    ??UI_GetReg_7
   \       0x42   0x2906             CMP      R1,#+6
   \       0x44   0xF000 0x80AD      BEQ.W    ??UI_GetReg_8
   \       0x48   0x2907             CMP      R1,#+7
   \       0x4A   0xF000 0x80AC      BEQ.W    ??UI_GetReg_9
   \       0x4E   0x2908             CMP      R1,#+8
   \       0x50   0xD04B             BEQ.N    ??UI_GetReg_10
   \       0x52   0x2909             CMP      R1,#+9
   \       0x54   0xF000 0x80D2      BEQ.W    ??UI_GetReg_11
   \       0x58   0x290A             CMP      R1,#+10
   \       0x5A   0xF000 0x80D1      BEQ.W    ??UI_GetReg_12
   \       0x5E   0x290B             CMP      R1,#+11
   \       0x60   0xF000 0x80D0      BEQ.W    ??UI_GetReg_13
   \       0x64   0x290C             CMP      R1,#+12
   \       0x66   0xD075             BEQ.N    ??UI_GetReg_14
   \       0x68   0x290D             CMP      R1,#+13
   \       0x6A   0xF000 0x80CD      BEQ.W    ??UI_GetReg_15
   \       0x6E   0x290E             CMP      R1,#+14
   \       0x70   0xF000 0x80CE      BEQ.W    ??UI_GetReg_16
   \       0x74   0x290F             CMP      R1,#+15
   \       0x76   0xF000 0x80CF      BEQ.W    ??UI_GetReg_17
   \       0x7A   0x2910             CMP      R1,#+16
   \       0x7C   0xF000 0x80D0      BEQ.W    ??UI_GetReg_18
   \       0x80   0x2911             CMP      R1,#+17
   \       0x82   0xF000 0x80E2      BEQ.W    ??UI_GetReg_19
   \       0x86   0x2914             CMP      R1,#+20
   \       0x88   0xF000 0x811B      BEQ.W    ??UI_GetReg_20
   \       0x8C   0x2915             CMP      R1,#+21
   \       0x8E   0xF000 0x8103      BEQ.W    ??UI_GetReg_21
   \       0x92   0x2919             CMP      R1,#+25
   \       0x94   0xF000 0x8089      BEQ.W    ??UI_GetReg_22
   \       0x98   0x291A             CMP      R1,#+26
   \       0x9A   0xF000 0x808A      BEQ.W    ??UI_GetReg_23
   \       0x9E   0x291B             CMP      R1,#+27
   \       0xA0   0xF000 0x81B5      BEQ.W    ??UI_GetReg_24
   \       0xA4   0x291C             CMP      R1,#+28
   \       0xA6   0xF000 0x81B6      BEQ.W    ??UI_GetReg_25
   \       0xAA   0x291D             CMP      R1,#+29
   \       0xAC   0xF000 0x81B5      BEQ.W    ??UI_GetReg_26
   \       0xB0   0x291E             CMP      R1,#+30
   \       0xB2   0xF000 0x8082      BEQ.W    ??UI_GetReg_27
   \       0xB6   0x291F             CMP      R1,#+31
   \       0xB8   0xD011             BEQ.N    ??UI_GetReg_28
   \       0xBA   0x2920             CMP      R1,#+32
   \       0xBC   0xD012             BEQ.N    ??UI_GetReg_29
   \       0xBE   0x2922             CMP      R1,#+34
   \       0xC0   0xF000 0x8205      BEQ.W    ??UI_GetReg_30
   \       0xC4   0x2923             CMP      R1,#+35
   \       0xC6   0xF000 0x8209      BEQ.W    ??UI_GetReg_31
   \       0xCA   0x2924             CMP      R1,#+36
   \       0xCC   0xF000 0x820A      BEQ.W    ??UI_GetReg_32
   \       0xD0   0x2925             CMP      R1,#+37
   \       0xD2   0xF000 0x820B      BEQ.W    ??UI_GetReg_33
   \       0xD6   0x2926             CMP      R1,#+38
   \       0xD8   0xF000 0x820C      BEQ.W    ??UI_GetReg_34
   \       0xDC   0x2927             CMP      R1,#+39
   \                     ??UI_GetReg_28: (+1)
   \       0xDE   0xF000 0x81EE      BEQ.W    ??UI_GetReg_35
   \       0xE2   0x2928             CMP      R1,#+40
   \                     ??UI_GetReg_29: (+1)
   \       0xE4   0xF000 0x81EF      BEQ.W    ??UI_GetReg_36
   \       0xE8   0x2929             CMP      R1,#+41
   \                     ??UI_GetReg_10: (+1)
   \       0xEA   0xF000 0x8207      BEQ.W    ??UI_GetReg_37
   \       0xEE   0x292A             CMP      R1,#+42
   \       0xF0   0xD030             BEQ.N    ??UI_GetReg_14
   \       0xF2   0x292B             CMP      R1,#+43
   \       0xF4   0xF000 0x820A      BEQ.W    ??UI_GetReg_38
   \       0xF8   0x292C             CMP      R1,#+44
   \       0xFA   0xF000 0x820B      BEQ.W    ??UI_GetReg_39
   \       0xFE   0x292D             CMP      R1,#+45
   \      0x100   0xF000 0x820C      BEQ.W    ??UI_GetReg_40
   \      0x104   0x292E             CMP      R1,#+46
   \      0x106   0xF000 0x8210      BEQ.W    ??UI_GetReg_41
   \      0x10A   0x292F             CMP      R1,#+47
   \      0x10C   0xF000 0x8196      BEQ.W    ??UI_GetReg_42
   \      0x110   0x2930             CMP      R1,#+48
   \      0x112   0xF000 0x81AC      BEQ.W    ??UI_GetReg_43
   \      0x116   0x2931             CMP      R1,#+49
   \      0x118   0xF000 0x80AE      BEQ.W    ??UI_GetReg_44
   \      0x11C   0x2932             CMP      R1,#+50
   \      0x11E   0xF000 0x80E7      BEQ.W    ??UI_GetReg_45
   \      0x122   0x2933             CMP      R1,#+51
   \      0x124   0xF000 0x80F4      BEQ.W    ??UI_GetReg_46
   \      0x128   0x2934             CMP      R1,#+52
   \      0x12A   0xF000 0x8106      BEQ.W    ??UI_GetReg_47
   \      0x12E   0x2935             CMP      R1,#+53
   \      0x130   0xF000 0x8118      BEQ.W    ??UI_GetReg_48
   \      0x134   0x2936             CMP      R1,#+54
   \      0x136   0xF000 0x812A      BEQ.W    ??UI_GetReg_49
   \      0x13A   0x293D             CMP      R1,#+61
   \      0x13C   0xF000 0x8172      BEQ.W    ??UI_GetReg_50
   \      0x140   0x293E             CMP      R1,#+62
   \      0x142   0xF000 0x8174      BEQ.W    ??UI_GetReg_51
   \      0x146   0x293F             CMP      R1,#+63
   \      0x148   0xF000 0x81A8      BEQ.W    ??UI_GetReg_52
   \      0x14C   0x2940             CMP      R1,#+64
   \      0x14E   0xF000 0x81AD      BEQ.W    ??UI_GetReg_53
   \      0x152   0x2941             CMP      R1,#+65
   \                     ??UI_GetReg_14: (+1)
   \      0x154   0xF000 0x81D6      BEQ.W    ??UI_GetReg_54
   \      0x158   0x2942             CMP      R1,#+66
   \      0x15A   0xF000 0x812D      BEQ.W    ??UI_GetReg_55
   \      0x15E   0x2943             CMP      R1,#+67
   \      0x160   0xF000 0x813F      BEQ.W    ??UI_GetReg_56
   \      0x164   0x295B             CMP      R1,#+91
   \      0x166   0xD035             BEQ.N    ??UI_GetReg_57
   \      0x168   0x296E             CMP      R1,#+110
   \      0x16A   0xD03F             BEQ.N    ??UI_GetReg_58
   \      0x16C   0x296F             CMP      R1,#+111
   \      0x16E   0xD041             BEQ.N    ??UI_GetReg_59
   \      0x170   0x2970             CMP      R1,#+112
   \      0x172   0xD026             BEQ.N    ??UI_GetReg_60
   \      0x174   0x2972             CMP      R1,#+114
   \      0x176   0xD027             BEQ.N    ??UI_GetReg_61
   \      0x178   0x2973             CMP      R1,#+115
   \      0x17A   0xBF18             IT       NE
   \      0x17C   0x2981             CMPNE    R1,#+129
   \      0x17E   0xD003             BEQ.N    ??UI_GetReg_62
   \      0x180   0xE1DA             B.N      ??UI_GetReg_63
    337            {
    338              case MC_PROTOCOL_REG_TARGET_MOTOR:
    339              {
    340                bRetVal = (int32_t)UI_GetSelectedMC(pHandle);
   \                     ??UI_GetReg_2: (+1)
   \      0x182   0x4618             MOV      R0,R3
   \      0x184   0x....'....        BL       UI_GetSelectedMC
    341              }
    342              break;
   \                     ??UI_GetReg_62: (+1)
   \      0x188   0xBD76             POP      {R1,R2,R4-R6,PC}
    343          
    344              case MC_PROTOCOL_REG_FLAGS:
    345              {
    346                bRetVal = (int32_t)STM_GetFaultState(pMCT->pStateMachine);
   \                     ??UI_GetReg_3: (+1)
   \      0x18A   0x6AA0             LDR      R0,[R4, #+40]
   \      0x18C   0x....'....        BL       STM_GetFaultState
    347              }
    348          	break;
   \      0x190   0xBD76             POP      {R1,R2,R4-R6,PC}
    349          
    350              case MC_PROTOCOL_REG_STATUS:
    351              {
    352                bRetVal = (int32_t)STM_GetState(pMCT->pStateMachine);
   \                     ??UI_GetReg_4: (+1)
   \      0x192   0x6AA0             LDR      R0,[R4, #+40]
   \      0x194   0x....'....        BL       STM_GetState
    353              }
    354          	break;
   \      0x198   0xBD76             POP      {R1,R2,R4-R6,PC}
    355          
    356              case MC_PROTOCOL_REG_SPEED_REF:
    357              {
    358                bRetVal = (int32_t)((MCI_GetMecSpeedRefUnit(pMCI)*_RPM)/SPEED_UNIT);
   \                     ??UI_GetReg_6: (+1)
   \      0x19A   0x4628             MOV      R0,R5
   \      0x19C   0xE023             B.N      ??UI_GetReg_64
    359              }
    360              break;
    361          
    362              case MC_PROTOCOL_REG_SPEED_KP:
    363              {
    364                bRetVal = (int32_t)PID_GetKP(pMCT->pPIDSpeed);
   \                     ??UI_GetReg_7: (+1)
   \      0x19E   0x6820             LDR      R0,[R4, #+0]
   \      0x1A0   0xE033             B.N      ??UI_GetReg_65
    365              }
    366              break;
    367          
    368              case MC_PROTOCOL_REG_SPEED_KI:
    369              {
    370                bRetVal = (int32_t)PID_GetKI(pMCT->pPIDSpeed);
   \                     ??UI_GetReg_8: (+1)
   \      0x1A2   0x6820             LDR      R0,[R4, #+0]
   \      0x1A4   0xE035             B.N      ??UI_GetReg_66
    371              }
    372              break;
    373          
    374              case MC_PROTOCOL_REG_SPEED_KD:
    375              {
    376                bRetVal = (int32_t)PID_GetKD(pMCT->pPIDSpeed);
   \                     ??UI_GetReg_9: (+1)
   \      0x1A6   0x6820             LDR      R0,[R4, #+0]
   \      0x1A8   0xE037             B.N      ??UI_GetReg_67
    377              }
    378              break;
    379          
    380              case MC_PROTOCOL_REG_BUS_VOLTAGE:
    381              {
    382                bRetVal = (int32_t)VBS_GetAvBusVoltage_V(pMCT->pBusVoltageSensor);
   \                     ??UI_GetReg_22: (+1)
   \      0x1AA   0x6B20             LDR      R0,[R4, #+48]
   \      0x1AC   0x....'....        BL       VBS_GetAvBusVoltage_V
    383              }
    384              break;
   \      0x1B0   0xBD76             POP      {R1,R2,R4-R6,PC}
    385          
    386              case MC_PROTOCOL_REG_HEATS_TEMP:
    387              {
    388                bRetVal = (int32_t)NTC_GetAvTemp_C(pMCT->pTemperatureSensor);
   \                     ??UI_GetReg_23: (+1)
   \      0x1B2   0x6AE0             LDR      R0,[R4, #+44]
   \      0x1B4   0x....'....        BL       NTC_GetAvTemp_C
    389              }
    390              break;
   \      0x1B8   0xBD76             POP      {R1,R2,R4-R6,PC}
    391          
    392              case MC_PROTOCOL_REG_SPEED_MEAS:
    393              {
    394                bRetVal = (int32_t)((MCI_GetAvrgMecSpeedUnit(pMCI) * _RPM)/SPEED_UNIT);
   \                     ??UI_GetReg_27: (+1)
   \      0x1BA   0x4628             MOV      R0,R5
   \      0x1BC   0x....'....        BL       MCI_GetAvrgMecSpeedUnit
   \      0x1C0   0xE177             B.N      ??UI_GetReg_68
    395              }
    396              break;
    397          
    398              case MC_PROTOCOL_REG_UID:
    399              {
    400                bRetVal = (int32_t)(MC_UID);
   \                     ??UI_GetReg_60: (+1)
   \      0x1C2   0xF8DF 0x037C      LDR.W    R0,??UI_GetReg_0  ;; 0x34a6847a
    401              }
    402              break;
   \      0x1C6   0xBD76             POP      {R1,R2,R4-R6,PC}
    403          
    404              case MC_PROTOCOL_REG_CTRBDID:
    405              {
    406                bRetVal = CTRBDID;
   \                     ??UI_GetReg_61: (+1)
   \      0x1C8   0x2001             MOVS     R0,#+1
    407              }
    408              break;
   \      0x1CA   0xBD76             POP      {R1,R2,R4-R6,PC}
    409          
    410              case MC_PROTOCOL_REG_PWBDID:
    411              {
    412                bRetVal = PWBDID;
    413              }
    414              break;
    415          
    416              case MC_PROTOCOL_REG_PWBDID2:
    417              {
    418                bRetVal = (uint32_t) 0;
    419              }
    420              break;
    421          
    422              case MC_PROTOCOL_REG_TORQUE_REF:
    423              {
    424                qd_t currComp;
    425                currComp = MCI_GetIqdref(pMCI);
    426                bRetVal = (int32_t)currComp.q;
    427              }
    428              break;
    429          
    430              case MC_PROTOCOL_REG_FLUX_REF:
    431              {
    432                qd_t currComp;
    433                currComp = MCI_GetIqdref(pMCI);
    434                bRetVal = (int32_t)currComp.d;
    435              }
    436              break;
    437          
    438              case MC_PROTOCOL_REG_CONTROL_MODE:
    439              {
    440                bRetVal = (int32_t)MCI_GetControlMode(pMCI);
   \                     ??UI_GetReg_5: (+1)
   \      0x1CC   0x4628             MOV      R0,R5
   \      0x1CE   0x....'....        BL       MCI_GetControlMode
    441              }
    442              break;
   \      0x1D2   0xBD76             POP      {R1,R2,R4-R6,PC}
    443          
    444              case MC_PROTOCOL_REG_RAMP_FINAL_SPEED:
    445              {
    446                if (MCI_GetControlMode(pMCI) == STC_SPEED_MODE)
   \                     ??UI_GetReg_57: (+1)
   \      0x1D4   0x4628             MOV      R0,R5
   \      0x1D6   0x....'....        BL       MCI_GetControlMode
   \      0x1DA   0x2801             CMP      R0,#+1
   \      0x1DC   0x4628             MOV      R0,R5
   \      0x1DE   0xD102             BNE.N    ??UI_GetReg_64
    447                {
    448                bRetVal = (int32_t)((MCI_GetLastRampFinalSpeed(pMCI) * _RPM)/SPEED_UNIT) ;
   \      0x1E0   0x....'....        BL       MCI_GetLastRampFinalSpeed
   \      0x1E4   0xE165             B.N      ??UI_GetReg_68
    449                }
    450                else
    451                {
    452                bRetVal = (int32_t)((MCI_GetMecSpeedRefUnit(pMCI) * _RPM)/SPEED_UNIT) ;
   \                     ??UI_GetReg_64: (+1)
   \      0x1E6   0x....'....        BL       MCI_GetMecSpeedRefUnit
   \      0x1EA   0xE162             B.N      ??UI_GetReg_68
    453                }
    454              }
    455              break;
    456          
    457              case MC_PROTOCOL_REG_SPEED_KP_DIV:
    458              {
    459                bRetVal = (int32_t)PID_GetKPDivisor(pMCT->pPIDSpeed);
   \                     ??UI_GetReg_58: (+1)
   \      0x1EC   0x6820             LDR      R0,[R4, #+0]
   \      0x1EE   0x....'....        BL       PID_GetKPDivisor
    460              }
    461              break;
   \      0x1F2   0xBD76             POP      {R1,R2,R4-R6,PC}
    462          
    463              case MC_PROTOCOL_REG_SPEED_KI_DIV:
    464              {
    465                bRetVal = (int32_t)PID_GetKIDivisor(pMCT->pPIDSpeed);
   \                     ??UI_GetReg_59: (+1)
   \      0x1F4   0x6820             LDR      R0,[R4, #+0]
   \      0x1F6   0x....'....        BL       PID_GetKIDivisor
    466              }
    467              break;
   \      0x1FA   0xBD76             POP      {R1,R2,R4-R6,PC}
    468          
    469              case MC_PROTOCOL_REG_TORQUE_KP:
    470              {
    471                bRetVal = (int32_t)PID_GetKP(pMCT->pPIDIq);
   \                     ??UI_GetReg_11: (+1)
   \      0x1FC   0x6860             LDR      R0,[R4, #+4]
   \      0x1FE   0xE004             B.N      ??UI_GetReg_65
    472              }
    473              break;
    474          
    475              case MC_PROTOCOL_REG_TORQUE_KI:
    476              {
    477                bRetVal = (int32_t)PID_GetKI(pMCT->pPIDIq);
   \                     ??UI_GetReg_12: (+1)
   \      0x200   0x6860             LDR      R0,[R4, #+4]
   \      0x202   0xE006             B.N      ??UI_GetReg_66
    478              }
    479              break;
    480          
    481              case MC_PROTOCOL_REG_TORQUE_KD:
    482              {
    483                bRetVal = (int32_t)PID_GetKD(pMCT->pPIDIq);
   \                     ??UI_GetReg_13: (+1)
   \      0x204   0x6860             LDR      R0,[R4, #+4]
   \      0x206   0xE008             B.N      ??UI_GetReg_67
    484              }
    485              break;
    486          
    487              case MC_PROTOCOL_REG_IQ_SPEEDMODE:
    488              {
    489                qd_t currComp;
    490                currComp = MCI_GetIqdref(pMCI);
    491                bRetVal = (int32_t)currComp.d;
    492              }
    493              break;
    494          
    495              case MC_PROTOCOL_REG_FLUX_KP:
    496              {
    497                bRetVal = (int32_t)PID_GetKP(pMCT->pPIDId);
   \                     ??UI_GetReg_15: (+1)
   \      0x208   0x68A0             LDR      R0,[R4, #+8]
   \                     ??UI_GetReg_65: (+1)
   \      0x20A   0x....'....        BL       PID_GetKP
    498              }
    499              break;
   \      0x20E   0xBD76             POP      {R1,R2,R4-R6,PC}
    500          
    501              case MC_PROTOCOL_REG_FLUX_KI:
    502              {
    503                bRetVal = (int32_t)PID_GetKI(pMCT->pPIDId);
   \                     ??UI_GetReg_16: (+1)
   \      0x210   0x68A0             LDR      R0,[R4, #+8]
   \                     ??UI_GetReg_66: (+1)
   \      0x212   0x....'....        BL       PID_GetKI
    504              }
    505              break;
   \      0x216   0xBD76             POP      {R1,R2,R4-R6,PC}
    506          
    507              case MC_PROTOCOL_REG_FLUX_KD:
    508              {
    509                bRetVal = (int32_t)PID_GetKD(pMCT->pPIDId);
   \                     ??UI_GetReg_17: (+1)
   \      0x218   0x68A0             LDR      R0,[R4, #+8]
   \                     ??UI_GetReg_67: (+1)
   \      0x21A   0x....'....        BL       PID_GetKD
    510              }
    511              break;
   \      0x21E   0xBD76             POP      {R1,R2,R4-R6,PC}
    512          
    513              case MC_PROTOCOL_REG_OBSERVER_C1:
    514              {
    515                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_18: (+1)
   \      0x220   0x6A98             LDR      R0,[R3, #+40]
   \      0x222   0xF893 0x102C      LDRB     R1,[R3, #+44]
   \      0x226   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
    516                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x22A   0x2000             MOVS     R0,#+0
    517                int16_t hC1,hC2;
    518                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x22C   0x0F0A             LSRS     R2,R1,#+28
   \      0x22E   0x2A09             CMP      R2,#+9
   \      0x230   0xBF08             IT       EQ
   \      0x232   0x69A0             LDREQ    R0,[R4, #+24]
    519                {
    520                  pSPD = pMCT->pSpeedSensorMain;
    521                }
    522                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x234   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \      0x238   0x2909             CMP      R1,#+9
   \      0x23A   0xBF08             IT       EQ
   \      0x23C   0x69E0             LDREQ    R0,[R4, #+28]
    523                {
    524                  pSPD = pMCT->pSpeedSensorAux;
    525                }
    526                if (pSPD != MC_NULL)
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD019             BEQ.N    ??UI_GetReg_69
    527                {
    528                  STO_PLL_GetObserverGains((STO_PLL_Handle_t*)pSPD,&hC1,&hC2);
   \      0x242   0xF10D 0x0202      ADD      R2,SP,#+2
   \      0x246   0x4669             MOV      R1,SP
   \      0x248   0xE013             B.N      ??UI_GetReg_70
    529                }
    530                bRetVal = (int32_t)hC1;
    531              }
    532              break;
    533          
    534              case MC_PROTOCOL_REG_OBSERVER_C2:
    535              {
    536                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_19: (+1)
   \      0x24A   0x6A98             LDR      R0,[R3, #+40]
   \      0x24C   0xF893 0x102C      LDRB     R1,[R3, #+44]
   \      0x250   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
    537                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x254   0x2000             MOVS     R0,#+0
    538                int16_t hC1,hC2;
    539                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x256   0x0F0A             LSRS     R2,R1,#+28
   \      0x258   0x2A09             CMP      R2,#+9
   \      0x25A   0xBF08             IT       EQ
   \      0x25C   0x69A0             LDREQ    R0,[R4, #+24]
    540                {
    541                  pSPD = pMCT->pSpeedSensorMain;
    542                }
    543                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x25E   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \      0x262   0x2909             CMP      R1,#+9
   \      0x264   0xBF08             IT       EQ
   \      0x266   0x69E0             LDREQ    R0,[R4, #+28]
    544                {
    545                  pSPD = pMCT->pSpeedSensorAux;
    546                }
    547                if (pSPD != MC_NULL)
   \      0x268   0x2800             CMP      R0,#+0
   \      0x26A   0xD004             BEQ.N    ??UI_GetReg_69
    548                {
    549                  STO_PLL_GetObserverGains((STO_PLL_Handle_t*)pSPD,&hC1,&hC2);
   \      0x26C   0x466A             MOV      R2,SP
   \      0x26E   0xF10D 0x0102      ADD      R1,SP,#+2
   \                     ??UI_GetReg_70: (+1)
   \      0x272   0x....'....        BL       STO_PLL_GetObserverGains
    550                }
    551                bRetVal = (int32_t)hC2;
   \                     ??UI_GetReg_69: (+1)
   \      0x276   0xE155             B.N      ??UI_GetReg_71
    552              }
    553              break;
    554          
    555              case MC_PROTOCOL_REG_OBS_EL_ANGLE:
    556              {
    557                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_44: (+1)
   \      0x278   0x6A99             LDR      R1,[R3, #+40]
   \      0x27A   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x27E   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    558                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x282   0x2100             MOVS     R1,#+0
    559                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x284   0x0F13             LSRS     R3,R2,#+28
   \      0x286   0x2B09             CMP      R3,#+9
   \      0x288   0xBF08             IT       EQ
   \      0x28A   0x69A1             LDREQ    R1,[R4, #+24]
    560                {
    561                  pSPD = pMCT->pSpeedSensorMain;
    562                }
    563                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x28C   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x290   0x2A09             CMP      R2,#+9
   \      0x292   0xD100             BNE.N    ??UI_GetReg_72
    564                {
    565                  pSPD = pMCT->pSpeedSensorAux;
   \      0x294   0x69E1             LDR      R1,[R4, #+28]
    566                }
    567                if (pSPD != MC_NULL)
   \                     ??UI_GetReg_72: (+1)
   \      0x296   0xE0E4             B.N      ??UI_GetReg_73
    568                {
    569                  bRetVal = SPD_GetElAngle(pSPD);
    570                }
    571              }
    572              break;
    573          
    574              case MC_PROTOCOL_REG_PLL_KP:
    575              {
    576                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_21: (+1)
   \      0x298   0x6A98             LDR      R0,[R3, #+40]
   \      0x29A   0xF893 0x102C      LDRB     R1,[R3, #+44]
   \      0x29E   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
    577                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x2A2   0x2000             MOVS     R0,#+0
    578                int16_t hPgain, hIgain;
    579                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x2A4   0x0F0A             LSRS     R2,R1,#+28
   \      0x2A6   0x2A09             CMP      R2,#+9
   \      0x2A8   0xBF08             IT       EQ
   \      0x2AA   0x69A0             LDREQ    R0,[R4, #+24]
    580                {
    581                  pSPD = pMCT->pSpeedSensorMain;
    582                }
    583                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x2AC   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \      0x2B0   0x2909             CMP      R1,#+9
   \      0x2B2   0xBF08             IT       EQ
   \      0x2B4   0x69E0             LDREQ    R0,[R4, #+28]
    584                {
    585                  pSPD = pMCT->pSpeedSensorAux;
    586                }
    587                if (pSPD != MC_NULL)
   \      0x2B6   0x2800             CMP      R0,#+0
   \      0x2B8   0xD019             BEQ.N    ??UI_GetReg_74
    588                {
    589                  STO_GetPLLGains((STO_PLL_Handle_t*)pSPD,&hPgain,&hIgain);
   \      0x2BA   0xF10D 0x0202      ADD      R2,SP,#+2
   \      0x2BE   0x4669             MOV      R1,SP
   \      0x2C0   0xE013             B.N      ??UI_GetReg_75
    590                }
    591                bRetVal = (int32_t)hPgain;
    592              }
    593              break;
    594          
    595              case MC_PROTOCOL_REG_PLL_KI:
    596              {
    597                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_20: (+1)
   \      0x2C2   0x6A98             LDR      R0,[R3, #+40]
   \      0x2C4   0xF893 0x102C      LDRB     R1,[R3, #+44]
   \      0x2C8   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
    598                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x2CC   0x2000             MOVS     R0,#+0
    599                int16_t hPgain, hIgain;
    600                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x2CE   0x0F0A             LSRS     R2,R1,#+28
   \      0x2D0   0x2A09             CMP      R2,#+9
   \      0x2D2   0xBF08             IT       EQ
   \      0x2D4   0x69A0             LDREQ    R0,[R4, #+24]
    601                {
    602                  pSPD = pMCT->pSpeedSensorMain;
    603                }
    604                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x2D6   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \      0x2DA   0x2909             CMP      R1,#+9
   \      0x2DC   0xBF08             IT       EQ
   \      0x2DE   0x69E0             LDREQ    R0,[R4, #+28]
    605                {
    606                  pSPD = pMCT->pSpeedSensorAux;
    607                }
    608                if (pSPD != MC_NULL)
   \      0x2E0   0x2800             CMP      R0,#+0
   \      0x2E2   0xD004             BEQ.N    ??UI_GetReg_74
    609                {
    610                  STO_GetPLLGains((STO_PLL_Handle_t*)pSPD,&hPgain,&hIgain);
   \      0x2E4   0x466A             MOV      R2,SP
   \      0x2E6   0xF10D 0x0102      ADD      R1,SP,#+2
   \                     ??UI_GetReg_75: (+1)
   \      0x2EA   0x....'....        BL       STO_GetPLLGains
    611                }
    612                bRetVal = (int32_t)hIgain;
   \                     ??UI_GetReg_74: (+1)
   \      0x2EE   0xE119             B.N      ??UI_GetReg_71
    613              }
    614              break;
    615          
    616              case MC_PROTOCOL_REG_OBS_ROT_SPEED:
    617              {
    618                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_45: (+1)
   \      0x2F0   0x6A99             LDR      R1,[R3, #+40]
   \      0x2F2   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x2F6   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    619                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x2FA   0x2100             MOVS     R1,#+0
    620                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x2FC   0x0F13             LSRS     R3,R2,#+28
   \      0x2FE   0x2B09             CMP      R3,#+9
   \      0x300   0xBF08             IT       EQ
   \      0x302   0x69A1             LDREQ    R1,[R4, #+24]
    621                {
    622                  pSPD = pMCT->pSpeedSensorMain;
    623                }
    624                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x304   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x308   0x2A09             CMP      R2,#+9
   \      0x30A   0xD100             BNE.N    ??UI_GetReg_76
    625                {
    626                  pSPD = pMCT->pSpeedSensorAux;
   \      0x30C   0x69E1             LDR      R1,[R4, #+28]
    627                }
    628                if (pSPD != MC_NULL)
   \                     ??UI_GetReg_76: (+1)
   \      0x30E   0xE0BF             B.N      ??UI_GetReg_77
    629                {
    630                  bRetVal = SPD_GetS16Speed(pSPD);
    631                }
    632              }
    633              break;
    634          
    635              case MC_PROTOCOL_REG_OBS_I_ALPHA:
    636              {
    637                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_46: (+1)
   \      0x310   0x6A99             LDR      R1,[R3, #+40]
   \      0x312   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x316   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    638                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x31A   0x2100             MOVS     R1,#+0
    639                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x31C   0x0F13             LSRS     R3,R2,#+28
   \      0x31E   0x2B09             CMP      R3,#+9
   \      0x320   0xBF08             IT       EQ
   \      0x322   0x69A1             LDREQ    R1,[R4, #+24]
    640                {
    641                  pSPD = pMCT->pSpeedSensorMain;
    642                }
    643                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x324   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x328   0x2A09             CMP      R2,#+9
   \      0x32A   0xBF08             IT       EQ
   \      0x32C   0x69E1             LDREQ    R1,[R4, #+28]
    644                {
    645                  pSPD = pMCT->pSpeedSensorAux;
    646                }
    647                if (pSPD != MC_NULL)
   \      0x32E   0x2900             CMP      R1,#+0
   \      0x330   0xD06C             BEQ.N    ??UI_GetReg_78
    648                {
    649                  bRetVal = STO_PLL_GetEstimatedCurrent((STO_PLL_Handle_t*)pSPD).alpha;
   \      0x332   0x4608             MOV      R0,R1
   \      0x334   0x....'....        BL       STO_PLL_GetEstimatedCurrent
   \      0x338   0xE0F3             B.N      ??UI_GetReg_79
    650                }
    651              }
    652              break;
    653          
    654              case MC_PROTOCOL_REG_OBS_I_BETA:
    655              {
    656                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_47: (+1)
   \      0x33A   0x6A99             LDR      R1,[R3, #+40]
   \      0x33C   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x340   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    657                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x344   0x2100             MOVS     R1,#+0
    658                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x346   0x0F13             LSRS     R3,R2,#+28
   \      0x348   0x2B09             CMP      R3,#+9
   \      0x34A   0xBF08             IT       EQ
   \      0x34C   0x69A1             LDREQ    R1,[R4, #+24]
    659                {
    660                  pSPD = pMCT->pSpeedSensorMain;
    661                }
    662                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x34E   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x352   0x2A09             CMP      R2,#+9
   \      0x354   0xBF08             IT       EQ
   \      0x356   0x69E1             LDREQ    R1,[R4, #+28]
    663                {
    664                  pSPD = pMCT->pSpeedSensorAux;
    665                }
    666                if (pSPD != MC_NULL)
   \      0x358   0x2900             CMP      R1,#+0
   \      0x35A   0xD057             BEQ.N    ??UI_GetReg_78
    667                {
    668                  bRetVal = STO_PLL_GetEstimatedCurrent((STO_PLL_Handle_t*)pSPD).beta;
   \      0x35C   0x4608             MOV      R0,R1
   \      0x35E   0x....'....        BL       STO_PLL_GetEstimatedCurrent
   \      0x362   0xE0E5             B.N      ??UI_GetReg_80
    669                }
    670              }
    671              break;
    672          
    673              case MC_PROTOCOL_REG_OBS_BEMF_ALPHA:
    674              {
    675                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_48: (+1)
   \      0x364   0x6A99             LDR      R1,[R3, #+40]
   \      0x366   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x36A   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    676                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x36E   0x2100             MOVS     R1,#+0
    677                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x370   0x0F13             LSRS     R3,R2,#+28
   \      0x372   0x2B09             CMP      R3,#+9
   \      0x374   0xBF08             IT       EQ
   \      0x376   0x69A1             LDREQ    R1,[R4, #+24]
    678                {
    679                  pSPD = pMCT->pSpeedSensorMain;
    680                }
    681                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x378   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x37C   0x2A09             CMP      R2,#+9
   \      0x37E   0xBF08             IT       EQ
   \      0x380   0x69E1             LDREQ    R1,[R4, #+28]
    682                {
    683                  pSPD =  pMCT->pSpeedSensorAux;
    684                }
    685                if (pSPD != MC_NULL)
   \      0x382   0x2900             CMP      R1,#+0
   \      0x384   0xD042             BEQ.N    ??UI_GetReg_78
    686                {
    687                  bRetVal = STO_PLL_GetEstimatedBemf((STO_PLL_Handle_t*)pSPD).alpha;
   \      0x386   0x4608             MOV      R0,R1
   \      0x388   0x....'....        BL       STO_PLL_GetEstimatedBemf
   \      0x38C   0xE0C9             B.N      ??UI_GetReg_79
    688                }
    689              }
    690              break;
    691          
    692              case MC_PROTOCOL_REG_OBS_BEMF_BETA:
    693              {
    694                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_49: (+1)
   \      0x38E   0x6A99             LDR      R1,[R3, #+40]
   \      0x390   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x394   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    695                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x398   0x2100             MOVS     R1,#+0
    696                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x39A   0x0F13             LSRS     R3,R2,#+28
   \      0x39C   0x2B09             CMP      R3,#+9
   \      0x39E   0xBF08             IT       EQ
   \      0x3A0   0x69A1             LDREQ    R1,[R4, #+24]
    697                {
    698                 pSPD = pMCT->pSpeedSensorMain;
    699                }
    700                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x3A2   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x3A6   0x2A09             CMP      R2,#+9
   \      0x3A8   0xBF08             IT       EQ
   \      0x3AA   0x69E1             LDREQ    R1,[R4, #+28]
    701                {
    702                  pSPD = pMCT->pSpeedSensorAux;
    703                }
    704                if (pSPD != MC_NULL)
   \      0x3AC   0x2900             CMP      R1,#+0
   \      0x3AE   0xD02D             BEQ.N    ??UI_GetReg_78
    705                {
    706                  bRetVal = STO_PLL_GetEstimatedBemf((STO_PLL_Handle_t*)pSPD).beta;
   \      0x3B0   0x4608             MOV      R0,R1
   \      0x3B2   0x....'....        BL       STO_PLL_GetEstimatedBemf
   \      0x3B6   0xE0BB             B.N      ??UI_GetReg_80
    707                }
    708              }
    709              break;
    710          
    711              case MC_PROTOCOL_REG_EST_BEMF_LEVEL:
    712              {
    713                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_55: (+1)
   \      0x3B8   0x6A99             LDR      R1,[R3, #+40]
   \      0x3BA   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x3BE   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    714                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x3C2   0x2100             MOVS     R1,#+0
    715                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x3C4   0x0F13             LSRS     R3,R2,#+28
   \      0x3C6   0x2B09             CMP      R3,#+9
   \      0x3C8   0xBF08             IT       EQ
   \      0x3CA   0x69A1             LDREQ    R1,[R4, #+24]
    716                {
    717                  pSPD = pMCT->pSpeedSensorMain;
    718                }
    719                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x3CC   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x3D0   0x2A09             CMP      R2,#+9
   \      0x3D2   0xBF08             IT       EQ
   \      0x3D4   0x69E1             LDREQ    R1,[R4, #+28]
    720                {
    721                  pSPD = pMCT->pSpeedSensorAux;
    722                }
    723                if (pSPD != MC_NULL)
   \      0x3D6   0x2900             CMP      R1,#+0
   \      0x3D8   0xD018             BEQ.N    ??UI_GetReg_78
    724                {
    725                  bRetVal = STO_PLL_GetEstimatedBemfLevel((STO_PLL_Handle_t*)pSPD) >> 16;
   \      0x3DA   0x4608             MOV      R0,R1
   \      0x3DC   0x....'....        BL       STO_PLL_GetEstimatedBemfLevel
   \      0x3E0   0xE013             B.N      ??UI_GetReg_81
    726                }
    727              }
    728              break;
    729          
    730              case MC_PROTOCOL_REG_OBS_BEMF_LEVEL:
    731              {
    732                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_56: (+1)
   \      0x3E2   0x6A99             LDR      R1,[R3, #+40]
   \      0x3E4   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x3E8   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    733                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x3EC   0x2100             MOVS     R1,#+0
    734                if (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x3EE   0x0F13             LSRS     R3,R2,#+28
   \      0x3F0   0x2B09             CMP      R3,#+9
   \      0x3F2   0xBF08             IT       EQ
   \      0x3F4   0x69A1             LDREQ    R1,[R4, #+24]
    735                {
    736                  pSPD = pMCT->pSpeedSensorMain;
    737                }
    738                if (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_STO_PLL)
   \      0x3F6   0xF3C2 0x6203      UBFX     R2,R2,#+24,#+4
   \      0x3FA   0x2A09             CMP      R2,#+9
   \      0x3FC   0xBF08             IT       EQ
   \      0x3FE   0x69E1             LDREQ    R1,[R4, #+28]
    739                {
    740                  pSPD = pMCT->pSpeedSensorAux;
    741                }
    742                if (pSPD != MC_NULL)
   \      0x400   0x2900             CMP      R1,#+0
   \      0x402   0xD003             BEQ.N    ??UI_GetReg_78
    743                {
    744                  bRetVal = STO_PLL_GetObservedBemfLevel((STO_PLL_Handle_t*)pSPD) >> 16;
   \      0x404   0x4608             MOV      R0,R1
   \      0x406   0x....'....        BL       STO_PLL_GetObservedBemfLevel
   \                     ??UI_GetReg_81: (+1)
   \      0x40A   0x1400             ASRS     R0,R0,#+16
   \                     ??UI_GetReg_78: (+1)
   \      0x40C   0xBD76             POP      {R1,R2,R4-R6,PC}
    745                }
    746              }
    747              break;
    748          
    749              case MC_PROTOCOL_REG_MOTOR_POWER:
    750              {
    751                bRetVal = MPM_GetAvrgElMotorPowerW(pMCT->pMPM);
   \                     ??UI_GetReg_24: (+1)
   \      0x40E   0x6BE0             LDR      R0,[R4, #+60]
   \      0x410   0x....'....        BL       MPM_GetAvrgElMotorPowerW
    752              }
    753              break;
   \      0x414   0xBD76             POP      {R1,R2,R4-R6,PC}
    754          
    755              case MC_PROTOCOL_REG_DAC_OUT1:
    756              {
    757                MC_Protocol_REG_t value = UI_GetDAC(pHandle, DAC_CH0);
    758                bRetVal = value;
   \                     ??UI_GetReg_25: (+1)
   \      0x416   0x2100             MOVS     R1,#+0
   \      0x418   0xE000             B.N      ??UI_GetReg_82
    759              }
    760              break;
    761          
    762              case MC_PROTOCOL_REG_DAC_OUT2:
    763              {
    764                MC_Protocol_REG_t value = UI_GetDAC(pHandle, DAC_CH1);
    765                bRetVal = value;
   \                     ??UI_GetReg_26: (+1)
   \      0x41A   0x2101             MOVS     R1,#+1
   \                     ??UI_GetReg_82: (+1)
   \      0x41C   0x4618             MOV      R0,R3
   \      0x41E   0x....'....        BL       UI_GetDAC
    766              }
    767              break;
   \                     ??UI_GetReg_83: (+1)
   \      0x422   0xBD76             POP      {R1,R2,R4-R6,PC}
    768          
    769              case MC_PROTOCOL_REG_DAC_USER1:
    770              {
    771                if (pHandle->pFctDACGetUserChannelValue)
   \                     ??UI_GetReg_50: (+1)
   \      0x424   0x691A             LDR      R2,[R3, #+16]
   \      0x426   0x2A00             CMP      R2,#+0
   \      0x428   0xD0FB             BEQ.N    ??UI_GetReg_83
    772                {
    773                  bRetVal = (int32_t) pHandle->pFctDACGetUserChannelValue(pHandle, 0);
   \      0x42A   0x2100             MOVS     R1,#+0
   \      0x42C   0xE003             B.N      ??UI_GetReg_84
    774                }
    775                else
    776                {
    777                  bRetVal = (uint32_t) 0;
    778                }
    779              }
    780              break;
    781          
    782              case MC_PROTOCOL_REG_DAC_USER2:
    783              {
    784                if (pHandle->pFctDACGetUserChannelValue)
   \                     ??UI_GetReg_51: (+1)
   \      0x42E   0x691A             LDR      R2,[R3, #+16]
   \      0x430   0x2A00             CMP      R2,#+0
   \      0x432   0xD002             BEQ.N    ??UI_GetReg_85
    785                {
    786                  bRetVal = (int32_t) pHandle->pFctDACGetUserChannelValue(pHandle, 1);
   \      0x434   0x2101             MOVS     R1,#+1
   \                     ??UI_GetReg_84: (+1)
   \      0x436   0x4618             MOV      R0,R3
   \      0x438   0x4790             BLX      R2
   \                     ??UI_GetReg_85: (+1)
   \      0x43A   0xBD76             POP      {R1,R2,R4-R6,PC}
    787                }
    788                else
    789                {
    790                  bRetVal = (uint32_t) 0;
    791                }
    792              }
    793              break;
    794          
    795              case MC_PROTOCOL_REG_MEAS_EL_ANGLE:
    796              {
    797                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_42: (+1)
   \      0x43C   0x6A99             LDR      R1,[R3, #+40]
   \      0x43E   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x442   0xF851 0x2022      LDR      R2,[R1, R2, LSL #+2]
    798                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x446   0x2100             MOVS     R1,#+0
    799                if ((MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_ENC) ||
    800                    (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_HALL))
   \      0x448   0x0F13             LSRS     R3,R2,#+28
   \      0x44A   0x2B02             CMP      R3,#+2
   \      0x44C   0xBF14             ITE      NE
   \      0x44E   0x2B01             CMPNE    R3,#+1
   \      0x450   0x69A1             LDREQ    R1,[R4, #+24]
    801                {
    802                  pSPD = pMCT->pSpeedSensorMain;
    803                }
    804                if ((AUX_SCFG_VALUE(hUICfg) == UI_SCODE_ENC) ||
    805                    (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_HALL))
   \      0x452   0xF3C2 0x6303      UBFX     R3,R2,#+24,#+4
   \      0x456   0x2B02             CMP      R3,#+2
   \      0x458   0xBF1A             ITTE     NE
   \      0x45A   0xF3C2 0x6203      UBFXNE   R2,R2,#+24,#+4
   \      0x45E   0x2A01             CMPNE    R2,#+1
   \      0x460   0x69E1             LDREQ    R1,[R4, #+28]
    806                {
    807                  pSPD = pMCT->pSpeedSensorAux;
    808                }
    809                if (pSPD != MC_NULL)
   \                     ??UI_GetReg_73: (+1)
   \      0x462   0x2900             CMP      R1,#+0
   \      0x464   0xD06A             BEQ.N    ??UI_GetReg_86
    810                {
    811                  bRetVal = SPD_GetElAngle(pSPD);
   \      0x466   0x4608             MOV      R0,R1
   \      0x468   0x....'....        BL       SPD_GetElAngle
   \      0x46C   0xBD76             POP      {R1,R2,R4-R6,PC}
    812                }
    813              }
    814              break;
    815          
    816              case MC_PROTOCOL_REG_MEAS_ROT_SPEED:
    817              {
    818                uint32_t hUICfg = pHandle->pUICfg[pHandle->bSelectedDrive];
   \                     ??UI_GetReg_43: (+1)
   \      0x46E   0x6A99             LDR      R1,[R3, #+40]
   \      0x470   0xF893 0x202C      LDRB     R2,[R3, #+44]
   \      0x474   0xF851 0x3022      LDR      R3,[R1, R2, LSL #+2]
    819                SpeednPosFdbk_Handle_t* pSPD = MC_NULL;
   \      0x478   0x2100             MOVS     R1,#+0
    820                if ((MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_ENC) ||
    821                    (MAIN_SCFG_VALUE(hUICfg) == UI_SCODE_HALL))
   \      0x47A   0x0F1A             LSRS     R2,R3,#+28
   \      0x47C   0x2A02             CMP      R2,#+2
   \      0x47E   0xBF14             ITE      NE
   \      0x480   0x2A01             CMPNE    R2,#+1
   \      0x482   0x69A1             LDREQ    R1,[R4, #+24]
    822                {
    823                  pSPD = pMCT->pSpeedSensorMain;
    824                }
    825                if ((AUX_SCFG_VALUE(hUICfg) == UI_SCODE_ENC) ||
    826                    (AUX_SCFG_VALUE(hUICfg) == UI_SCODE_HALL))
   \      0x484   0xF3C3 0x6203      UBFX     R2,R3,#+24,#+4
   \      0x488   0x2A02             CMP      R2,#+2
   \      0x48A   0xBF14             ITE      NE
   \      0x48C   0x2A01             CMPNE    R2,#+1
   \      0x48E   0x69E1             LDREQ    R1,[R4, #+28]
    827                {
    828                  pSPD = pMCT->pSpeedSensorAux;
    829                }
    830                if (pSPD != MC_NULL)
   \                     ??UI_GetReg_77: (+1)
   \      0x490   0x2900             CMP      R1,#+0
   \      0x492   0xD053             BEQ.N    ??UI_GetReg_86
    831                {
    832                  bRetVal = SPD_GetS16Speed(pSPD);
   \      0x494   0x4608             MOV      R0,R1
   \      0x496   0x....'....        BL       SPD_GetS16Speed
   \      0x49A   0xBD76             POP      {R1,R2,R4-R6,PC}
    833                }
    834              }
    835              break;
    836          
    837              case MC_PROTOCOL_REG_MAX_APP_SPEED:
    838              {
    839                bRetVal = (STC_GetMaxAppPositiveMecSpeedUnit(pMCT->pSpeednTorqueCtrl) * _RPM)/SPEED_UNIT ;
   \                     ??UI_GetReg_52: (+1)
   \      0x49C   0x6A60             LDR      R0,[R4, #+36]
   \      0x49E   0x....'....        BL       STC_GetMaxAppPositiveMecSpeedUnit
   \      0x4A2   0x4346             MULS     R6,R6,R0
   \      0x4A4   0x200A             MOVS     R0,#+10
   \      0x4A6   0xFB96 0xF0F0      SDIV     R0,R6,R0
    840              }
    841              break;
   \      0x4AA   0xBD76             POP      {R1,R2,R4-R6,PC}
    842          
    843              case MC_PROTOCOL_REG_MIN_APP_SPEED:
    844              {
    845                bRetVal = (STC_GetMinAppNegativeMecSpeedUnit(pMCT->pSpeednTorqueCtrl)  * _RPM)/SPEED_UNIT ;
   \                     ??UI_GetReg_53: (+1)
   \      0x4AC   0x6A60             LDR      R0,[R4, #+36]
   \      0x4AE   0x....'....        BL       STC_GetMinAppNegativeMecSpeedUnit
   \                     ??UI_GetReg_68: (+1)
   \      0x4B2   0xFB10 0xF006      SMULBB   R0,R0,R6
   \      0x4B6   0x210A             MOVS     R1,#+10
   \      0x4B8   0xFB90 0xF0F1      SDIV     R0,R0,R1
    846              }
    847              break;
   \      0x4BC   0xBD76             POP      {R1,R2,R4-R6,PC}
    848          
    849              case MC_PROTOCOL_REG_TORQUE_MEAS:
    850              case MC_PROTOCOL_REG_I_Q:
    851              {
    852                bRetVal = MCI_GetIqd(pMCI).q;
   \                     ??UI_GetReg_35: (+1)
   \      0x4BE   0x4628             MOV      R0,R5
   \      0x4C0   0x....'....        BL       MCI_GetIqd
   \      0x4C4   0xE02D             B.N      ??UI_GetReg_79
    853              }
    854              break;
    855          
    856              case MC_PROTOCOL_REG_FLUX_MEAS:
    857              case MC_PROTOCOL_REG_I_D:
    858              {
    859                bRetVal = MCI_GetIqd(pMCI).d;
   \                     ??UI_GetReg_36: (+1)
   \      0x4C6   0x4628             MOV      R0,R5
   \      0x4C8   0x....'....        BL       MCI_GetIqd
   \      0x4CC   0xE030             B.N      ??UI_GetReg_80
    860              }
    861              break;
    862          
    863              case MC_PROTOCOL_REG_RUC_STAGE_NBR:
    864              {
    865                if (pMCT->pRevupCtrl)
   \                     ??UI_GetReg_30: (+1)
   \      0x4CE   0x6961             LDR      R1,[R4, #+20]
   \      0x4D0   0x2900             CMP      R1,#+0
   \      0x4D2   0xD033             BEQ.N    ??UI_GetReg_86
    866                {
    867                  bRetVal = (int32_t)RUC_GetNumberOfPhases(pMCT->pRevupCtrl);
   \      0x4D4   0x4608             MOV      R0,R1
   \      0x4D6   0x....'....        BL       RUC_GetNumberOfPhases
   \      0x4DA   0xBD76             POP      {R1,R2,R4-R6,PC}
    868                }
    869                else
    870                {
    871                  bRetVal = (uint32_t) 0;
    872                }
    873              }
    874              break;
    875          
    876              case MC_PROTOCOL_REG_I_A:
    877              {
    878                bRetVal = MCI_GetIab(pMCI).a;
   \                     ??UI_GetReg_31: (+1)
   \      0x4DC   0x4628             MOV      R0,R5
   \      0x4DE   0x....'....        BL       MCI_GetIab
   \      0x4E2   0xE01E             B.N      ??UI_GetReg_79
    879              }
    880              break;
    881          
    882              case MC_PROTOCOL_REG_I_B:
    883              {
    884                bRetVal = MCI_GetIab(pMCI).b;
   \                     ??UI_GetReg_32: (+1)
   \      0x4E4   0x4628             MOV      R0,R5
   \      0x4E6   0x....'....        BL       MCI_GetIab
   \      0x4EA   0xE021             B.N      ??UI_GetReg_80
    885              }
    886              break;
    887          
    888              case MC_PROTOCOL_REG_I_ALPHA:
    889              {
    890                bRetVal = MCI_GetIalphabeta(pMCI).alpha;
   \                     ??UI_GetReg_33: (+1)
   \      0x4EC   0x4628             MOV      R0,R5
   \      0x4EE   0x....'....        BL       MCI_GetIalphabeta
   \      0x4F2   0xE016             B.N      ??UI_GetReg_79
    891              }
    892              break;
    893          
    894              case MC_PROTOCOL_REG_I_BETA:
    895              {
    896                bRetVal = MCI_GetIalphabeta(pMCI).beta;
   \                     ??UI_GetReg_34: (+1)
   \      0x4F4   0x4628             MOV      R0,R5
   \      0x4F6   0x....'....        BL       MCI_GetIalphabeta
   \      0x4FA   0xE019             B.N      ??UI_GetReg_80
    897              }
    898              break;
    899          
    900              case MC_PROTOCOL_REG_I_Q_REF:
    901              {
    902                bRetVal = MCI_GetIqdref(pMCI).q;
   \                     ??UI_GetReg_37: (+1)
   \      0x4FC   0x4628             MOV      R0,R5
   \      0x4FE   0x....'....        BL       MCI_GetIqdref
   \      0x502   0xE00E             B.N      ??UI_GetReg_79
    903              }
    904              break;
    905          
    906              case MC_PROTOCOL_REG_I_D_REF:
    907              {
    908                bRetVal = MCI_GetIqdref(pMCI).d;
   \                     ??UI_GetReg_54: (+1)
   \      0x504   0x4628             MOV      R0,R5
   \      0x506   0x....'....        BL       MCI_GetIqdref
   \      0x50A   0xE011             B.N      ??UI_GetReg_80
    909              }
    910              break;
    911          
    912              case MC_PROTOCOL_REG_V_Q:
    913              {
    914                bRetVal = MCI_GetVqd(pMCI).q;
   \                     ??UI_GetReg_38: (+1)
   \      0x50C   0x4628             MOV      R0,R5
   \      0x50E   0x....'....        BL       MCI_GetVqd
   \      0x512   0xE006             B.N      ??UI_GetReg_79
    915              }
    916              break;
    917          
    918              case MC_PROTOCOL_REG_V_D:
    919              {
    920                bRetVal = MCI_GetVqd(pMCI).d;
   \                     ??UI_GetReg_39: (+1)
   \      0x514   0x4628             MOV      R0,R5
   \      0x516   0x....'....        BL       MCI_GetVqd
   \      0x51A   0xE009             B.N      ??UI_GetReg_80
    921              }
    922              break;
    923          
    924             case MC_PROTOCOL_REG_V_ALPHA:
    925              {
    926                bRetVal = MCI_GetValphabeta(pMCI).alpha;
   \                     ??UI_GetReg_40: (+1)
   \      0x51C   0x4628             MOV      R0,R5
   \      0x51E   0x....'....        BL       MCI_GetValphabeta
   \                     ??UI_GetReg_79: (+1)
   \      0x522   0x9000             STR      R0,[SP, #+0]
   \                     ??UI_GetReg_71: (+1)
   \      0x524   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
    927              }
    928              break;
   \      0x528   0xBD76             POP      {R1,R2,R4-R6,PC}
    929          
    930              case MC_PROTOCOL_REG_V_BETA:
    931              {
    932                bRetVal = MCI_GetValphabeta(pMCI).beta;
   \                     ??UI_GetReg_41: (+1)
   \      0x52A   0x4628             MOV      R0,R5
   \      0x52C   0x....'....        BL       MCI_GetValphabeta
   \                     ??UI_GetReg_80: (+1)
   \      0x530   0x9000             STR      R0,[SP, #+0]
   \      0x532   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
    933              }
    934              break;
   \      0x536   0xBD76             POP      {R1,R2,R4-R6,PC}
    935          
    936              default:
    937          	{
    938                if ( success != (bool *) 0 ) 
   \                     ??UI_GetReg_63: (+1)
   \      0x538   0xB102             CBZ.N    R2,??UI_GetReg_86
    939                {
    940                  *success = false;
   \      0x53A   0x7010             STRB     R0,[R2, #+0]
    941                }
    942          	}
    943              break;
    944            }
    945            return bRetVal;
   \                     ??UI_GetReg_86: (+1)
   \      0x53C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \      0x53E   0xBF00             Nop
   \                     ??UI_GetReg_0:
   \      0x540   0x34A6'847A        DC32     0x34a6847a
    946          }
    947          
    948          /**
    949            * @brief  Allow to execute a command coming from the user.
    950            * @param  pHandle: Pointer on Handle structure of UI component.
    951            * @param  bCmdID: Code of command to execute.
    952            *         See MC_PROTOCOL_CMD_xxx for code definition.
    953            *  @retval Return true if the command executed succesfully, otherwise false.
    954          */

   \                                 In section .text, align 4
    955          __weak bool UI_ExecCmd(UI_Handle_t *pHandle, uint8_t bCmdID)
    956          {
   \                     UI_ExecCmd: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    957            bool retVal = true;
    958          
    959            MCI_Handle_t * pMCI = pHandle->pMCI[pHandle->bSelectedDrive];
   \        0x2   0xF850 0x2F20      LDR      R2,[R0, #+32]!
   \        0x6   0x7B00             LDRB     R0,[R0, #+12]
   \        0x8   0x2401             MOVS     R4,#+1
    960          
    961            switch (bCmdID)
   \        0xA   0x1E49             SUBS     R1,R1,#+1
   \        0xC   0xF852 0x5020      LDR      R5,[R2, R0, LSL #+2]
   \       0x10   0x290D             CMP      R1,#+13
   \       0x12   0xD82D             BHI.N    ??UI_ExecCmd_1
   \       0x14   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??UI_ExecCmd_0:
   \       0x18   0x07 0x09          DC8      0x7,0x9,0xB,0x2D

   \              0x0B 0x2D
   \       0x1C   0x2D 0x14          DC8      0x2D,0x14,0x20,0x24

   \              0x20 0x24
   \       0x20   0x28 0x2C          DC8      0x28,0x2C,0x2C,0x2C

   \              0x2C 0x2C
   \       0x24   0x2C 0x09          DC8      0x2C,0x9
    962            {
    963            case MC_PROTOCOL_CMD_START_MOTOR:
    964              {
    965                /* Call MCI Start motor; */
    966                MCI_StartMotor(pMCI);
   \                     ??UI_ExecCmd_2: (+1)
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0xE010             B.N      ??UI_ExecCmd_3
    967              }
    968              break;
    969          
    970            case MC_PROTOCOL_CMD_STOP_MOTOR:
    971            case MC_PROTOCOL_CMD_SC_STOP:
    972              {
    973                /* Call MCI Stop motor; */
    974                MCI_StopMotor(pMCI);
   \                     ??UI_ExecCmd_4: (+1)
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0xE011             B.N      ??UI_ExecCmd_5
    975              }
    976              break;
    977          
    978            case MC_PROTOCOL_CMD_STOP_RAMP:
    979              {
    980                if (MCI_GetSTMState(pMCI) == RUN)
   \                     ??UI_ExecCmd_6: (+1)
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       MCI_GetSTMState
   \       0x34   0x2806             CMP      R0,#+6
   \       0x36   0xD11C             BNE.N    ??UI_ExecCmd_7
    981                {
    982                  MCI_StopRamp(pMCI);
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x....'....        BL       MCI_StopRamp
   \       0x3E   0xE018             B.N      ??UI_ExecCmd_7
    983                }
    984              }
    985              break;
    986          
    987            case MC_PROTOCOL_CMD_PING:
    988              {
    989          	  /* Do nothing at the moment */
    990              }
    991              break;
    992          
    993            case MC_PROTOCOL_CMD_START_STOP:
    994              {
    995                /* Queries the STM and a command start or stop depending on the state. */
    996                if (MCI_GetSTMState(pMCI) == IDLE)
   \                     ??UI_ExecCmd_8: (+1)
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0x....'....        BL       MCI_GetSTMState
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0xD102             BNE.N    ??UI_ExecCmd_5
    997                {
    998                  MCI_StartMotor(pMCI);
   \                     ??UI_ExecCmd_3: (+1)
   \       0x4C   0x....'....        BL       MCI_StartMotor
   \       0x50   0xE00F             B.N      ??UI_ExecCmd_7
    999                }
   1000                else
   1001                {
   1002                  MCI_StopMotor(pMCI);
   \                     ??UI_ExecCmd_5: (+1)
   \       0x52   0x....'....        BL       MCI_StopMotor
   \       0x56   0xE00C             B.N      ??UI_ExecCmd_7
   1003                }
   1004              }
   1005              break;
   1006          
   1007            case MC_PROTOCOL_CMD_RESET:
   1008              {
   1009          	  /* Do nothing at the moment */
   1010              }
   1011              break;
   1012          
   1013            case MC_PROTOCOL_CMD_FAULT_ACK:
   1014              {
   1015                MCI_FaultAcknowledged(pMCI);
   \                     ??UI_ExecCmd_9: (+1)
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       MCI_FaultAcknowledged
   1016              }
   1017              break;
   \       0x5E   0xE008             B.N      ??UI_ExecCmd_7
   1018          
   1019            case MC_PROTOCOL_CMD_ENCODER_ALIGN:
   1020              {
   1021                MCI_EncoderAlign(pMCI);
   \                     ??UI_ExecCmd_10: (+1)
   \       0x60   0x4628             MOV      R0,R5
   \       0x62   0x....'....        BL       MCI_EncoderAlign
   1022              }
   1023              break;
   \       0x66   0xE004             B.N      ??UI_ExecCmd_7
   1024          
   1025            case MC_PROTOCOL_CMD_IQDREF_CLEAR:
   1026              {
   1027                MCI_Clear_Iqdref(pMCI);
   \                     ??UI_ExecCmd_11: (+1)
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x....'....        BL       MCI_Clear_Iqdref
   1028              }
   1029              break;
   \       0x6E   0xE000             B.N      ??UI_ExecCmd_7
   1030          
   1031            default:
   1032              {
   1033              retVal = false;
   \                     ??UI_ExecCmd_1: (+1)
   \       0x70   0x2400             MOVS     R4,#+0
   1034          	}
   1035              break;
   1036            }
   1037            return retVal;
   \                     ??UI_ExecCmd_7: (+1)
   \       0x72   0x4620             MOV      R0,R4
   \       0x74   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1038          }
   1039          
   1040          /**
   1041            * @brief  Allow to execute a speed ramp command coming from the user.
   1042            * @param  pHandle: Pointer on Handle structure of UI component.
   1043            * @param  wFinalMecSpeedUnit: Final speed value expressed in the unit defined by #SPEED_UNIT.
   1044            * @param  hDurationms: Duration of the ramp expressed in milliseconds. 
   1045            *         It is possible to set 0 to perform an instantaneous change in the value.
   1046            *  @retval Return true if the command executed succesfully, otherwise false.
   1047            */

   \                                 In section .text, align 2
   1048          __weak bool UI_ExecSpeedRamp(UI_Handle_t *pHandle, int32_t wFinalMecSpeedUnit, uint16_t hDurationms)
   1049          {
   \                     UI_ExecSpeedRamp: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1050            MCI_Handle_t * pMCI = pHandle->pMCI[pHandle->bSelectedDrive];
   1051          
   1052            /* Call MCI Exec Ramp */
   1053            MCI_ExecSpeedRamp(pMCI,(int16_t)((wFinalMecSpeedUnit*SPEED_UNIT)/_RPM),hDurationms);
   \        0x2   0xF100 0x0320      ADD      R3,R0,#+32
   \        0x6   0x200A             MOVS     R0,#+10
   \        0x8   0x681D             LDR      R5,[R3, #+0]
   \        0xA   0x4341             MULS     R1,R0,R1
   \        0xC   0x7B18             LDRB     R0,[R3, #+12]
   \        0xE   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
   \       0x12   0x243C             MOVS     R4,#+60
   \       0x14   0xFB91 0xF1F4      SDIV     R1,R1,R4
   \       0x18   0xB209             SXTH     R1,R1
   \       0x1A   0x....'....        BL       MCI_ExecSpeedRamp
   1054            return true;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1055          }
   1056          /**
   1057            * @brief  It is used to execute a torque ramp command coming from the user.
   1058            * @param  pHandle: Pointer on Handle structure of UI component.
   1059            * @param  hTargetFinal: final torque value. See MCI interface for more
   1060                      details.
   1061            * @param  hDurationms: the duration of the ramp expressed in milliseconds. It
   1062            *         is possible to set 0 to perform an instantaneous change in the value.
   1063            *  @retval Return true if the command executed succesfully, otherwise false.
   1064            */

   \                                 In section .text, align 2
   1065          __weak bool UI_ExecTorqueRamp(UI_Handle_t *pHandle, int16_t hTargetFinal, uint16_t hDurationms)
   1066          {
   \                     UI_ExecTorqueRamp: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1067          
   1068            MCI_Handle_t * pMCI = pHandle->pMCI[pHandle->bSelectedDrive];
   1069          
   1070            /* Call MCI Exec Ramp */
   1071            MCI_ExecTorqueRamp(pMCI,hTargetFinal,hDurationms);
   \        0x2   0xF850 0x3F20      LDR      R3,[R0, #+32]!
   \        0x6   0x7B00             LDRB     R0,[R0, #+12]
   \        0x8   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \        0xC   0x....'....        BL       MCI_ExecTorqueRamp
   1072            return true;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1073          }
   1074          
   1075          /**
   1076            * @brief  Executes a get Revup data command coming from the user
   1077            *
   1078            * @param  pHandle Pointer on Handle structure of UI component.
   1079            * @param  bStage Rev up phase to be read (zero based).
   1080            * @param  pDurationms Pointer to an uint16_t variable used to retrieve
   1081            *         the duration of the Revup stage.
   1082            * @param  pFinalMecSpeedUnit Pointer to an int16_t variable used to
   1083            *         retrieve the mechanical speed at the end of that stage. Expressed in
   1084            *         the unit defined by #SPEED_UNIT.
   1085            * @param  pFinalTorque Pointer to an int16_t variable used to
   1086            *         retrieve the value of motor torque at the end of that stage. 
   1087            *         This value represents actually the Iq current expressed in digit.
   1088            *         
   1089            *  @retval Returns true if the command executed successfully, false otherwise.
   1090            */

   \                                 In section .text, align 2
   1091          __weak bool UI_GetRevupData(UI_Handle_t *pHandle, uint8_t bStage, uint16_t* pDurationms,
   1092                               int16_t* pFinalMecSpeedUnit, int16_t* pFinalTorque )
   1093          {
   \                     UI_GetRevupData: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4688             MOV      R8,R1
   1094            bool hRetVal = true;
   1095          
   1096            RevUpCtrl_Handle_t *pRevupCtrl = pHandle->pMCT[pHandle->bSelectedDrive]->pRevupCtrl;
   \        0x6   0xF850 0x1F24      LDR      R1,[R0, #+36]!
   \        0xA   0x7A00             LDRB     R0,[R0, #+8]
   \        0xC   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \       0x10   0x694C             LDR      R4,[R1, #+20]
   \       0x12   0x4616             MOV      R6,R2
   \       0x14   0x4699             MOV      R9,R3
   \       0x16   0x2501             MOVS     R5,#+1
   1097            if (pRevupCtrl)
   \       0x18   0xB18C             CBZ.N    R4,??UI_GetRevupData_0
   \       0x1A   0x9F08             LDR      R7,[SP, #+32]
   1098            {
   1099              *pDurationms = RUC_GetPhaseDurationms(pRevupCtrl, bStage);
   \       0x1C   0x4641             MOV      R1,R8
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       RUC_GetPhaseDurationms
   \       0x24   0x8030             STRH     R0,[R6, #+0]
   1100              *pFinalMecSpeedUnit = RUC_GetPhaseFinalMecSpeedUnit(pRevupCtrl, bStage);
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       RUC_GetPhaseFinalMecSpeedUnit
   \       0x2E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   1101              *pFinalTorque = RUC_GetPhaseFinalTorque(pRevupCtrl, bStage);
   \       0x32   0x4641             MOV      R1,R8
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       RUC_GetPhaseFinalTorque
   \       0x3A   0x8038             STRH     R0,[R7, #+0]
   \       0x3C   0xE000             B.N      ??UI_GetRevupData_1
   1102            }
   1103            else
   1104            {
   1105              hRetVal = false;
   \                     ??UI_GetRevupData_0: (+1)
   \       0x3E   0x2500             MOVS     R5,#+0
   1106            }
   1107            return hRetVal;
   \                     ??UI_GetRevupData_1: (+1)
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1108          }
   1109          
   1110          /**
   1111            * @brief  It is used to execute a set Revup data command coming from the user.
   1112            * @param  pHandle: Pointer on Handle structure of UI component.
   1113            * @param  bStage: is the rev up phase, zero based, to be modified.
   1114            * @param  hDurationms: is the new duration of the Revup stage.
   1115            * @param  hFinalMecSpeedUnit: is the new mechanical speed at the end of that
   1116            *         stage expressed in the unit defined by SPEED_UNIT.
   1117            * @param  hFinalTorque: is the new value of motor torque at the end of that
   1118            *         stage. This value represents actually the Iq current expressed in
   1119            *         digit.
   1120            *  @retval Return true if the command executed successfully, otherwise false.
   1121            */

   \                                 In section .text, align 2
   1122          __weak bool UI_SetRevupData(UI_Handle_t *pHandle, uint8_t bStage, uint16_t hDurationms,
   1123                               int16_t hFinalMecSpeedUnit, int16_t hFinalTorque )
   1124          {
   \                     UI_SetRevupData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
   1125            RevUpCtrl_Handle_t *pRevupCtrl = pHandle->pMCT[pHandle->bSelectedDrive]->pRevupCtrl;
   \        0x4   0xF850 0x1F24      LDR      R1,[R0, #+36]!
   \        0x8   0x7A00             LDRB     R0,[R0, #+8]
   \        0xA   0xF9BD 0x6018      LDRSH    R6,[SP, #+24]
   \        0xE   0x461D             MOV      R5,R3
   \       0x10   0xF851 0x3020      LDR      R3,[R1, R0, LSL #+2]
   \       0x14   0x695F             LDR      R7,[R3, #+20]
   1126            RUC_SetPhaseDurationms(pRevupCtrl, bStage, hDurationms);
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x4638             MOV      R0,R7
   \       0x1A   0x....'....        BL       RUC_SetPhaseDurationms
   1127            RUC_SetPhaseFinalMecSpeedUnit(pRevupCtrl, bStage, hFinalMecSpeedUnit);
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x4621             MOV      R1,R4
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x....'....        BL       RUC_SetPhaseFinalMecSpeedUnit
   1128            RUC_SetPhaseFinalTorque(pRevupCtrl, bStage, hFinalTorque);
   \       0x28   0x4632             MOV      R2,R6
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x4638             MOV      R0,R7
   \       0x2E   0x....'....        BL       RUC_SetPhaseFinalTorque
   1129            return true;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1130          }
   1131          
   1132          /**
   1133            * @brief  Allow to execute a set current reference command coming from the user.
   1134            * @param  pHandle: Pointer on Handle structure of UI component.
   1135            * @param  hIqRef: Current Iq reference on qd reference frame. 
   1136            *         This value is expressed in digit. 
   1137            * @note   current convertion formula (from digit to Amps):
   1138            *               Current(Amps) = [Current(digit) * Vdd micro] / [65536 * Rshunt * Aop]
   1139            * @param  hIdRef: Current Id reference on qd reference frame. 
   1140            *         This value is expressed in digit. See hIqRef param description.
   1141            * @retval none.
   1142            */

   \                                 In section .text, align 2
   1143          __weak void UI_SetCurrentReferences(UI_Handle_t *pHandle, int16_t hIqRef, int16_t hIdRef)
   1144          {
   \                     UI_SetCurrentReferences: (+1)
   \        0x0   0xB082             SUB      SP,SP,#+8
   1145          
   1146            MCI_Handle_t * pMCI = pHandle->pMCI[pHandle->bSelectedDrive];
   1147            qd_t currComp;
   1148            currComp.q = hIqRef;
   \        0x2   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   1149            currComp.d = hIdRef;
   \        0x6   0xF8AD 0x2002      STRH     R2,[SP, #+2]
   1150            MCI_SetCurrentReferences(pMCI,currComp);
   \        0xA   0xF850 0x2F20      LDR      R2,[R0, #+32]!
   \        0xE   0x7B03             LDRB     R3,[R0, #+12]
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0xF852 0x0023      LDR      R0,[R2, R3, LSL #+2]
   \       0x16   0xB002             ADD      SP,SP,#+8
   \       0x18   0x....'....        B.W      MCI_SetCurrentReferences
   1151          }
   1152          
   1153          /**
   1154            * @brief  Allow to get information about MP registers available for each step.
   1155            *         PC send to the FW the list of steps to get the available registers. 
   1156            *         The FW returs the list of available registers for that steps.
   1157            * @param  stepList: List of requested steps.
   1158            * @param  pMPInfo: The returned list of register.
   1159            *         It is populated by this function.
   1160            * @retval true if MP is enabled, false otherwise.
   1161            */

   \                                 In section .text, align 2
   1162          __weak bool UI_GetMPInfo(pMPInfo_t stepList, pMPInfo_t pMPInfo)
   1163          {
   1164              return false;
   \                     UI_GetMPInfo: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1165          }
   1166          
   1167          /**
   1168            * @brief  Hardware and software DAC initialization.
   1169            * @param  pHandle: Pointer on Handle structure of DACx UI component.
   1170            * @retval none.
   1171            */

   \                                 In section .text, align 2
   1172          __weak void UI_DACInit(UI_Handle_t *pHandle)
   1173          {
   1174            if (pHandle->pFct_DACInit)
   \                     UI_DACInit: (+1)
   \        0x0   0x6941             LDR      R1,[R0, #+20]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF18             IT       NE
   1175            {
   1176          	  pHandle->pFct_DACInit(pHandle);
   \        0x6   0x4708             BXNE     R1
   1177            }
   1178          }
   \        0x8   0x4770             BX       LR               ;; return
   1179          
   1180          /**
   1181            * @brief  Allow to update the DAC outputs. 
   1182            * @param  pHandle: Pointer on Handle structure of DACx UI component.
   1183            * @retval none.
   1184            */

   \                                 In section .text, align 2, keep-with-next
   1185          void UI_DACExec(UI_Handle_t *pHandle)
   1186          {
   1187            if (pHandle->pFct_DACExec)
   \                     UI_DACExec: (+1)
   \        0x0   0x6981             LDR      R1,[R0, #+24]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF18             IT       NE
   1188            {
   1189              pHandle->pFct_DACExec(pHandle);
   \        0x6   0x4708             BXNE     R1
   1190            }
   1191          }
   \        0x8   0x4770             BX       LR               ;; return
   1192          
   1193          /**
   1194            * @brief  Allow to set up the DAC outputs. 
   1195            *         Selected variables will be provided in the related output channels after next DACExec.
   1196            * @param  pHandle: Pointer on Handle structure of DACx UI component.
   1197            * @param  bChannel: DAC channel to program. 
   1198            *         It must be one of the exported channels (Example: DAC_CH0).
   1199            * @param  bVariable: Value to be provided in out through the selected channel.
   1200            *         It must be one of the exported UI register (Example: MC_PROTOCOL_REG_I_A).
   1201            * @retval none.
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203          void UI_SetDAC(UI_Handle_t *pHandle, DAC_Channel_t bChannel,
   1204                                   MC_Protocol_REG_t bVariable)
   1205          {
   1206            if (pHandle->pFctDACSetChannelConfig)
   \                     UI_SetDAC: (+1)
   \        0x0   0x6843             LDR      R3,[R0, #+4]
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xBF18             IT       NE
   1207            {
   1208          	  pHandle->pFctDACSetChannelConfig(pHandle, bChannel, bVariable);
   \        0x6   0x4718             BXNE     R3
   1209            }
   1210          }
   \        0x8   0x4770             BX       LR               ;; return
   1211          
   1212          /**
   1213            * @brief  Allow to get the current DAC channel selected output.
   1214            * @param  pHandle: Pointer on Handle structure of DACx UI component.
   1215            * @param  bChannel: Inspected DAC channel. 
   1216            *         It must be one of the exported channels (Example: DAC_CH0).
   1217            * @retval MC_Protocol_REG_t: Variables provided in out through the inspected channel. 
   1218            *         It must be one of the exported UI register (Example: MC_PROTOCOL_REG_I_A).
   1219            */

   \                                 In section .text, align 2
   1220          __weak MC_Protocol_REG_t UI_GetDAC(UI_Handle_t *pHandle, DAC_Channel_t bChannel)
   1221          {
   \                     UI_GetDAC: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1222            MC_Protocol_REG_t retVal = MC_PROTOCOL_REG_UNDEFINED;
   1223            if (pHandle->pFctDACGetChannelConfig)
   \        0x2   0x6883             LDR      R3,[R0, #+8]
   \        0x4   0x2289             MOVS     R2,#+137
   \        0x6   0xB10B             CBZ.N    R3,??UI_GetDAC_0
   1224            {
   1225              retVal = pHandle->pFctDACGetChannelConfig(pHandle, bChannel);
   \        0x8   0x4798             BLX      R3
   \        0xA   0x4602             MOV      R2,R0
   1226            }
   1227            return retVal;
   \                     ??UI_GetDAC_0: (+1)
   \        0xC   0x4610             MOV      R0,R2
   \        0xE   0xBD02             POP      {R1,PC}          ;; return
   1228          }
   1229          
   1230          /**
   1231            * @brief  Allow to set the value of the user DAC channel.
   1232            * @param  pHandle: Pointer on Handle structure of DACx UI component.
   1233            * @param  bUserChNumber: user DAC channel to program.
   1234            * @param  hValue: Value to be put in output.
   1235            * @retval none.
   1236            */

   \                                 In section .text, align 2
   1237          __weak void UI_SetUserDAC(UI_Handle_t *pHandle, DAC_UserChannel_t bUserChNumber, int16_t hValue)
   1238          {
   1239            if (pHandle->pFctDACSetUserChannelValue)
   \                     UI_SetUserDAC: (+1)
   \        0x0   0x68C3             LDR      R3,[R0, #+12]
   \        0x2   0x2B00             CMP      R3,#+0
   \        0x4   0xBF18             IT       NE
   1240            {
   1241          	  pHandle->pFctDACSetUserChannelValue(pHandle, bUserChNumber, hValue);
   \        0x6   0x4718             BXNE     R3
   1242            }
   1243          }
   \        0x8   0x4770             BX       LR               ;; return
   1244          
   1245          /**
   1246            * @}
   1247            */
   1248          
   1249          /**
   1250            * @}
   1251            */
   1252          
   1253          /**
   1254            * @}
   1255            */
   1256          
   1257          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   UI_DACExec
         0   -- Indirect call
       0   UI_DACInit
         0   -- Indirect call
      16   UI_ExecCmd
        16   -> MCI_Clear_Iqdref
        16   -> MCI_EncoderAlign
        16   -> MCI_FaultAcknowledged
        16   -> MCI_GetSTMState
        16   -> MCI_StartMotor
        16   -> MCI_StopMotor
        16   -> MCI_StopRamp
      16   UI_ExecSpeedRamp
        16   -> MCI_ExecSpeedRamp
       8   UI_ExecTorqueRamp
         8   -> MCI_ExecTorqueRamp
       8   UI_GetDAC
         8   -- Indirect call
       0   UI_GetMPInfo
      24   UI_GetReg
        24   -- Indirect call
        24   -> MCI_GetAvrgMecSpeedUnit
        24   -> MCI_GetControlMode
        24   -> MCI_GetIab
        24   -> MCI_GetIalphabeta
        24   -> MCI_GetIqd
        24   -> MCI_GetIqdref
        24   -> MCI_GetLastRampFinalSpeed
        24   -> MCI_GetMecSpeedRefUnit
        24   -> MCI_GetValphabeta
        24   -> MCI_GetVqd
        24   -> MPM_GetAvrgElMotorPowerW
        24   -> NTC_GetAvTemp_C
        24   -> PID_GetKD
        24   -> PID_GetKI
        24   -> PID_GetKIDivisor
        24   -> PID_GetKP
        24   -> PID_GetKPDivisor
        24   -> RUC_GetNumberOfPhases
        24   -> SPD_GetElAngle
        24   -> SPD_GetS16Speed
        24   -> STC_GetMaxAppPositiveMecSpeedUnit
        24   -> STC_GetMinAppNegativeMecSpeedUnit
        24   -> STM_GetFaultState
        24   -> STM_GetState
        24   -> STO_GetPLLGains
        24   -> STO_PLL_GetEstimatedBemf
        24   -> STO_PLL_GetEstimatedBemfLevel
        24   -> STO_PLL_GetEstimatedCurrent
        24   -> STO_PLL_GetObservedBemfLevel
        24   -> STO_PLL_GetObserverGains
        24   -> UI_GetDAC
        24   -> UI_GetSelectedMC
        24   -> VBS_GetAvBusVoltage_V
      32   UI_GetRevupData
        32   -> RUC_GetPhaseDurationms
        32   -> RUC_GetPhaseFinalMecSpeedUnit
        32   -> RUC_GetPhaseFinalTorque
       0   UI_GetSelectedMC
       0   UI_GetSelectedMCConfig
       8   UI_Init
       8   UI_SelectMC
       8   UI_SetCurrentReferences
         0   -> MCI_SetCurrentReferences
       0   UI_SetDAC
         0   -- Indirect call
      24   UI_SetReg
        24   -> MCI_ExecSpeedRamp
        24   -> MCI_ExecTorqueRamp
        24   -> MCI_GetIqdref
        24   -> MCI_GetMecSpeedRefUnit
        24   -> MCI_GetTeref
        24   -> MCI_SetCurrentReferences
        24   -> MCI_SetIdref
        24   -> PID_SetKD
        24   -> PID_SetKI
        24   -> PID_SetKP
        24   -> STO_GetPLLGains
        24   -> STO_PLL_GetObserverGains
        24   -> STO_PLL_SetObserverGains
        24   -> STO_SetPLLGains
        24   -> UI_SelectMC
      24   UI_SetRevupData
        24   -> RUC_SetPhaseDurationms
        24   -> RUC_SetPhaseFinalMecSpeedUnit
        24   -> RUC_SetPhaseFinalTorque
       0   UI_SetUserDAC
         0   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      10  UI_DACExec
      10  UI_DACInit
     118  UI_ExecCmd
      34  UI_ExecSpeedRamp
      20  UI_ExecTorqueRamp
      16  UI_GetDAC
       4  UI_GetMPInfo
   1'348  UI_GetReg
      70  UI_GetRevupData
       6  UI_GetSelectedMC
      12  UI_GetSelectedMCConfig
      20  UI_Init
      22  UI_SelectMC
      28  UI_SetCurrentReferences
      10  UI_SetDAC
     490  UI_SetReg
      54  UI_SetRevupData
      10  UI_SetUserDAC

 
 2'282 bytes in section .text
 
 20 bytes of CODE memory (+ 2'262 bytes shared)

Errors: none
Warnings: none
