###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:12
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_i2c.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW4512.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_i2c.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\stm32f3xx_hal_i2c.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\stm32f3xx_hal_i2c.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @brief   I2C HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State and Errors functions
     11            *
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16              [..]
     17              The I2C HAL driver can be used as follows:
     18          
     19              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     20                  I2C_HandleTypeDef  hi2c;
     21          
     22              (#)Initialize the I2C low level resources by implementing the @ref HAL_I2C_MspInit() API:
     23                  (##) Enable the I2Cx interface clock
     24                  (##) I2C pins configuration
     25                      (+++) Enable the clock for the I2C GPIOs
     26                      (+++) Configure I2C pins as alternate function open-drain
     27                  (##) NVIC configuration if you need to use interrupt process
     28                      (+++) Configure the I2Cx interrupt priority
     29                      (+++) Enable the NVIC I2C IRQ Channel
     30                  (##) DMA Configuration if you need to use DMA process
     31                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive channel
     32                      (+++) Enable the DMAx interface clock using
     33                      (+++) Configure the DMA handle parameters
     34                      (+++) Configure the DMA Tx or Rx channel
     35                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     36                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
     37                            the DMA Tx or Rx channel
     38          
     39              (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,
     40                  Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.
     41          
     42              (#) Initialize the I2C registers by calling the @ref HAL_I2C_Init(), configures also the low level Hardware
     43                  (GPIO, CLOCK, NVIC...etc) by calling the customized @ref HAL_I2C_MspInit(&hi2c) API.
     44          
     45              (#) To check if target device is ready for communication, use the function @ref HAL_I2C_IsDeviceReady()
     46          
     47              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     48          
     49              *** Polling mode IO operation ***
     50              =================================
     51              [..]
     52                (+) Transmit in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Transmit()
     53                (+) Receive in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Receive()
     54                (+) Transmit in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Transmit()
     55                (+) Receive in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Receive()
     56          
     57              *** Polling mode IO MEM operation ***
     58              =====================================
     59              [..]
     60                (+) Write an amount of data in blocking mode to a specific memory address using @ref HAL_I2C_Mem_Write()
     61                (+) Read an amount of data in blocking mode from a specific memory address using @ref HAL_I2C_Mem_Read()
     62          
     63          
     64              *** Interrupt mode IO operation ***
     65              ===================================
     66              [..]
     67                (+) Transmit in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Transmit_IT()
     68                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
     69                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
     70                (+) Receive in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Receive_IT()
     71                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
     72                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
     73                (+) Transmit in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Transmit_IT()
     74                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
     75                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
     76                (+) Receive in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Receive_IT()
     77                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
     78                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
     79                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
     80                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
     81                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
     82                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
     83                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
     84                (+) Discard a slave I2C process communication using @ref __HAL_I2C_GENERATE_NACK() macro.
     85                     This action will inform Master to generate a Stop condition to discard the communication.
     86          
     87          
     88              *** Interrupt mode or DMA mode IO sequential operation ***
     89              ==========================================================
     90              [..]
     91                (@) These interfaces allow to manage a sequential transfer with a repeated start condition
     92                    when a direction change during transfer
     93              [..]
     94                (+) A specific option field manage the different steps of a sequential transfer
     95                (+) Option field values are defined through @ref I2C_XFEROPTIONS and are listed below:
     96                (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces in no sequential mode
     97                (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
     98                                      and data to transfer without a final stop condition
     99                (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with start condition, address
    100                                      and data to transfer without a final stop condition, an then permit a call the same master sequential interface
    101                                      several times (like @ref HAL_I2C_Master_Seq_Transmit_IT() then @ref HAL_I2C_Master_Seq_Transmit_IT()
    102                                      or @ref HAL_I2C_Master_Seq_Transmit_DMA() then @ref HAL_I2C_Master_Seq_Transmit_DMA())
    103                (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
    104                                      and with new data to transfer if the direction change or manage only the new data to transfer
    105                                      if no direction change and without a final stop condition in both cases
    106                (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
    107                                      and with new data to transfer if the direction change or manage only the new data to transfer
    108                                      if no direction change and with a final stop condition in both cases
    109                (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition after several call of the same master sequential
    110                                      interface several times (link with option I2C_FIRST_AND_NEXT_FRAME).
    111                                      Usage can, transfer several bytes one by one using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    112                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    113                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    114                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME).
    115                                      Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or Receive sequence permit to call the oposite interface Receive or Transmit
    116                                        without stopping the communication and so generate a restart condition.
    117                (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after each call of the same master sequential
    118                                      interface.
    119                                      Usage can, transfer several bytes one by one with a restart with slave address between each bytes using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    120                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    121                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    122                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME).
    123                                      Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic generation of STOP condition.
    124          
    125                (+) Differents sequential I2C interfaces are listed below:
    126                (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Transmit_IT()
    127                      or using @ref HAL_I2C_Master_Seq_Transmit_DMA()
    128                (+++) At transmission end of current frame transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    129                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    130                (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Receive_IT()
    131                      or using @ref HAL_I2C_Master_Seq_Receive_DMA()
    132                (+++) At reception end of current frame transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    133                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    134                (++) Abort a master IT or DMA I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    135                (+++) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    136                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    137                (++) Enable/disable the Address listen mode in slave I2C mode using @ref HAL_I2C_EnableListen_IT() @ref HAL_I2C_DisableListen_IT()
    138                (+++) When address slave I2C match, @ref HAL_I2C_AddrCallback() is executed and user can
    139                     add his own code to check the Address Match Code and the transmission direction request by master (Write/Read).
    140                (+++) At Listen mode end @ref HAL_I2C_ListenCpltCallback() is executed and user can
    141                     add his own code by customization of function pointer @ref HAL_I2C_ListenCpltCallback()
    142                (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Transmit_IT()
    143                      or using @ref HAL_I2C_Slave_Seq_Transmit_DMA()
    144                (+++) At transmission end of current frame transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    145                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    146                (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Receive_IT()
    147                      or using @ref HAL_I2C_Slave_Seq_Receive_DMA()
    148                (+++) At reception end of current frame transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    149                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    150                (++) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    151                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    152                (++) Discard a slave I2C process communication using @ref __HAL_I2C_GENERATE_NACK() macro.
    153                     This action will inform Master to generate a Stop condition to discard the communication.
    154          
    155              *** Interrupt mode IO MEM operation ***
    156              =======================================
    157              [..]
    158                (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
    159                    @ref HAL_I2C_Mem_Write_IT()
    160                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    161                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    162                (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
    163                    @ref HAL_I2C_Mem_Read_IT()
    164                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    165                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    166                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    167                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    168          
    169              *** DMA mode IO operation ***
    170              ==============================
    171              [..]
    172                (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
    173                    @ref HAL_I2C_Master_Transmit_DMA()
    174                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    175                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    176                (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
    177                    @ref HAL_I2C_Master_Receive_DMA()
    178                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    179                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    180                (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
    181                    @ref HAL_I2C_Slave_Transmit_DMA()
    182                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    183                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    184                (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
    185                    @ref HAL_I2C_Slave_Receive_DMA()
    186                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    187                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    188                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    189                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    190                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    191                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    192                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    193                (+) Discard a slave I2C process communication using @ref __HAL_I2C_GENERATE_NACK() macro.
    194                     This action will inform Master to generate a Stop condition to discard the communication.
    195          
    196              *** DMA mode IO MEM operation ***
    197              =================================
    198              [..]
    199                (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
    200                    @ref HAL_I2C_Mem_Write_DMA()
    201                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    202                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    203                (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
    204                    @ref HAL_I2C_Mem_Read_DMA()
    205                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    206                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    207                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    208                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    209          
    210          
    211               *** I2C HAL driver macros list ***
    212               ==================================
    213               [..]
    214                 Below the list of most used macros in I2C HAL driver.
    215          
    216                (+) @ref __HAL_I2C_ENABLE: Enable the I2C peripheral
    217                (+) @ref __HAL_I2C_DISABLE: Disable the I2C peripheral
    218                (+) @ref __HAL_I2C_GENERATE_NACK: Generate a Non-Acknowledge I2C peripheral in Slave mode
    219                (+) @ref __HAL_I2C_GET_FLAG: Check whether the specified I2C flag is set or not
    220                (+) @ref __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag
    221                (+) @ref __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    222                (+) @ref __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    223          
    224               *** Callback registration ***
    225               =============================================
    226              [..]
    227               The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1
    228               allows the user to configure dynamically the driver callbacks.
    229               Use Functions @ref HAL_I2C_RegisterCallback() or @ref HAL_I2C_RegisterAddrCallback()
    230               to register an interrupt callback.
    231              [..]
    232               Function @ref HAL_I2C_RegisterCallback() allows to register following callbacks:
    233                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    234                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    235                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    236                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    237                 (+) ListenCpltCallback   : callback for end of listen mode.
    238                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    239                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    240                 (+) ErrorCallback        : callback for error detection.
    241                 (+) AbortCpltCallback    : callback for abort completion process.
    242                 (+) MspInitCallback      : callback for Msp Init.
    243                 (+) MspDeInitCallback    : callback for Msp DeInit.
    244               This function takes as parameters the HAL peripheral handle, the Callback ID
    245               and a pointer to the user callback function.
    246              [..]
    247               For specific callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_RegisterAddrCallback().
    248              [..]
    249               Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default
    250               weak function.
    251               @ref HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
    252               and the Callback ID.
    253               This function allows to reset following callbacks:
    254                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    255                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    256                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    257                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    258                 (+) ListenCpltCallback   : callback for end of listen mode.
    259                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    260                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    261                 (+) ErrorCallback        : callback for error detection.
    262                 (+) AbortCpltCallback    : callback for abort completion process.
    263                 (+) MspInitCallback      : callback for Msp Init.
    264                 (+) MspDeInitCallback    : callback for Msp DeInit.
    265              [..]
    266               For callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_UnRegisterAddrCallback().
    267              [..]
    268               By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET
    269               all callbacks are set to the corresponding weak functions:
    270               examples @ref HAL_I2C_MasterTxCpltCallback(), @ref HAL_I2C_MasterRxCpltCallback().
    271               Exception done for MspInit and MspDeInit functions that are
    272               reset to the legacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when
    273               these callbacks are null (not registered beforehand).
    274               If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()
    275               keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    276              [..]
    277               Callbacks can be registered/unregistered in @ref HAL_I2C_STATE_READY state only.
    278               Exception done MspInit/MspDeInit functions that can be registered/unregistered
    279               in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
    280               thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    281               Then, the user first registers the MspInit/MspDeInit user callbacks
    282               using @ref HAL_I2C_RegisterCallback() before calling @ref HAL_I2C_DeInit()
    283               or @ref HAL_I2C_Init() function.
    284              [..]
    285               When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or
    286               not defined, the callback registration feature is not available and all callbacks
    287               are set to the corresponding weak functions.
    288          
    289               [..]
    290                 (@) You can refer to the I2C HAL driver header file for more useful macros
    291          
    292            @endverbatim
    293            ******************************************************************************
    294            * @attention
    295            *
    296            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    297            * All rights reserved.</center></h2>
    298            *
    299            * This software component is licensed by ST under BSD 3-Clause license,
    300            * the "License"; You may not use this file except in compliance with the
    301            * License. You may obtain a copy of the License at:
    302            *                        opensource.org/licenses/BSD-3-Clause
    303            *
    304            ******************************************************************************
    305            */
    306          
    307          /* Includes ------------------------------------------------------------------*/
    308          #include "stm32f3xx_hal.h"
    309          
    310          /** @addtogroup STM32F3xx_HAL_Driver
    311            * @{
    312            */
    313          
    314          /** @defgroup I2C I2C
    315            * @brief I2C HAL module driver
    316            * @{
    317            */
    318          
    319          #ifdef HAL_I2C_MODULE_ENABLED
    320          
    321          /* Private typedef -----------------------------------------------------------*/
    322          /* Private define ------------------------------------------------------------*/
    323          
    324          /** @defgroup I2C_Private_Define I2C Private Define
    325            * @{
    326            */
    327          #define TIMING_CLEAR_MASK   (0xF0FFFFFFU)  /*!< I2C TIMING clear register Mask */
    328          #define I2C_TIMEOUT_ADDR    (10000U)       /*!< 10 s  */
    329          #define I2C_TIMEOUT_BUSY    (25U)          /*!< 25 ms */
    330          #define I2C_TIMEOUT_DIR     (25U)          /*!< 25 ms */
    331          #define I2C_TIMEOUT_RXNE    (25U)          /*!< 25 ms */
    332          #define I2C_TIMEOUT_STOPF   (25U)          /*!< 25 ms */
    333          #define I2C_TIMEOUT_TC      (25U)          /*!< 25 ms */
    334          #define I2C_TIMEOUT_TCR     (25U)          /*!< 25 ms */
    335          #define I2C_TIMEOUT_TXIS    (25U)          /*!< 25 ms */
    336          #define I2C_TIMEOUT_FLAG    (25U)          /*!< 25 ms */
    337          
    338          #define MAX_NBYTE_SIZE      255U
    339          #define SlaveAddr_SHIFT     7U
    340          #define SlaveAddr_MSK       0x06U
    341          
    342          /* Private define for @ref PreviousState usage */
    343          #define I2C_STATE_MSK             ((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | (uint32_t)HAL_I2C_STATE_BUSY_RX) & (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY)))) /*!< Mask State define, keep only RX and TX bits            */
    344          #define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))                                                        /*!< Default Value                                          */
    345          #define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy TX, combinaison of State LSB and Mode enum */
    346          #define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy RX, combinaison of State LSB and Mode enum */
    347          #define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy TX, combinaison of State LSB and Mode enum  */
    348          #define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy RX, combinaison of State LSB and Mode enum  */
    349          #define I2C_STATE_MEM_BUSY_TX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MEM))               /*!< Memory Busy TX, combinaison of State LSB and Mode enum */
    350          #define I2C_STATE_MEM_BUSY_RX     ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MEM))               /*!< Memory Busy RX, combinaison of State LSB and Mode enum */
    351          
    352          
    353          /* Private define to centralize the enable/disable of Interrupts */
    354          #define I2C_XFER_TX_IT          (0x00000001U)
    355          #define I2C_XFER_RX_IT          (0x00000002U)
    356          #define I2C_XFER_LISTEN_IT      (0x00000004U)
    357          
    358          #define I2C_XFER_ERROR_IT       (0x00000011U)
    359          #define I2C_XFER_CPLT_IT        (0x00000012U)
    360          #define I2C_XFER_RELOAD_IT      (0x00000012U)
    361          
    362          /* Private define Sequential Transfer Options default/reset value */
    363          #define I2C_NO_OPTION_FRAME     (0xFFFF0000U)
    364          /**
    365            * @}
    366            */
    367          
    368          /* Private macro -------------------------------------------------------------*/
    369          /* Private variables ---------------------------------------------------------*/
    370          /* Private function prototypes -----------------------------------------------*/
    371          
    372          /** @defgroup I2C_Private_Functions I2C Private Functions
    373            * @{
    374            */
    375          /* Private functions to handle DMA transfer */
    376          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    377          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    378          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    379          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    380          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    381          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma);
    382          
    383          /* Private functions to handle IT transfer */
    384          static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    385          static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c);
    386          static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c);
    387          static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    388          static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    389          static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags);
    390          static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode);
    391          
    392          /* Private functions to handle IT transfer */
    393          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    394          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    395          
    396          /* Private functions for I2C transfer IRQ handler */
    397          static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    398          static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    399          static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    400          static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources);
    401          
    402          /* Private functions to handle flags during polling transfer */
    403          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart);
    404          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    405          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    406          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    407          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    408          
    409          /* Private functions to centralize the enable/disable of Interrupts */
    410          static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);
    411          static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest);
    412          
    413          /* Private function to flush TXDR register */
    414          static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c);
    415          
    416          /* Private function to handle  start, restart or stop a transfer */
    417          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request);
    418          
    419          /* Private function to Convert Specific options */
    420          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c);
    421          /**
    422            * @}
    423            */
    424          
    425          /* Exported functions --------------------------------------------------------*/
    426          
    427          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    428            * @{
    429            */
    430          
    431          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    432           *  @brief    Initialization and Configuration functions
    433           *
    434          @verbatim
    435           ===============================================================================
    436                        ##### Initialization and de-initialization functions #####
    437           ===============================================================================
    438              [..]  This subsection provides a set of functions allowing to initialize and
    439                    deinitialize the I2Cx peripheral:
    440          
    441                (+) User must Implement HAL_I2C_MspInit() function in which he configures
    442                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    443          
    444                (+) Call the function HAL_I2C_Init() to configure the selected device with
    445                    the selected configuration:
    446                  (++) Clock Timing
    447                  (++) Own Address 1
    448                  (++) Addressing mode (Master, Slave)
    449                  (++) Dual Addressing mode
    450                  (++) Own Address 2
    451                  (++) Own Address 2 Mask
    452                  (++) General call mode
    453                  (++) Nostretch mode
    454          
    455                (+) Call the function HAL_I2C_DeInit() to restore the default configuration
    456                    of the selected I2Cx peripheral.
    457          
    458          @endverbatim
    459            * @{
    460            */
    461          
    462          /**
    463            * @brief  Initializes the I2C according to the specified parameters
    464            *         in the I2C_InitTypeDef and initialize the associated handle.
    465            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    466            *                the configuration information for the specified I2C.
    467            * @retval HAL status
    468            */

   \                                 In section .text, align 2, keep-with-next
    469          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    470          {
   \                     HAL_I2C_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    471            /* Check the I2C handle allocation */
    472            if (hi2c == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_I2C_Init_0
    473            {
    474              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    475            }
    476          
    477            /* Check the parameters */
    478            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    479            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    480            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    481            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    482            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    483            assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    484            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    485            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    486          
    487            if (hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \        0xA   0xF104 0x0540      ADD      R5,R4,#+64
   \        0xE   0x7868             LDRB     R0,[R5, #+1]
   \       0x10   0xB920             CBNZ.N   R0,??HAL_I2C_Init_1
    488            {
    489              /* Allocate lock resource and initialize it */
    490              hi2c->Lock = HAL_UNLOCKED;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x7029             STRB     R1,[R5, #+0]
    491          
    492          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    493              /* Init the I2C Callback settings */
    494              hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    495              hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    496              hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
    497              hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
    498              hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
    499              hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
    500              hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
    501              hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
    502              hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    503              hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
    504          
    505              if (hi2c->MspInitCallback == NULL)
    506              {
    507                hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
    508              }
    509          
    510              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    511              hi2c->MspInitCallback(hi2c);
    512          #else
    513              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    514              HAL_I2C_MspInit(hi2c);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       HAL_I2C_MspInit
    515          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    516            }
    517          
    518            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \       0x1C   0x....'....        BL       ?Subroutine32
    519          
    520            /* Disable the selected I2C peripheral */
    521            __HAL_I2C_DISABLE(hi2c);
    522          
    523            /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
    524            /* Configure I2Cx: Frequency range */
    525            hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x20   0x6860             LDR      R0,[R4, #+4]
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \       0x28   0x6108             STR      R0,[R1, #+16]
    526          
    527            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    528            /* Disable Own Address1 before set the Own Address1 configuration */
    529            hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6881             LDR      R1,[R0, #+8]
   \       0x2E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \       0x32   0x6081             STR      R1,[R0, #+8]
    530          
    531            /* Configure I2Cx: Own Address1 and ack own address1 mode */
    532            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \       0x34   0x68E0             LDR      R0,[R4, #+12]
    533            {
    534              hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    535            }
    536            else /* I2C_ADDRESSINGMODE_10BIT */
    537            {
    538              hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0x68A0             LDR      R0,[R4, #+8]
   \       0x3C   0xBF0C             ITE      EQ
   \       0x3E   0xF440 0x4000      ORREQ    R0,R0,#0x8000
   \       0x42   0xF440 0x4004      ORRNE    R0,R0,#0x8400
   \       0x46   0x6088             STR      R0,[R1, #+8]
    539            }
    540          
    541            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    542            /* Configure I2Cx: Addressing Master mode */
    543            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0x48   0x68E0             LDR      R0,[R4, #+12]
   \       0x4A   0x2802             CMP      R0,#+2
   \       0x4C   0xD103             BNE.N    ??HAL_I2C_Init_2
    544            {
    545              hi2c->Instance->CR2 = (I2C_CR2_ADD10);
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0xF44F 0x6100      MOV      R1,#+2048
   \       0x54   0x6041             STR      R1,[R0, #+4]
    546            }
    547            /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
    548            hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
   \                     ??HAL_I2C_Init_2: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6841             LDR      R1,[R0, #+4]
   \       0x5A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \       0x5E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x62   0x6041             STR      R1,[R0, #+4]
    549          
    550            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    551            /* Disable Own Address2 before set the Own Address2 configuration */
    552            hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x68C1             LDR      R1,[R0, #+12]
   \       0x68   0xF421 0x4100      BIC      R1,R1,#0x8000
   \       0x6C   0x60C1             STR      R1,[R0, #+12]
    553          
    554            /* Configure I2Cx: Dual mode and Own Address2 */
    555            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
   \       0x6E   0x6960             LDR      R0,[R4, #+20]
   \       0x70   0x6921             LDR      R1,[R4, #+16]
   \       0x72   0x69A2             LDR      R2,[R4, #+24]
   \       0x74   0x4301             ORRS     R1,R0,R1
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \       0x7C   0x60C1             STR      R1,[R0, #+12]
    556          
    557            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    558            /* Configure I2Cx: Generalcall and NoStretch mode */
    559            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \       0x7E   0x6A20             LDR      R0,[R4, #+32]
   \       0x80   0x69E1             LDR      R1,[R4, #+28]
   \       0x82   0x6822             LDR      R2,[R4, #+0]
   \       0x84   0x4301             ORRS     R1,R0,R1
   \       0x86   0x6011             STR      R1,[R2, #+0]
    560          
    561            /* Enable the selected I2C peripheral */
    562            __HAL_I2C_ENABLE(hi2c);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6801             LDR      R1,[R0, #+0]
   \       0x8C   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x90   0x6001             STR      R1,[R0, #+0]
    563          
    564            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x6068             STR      R0,[R5, #+4]
    565            hi2c->State = HAL_I2C_STATE_READY;
   \       0x96   0x2120             MOVS     R1,#+32
   \       0x98   0x7069             STRB     R1,[R5, #+1]
    566            hi2c->PreviousState = I2C_STATE_NONE;
   \       0x9A   0x6320             STR      R0,[R4, #+48]
    567            hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x9C   0x70A8             STRB     R0,[R5, #+2]
    568          
    569            return HAL_OK;
   \       0x9E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    570          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine32: (+1)
   \        0x0   0x2024             MOVS     R0,#+36
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x0849             LSRS     R1,R1,#+1
   \        0xA   0x0049             LSLS     R1,R1,#+1
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0x4770             BX       LR
    571          
    572          /**
    573            * @brief  DeInitialize the I2C peripheral.
    574            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    575            *                the configuration information for the specified I2C.
    576            * @retval HAL status
    577            */

   \                                 In section .text, align 2, keep-with-next
    578          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    579          {
   \                     HAL_I2C_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    580            /* Check the I2C handle allocation */
    581            if (hi2c == NULL)
   \        0x4   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    582            {
    583              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    584            }
    585          
    586            /* Check the parameters */
    587            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    588          
    589            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \        0xA   0xF104 0x0540      ADD      R5,R4,#+64
   \        0xE   0x....'....        BL       ?Subroutine32
    590          
    591            /* Disable the I2C Peripheral Clock */
    592            __HAL_I2C_DISABLE(hi2c);
    593          
    594          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    595            if (hi2c->MspDeInitCallback == NULL)
    596            {
    597              hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
    598            }
    599          
    600            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    601            hi2c->MspDeInitCallback(hi2c);
    602          #else
    603            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    604            HAL_I2C_MspDeInit(hi2c);
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       HAL_I2C_MspDeInit
    605          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    606          
    607            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6068             STR      R0,[R5, #+4]
    608            hi2c->State = HAL_I2C_STATE_RESET;
   \       0x1C   0x7068             STRB     R0,[R5, #+1]
    609            hi2c->PreviousState = I2C_STATE_NONE;
   \       0x1E   0x6320             STR      R0,[R4, #+48]
    610            hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x20   0x70A8             STRB     R0,[R5, #+2]
    611          
    612            /* Release Lock */
    613            __HAL_UNLOCK(hi2c);
   \       0x22   0x7028             STRB     R0,[R5, #+0]
    614          
    615            return HAL_OK;
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    616          }
    617          
    618          /**
    619            * @brief Initialize the I2C MSP.
    620            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    621            *                the configuration information for the specified I2C.
    622            * @retval None
    623            */

   \                                 In section .text, align 2
    624          __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    625          {
    626            /* Prevent unused argument(s) compilation warning */
    627            UNUSED(hi2c);
    628          
    629            /* NOTE : This function should not be modified, when the callback is needed,
    630                      the HAL_I2C_MspInit could be implemented in the user file
    631             */
    632          }
   \                     HAL_I2C_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    633          
    634          /**
    635            * @brief DeInitialize the I2C MSP.
    636            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    637            *                the configuration information for the specified I2C.
    638            * @retval None
    639            */

   \                                 In section .text, align 2
    640          __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    641          {
    642            /* Prevent unused argument(s) compilation warning */
    643            UNUSED(hi2c);
    644          
    645            /* NOTE : This function should not be modified, when the callback is needed,
    646                      the HAL_I2C_MspDeInit could be implemented in the user file
    647             */
    648          }
   \                     HAL_I2C_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    649          
    650          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    651          /**
    652            * @brief  Register a User I2C Callback
    653            *         To be used instead of the weak predefined callback
    654            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    655            *                the configuration information for the specified I2C.
    656            * @param  CallbackID ID of the callback to be registered
    657            *         This parameter can be one of the following values:
    658            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    659            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    660            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    661            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    662            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    663            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    664            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    665            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    666            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    667            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    668            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    669            * @param  pCallback pointer to the Callback function
    670            * @retval HAL status
    671            */
    672          HAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID, pI2C_CallbackTypeDef pCallback)
    673          {
    674            HAL_StatusTypeDef status = HAL_OK;
    675          
    676            if (pCallback == NULL)
    677            {
    678              /* Update the error code */
    679              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    680          
    681              return HAL_ERROR;
    682            }
    683            /* Process locked */
    684            __HAL_LOCK(hi2c);
    685          
    686            if (HAL_I2C_STATE_READY == hi2c->State)
    687            {
    688              switch (CallbackID)
    689              {
    690                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    691                  hi2c->MasterTxCpltCallback = pCallback;
    692                  break;
    693          
    694                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    695                  hi2c->MasterRxCpltCallback = pCallback;
    696                  break;
    697          
    698                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    699                  hi2c->SlaveTxCpltCallback = pCallback;
    700                  break;
    701          
    702                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    703                  hi2c->SlaveRxCpltCallback = pCallback;
    704                  break;
    705          
    706                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    707                  hi2c->ListenCpltCallback = pCallback;
    708                  break;
    709          
    710                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    711                  hi2c->MemTxCpltCallback = pCallback;
    712                  break;
    713          
    714                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    715                  hi2c->MemRxCpltCallback = pCallback;
    716                  break;
    717          
    718                case HAL_I2C_ERROR_CB_ID :
    719                  hi2c->ErrorCallback = pCallback;
    720                  break;
    721          
    722                case HAL_I2C_ABORT_CB_ID :
    723                  hi2c->AbortCpltCallback = pCallback;
    724                  break;
    725          
    726                case HAL_I2C_MSPINIT_CB_ID :
    727                  hi2c->MspInitCallback = pCallback;
    728                  break;
    729          
    730                case HAL_I2C_MSPDEINIT_CB_ID :
    731                  hi2c->MspDeInitCallback = pCallback;
    732                  break;
    733          
    734                default :
    735                  /* Update the error code */
    736                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    737          
    738                  /* Return error status */
    739                  status =  HAL_ERROR;
    740                  break;
    741              }
    742            }
    743            else if (HAL_I2C_STATE_RESET == hi2c->State)
    744            {
    745              switch (CallbackID)
    746              {
    747                case HAL_I2C_MSPINIT_CB_ID :
    748                  hi2c->MspInitCallback = pCallback;
    749                  break;
    750          
    751                case HAL_I2C_MSPDEINIT_CB_ID :
    752                  hi2c->MspDeInitCallback = pCallback;
    753                  break;
    754          
    755                default :
    756                  /* Update the error code */
    757                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    758          
    759                  /* Return error status */
    760                  status =  HAL_ERROR;
    761                  break;
    762              }
    763            }
    764            else
    765            {
    766              /* Update the error code */
    767              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    768          
    769              /* Return error status */
    770              status =  HAL_ERROR;
    771            }
    772          
    773            /* Release Lock */
    774            __HAL_UNLOCK(hi2c);
    775            return status;
    776          }
    777          
    778          /**
    779            * @brief  Unregister an I2C Callback
    780            *         I2C callback is redirected to the weak predefined callback
    781            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    782            *                the configuration information for the specified I2C.
    783            * @param  CallbackID ID of the callback to be unregistered
    784            *         This parameter can be one of the following values:
    785            *         This parameter can be one of the following values:
    786            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    787            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    788            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    789            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    790            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    791            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    792            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    793            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    794            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    795            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    796            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    797            * @retval HAL status
    798            */
    799          HAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID)
    800          {
    801            HAL_StatusTypeDef status = HAL_OK;
    802          
    803            /* Process locked */
    804            __HAL_LOCK(hi2c);
    805          
    806            if (HAL_I2C_STATE_READY == hi2c->State)
    807            {
    808              switch (CallbackID)
    809              {
    810                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    811                  hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    812                  break;
    813          
    814                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    815                  hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    816                  break;
    817          
    818                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    819                  hi2c->SlaveTxCpltCallback = HAL_I2C_SlaveTxCpltCallback;   /* Legacy weak SlaveTxCpltCallback  */
    820                  break;
    821          
    822                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    823                  hi2c->SlaveRxCpltCallback = HAL_I2C_SlaveRxCpltCallback;   /* Legacy weak SlaveRxCpltCallback  */
    824                  break;
    825          
    826                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    827                  hi2c->ListenCpltCallback = HAL_I2C_ListenCpltCallback;     /* Legacy weak ListenCpltCallback   */
    828                  break;
    829          
    830                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    831                  hi2c->MemTxCpltCallback = HAL_I2C_MemTxCpltCallback;       /* Legacy weak MemTxCpltCallback    */
    832                  break;
    833          
    834                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    835                  hi2c->MemRxCpltCallback = HAL_I2C_MemRxCpltCallback;       /* Legacy weak MemRxCpltCallback    */
    836                  break;
    837          
    838                case HAL_I2C_ERROR_CB_ID :
    839                  hi2c->ErrorCallback = HAL_I2C_ErrorCallback;               /* Legacy weak ErrorCallback        */
    840                  break;
    841          
    842                case HAL_I2C_ABORT_CB_ID :
    843                  hi2c->AbortCpltCallback = HAL_I2C_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    844                  break;
    845          
    846                case HAL_I2C_MSPINIT_CB_ID :
    847                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    848                  break;
    849          
    850                case HAL_I2C_MSPDEINIT_CB_ID :
    851                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    852                  break;
    853          
    854                default :
    855                  /* Update the error code */
    856                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    857          
    858                  /* Return error status */
    859                  status =  HAL_ERROR;
    860                  break;
    861              }
    862            }
    863            else if (HAL_I2C_STATE_RESET == hi2c->State)
    864            {
    865              switch (CallbackID)
    866              {
    867                case HAL_I2C_MSPINIT_CB_ID :
    868                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    869                  break;
    870          
    871                case HAL_I2C_MSPDEINIT_CB_ID :
    872                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    873                  break;
    874          
    875                default :
    876                  /* Update the error code */
    877                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    878          
    879                  /* Return error status */
    880                  status =  HAL_ERROR;
    881                  break;
    882              }
    883            }
    884            else
    885            {
    886              /* Update the error code */
    887              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    888          
    889              /* Return error status */
    890              status =  HAL_ERROR;
    891            }
    892          
    893            /* Release Lock */
    894            __HAL_UNLOCK(hi2c);
    895            return status;
    896          }
    897          
    898          /**
    899            * @brief  Register the Slave Address Match I2C Callback
    900            *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback
    901            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    902            *                the configuration information for the specified I2C.
    903            * @param  pCallback pointer to the Address Match Callback function
    904            * @retval HAL status
    905            */
    906          HAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback)
    907          {
    908            HAL_StatusTypeDef status = HAL_OK;
    909          
    910            if (pCallback == NULL)
    911            {
    912              /* Update the error code */
    913              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    914          
    915              return HAL_ERROR;
    916            }
    917            /* Process locked */
    918            __HAL_LOCK(hi2c);
    919          
    920            if (HAL_I2C_STATE_READY == hi2c->State)
    921            {
    922              hi2c->AddrCallback = pCallback;
    923            }
    924            else
    925            {
    926              /* Update the error code */
    927              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    928          
    929              /* Return error status */
    930              status =  HAL_ERROR;
    931            }
    932          
    933            /* Release Lock */
    934            __HAL_UNLOCK(hi2c);
    935            return status;
    936          }
    937          
    938          /**
    939            * @brief  UnRegister the Slave Address Match I2C Callback
    940            *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback
    941            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    942            *                the configuration information for the specified I2C.
    943            * @retval HAL status
    944            */
    945          HAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c)
    946          {
    947            HAL_StatusTypeDef status = HAL_OK;
    948          
    949            /* Process locked */
    950            __HAL_LOCK(hi2c);
    951          
    952            if (HAL_I2C_STATE_READY == hi2c->State)
    953            {
    954              hi2c->AddrCallback = HAL_I2C_AddrCallback; /* Legacy weak AddrCallback  */
    955            }
    956            else
    957            {
    958              /* Update the error code */
    959              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    960          
    961              /* Return error status */
    962              status =  HAL_ERROR;
    963            }
    964          
    965            /* Release Lock */
    966            __HAL_UNLOCK(hi2c);
    967            return status;
    968          }
    969          
    970          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    971          
    972          /**
    973            * @}
    974            */
    975          
    976          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    977           *  @brief   Data transfers functions
    978           *
    979          @verbatim
    980           ===============================================================================
    981                                ##### IO operation functions #####
    982           ===============================================================================
    983              [..]
    984              This subsection provides a set of functions allowing to manage the I2C data
    985              transfers.
    986          
    987              (#) There are two modes of transfer:
    988                 (++) Blocking mode : The communication is performed in the polling mode.
    989                      The status of all data processing is returned by the same function
    990                      after finishing transfer.
    991                 (++) No-Blocking mode : The communication is performed using Interrupts
    992                      or DMA. These functions return the status of the transfer startup.
    993                      The end of the data processing will be indicated through the
    994                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
    995                      using DMA mode.
    996          
    997              (#) Blocking mode functions are :
    998                  (++) HAL_I2C_Master_Transmit()
    999                  (++) HAL_I2C_Master_Receive()
   1000                  (++) HAL_I2C_Slave_Transmit()
   1001                  (++) HAL_I2C_Slave_Receive()
   1002                  (++) HAL_I2C_Mem_Write()
   1003                  (++) HAL_I2C_Mem_Read()
   1004                  (++) HAL_I2C_IsDeviceReady()
   1005          
   1006              (#) No-Blocking mode functions with Interrupt are :
   1007                  (++) HAL_I2C_Master_Transmit_IT()
   1008                  (++) HAL_I2C_Master_Receive_IT()
   1009                  (++) HAL_I2C_Slave_Transmit_IT()
   1010                  (++) HAL_I2C_Slave_Receive_IT()
   1011                  (++) HAL_I2C_Mem_Write_IT()
   1012                  (++) HAL_I2C_Mem_Read_IT()
   1013                  (++) HAL_I2C_Master_Seq_Transmit_IT()
   1014                  (++) HAL_I2C_Master_Seq_Receive_IT()
   1015                  (++) HAL_I2C_Slave_Seq_Transmit_IT()
   1016                  (++) HAL_I2C_Slave_Seq_Receive_IT()
   1017                  (++) HAL_I2C_EnableListen_IT()
   1018                  (++) HAL_I2C_DisableListen_IT()
   1019                  (++) HAL_I2C_Master_Abort_IT()
   1020          
   1021              (#) No-Blocking mode functions with DMA are :
   1022                  (++) HAL_I2C_Master_Transmit_DMA()
   1023                  (++) HAL_I2C_Master_Receive_DMA()
   1024                  (++) HAL_I2C_Slave_Transmit_DMA()
   1025                  (++) HAL_I2C_Slave_Receive_DMA()
   1026                  (++) HAL_I2C_Mem_Write_DMA()
   1027                  (++) HAL_I2C_Mem_Read_DMA()
   1028                  (++) HAL_I2C_Master_Seq_Transmit_DMA()
   1029                  (++) HAL_I2C_Master_Seq_Receive_DMA()
   1030                  (++) HAL_I2C_Slave_Seq_Transmit_DMA()
   1031                  (++) HAL_I2C_Slave_Seq_Receive_DMA()
   1032          
   1033              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
   1034                  (++) HAL_I2C_MasterTxCpltCallback()
   1035                  (++) HAL_I2C_MasterRxCpltCallback()
   1036                  (++) HAL_I2C_SlaveTxCpltCallback()
   1037                  (++) HAL_I2C_SlaveRxCpltCallback()
   1038                  (++) HAL_I2C_MemTxCpltCallback()
   1039                  (++) HAL_I2C_MemRxCpltCallback()
   1040                  (++) HAL_I2C_AddrCallback()
   1041                  (++) HAL_I2C_ListenCpltCallback()
   1042                  (++) HAL_I2C_ErrorCallback()
   1043                  (++) HAL_I2C_AbortCpltCallback()
   1044          
   1045          @endverbatim
   1046            * @{
   1047            */
   1048          
   1049          /**
   1050            * @brief  Transmits in master mode an amount of data in blocking mode.
   1051            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1052            *                the configuration information for the specified I2C.
   1053            * @param  DevAddress Target device address: The device 7 bits address value
   1054            *         in datasheet must be shifted to the left before calling the interface
   1055            * @param  pData Pointer to data buffer
   1056            * @param  Size Amount of data to be sent
   1057            * @param  Timeout Timeout duration
   1058            * @retval HAL status
   1059            */

   \                                 In section .text, align 2, keep-with-next
   1060          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1061          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine63
   1062            uint32_t tickstart;
   1063          
   1064            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_135: (+1)
   \        0x8   0xD13D             BNE.N    ??HAL_I2C_Master_Transmit_0
   1065            {
   1066              /* Process Locked */
   1067              __HAL_LOCK(hi2c);
   \        0xA   0x7821             LDRB     R1,[R4, #+0]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD03A             BEQ.N    ??HAL_I2C_Master_Transmit_0
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x7020             STRB     R0,[R4, #+0]
   1068          
   1069              /* Init tickstart for timeout management*/
   1070              tickstart = HAL_GetTick();
   \       0x14   0x....'....        BL       HAL_GetTick
   \       0x18   0x....'....        BL       ?Subroutine69
   1071          
   1072              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_150: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD12D             BNE.N    ??HAL_I2C_Master_Transmit_1
   1073              {
   1074                return HAL_ERROR;
   1075              }
   1076          
   1077              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x20   0x2021             MOVS     R0,#+33
   \       0x22   0x....'....        BL       ?Subroutine56
   1078              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   1079              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1080          
   1081              /* Prepare transfer parameters */
   1082              hi2c->pBuffPtr  = pData;
   1083              hi2c->XferCount = Size;
   1084              hi2c->XferISR   = NULL;
   1085          
   1086              /* Send Slave Address */
   1087              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   1088              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \                     ??CrossCallReturnLabel_117: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable17  ;; 0x80002000
   \       0x2A   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x2E   0xBF28             IT       CS
   \       0x30   0x8535             STRHCS   R5,[R6, #+40]
   1089              {
   1090                hi2c->XferSize = MAX_NBYTE_SIZE;
   1091                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \       0x32   0xD206             BCS.N    ??HAL_I2C_Master_Transmit_2
   1092              }
   1093              else
   1094              {
   1095                hi2c->XferSize = hi2c->XferCount;
   \       0x34   0x8D72             LDRH     R2,[R6, #+42]
   \       0x36   0x8532             STRH     R2,[R6, #+40]
   1096                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   1097              }
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \       0x38   0x....'....        BL       ?Subroutine74
   \                     ??CrossCallReturnLabel_163: (+1)
   \       0x3C   0xE003             B.N      ??CrossCallReturnLabel_166
   1098          
   1099              while (hi2c->XferCount > 0U)
   1100              {
   1101                /* Wait until TXIS flag is set */
   1102                if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1103                {
   1104                  return HAL_ERROR;
   1105                }
   1106                /* Write data to TXDR */
   1107                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   1108          
   1109                /* Increment Buffer pointer */
   1110                hi2c->pBuffPtr++;
   1111          
   1112                hi2c->XferCount--;
   1113                hi2c->XferSize--;
   1114          
   1115                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   1116                {
   1117                  /* Wait until TCR flag is set */
   1118                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   1119                  {
   1120                    return HAL_ERROR;
   1121                  }
   1122          
   1123                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1124                  {
   1125                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \       0x3E   0x8535             STRH     R5,[R6, #+40]
   1126                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \       0x40   0x2000             MOVS     R0,#+0
   1127                  }
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \       0x42   0x....'....        BL       ?Subroutine75
   \                     ??CrossCallReturnLabel_166: (+1)
   \       0x46   0x....'....        BL       ??Subroutine101_0
   \                     ??CrossCallReturnLabel_252: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine81
   \                     ??CrossCallReturnLabel_179: (+1)
   \       0x4E   0xD012             BEQ.N    ??HAL_I2C_Master_Transmit_5
   \       0x50   0x....'....        BL       I2C_WaitOnTXISFlagUntilTimeout
   \       0x54   0xB990             CBNZ.N   R0,??HAL_I2C_Master_Transmit_1
   \       0x56   0x....'....        BL       ?Subroutine78
   \                     ??CrossCallReturnLabel_173: (+1)
   \       0x5A   0xD0F6             BEQ.N    ??CrossCallReturnLabel_252
   \       0x5C   0xB289             UXTH     R1,R1
   \       0x5E   0x2900             CMP      R1,#+0
   \       0x60   0xD1F3             BNE.N    ??CrossCallReturnLabel_252
   \       0x62   0x....'....        BL       ?Subroutine70
   \                     ??CrossCallReturnLabel_154: (+1)
   \       0x66   0xB948             CBNZ.N   R0,??HAL_I2C_Master_Transmit_1
   \       0x68   0x....'....        BL       ?Subroutine82
   \                     ??CrossCallReturnLabel_181: (+1)
   \       0x6C   0xD2E7             BCS.N    ??HAL_I2C_Master_Transmit_4
   1128                  else
   1129                  {
   1130                    hi2c->XferSize = hi2c->XferCount;
   \       0x6E   0x8D72             LDRH     R2,[R6, #+42]
   \       0x70   0x8532             STRH     R2,[R6, #+40]
   1131                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xE7E0             B.N      ??HAL_I2C_Master_Transmit_3
   1132                  }
   1133                }
   1134              }
   1135          
   1136              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1137              /* Wait until STOPF flag is set */
   1138              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \       0x76   0x....'....        BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0x7A   0xB108             CBZ.N    R0,??HAL_I2C_Master_Transmit_6
   1139              {
   1140                return HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xE003             B.N      ??HAL_I2C_Master_Transmit_7
   1141              }
   1142          
   1143              /* Clear STOP Flag */
   1144              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \       0x80   0x....'....        BL       ?Subroutine61
   1145          
   1146              /* Clear Configuration Register 2 */
   1147              I2C_RESET_CR2(hi2c);
   1148          
   1149              hi2c->State = HAL_I2C_STATE_READY;
   1150              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1151          
   1152              /* Process Unlocked */
   1153              __HAL_UNLOCK(hi2c);
   1154          
   1155              return HAL_OK;
   \                     ??CrossCallReturnLabel_129: (+1)
   \       0x84   0xE000             B.N      ??HAL_I2C_Master_Transmit_7
   1156            }
   1157            else
   1158            {
   1159              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \       0x86   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \       0x88   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1160            }
   1161          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine81: (+1)
   \        0x0   0x8D70             LDRH     R0,[R6, #+42]
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0x464A             MOV      R2,R9
   \        0x6   0x4639             MOV      R1,R7
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine75: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0xF04F 0x7380      MOV      R3,#+16777216
   \        0x6   0x22FF             MOVS     R2,#+255
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine74: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0xF04F 0x7300      MOV      R3,#+33554432
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine69: (+1)
   \        0x0   0x4681             MOV      R9,R0
   \        0x2   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \        0x6   0x2319             MOVS     R3,#+25
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF44F 0x4100      MOV      R1,#+32768
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine63: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0440      ADD      R4,R6,#+64
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x7860             LDRB     R0,[R4, #+1]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0x4615             MOV      R5,R2
   \        0xE   0x461F             MOV      R7,R3
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine56: (+1)
   \        0x0   0x7060             STRB     R0,[R4, #+1]
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x70A1             STRB     R1,[R4, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6060             STR      R0,[R4, #+4]
   \        0xA   0x6275             STR      R5,[R6, #+36]
   \        0xC   0x8577             STRH     R7,[R6, #+42]
   \        0xE   0x6370             STR      R0,[R6, #+52]
   \       0x10   0x25FF             MOVS     R5,#+255
   \       0x12   0x9F08             LDR      R7,[SP, #+32]
   \       0x14   0x8D71             LDRH     R1,[R6, #+42]
   \       0x16   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine82: (+1)
   \        0x0   0x8D70             LDRH     R0,[R6, #+42]
   \        0x2   0xF5B0 0x7F80      CMP      R0,#+256
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine78: (+1)
   \        0x0   0x6A70             LDR      R0,[R6, #+36]
   \        0x2   0x6832             LDR      R2,[R6, #+0]
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x6291             STR      R1,[R2, #+40]
   \        0x8   0x6A70             LDR      R0,[R6, #+36]
   \        0xA   0x1C41             ADDS     R1,R0,#+1
   \        0xC   0x6271             STR      R1,[R6, #+36]
   \        0xE   0x8D70             LDRH     R0,[R6, #+42]
   \       0x10   0x1E41             SUBS     R1,R0,#+1
   \       0x12   0x8571             STRH     R1,[R6, #+42]
   \       0x14   0x8D30             LDRH     R0,[R6, #+40]
   \       0x16   0x1E41             SUBS     R1,R0,#+1
   \       0x18   0x8531             STRH     R1,[R6, #+40]
   \       0x1A   0x8D70             LDRH     R0,[R6, #+42]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine70: (+1)
   \        0x0   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \        0x4   0x463B             MOV      R3,R7
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2180             MOVS     R1,#+128
   \        0xA   0x4630             MOV      R0,R6
   \        0xC   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine61: (+1)
   \        0x0   0x6831             LDR      R1,[R6, #+0]
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0x61C8             STR      R0,[R1, #+28]
   \        0x6   0x6831             LDR      R1,[R6, #+0]
   \        0x8   0x....'....        LDR.W    R0,??DataTable28  ;; 0xfe00e800
   \        0xC   0x684A             LDR      R2,[R1, #+4]
   \        0xE   0x4002             ANDS     R2,R0,R2
   \       0x10   0x604A             STR      R2,[R1, #+4]
   \       0x12   0x2120             MOVS     R1,#+32
   \       0x14   0x7061             STRB     R1,[R4, #+1]
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x70A0             STRB     R0,[R4, #+2]
   \       0x1A   0x7020             STRB     R0,[R4, #+0]
   \       0x1C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine101_0: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x....'....        B.W      I2C_TransferConfig
   1162          
   1163          /**
   1164            * @brief  Receives in master mode an amount of data in blocking mode.
   1165            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1166            *                the configuration information for the specified I2C.
   1167            * @param  DevAddress Target device address: The device 7 bits address value
   1168            *         in datasheet must be shifted to the left before calling the interface
   1169            * @param  pData Pointer to data buffer
   1170            * @param  Size Amount of data to be sent
   1171            * @param  Timeout Timeout duration
   1172            * @retval HAL status
   1173            */

   \                                 In section .text, align 2, keep-with-next
   1174          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1175          {
   \                     HAL_I2C_Master_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine63
   1176            uint32_t tickstart;
   1177          
   1178            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_136: (+1)
   \        0x8   0xD13E             BNE.N    ??HAL_I2C_Master_Receive_0
   1179            {
   1180              /* Process Locked */
   1181              __HAL_LOCK(hi2c);
   \        0xA   0x7821             LDRB     R1,[R4, #+0]
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD03B             BEQ.N    ??HAL_I2C_Master_Receive_0
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x7020             STRB     R0,[R4, #+0]
   1182          
   1183              /* Init tickstart for timeout management*/
   1184              tickstart = HAL_GetTick();
   \       0x14   0x....'....        BL       HAL_GetTick
   \       0x18   0x....'....        BL       ?Subroutine69
   1185          
   1186              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_149: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD12E             BNE.N    ??HAL_I2C_Master_Receive_1
   1187              {
   1188                return HAL_ERROR;
   1189              }
   1190          
   1191              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x20   0x2022             MOVS     R0,#+34
   \       0x22   0x....'....        BL       ?Subroutine56
   1192              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   1193              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1194          
   1195              /* Prepare transfer parameters */
   1196              hi2c->pBuffPtr  = pData;
   1197              hi2c->XferCount = Size;
   1198              hi2c->XferISR   = NULL;
   1199          
   1200              /* Send Slave Address */
   1201              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   1202              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \                     ??CrossCallReturnLabel_118: (+1)
   \       0x26   0x....'....        LDR.W    R0,??DataTable19  ;; 0x80002400
   \       0x2A   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x2E   0xBF28             IT       CS
   \       0x30   0x8535             STRHCS   R5,[R6, #+40]
   1203              {
   1204                hi2c->XferSize = MAX_NBYTE_SIZE;
   1205                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \       0x32   0xD206             BCS.N    ??HAL_I2C_Master_Receive_2
   1206              }
   1207              else
   1208              {
   1209                hi2c->XferSize = hi2c->XferCount;
   \       0x34   0x8D72             LDRH     R2,[R6, #+42]
   \       0x36   0x8532             STRH     R2,[R6, #+40]
   1210                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   1211              }
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \       0x38   0x....'....        BL       ?Subroutine74
   \                     ??CrossCallReturnLabel_164: (+1)
   \       0x3C   0xE003             B.N      ??CrossCallReturnLabel_167
   1212          
   1213              while (hi2c->XferCount > 0U)
   1214              {
   1215                /* Wait until RXNE flag is set */
   1216                if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1217                {
   1218                  return HAL_ERROR;
   1219                }
   1220          
   1221                /* Read data from RXDR */
   1222                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   1223          
   1224                /* Increment Buffer pointer */
   1225                hi2c->pBuffPtr++;
   1226          
   1227                hi2c->XferSize--;
   1228                hi2c->XferCount--;
   1229          
   1230                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   1231                {
   1232                  /* Wait until TCR flag is set */
   1233                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   1234                  {
   1235                    return HAL_ERROR;
   1236                  }
   1237          
   1238                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1239                  {
   1240                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \       0x3E   0x8535             STRH     R5,[R6, #+40]
   1241                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \       0x40   0x2000             MOVS     R0,#+0
   1242                  }
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \       0x42   0x....'....        BL       ?Subroutine75
   \                     ??CrossCallReturnLabel_167: (+1)
   \       0x46   0x....'....        BL       ??Subroutine101_0
   \                     ??CrossCallReturnLabel_251: (+1)
   \       0x4A   0x....'....        BL       ?Subroutine81
   \                     ??CrossCallReturnLabel_180: (+1)
   \       0x4E   0xD013             BEQ.N    ??HAL_I2C_Master_Receive_5
   \       0x50   0x....'....        BL       I2C_WaitOnRXNEFlagUntilTimeout
   \       0x54   0xB998             CBNZ.N   R0,??HAL_I2C_Master_Receive_1
   \       0x56   0x....'....        BL       ?Subroutine79
   \                     ??CrossCallReturnLabel_175: (+1)
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD0F5             BEQ.N    ??CrossCallReturnLabel_251
   \       0x5E   0xB289             UXTH     R1,R1
   \       0x60   0x2900             CMP      R1,#+0
   \       0x62   0xD1F2             BNE.N    ??CrossCallReturnLabel_251
   \       0x64   0x....'....        BL       ?Subroutine70
   \                     ??CrossCallReturnLabel_153: (+1)
   \       0x68   0xB948             CBNZ.N   R0,??HAL_I2C_Master_Receive_1
   \       0x6A   0x....'....        BL       ?Subroutine82
   \                     ??CrossCallReturnLabel_182: (+1)
   \       0x6E   0xD2E6             BCS.N    ??HAL_I2C_Master_Receive_4
   1243                  else
   1244                  {
   1245                    hi2c->XferSize = hi2c->XferCount;
   \       0x70   0x8D72             LDRH     R2,[R6, #+42]
   \       0x72   0x8532             STRH     R2,[R6, #+40]
   1246                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xE7DF             B.N      ??HAL_I2C_Master_Receive_3
   1247                  }
   1248                }
   1249              }
   1250          
   1251              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1252              /* Wait until STOPF flag is set */
   1253              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \       0x78   0x....'....        BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0x7C   0xB108             CBZ.N    R0,??HAL_I2C_Master_Receive_6
   1254              {
   1255                return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xE003             B.N      ??HAL_I2C_Master_Receive_7
   1256              }
   1257          
   1258              /* Clear STOP Flag */
   1259              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \       0x82   0x....'....        BL       ?Subroutine61
   1260          
   1261              /* Clear Configuration Register 2 */
   1262              I2C_RESET_CR2(hi2c);
   1263          
   1264              hi2c->State = HAL_I2C_STATE_READY;
   1265              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1266          
   1267              /* Process Unlocked */
   1268              __HAL_UNLOCK(hi2c);
   1269          
   1270              return HAL_OK;
   \                     ??CrossCallReturnLabel_130: (+1)
   \       0x86   0xE000             B.N      ??HAL_I2C_Master_Receive_7
   1271            }
   1272            else
   1273            {
   1274              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \       0x88   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \       0x8A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1275            }
   1276          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine79: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6A41             LDR      R1,[R0, #+36]
   \        0x4   0x6A70             LDR      R0,[R6, #+36]
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   \        0x8   0x6A71             LDR      R1,[R6, #+36]
   \        0xA   0x8D30             LDRH     R0,[R6, #+40]
   \        0xC   0x1C4A             ADDS     R2,R1,#+1
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x6272             STR      R2,[R6, #+36]
   \       0x12   0x8531             STRH     R1,[R6, #+40]
   \       0x14   0x8D70             LDRH     R0,[R6, #+42]
   \       0x16   0x1E42             SUBS     R2,R0,#+1
   \       0x18   0x8572             STRH     R2,[R6, #+42]
   \       0x1A   0x8D70             LDRH     R0,[R6, #+42]
   \       0x1C   0x4770             BX       LR
   1277          
   1278          /**
   1279            * @brief  Transmits in slave mode an amount of data in blocking mode.
   1280            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1281            *                the configuration information for the specified I2C.
   1282            * @param  pData Pointer to data buffer
   1283            * @param  Size Amount of data to be sent
   1284            * @param  Timeout Timeout duration
   1285            * @retval HAL status
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1288          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine67
   1289            uint32_t tickstart;
   1290          
   1291            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_144: (+1)
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xD163             BNE.N    ??HAL_I2C_Slave_Transmit_0
   1292            {
   1293              if ((pData == NULL) || (Size == 0U))
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xBF18             IT       NE
   \       0x12   0xF1B9 0x0F00      CMPNE    R9,#+0
   \       0x16   0xD103             BNE.N    ??HAL_I2C_Slave_Transmit_1
   1294              {
   1295                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x18   0xF44F 0x7000      MOV      R0,#+512
   \       0x1C   0x6068             STR      R0,[R5, #+4]
   1296                return  HAL_ERROR;
   \       0x1E   0xE055             B.N      ??HAL_I2C_Slave_Transmit_2
   1297              }
   1298              /* Process Locked */
   1299              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \       0x20   0x7828             LDRB     R0,[R5, #+0]
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD057             BEQ.N    ??HAL_I2C_Slave_Transmit_0
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x7029             STRB     R1,[R5, #+0]
   1300          
   1301              /* Init tickstart for timeout management*/
   1302              tickstart = HAL_GetTick();
   \       0x2A   0x....'....        BL       HAL_GetTick
   \       0x2E   0x4607             MOV      R7,R0
   1303          
   1304              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x30   0x2021             MOVS     R0,#+33
   \       0x32   0x....'....        BL       ?Subroutine38
   1305              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   1306              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1307          
   1308              /* Prepare transfer parameters */
   1309              hi2c->pBuffPtr  = pData;
   1310              hi2c->XferCount = Size;
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x36   0xF8A6 0x902A      STRH     R9,[R6, #+42]
   1311              hi2c->XferISR   = NULL;
   \       0x3A   0x6370             STR      R0,[R6, #+52]
   1312          
   1313              /* Enable Address Acknowledge */
   1314              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1315          
   1316              /* Wait until ADDR flag is set */
   1317              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x3C   0x4643             MOV      R3,R8
   \       0x3E   0x....'....        BL       ?Subroutine49
   \                     ??CrossCallReturnLabel_99: (+1)
   \       0x42   0xBB60             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_3
   1318              {
   1319                /* Disable Address Acknowledge */
   1320                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1321                return HAL_ERROR;
   1322              }
   1323          
   1324              /* Clear ADDR flag */
   1325              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x44   0x6831             LDR      R1,[R6, #+0]
   \       0x46   0x2008             MOVS     R0,#+8
   \       0x48   0x61C8             STR      R0,[R1, #+28]
   1326          
   1327              /* If 10bit addressing mode is selected */
   1328              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0x4A   0x68F0             LDR      R0,[R6, #+12]
   \       0x4C   0x2802             CMP      R0,#+2
   \       0x4E   0xD109             BNE.N    ??HAL_I2C_Slave_Transmit_4
   1329              {
   1330                /* Wait until ADDR flag is set */
   1331                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x50   0x9700             STR      R7,[SP, #+0]
   \       0x52   0x4643             MOV      R3,R8
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x2108             MOVS     R1,#+8
   \       0x58   0x....'....        BL       ??Subroutine72_0
   \                     ??CrossCallReturnLabel_158: (+1)
   \       0x5C   0xB9F8             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_3
   1332                {
   1333                  /* Disable Address Acknowledge */
   1334                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1335                  return HAL_ERROR;
   1336                }
   1337          
   1338                /* Clear ADDR flag */
   1339                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x5E   0x6831             LDR      R1,[R6, #+0]
   \       0x60   0x2008             MOVS     R0,#+8
   \       0x62   0x61C8             STR      R0,[R1, #+28]
   1340              }
   1341          
   1342              /* Wait until DIR flag is set Transmitter mode */
   1343              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \       0x64   0x9700             STR      R7,[SP, #+0]
   \       0x66   0x4643             MOV      R3,R8
   \       0x68   0x2200             MOVS     R2,#+0
   \       0x6A   0xF44F 0x3180      MOV      R1,#+65536
   \       0x6E   0x....'....        BL       ??Subroutine72_0
   \                     ??CrossCallReturnLabel_157: (+1)
   \       0x72   0xB150             CBZ.N    R0,??HAL_I2C_Slave_Transmit_5
   1344              {
   1345                /* Disable Address Acknowledge */
   1346                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \       0x74   0xE013             B.N      ??HAL_I2C_Slave_Transmit_3
   1347                return HAL_ERROR;
   1348              }
   1349          
   1350              while (hi2c->XferCount > 0U)
   1351              {
   1352                /* Wait until TXIS flag is set */
   1353                if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1354                {
   1355                  /* Disable Address Acknowledge */
   1356                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1357                  return HAL_ERROR;
   1358                }
   1359          
   1360                /* Write data to TXDR */
   1361                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \       0x76   0x6A70             LDR      R0,[R6, #+36]
   \       0x78   0x6832             LDR      R2,[R6, #+0]
   \       0x7A   0x7801             LDRB     R1,[R0, #+0]
   \       0x7C   0x6291             STR      R1,[R2, #+40]
   1362          
   1363                /* Increment Buffer pointer */
   1364                hi2c->pBuffPtr++;
   \       0x7E   0x6A70             LDR      R0,[R6, #+36]
   \       0x80   0x1C41             ADDS     R1,R0,#+1
   \       0x82   0x6271             STR      R1,[R6, #+36]
   1365          
   1366                hi2c->XferCount--;
   \       0x84   0x8D70             LDRH     R0,[R6, #+42]
   \       0x86   0x1E41             SUBS     R1,R0,#+1
   \       0x88   0x8571             STRH     R1,[R6, #+42]
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \       0x8A   0x463A             MOV      R2,R7
   \       0x8C   0x8D70             LDRH     R0,[R6, #+42]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0x4641             MOV      R1,R8
   \       0x92   0x4630             MOV      R0,R6
   \       0x94   0xD006             BEQ.N    ??HAL_I2C_Slave_Transmit_7
   \       0x96   0x....'....        BL       I2C_WaitOnTXISFlagUntilTimeout
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD0EB             BEQ.N    ??HAL_I2C_Slave_Transmit_6
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \       0x9E   0x....'....        BL       ??Subroutine51_0
   \                     ??CrossCallReturnLabel_102: (+1)
   \       0xA2   0xE013             B.N      ??HAL_I2C_Slave_Transmit_2
   1367              }
   1368          
   1369              /* Wait until STOP flag is set */
   1370              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \       0xA4   0x....'....        BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0xA8   0xB130             CBZ.N    R0,??HAL_I2C_Slave_Transmit_8
   1371              {
   1372                /* Disable Address Acknowledge */
   1373                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \       0xAA   0x....'....        BL       ??Subroutine51_0
   1374          
   1375                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??CrossCallReturnLabel_103: (+1)
   \       0xAE   0x6868             LDR      R0,[R5, #+4]
   \       0xB0   0x2804             CMP      R0,#+4
   \       0xB2   0xD10B             BNE.N    ??HAL_I2C_Slave_Transmit_2
   1376                {
   1377                  /* Normal use case for Transmitter mode */
   1378                  /* A NACK is generated to confirm the end of transfer */
   1379                  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xB4   0x2100             MOVS     R1,#+0
   \       0xB6   0x6069             STR      R1,[R5, #+4]
   1380                }
   1381                else
   1382                {
   1383                  return HAL_ERROR;
   1384                }
   1385              }
   1386          
   1387              /* Clear STOP flag */
   1388              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \       0xB8   0x2020             MOVS     R0,#+32
   \       0xBA   0x6831             LDR      R1,[R6, #+0]
   \       0xBC   0x61C8             STR      R0,[R1, #+28]
   1389          
   1390              /* Wait until BUSY flag is reset */
   1391              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
   \       0xBE   0x9700             STR      R7,[SP, #+0]
   \       0xC0   0x4643             MOV      R3,R8
   \       0xC2   0x....'....        BL       ?Subroutine72
   \                     ??CrossCallReturnLabel_160: (+1)
   \       0xC6   0x....'....        BL       ?Subroutine51
   \                     ??CrossCallReturnLabel_104: (+1)
   \       0xCA   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_9
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xE003             B.N      ??HAL_I2C_Slave_Transmit_10
   1392              {
   1393                /* Disable Address Acknowledge */
   1394                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1395                return HAL_ERROR;
   1396              }
   1397          
   1398              /* Disable Address Acknowledge */
   1399              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1400          
   1401              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \       0xD0   0x....'....        BL       ?Subroutine40
   1402              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1403          
   1404              /* Process Unlocked */
   1405              __HAL_UNLOCK(hi2c);
   1406          
   1407              return HAL_OK;
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0xD4   0xE000             B.N      ??HAL_I2C_Slave_Transmit_10
   1408            }
   1409            else
   1410            {
   1411              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \       0xD6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \       0xD8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1412            }
   1413          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine72: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF44F 0x4100      MOV      R1,#+32768
   \                     ??Subroutine72_0: (+1)
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine67: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0540      ADD      R5,R6,#+64
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine49: (+1)
   \        0x0   0x6830             LDR      R0,[R6, #+0]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF421 0x4100      BIC      R1,R1,#0x8000
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x9700             STR      R7,[SP, #+0]
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2108             MOVS     R1,#+8
   \       0x10   0x4630             MOV      R0,R6
   \       0x12   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine40: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A9             STRB     R1,[R5, #+2]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x7028             STRB     R0,[R5, #+0]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine38: (+1)
   \        0x0   0x7068             STRB     R0,[R5, #+1]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x70A9             STRB     R1,[R5, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6068             STR      R0,[R5, #+4]
   \        0xA   0x6274             STR      R4,[R6, #+36]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine51: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \                     ??Subroutine51_0: (+1)
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \                     ??Subroutine51_1: (+1)
   \        0x4   0x6841             LDR      R1,[R0, #+4]
   \        0x6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0xA   0x6041             STR      R1,[R0, #+4]
   \        0xC   0x4770             BX       LR
   1414          
   1415          /**
   1416            * @brief  Receive in slave mode an amount of data in blocking mode
   1417            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1418            *                the configuration information for the specified I2C.
   1419            * @param  pData Pointer to data buffer
   1420            * @param  Size Amount of data to be sent
   1421            * @param  Timeout Timeout duration
   1422            * @retval HAL status
   1423            */

   \                                 In section .text, align 2, keep-with-next
   1424          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1425          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine67
   1426            uint32_t tickstart;
   1427          
   1428            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_145: (+1)
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0xD15F             BNE.N    ??HAL_I2C_Slave_Receive_0
   1429            {
   1430              if ((pData == NULL) || (Size == 0U))
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xBF18             IT       NE
   \       0x12   0xF1B8 0x0F00      CMPNE    R8,#+0
   \       0x16   0xD103             BNE.N    ??HAL_I2C_Slave_Receive_1
   1431              {
   1432                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x18   0xF44F 0x7000      MOV      R0,#+512
   \       0x1C   0x6068             STR      R0,[R5, #+4]
   1433                return  HAL_ERROR;
   \       0x1E   0xE051             B.N      ??HAL_I2C_Slave_Receive_2
   1434              }
   1435              /* Process Locked */
   1436              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \       0x20   0x7828             LDRB     R0,[R5, #+0]
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD053             BEQ.N    ??HAL_I2C_Slave_Receive_0
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x7029             STRB     R1,[R5, #+0]
   1437          
   1438              /* Init tickstart for timeout management*/
   1439              tickstart = HAL_GetTick();
   \       0x2A   0x....'....        BL       HAL_GetTick
   \       0x2E   0x4607             MOV      R7,R0
   1440          
   1441              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x30   0x2022             MOVS     R0,#+34
   \       0x32   0x....'....        BL       ?Subroutine38
   1442              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   1443              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1444          
   1445              /* Prepare transfer parameters */
   1446              hi2c->pBuffPtr  = pData;
   1447              hi2c->XferCount = Size;
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0x36   0xF8A6 0x802A      STRH     R8,[R6, #+42]
   1448              hi2c->XferISR   = NULL;
   \       0x3A   0x6370             STR      R0,[R6, #+52]
   1449          
   1450              /* Enable Address Acknowledge */
   1451              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1452          
   1453              /* Wait until ADDR flag is set */
   1454              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x3C   0x464B             MOV      R3,R9
   \       0x3E   0x....'....        BL       ?Subroutine49
   \                     ??CrossCallReturnLabel_98: (+1)
   \       0x42   0xBB90             CBNZ.N   R0,??HAL_I2C_Slave_Receive_3
   1455              {
   1456                /* Disable Address Acknowledge */
   1457                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1458                return HAL_ERROR;
   1459              }
   1460          
   1461              /* Clear ADDR flag */
   1462              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x44   0x6831             LDR      R1,[R6, #+0]
   \       0x46   0x2008             MOVS     R0,#+8
   \       0x48   0x61C8             STR      R0,[R1, #+28]
   1463          
   1464              /* Wait until DIR flag is reset Receiver mode */
   1465              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
   \       0x4A   0x9700             STR      R7,[SP, #+0]
   \       0x4C   0x464B             MOV      R3,R9
   \       0x4E   0x2201             MOVS     R2,#+1
   \       0x50   0xF44F 0x3180      MOV      R1,#+65536
   \       0x54   0x....'....        BL       ??Subroutine72_0
   \                     ??CrossCallReturnLabel_156: (+1)
   \       0x58   0xB148             CBZ.N    R0,??HAL_I2C_Slave_Receive_4
   1466              {
   1467                /* Disable Address Acknowledge */
   1468                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \       0x5A   0xE026             B.N      ??HAL_I2C_Slave_Receive_3
   1469                return HAL_ERROR;
   1470              }
   1471          
   1472              while (hi2c->XferCount > 0U)
   1473              {
   1474                /* Wait until RXNE flag is set */
   1475                if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   1476                {
   1477                  /* Disable Address Acknowledge */
   1478                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1479          
   1480                  /* Store Last receive data if any */
   1481                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   1482                  {
   1483                    /* Read data from RXDR */
   1484                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   1485          
   1486                    /* Increment Buffer pointer */
   1487                    hi2c->pBuffPtr++;
   1488          
   1489                    hi2c->XferCount--;
   1490                  }
   1491          
   1492                  return HAL_ERROR;
   1493                }
   1494          
   1495                /* Read data from RXDR */
   1496                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \       0x5C   0x6A41             LDR      R1,[R0, #+36]
   \       0x5E   0x6A70             LDR      R0,[R6, #+36]
   \       0x60   0x7001             STRB     R1,[R0, #+0]
   1497          
   1498                /* Increment Buffer pointer */
   1499                hi2c->pBuffPtr++;
   \       0x62   0x6A71             LDR      R1,[R6, #+36]
   \       0x64   0x1C4A             ADDS     R2,R1,#+1
   \       0x66   0x6272             STR      R2,[R6, #+36]
   1500          
   1501                hi2c->XferCount--;
   \       0x68   0x8D70             LDRH     R0,[R6, #+42]
   \       0x6A   0x1E41             SUBS     R1,R0,#+1
   \       0x6C   0x8571             STRH     R1,[R6, #+42]
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \       0x6E   0x463A             MOV      R2,R7
   \       0x70   0x8D70             LDRH     R0,[R6, #+42]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0x4649             MOV      R1,R9
   \       0x76   0x4630             MOV      R0,R6
   \       0x78   0xD014             BEQ.N    ??HAL_I2C_Slave_Receive_6
   \       0x7A   0x....'....        BL       I2C_WaitOnRXNEFlagUntilTimeout
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0x6830             LDR      R0,[R6, #+0]
   \       0x82   0xD0EB             BEQ.N    ??HAL_I2C_Slave_Receive_5
   \       0x84   0x....'....        BL       ??Subroutine51_1
   \                     ??CrossCallReturnLabel_105: (+1)
   \       0x88   0x6830             LDR      R0,[R6, #+0]
   \       0x8A   0x6981             LDR      R1,[R0, #+24]
   \       0x8C   0x074A             LSLS     R2,R1,#+29
   \       0x8E   0xD519             BPL.N    ??HAL_I2C_Slave_Receive_2
   \       0x90   0x6A40             LDR      R0,[R0, #+36]
   \       0x92   0x6A71             LDR      R1,[R6, #+36]
   \       0x94   0x7008             STRB     R0,[R1, #+0]
   \       0x96   0x6A70             LDR      R0,[R6, #+36]
   \       0x98   0x1C42             ADDS     R2,R0,#+1
   \       0x9A   0x6272             STR      R2,[R6, #+36]
   \       0x9C   0x8D70             LDRH     R0,[R6, #+42]
   \       0x9E   0x1E41             SUBS     R1,R0,#+1
   \       0xA0   0x8571             STRH     R1,[R6, #+42]
   \       0xA2   0xE00F             B.N      ??HAL_I2C_Slave_Receive_2
   1502              }
   1503          
   1504              /* Wait until STOP flag is set */
   1505              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \       0xA4   0x....'....        BL       I2C_WaitOnSTOPFlagUntilTimeout
   \       0xA8   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Receive_7
   1506              {
   1507                /* Disable Address Acknowledge */
   1508                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \       0xAA   0x....'....        BL       ??Subroutine51_0
   1509                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_106: (+1)
   \       0xAE   0xE009             B.N      ??HAL_I2C_Slave_Receive_2
   1510              }
   1511          
   1512              /* Clear STOP flag */
   1513              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \       0xB0   0x6831             LDR      R1,[R6, #+0]
   \       0xB2   0x2020             MOVS     R0,#+32
   \       0xB4   0x61C8             STR      R0,[R1, #+28]
   1514          
   1515              /* Wait until BUSY flag is reset */
   1516              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
   \       0xB6   0x9700             STR      R7,[SP, #+0]
   \       0xB8   0x464B             MOV      R3,R9
   \       0xBA   0x....'....        BL       ?Subroutine72
   \                     ??CrossCallReturnLabel_159: (+1)
   \       0xBE   0x....'....        BL       ?Subroutine51
   \                     ??CrossCallReturnLabel_107: (+1)
   \       0xC2   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_8
   1517              {
   1518                /* Disable Address Acknowledge */
   1519                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1520                return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xE003             B.N      ??HAL_I2C_Slave_Receive_9
   1521              }
   1522          
   1523              /* Disable Address Acknowledge */
   1524              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1525          
   1526              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \       0xC8   0x....'....        BL       ?Subroutine40
   1527              hi2c->Mode  = HAL_I2C_MODE_NONE;
   1528          
   1529              /* Process Unlocked */
   1530              __HAL_UNLOCK(hi2c);
   1531          
   1532              return HAL_OK;
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0xCC   0xE000             B.N      ??HAL_I2C_Slave_Receive_9
   1533            }
   1534            else
   1535            {
   1536              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \       0xCE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \       0xD0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1537            }
   1538          }
   1539          
   1540          /**
   1541            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1542            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1543            *                the configuration information for the specified I2C.
   1544            * @param  DevAddress Target device address: The device 7 bits address value
   1545            *         in datasheet must be shifted to the left before calling the interface
   1546            * @param  pData Pointer to data buffer
   1547            * @param  Size Amount of data to be sent
   1548            * @retval HAL status
   1549            */

   \                                 In section .text, align 2, keep-with-next
   1550          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1551          {
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine85
   1552            uint32_t xfermode;
   1553          
   1554            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_193: (+1)
   \        0x6   0xD113             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1555            {
   1556              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0x8   0x6826             LDR      R6,[R4, #+0]
   \        0xA   0x69B0             LDR      R0,[R6, #+24]
   \        0xC   0x0406             LSLS     R6,R0,#+16
   \        0xE   0xD40F             BMI.N    ??HAL_I2C_Master_Transmit_IT_0
   1557              {
   1558                return HAL_BUSY;
   1559              }
   1560          
   1561              /* Process Locked */
   1562              __HAL_LOCK(hi2c);
   \       0x10   0x7828             LDRB     R0,[R5, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \       0x16   0x2601             MOVS     R6,#+1
   \       0x18   0x702E             STRB     R6,[R5, #+0]
   1563          
   1564              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x1A   0x2021             MOVS     R0,#+33
   \       0x1C   0x....'....        BL       ?Subroutine35
   1565              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   1566              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1567          
   1568              /* Prepare transfer parameters */
   1569              hi2c->pBuffPtr    = pData;
   1570              hi2c->XferCount   = Size;
   1571              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1572              hi2c->XferISR     = I2C_Master_ISR_IT;
   1573          
   1574              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1575              {
   1576                hi2c->XferSize = MAX_NBYTE_SIZE;
   1577                xfermode = I2C_RELOAD_MODE;
   1578              }
   1579              else
   1580              {
   1581                hi2c->XferSize = hi2c->XferCount;
   1582                xfermode = I2C_AUTOEND_MODE;
   1583              }
   1584          
   1585              /* Send Slave Address */
   1586              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
   1587              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x20   0x....'....        LDR.W    R6,??DataTable17  ;; 0x80002000
   \       0x24   0x....'....        BL       ?Subroutine33
   1588          
   1589              /* Process Unlocked */
   1590              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x702B             STRB     R3,[R5, #+0]
   1591          
   1592              /* Note : The I2C interrupts must be enabled after unlocking current process
   1593                        to avoid the risk of I2C interrupt handle execution before current
   1594                        process unlock */
   1595          
   1596              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1597              /* possible to enable all of these */
   1598              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1599              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x....             B.N      ?Subroutine0
   1600          
   1601              return HAL_OK;
   1602            }
   1603            else
   1604            {
   1605              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1606            }
   1607          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine85: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF104 0x0540      ADD      R5,R4,#+64
   \        0x6   0x7868             LDRB     R0,[R5, #+1]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine35: (+1)
   \        0x0   0x7068             STRB     R0,[R5, #+1]
   \        0x2   0x2710             MOVS     R7,#+16
   \        0x4   0x70AF             STRB     R7,[R5, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6068             STR      R0,[R5, #+4]
   \        0xA   0x6262             STR      R2,[R4, #+36]
   \        0xC   0x8563             STRH     R3,[R4, #+42]
   \        0xE   0x....'....        LDR.W    R0,??DataTable22  ;; 0xffff0000
   \       0x12   0x....'....        LDR.W    R2,??DataTable22_1
   \       0x16   0x62E0             STR      R0,[R4, #+44]
   \       0x18   0x6362             STR      R2,[R4, #+52]
   \       0x1A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x1C   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x20   0xD304             BCC.N    ??Subroutine35_0
   \       0x22   0x22FF             MOVS     R2,#+255
   \       0x24   0x8522             STRH     R2,[R4, #+40]
   \       0x26   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x2A   0x4770             BX       LR
   \                     ??Subroutine35_0: (+1)
   \       0x2C   0x8D60             LDRH     R0,[R4, #+42]
   \       0x2E   0x8520             STRH     R0,[R4, #+40]
   \       0x30   0xF04F 0x7300      MOV      R3,#+33554432
   \                     ??Subroutine35_1: (+1)
   \       0x34   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine33: (+1)
   \        0x0   0x9600             STR      R6,[SP, #+0]
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x8D22             LDRH     R2,[R4, #+40]
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x....'....        B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....'....        BL       ??Subroutine31_1
   \                     ??CrossCallReturnLabel_57: (+1)
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine31: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7028             STRB     R0,[R5, #+0]
   \                     ??Subroutine31_0: (+1)
   \        0x4   0x2101             MOVS     R1,#+1
   \                     ??Subroutine31_1: (+1)
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....'....        B.W      I2C_Enable_IRQ
   1608          
   1609          /**
   1610            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1611            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1612            *                the configuration information for the specified I2C.
   1613            * @param  DevAddress Target device address: The device 7 bits address value
   1614            *         in datasheet must be shifted to the left before calling the interface
   1615            * @param  pData Pointer to data buffer
   1616            * @param  Size Amount of data to be sent
   1617            * @retval HAL status
   1618            */

   \                                 In section .text, align 2, keep-with-next
   1619          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1620          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine85
   1621            uint32_t xfermode;
   1622          
   1623            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_194: (+1)
   \        0x6   0xD113             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1624            {
   1625              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0x8   0x6826             LDR      R6,[R4, #+0]
   \        0xA   0x69B0             LDR      R0,[R6, #+24]
   \        0xC   0x0406             LSLS     R6,R0,#+16
   \        0xE   0xD40F             BMI.N    ??HAL_I2C_Master_Receive_IT_0
   1626              {
   1627                return HAL_BUSY;
   1628              }
   1629          
   1630              /* Process Locked */
   1631              __HAL_LOCK(hi2c);
   \       0x10   0x7828             LDRB     R0,[R5, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD00C             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \       0x16   0x2601             MOVS     R6,#+1
   \       0x18   0x702E             STRB     R6,[R5, #+0]
   1632          
   1633              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x1A   0x2022             MOVS     R0,#+34
   \       0x1C   0x....'....        BL       ?Subroutine35
   1634              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   1635              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1636          
   1637              /* Prepare transfer parameters */
   1638              hi2c->pBuffPtr    = pData;
   1639              hi2c->XferCount   = Size;
   1640              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1641              hi2c->XferISR     = I2C_Master_ISR_IT;
   1642          
   1643              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   1644              {
   1645                hi2c->XferSize = MAX_NBYTE_SIZE;
   1646                xfermode = I2C_RELOAD_MODE;
   1647              }
   1648              else
   1649              {
   1650                hi2c->XferSize = hi2c->XferCount;
   1651                xfermode = I2C_AUTOEND_MODE;
   1652              }
   1653          
   1654              /* Send Slave Address */
   1655              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
   1656              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0x20   0x....'....        LDR.W    R6,??DataTable19  ;; 0x80002400
   \       0x24   0x....'....        BL       ?Subroutine33
   1657          
   1658              /* Process Unlocked */
   1659              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x702B             STRB     R3,[R5, #+0]
   1660          
   1661              /* Note : The I2C interrupts must be enabled after unlocking current process
   1662                        to avoid the risk of I2C interrupt handle execution before current
   1663                        process unlock */
   1664          
   1665              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1666              /* possible to enable all of these */
   1667              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1668              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x2C   0x2102             MOVS     R1,#+2
   \       0x2E   0x....             B.N      ?Subroutine0
   1669          
   1670              return HAL_OK;
   1671            }
   1672            else
   1673            {
   1674              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1675            }
   1676          }
   1677          
   1678          /**
   1679            * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
   1680            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1681            *                the configuration information for the specified I2C.
   1682            * @param  pData Pointer to data buffer
   1683            * @param  Size Amount of data to be sent
   1684            * @retval HAL status
   1685            */

   \                                 In section .text, align 2, keep-with-next
   1686          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1687          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1688            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x0340      ADD      R3,R0,#+64
   \        0x6   0x785C             LDRB     R4,[R3, #+1]
   \        0x8   0x2C20             CMP      R4,#+32
   \        0xA   0xD109             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1689            {
   1690              /* Process Locked */
   1691              __HAL_LOCK(hi2c);
   \        0xC   0x781D             LDRB     R5,[R3, #+0]
   \        0xE   0x2D01             CMP      R5,#+1
   \       0x10   0xD006             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \       0x12   0x2401             MOVS     R4,#+1
   \       0x14   0x701C             STRB     R4,[R3, #+0]
   1692          
   1693              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x16   0x2521             MOVS     R5,#+33
   \       0x18   0x....'....        BL       ?Subroutine90
   1694              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   1695              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1696          
   1697              /* Enable Address Acknowledge */
   1698              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1699          
   1700              /* Prepare transfer parameters */
   1701              hi2c->pBuffPtr    = pData;
   1702              hi2c->XferCount   = Size;
   1703              hi2c->XferSize    = hi2c->XferCount;
   1704              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1705              hi2c->XferISR     = I2C_Slave_ISR_IT;
   1706          
   1707              /* Process Unlocked */
   1708              __HAL_UNLOCK(hi2c);
   1709          
   1710              /* Note : The I2C interrupts must be enabled after unlocking current process
   1711                        to avoid the risk of I2C interrupt handle execution before current
   1712                        process unlock */
   1713          
   1714              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1715              /* possible to enable all of these */
   1716              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1717              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
   \                     ??CrossCallReturnLabel_209: (+1)
   \       0x1C   0x2105             MOVS     R1,#+5
   \       0x1E   0x....             B.N      ?Subroutine1
   1718          
   1719              return HAL_OK;
   1720            }
   1721            else
   1722            {
   1723              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBD70             POP      {R4-R6,PC}       ;; return
   1724            }
   1725          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine90: (+1)
   \        0x0   0x705D             STRB     R5,[R3, #+1]
   \        0x2   0x2620             MOVS     R6,#+32
   \        0x4   0x709E             STRB     R6,[R3, #+2]
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x605C             STR      R4,[R3, #+4]
   \        0xA   0x6804             LDR      R4,[R0, #+0]
   \        0xC   0x6865             LDR      R5,[R4, #+4]
   \        0xE   0xF425 0x4500      BIC      R5,R5,#0x8000
   \       0x12   0x6065             STR      R5,[R4, #+4]
   \       0x14   0x6241             STR      R1,[R0, #+36]
   \       0x16   0x8542             STRH     R2,[R0, #+42]
   \       0x18   0x8D41             LDRH     R1,[R0, #+42]
   \       0x1A   0x....'....        LDR.W    R2,??DataTable22  ;; 0xffff0000
   \       0x1E   0x....'....        LDR.W    R4,??DataTable23
   \       0x22   0x8501             STRH     R1,[R0, #+40]
   \       0x24   0x62C2             STR      R2,[R0, #+44]
   \       0x26   0x6344             STR      R4,[R0, #+52]
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x701A             STRB     R2,[R3, #+0]
   \       0x2C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....'....        BL       I2C_Enable_IRQ
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD70             POP      {R4-R6,PC}
   1726          
   1727          /**
   1728            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt
   1729            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1730            *                the configuration information for the specified I2C.
   1731            * @param  pData Pointer to data buffer
   1732            * @param  Size Amount of data to be sent
   1733            * @retval HAL status
   1734            */

   \                                 In section .text, align 2, keep-with-next
   1735          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1736          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1737            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x0340      ADD      R3,R0,#+64
   \        0x6   0x785C             LDRB     R4,[R3, #+1]
   \        0x8   0x2C20             CMP      R4,#+32
   \        0xA   0xD109             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1738            {
   1739              /* Process Locked */
   1740              __HAL_LOCK(hi2c);
   \        0xC   0x781D             LDRB     R5,[R3, #+0]
   \        0xE   0x2D01             CMP      R5,#+1
   \       0x10   0xD006             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \       0x12   0x2401             MOVS     R4,#+1
   \       0x14   0x701C             STRB     R4,[R3, #+0]
   1741          
   1742              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x16   0x2522             MOVS     R5,#+34
   \       0x18   0x....'....        BL       ?Subroutine90
   1743              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   1744              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1745          
   1746              /* Enable Address Acknowledge */
   1747              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   1748          
   1749              /* Prepare transfer parameters */
   1750              hi2c->pBuffPtr    = pData;
   1751              hi2c->XferCount   = Size;
   1752              hi2c->XferSize    = hi2c->XferCount;
   1753              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   1754              hi2c->XferISR     = I2C_Slave_ISR_IT;
   1755          
   1756              /* Process Unlocked */
   1757              __HAL_UNLOCK(hi2c);
   1758          
   1759              /* Note : The I2C interrupts must be enabled after unlocking current process
   1760                        to avoid the risk of I2C interrupt handle execution before current
   1761                        process unlock */
   1762          
   1763              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1764              /* possible to enable all of these */
   1765              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1766              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
   \                     ??CrossCallReturnLabel_210: (+1)
   \       0x1C   0x2106             MOVS     R1,#+6
   \       0x1E   0x....             B.N      ?Subroutine1
   1767          
   1768              return HAL_OK;
   1769            }
   1770            else
   1771            {
   1772              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBD70             POP      {R4-R6,PC}       ;; return
   1773            }
   1774          }
   1775          
   1776          /**
   1777            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1778            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1779            *                the configuration information for the specified I2C.
   1780            * @param  DevAddress Target device address: The device 7 bits address value
   1781            *         in datasheet must be shifted to the left before calling the interface
   1782            * @param  pData Pointer to data buffer
   1783            * @param  Size Amount of data to be sent
   1784            * @retval HAL status
   1785            */

   \                                 In section .text, align 2, keep-with-next
   1786          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1787          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine8
   1788            uint32_t xfermode;
   1789            HAL_StatusTypeDef dmaxferstatus;
   1790          
   1791            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x8   0x4611             MOV      R1,R2
   \        0xA   0xD14C             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1792            {
   1793              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0xC   0x6822             LDR      R2,[R4, #+0]
   \        0xE   0x6990             LDR      R0,[R2, #+24]
   \       0x10   0x0402             LSLS     R2,R0,#+16
   \       0x12   0xD448             BMI.N    ??HAL_I2C_Master_Transmit_DMA_0
   1794              {
   1795                return HAL_BUSY;
   1796              }
   1797          
   1798              /* Process Locked */
   1799              __HAL_LOCK(hi2c);
   \       0x14   0x7828             LDRB     R0,[R5, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD045             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0x702A             STRB     R2,[R5, #+0]
   1800          
   1801              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x1E   0x2021             MOVS     R0,#+33
   \       0x20   0x....'....        BL       ?Subroutine41
   1802              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   1803              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1804          
   1805              /* Prepare transfer parameters */
   1806              hi2c->pBuffPtr    = pData;
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x24   0x6261             STR      R1,[R4, #+36]
   1807              hi2c->XferCount   = Size;
   \       0x26   0x8563             STRH     R3,[R4, #+42]
   1808              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x28   0x....'....        LDR.W    R0,??DataTable22  ;; 0xffff0000
   1809              hi2c->XferISR     = I2C_Master_ISR_DMA;
   \       0x2C   0x....'....        LDR.W    R2,??DataTable23_1
   1810          
   1811              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x30   0x....'....        LDR.W    R7,??DataTable17  ;; 0x80002000
   \       0x34   0x62E0             STR      R0,[R4, #+44]
   \       0x36   0x6362             STR      R2,[R4, #+52]
   \       0x38   0x....'....        BL       ?Subroutine88
   \                     ??CrossCallReturnLabel_202: (+1)
   \       0x3C   0xD304             BCC.N    ??HAL_I2C_Master_Transmit_DMA_1
   1812              {
   1813                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x3E   0x22FF             MOVS     R2,#+255
   \       0x40   0x8522             STRH     R2,[R4, #+40]
   1814                xfermode = I2C_RELOAD_MODE;
   \       0x42   0xF04F 0x7880      MOV      R8,#+16777216
   \       0x46   0xE002             B.N      ??HAL_I2C_Master_Transmit_DMA_2
   1815              }
   1816              else
   1817              {
   1818                hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \       0x48   0x....'....        BL       ?Subroutine89
   1819                xfermode = I2C_AUTOEND_MODE;
   1820              }
   1821          
   1822              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_207: (+1)
   \       0x4C   0xD025             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_3
   1823              {
   1824                if (hi2c->hdmatx != NULL)
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \       0x4E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x50   0xB1D0             CBZ.N    R0,??HAL_I2C_Master_Transmit_DMA_4
   1825                {
   1826                  /* Set the I2C DMA transfer complete callback */
   1827                  hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \       0x52   0x....'....        LDR.W    R2,??DataTable23_2
   \       0x56   0x6282             STR      R2,[R0, #+40]
   1828          
   1829                  /* Set the DMA error callback */
   1830                  hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x58   0x....'....        LDR.W    R0,??DataTable23_3
   \       0x5C   0x6BA2             LDR      R2,[R4, #+56]
   \       0x5E   0x6310             STR      R0,[R2, #+48]
   1831          
   1832                  /* Set the unused DMA callbacks to NULL */
   1833                  hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x6BA2             LDR      R2,[R4, #+56]
   \       0x64   0x62D0             STR      R0,[R2, #+44]
   1834                  hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x66   0x6BA2             LDR      R2,[R4, #+56]
   \       0x68   0x6350             STR      R0,[R2, #+52]
   1835          
   1836                  /* Enable the DMA channel */
   1837                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   1838                }
   1839                else
   1840                {
   1841                  /* Update I2C state */
   1842                  hi2c->State     = HAL_I2C_STATE_READY;
   1843                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   1844          
   1845                  /* Update I2C error code */
   1846                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   1847          
   1848                  /* Process Unlocked */
   1849                  __HAL_UNLOCK(hi2c);
   1850          
   1851                  return HAL_ERROR;
   1852                }
   1853          
   1854                if (dmaxferstatus == HAL_OK)
   \       0x6A   0x....'....        BL       ?Subroutine36
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0x6E   0xB970             CBNZ.N   R0,??HAL_I2C_Master_Transmit_DMA_5
   1855                {
   1856                  /* Send Slave Address */
   1857                  /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   1858                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
   \       0x70   0x9700             STR      R7,[SP, #+0]
   \       0x72   0x4643             MOV      R3,R8
   \       0x74   0x8D22             LDRH     R2,[R4, #+40]
   \       0x76   0xB2D2             UXTB     R2,R2
   \       0x78   0x....'....        BL       ??Subroutine100_0
   1859          
   1860                  /* Update XferCount value */
   1861                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_244: (+1)
   \       0x7C   0x....'....        BL       ?Subroutine15
   1862          
   1863                  /* Process Unlocked */
   1864                  __HAL_UNLOCK(hi2c);
   1865          
   1866                  /* Note : The I2C interrupts must be enabled after unlocking current process
   1867                            to avoid the risk of I2C interrupt handle execution before current
   1868                            process unlock */
   1869                  /* Enable ERR and NACK interrupts */
   1870                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   1871          
   1872                  /* Enable DMA Request */
   1873                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x....'....        BL       ?Subroutine43
   1874                }
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x86   0xE00C             B.N      ??CrossCallReturnLabel_60
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \       0x88   0x....'....        BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x8C   0xE001             B.N      ??CrossCallReturnLabel_22
   1875                else
   1876                {
   1877                  /* Update I2C state */
   1878                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \       0x8E   0x....'....        BL       ?Subroutine19
   1879                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   1880          
   1881                  /* Update I2C error code */
   1882                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x92   0x6068             STR      R0,[R5, #+4]
   1883          
   1884                  /* Process Unlocked */
   1885                  __HAL_UNLOCK(hi2c);
   \       0x94   0x7029             STRB     R1,[R5, #+0]
   1886          
   1887                  return HAL_ERROR;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE006             B.N      ??HAL_I2C_Master_Transmit_DMA_6
   1888                }
   1889              }
   1890              else
   1891              {
   1892                /* Update Transfer ISR function pointer */
   1893                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \       0x9A   0x....'....        BL       ?Subroutine30
   1894          
   1895                /* Send Slave Address */
   1896                /* Set NBYTES to write and generate START condition */
   1897                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   1898          
   1899                /* Process Unlocked */
   1900                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_246: (+1)
   \       0x9E   0x....'....        BL       ?Subroutine31
   1901          
   1902                /* Note : The I2C interrupts must be enabled after unlocking current process
   1903                          to avoid the risk of I2C interrupt handle execution before current
   1904                          process unlock */
   1905                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1906                /* possible to enable all of these */
   1907                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1908                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   1909              }
   1910          
   1911              return HAL_OK;
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xE000             B.N      ??HAL_I2C_Master_Transmit_DMA_6
   1912            }
   1913            else
   1914            {
   1915              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \       0xA6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_6: (+1)
   \       0xA8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1916            }
   1917          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine30: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable22_1
   \        0x4   0x6360             STR      R0,[R4, #+52]
   \        0x6   0x9700             STR      R7,[SP, #+0]
   \        0x8   0x4643             MOV      R3,R8
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC                      REQUIRE ??Subroutine100_0
   \        0xC                      ;; // Fall through to label ??Subroutine100_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine100_0: (+1)
   \        0x0   0x4631             MOV      R1,R6
   \                     ??Subroutine100_1: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....'....        B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine89: (+1)
   \        0x0   0x8D60             LDRH     R0,[R4, #+42]
   \        0x2   0x8520             STRH     R0,[R4, #+40]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xF04F 0x7800      MOV      R8,#+33554432
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine41: (+1)
   \        0x0   0x7068             STRB     R0,[R5, #+1]
   \        0x2   0x2710             MOVS     R7,#+16
   \        0x4   0x70AF             STRB     R7,[R5, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6068             STR      R0,[R5, #+4]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A9             STRB     R1,[R5, #+2]
   \        0x8   0x6868             LDR      R0,[R5, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7068             STRB     R0,[R5, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A9             STRB     R1,[R5, #+2]
   \        0x8   0x6868             LDR      R0,[R5, #+4]
   \        0xA   0xF040 0x0080      ORR      R0,R0,#0x80
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x8D61             LDRH     R1,[R4, #+42]
   \        0x2   0x8D20             LDRH     R0,[R4, #+40]
   \        0x4   0x1A09             SUBS     R1,R1,R0
   \        0x6   0x8561             STRH     R1,[R4, #+42]
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x7029             STRB     R1,[R5, #+0]
   \        0xE   0x2111             MOVS     R1,#+17
   \       0x10   0x....'....        B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF104 0x0540      ADD      R5,R4,#+64
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine43: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine88: (+1)
   \        0x0   0x8D60             LDRH     R0,[R4, #+42]
   \        0x2   0xF5B0 0x7F80      CMP      R0,#+256
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine36: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x8D23             LDRH     R3,[R4, #+40]
   \        0x4   0xF100 0x0228      ADD      R2,R0,#+40
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x....'....        B.W      HAL_DMA_Start_IT
   1918          
   1919          /**
   1920            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
   1921            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1922            *                the configuration information for the specified I2C.
   1923            * @param  DevAddress Target device address: The device 7 bits address value
   1924            *         in datasheet must be shifted to the left before calling the interface
   1925            * @param  pData Pointer to data buffer
   1926            * @param  Size Amount of data to be sent
   1927            * @retval HAL status
   1928            */

   \                                 In section .text, align 2, keep-with-next
   1929          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1930          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine8
   1931            uint32_t xfermode;
   1932            HAL_StatusTypeDef dmaxferstatus;
   1933          
   1934            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x8   0xD14E             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   1935            {
   1936              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \        0xA   0x6821             LDR      R1,[R4, #+0]
   \        0xC   0x6988             LDR      R0,[R1, #+24]
   \        0xE   0x0401             LSLS     R1,R0,#+16
   \       0x10   0xD44A             BMI.N    ??HAL_I2C_Master_Receive_DMA_0
   1937              {
   1938                return HAL_BUSY;
   1939              }
   1940          
   1941              /* Process Locked */
   1942              __HAL_LOCK(hi2c);
   \       0x12   0x7828             LDRB     R0,[R5, #+0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD047             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x7029             STRB     R1,[R5, #+0]
   1943          
   1944              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x1C   0x2022             MOVS     R0,#+34
   \       0x1E   0x....'....        BL       ?Subroutine41
   1945              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   1946              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1947          
   1948              /* Prepare transfer parameters */
   1949              hi2c->pBuffPtr    = pData;
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x22   0x6262             STR      R2,[R4, #+36]
   1950              hi2c->XferCount   = Size;
   \       0x24   0x8563             STRH     R3,[R4, #+42]
   1951              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x26   0x....'....        LDR.W    R0,??DataTable22  ;; 0xffff0000
   1952              hi2c->XferISR     = I2C_Master_ISR_DMA;
   \       0x2A   0x....'....        LDR.W    R1,??DataTable23_1
   1953          
   1954              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x2E   0x....'....        LDR.W    R7,??DataTable19  ;; 0x80002400
   \       0x32   0x62E0             STR      R0,[R4, #+44]
   \       0x34   0x6361             STR      R1,[R4, #+52]
   \       0x36   0x....'....        BL       ?Subroutine88
   \                     ??CrossCallReturnLabel_203: (+1)
   \       0x3A   0xD304             BCC.N    ??HAL_I2C_Master_Receive_DMA_1
   1955              {
   1956                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x3C   0x21FF             MOVS     R1,#+255
   \       0x3E   0x8521             STRH     R1,[R4, #+40]
   1957                xfermode = I2C_RELOAD_MODE;
   \       0x40   0xF04F 0x7880      MOV      R8,#+16777216
   \       0x44   0xE002             B.N      ??HAL_I2C_Master_Receive_DMA_2
   1958              }
   1959              else
   1960              {
   1961                hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \       0x46   0x....'....        BL       ?Subroutine89
   1962                xfermode = I2C_AUTOEND_MODE;
   1963              }
   1964          
   1965              if (hi2c->XferSize > 0U)
   \                     ??CrossCallReturnLabel_208: (+1)
   \       0x4A   0xD027             BEQ.N    ??HAL_I2C_Master_Receive_DMA_3
   1966              {
   1967                if (hi2c->hdmarx != NULL)
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \       0x4C   0x6BE0             LDR      R0,[R4, #+60]
   \       0x4E   0xB1E0             CBZ.N    R0,??HAL_I2C_Master_Receive_DMA_4
   1968                {
   1969                  /* Set the I2C DMA transfer complete callback */
   1970                  hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \       0x50   0x....'....        LDR.W    R1,??DataTable24
   \       0x54   0x6281             STR      R1,[R0, #+40]
   1971          
   1972                  /* Set the DMA error callback */
   1973                  hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x56   0x....'....        LDR.W    R0,??DataTable23_3
   \       0x5A   0x6BE1             LDR      R1,[R4, #+60]
   \       0x5C   0x6308             STR      R0,[R1, #+48]
   1974          
   1975                  /* Set the unused DMA callbacks to NULL */
   1976                  hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6BE1             LDR      R1,[R4, #+60]
   \       0x62   0x62C8             STR      R0,[R1, #+44]
   1977                  hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x64   0x6BE1             LDR      R1,[R4, #+60]
   \       0x66   0x6348             STR      R0,[R1, #+52]
   1978          
   1979                  /* Enable the DMA channel */
   1980                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   1981                }
   1982                else
   1983                {
   1984                  /* Update I2C state */
   1985                  hi2c->State     = HAL_I2C_STATE_READY;
   1986                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   1987          
   1988                  /* Update I2C error code */
   1989                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   1990          
   1991                  /* Process Unlocked */
   1992                  __HAL_UNLOCK(hi2c);
   1993          
   1994                  return HAL_ERROR;
   1995                }
   1996          
   1997                if (dmaxferstatus == HAL_OK)
   \       0x68   0x....'....        BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0x6C   0xB980             CBNZ.N   R0,??HAL_I2C_Master_Receive_DMA_5
   1998                {
   1999                  /* Send Slave Address */
   2000                  /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2001                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \       0x6E   0x9700             STR      R7,[SP, #+0]
   \       0x70   0x4643             MOV      R3,R8
   \       0x72   0x8D22             LDRH     R2,[R4, #+40]
   \       0x74   0xB2D2             UXTB     R2,R2
   \       0x76   0x....'....        BL       ??Subroutine100_0
   2002          
   2003                  /* Update XferCount value */
   2004                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_243: (+1)
   \       0x7A   0x....'....        BL       ?Subroutine15
   2005          
   2006                  /* Process Unlocked */
   2007                  __HAL_UNLOCK(hi2c);
   2008          
   2009                  /* Note : The I2C interrupts must be enabled after unlocking current process
   2010                            to avoid the risk of I2C interrupt handle execution before current
   2011                            process unlock */
   2012                  /* Enable ERR and NACK interrupts */
   2013                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   2014          
   2015                  /* Enable DMA Request */
   2016                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x6801             LDR      R1,[R0, #+0]
   \       0x82   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x86   0x6001             STR      R1,[R0, #+0]
   \       0x88   0xE00C             B.N      ??CrossCallReturnLabel_59
   2017                }
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x8E   0xE001             B.N      ??CrossCallReturnLabel_23
   2018                else
   2019                {
   2020                  /* Update I2C state */
   2021                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \       0x90   0x....'....        BL       ?Subroutine19
   2022                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   2023          
   2024                  /* Update I2C error code */
   2025                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x94   0x6068             STR      R0,[R5, #+4]
   2026          
   2027                  /* Process Unlocked */
   2028                  __HAL_UNLOCK(hi2c);
   \       0x96   0x7029             STRB     R1,[R5, #+0]
   2029          
   2030                  return HAL_ERROR;
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xE006             B.N      ??HAL_I2C_Master_Receive_DMA_6
   2031                }
   2032              }
   2033              else
   2034              {
   2035                /* Update Transfer ISR function pointer */
   2036                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \       0x9C   0x....'....        BL       ?Subroutine30
   2037          
   2038                /* Send Slave Address */
   2039                /* Set NBYTES to read and generate START condition */
   2040                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   2041          
   2042                /* Process Unlocked */
   2043                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_245: (+1)
   \       0xA0   0x....'....        BL       ?Subroutine31
   2044          
   2045                /* Note : The I2C interrupts must be enabled after unlocking current process
   2046                          to avoid the risk of I2C interrupt handle execution before current
   2047                          process unlock */
   2048                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   2049                /* possible to enable all of these */
   2050                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2051                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   2052              }
   2053          
   2054              return HAL_OK;
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0xE000             B.N      ??HAL_I2C_Master_Receive_DMA_6
   2055            }
   2056            else
   2057            {
   2058              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \       0xA8   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_6: (+1)
   \       0xAA   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2059            }
   2060          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine37: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0x8D23             LDRH     R3,[R4, #+40]
   \        0x4   0xF100 0x0124      ADD      R1,R0,#+36
   \        0x8   0x6BE0             LDR      R0,[R4, #+60]
   \        0xA   0x....'....        B.W      HAL_DMA_Start_IT
   2061          
   2062          /**
   2063            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
   2064            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2065            *                the configuration information for the specified I2C.
   2066            * @param  pData Pointer to data buffer
   2067            * @param  Size Amount of data to be sent
   2068            * @retval HAL status
   2069            */

   \                                 In section .text, align 2, keep-with-next
   2070          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2071          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine93
   2072            HAL_StatusTypeDef dmaxferstatus;
   2073          
   2074            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_216: (+1)
   \        0x6   0xD12D             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   2075            {
   2076              if ((pData == NULL) || (Size == 0U))
   \        0x8   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Transmit_DMA_1
   \        0xA   0x0010             MOVS     R0,R2
   \        0xC   0xD103             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_2
   2077              {
   2078                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \        0xE   0xF44F 0x7000      MOV      R0,#+512
   \       0x12   0x6060             STR      R0,[R4, #+4]
   2079                return  HAL_ERROR;
   \       0x14   0xE024             B.N      ??CrossCallReturnLabel_12
   2080              }
   2081              /* Process Locked */
   2082              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \       0x16   0x7820             LDRB     R0,[R4, #+0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD023             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \       0x1C   0x2301             MOVS     R3,#+1
   \       0x1E   0x7023             STRB     R3,[R4, #+0]
   2083          
   2084              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x20   0x2021             MOVS     R0,#+33
   \       0x22   0x....'....        BL       ?Subroutine55
   2085              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   2086              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2087          
   2088              /* Prepare transfer parameters */
   2089              hi2c->pBuffPtr    = pData;
   2090              hi2c->XferCount   = Size;
   2091              hi2c->XferSize    = hi2c->XferCount;
   2092              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2093              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   2094          
   2095              if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_115: (+1)
   \       0x26   0x6BA8             LDR      R0,[R5, #+56]
   \       0x28   0xB1A8             CBZ.N    R0,??HAL_I2C_Slave_Transmit_DMA_3
   2096              {
   2097                /* Set the I2C DMA transfer complete callback */
   2098                hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   \       0x2A   0x....'....        LDR.W    R2,??DataTable26
   \       0x2E   0x6282             STR      R2,[R0, #+40]
   2099          
   2100                /* Set the DMA error callback */
   2101                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x30   0x....'....        LDR.W    R0,??DataTable23_3
   \       0x34   0x6BAA             LDR      R2,[R5, #+56]
   \       0x36   0x6310             STR      R0,[R2, #+48]
   2102          
   2103                /* Set the unused DMA callbacks to NULL */
   2104                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x6BAA             LDR      R2,[R5, #+56]
   \       0x3C   0x62D0             STR      R0,[R2, #+44]
   2105                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x3E   0x6BAA             LDR      R2,[R5, #+56]
   \       0x40   0x6350             STR      R0,[R2, #+52]
   2106          
   2107                /* Enable the DMA channel */
   2108                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   2109              }
   2110              else
   2111              {
   2112                /* Update I2C state */
   2113                hi2c->State     = HAL_I2C_STATE_LISTEN;
   2114                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2115          
   2116                /* Update I2C error code */
   2117                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2118          
   2119                /* Process Unlocked */
   2120                __HAL_UNLOCK(hi2c);
   2121          
   2122                return HAL_ERROR;
   2123              }
   2124          
   2125              if (dmaxferstatus == HAL_OK)
   \       0x42   0x....'....        BL       ?Subroutine92
   \                     ??CrossCallReturnLabel_215: (+1)
   \       0x46   0xB948             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_DMA_4
   2126              {
   2127                /* Enable Address Acknowledge */
   2128                hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \       0x48   0x....'....        BL       ?Subroutine50
   2129          
   2130                /* Process Unlocked */
   2131                __HAL_UNLOCK(hi2c);
   2132          
   2133                /* Note : The I2C interrupts must be enabled after unlocking current process
   2134                          to avoid the risk of I2C interrupt handle execution before current
   2135                          process unlock */
   2136                /* Enable ERR, STOP, NACK, ADDR interrupts */
   2137                I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   2138          
   2139                /* Enable DMA Request */
   2140                hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_101: (+1)
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0x6801             LDR      R1,[R0, #+0]
   \       0x50   0xF441 0x4180      ORR      R1,R1,#0x4000
   \       0x54   0x....             B.N      ?Subroutine2
   2141              }
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \       0x56   0x....'....        BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x5A   0xE001             B.N      ??CrossCallReturnLabel_12
   2142              else
   2143              {
   2144                /* Update I2C state */
   2145                hi2c->State     = HAL_I2C_STATE_LISTEN;
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \       0x5C   0x....'....        BL       ?Subroutine14
   2146                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2147          
   2148                /* Update I2C error code */
   2149                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2150          
   2151                /* Process Unlocked */
   2152                __HAL_UNLOCK(hi2c);
   2153          
   2154                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xBD70             POP      {R4-R6,PC}
   2155              }
   2156          
   2157              return HAL_OK;
   2158            }
   2159            else
   2160            {
   2161              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \       0x64   0x2002             MOVS     R0,#+2
   \       0x66   0xBD70             POP      {R4-R6,PC}       ;; return
   2162            }
   2163          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine93: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0xF105 0x0440      ADD      R4,R5,#+64
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine55: (+1)
   \        0x0   0x7060             STRB     R0,[R4, #+1]
   \        0x2   0x2620             MOVS     R6,#+32
   \        0x4   0x70A6             STRB     R6,[R4, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6060             STR      R0,[R4, #+4]
   \        0xA   0x6269             STR      R1,[R5, #+36]
   \        0xC   0x856A             STRH     R2,[R5, #+42]
   \        0xE   0x8D68             LDRH     R0,[R5, #+42]
   \       0x10   0x....'....        LDR.W    R2,??DataTable22  ;; 0xffff0000
   \       0x14   0x8528             STRH     R0,[R5, #+40]
   \       0x16   0x62EA             STR      R2,[R5, #+44]
   \       0x18   0x....'....        LDR.W    R0,??DataTable27_1
   \       0x1C   0x6368             STR      R0,[R5, #+52]
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine50: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0xF421 0x4100      BIC      R1,R1,#0x8000
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x7020             STRB     R0,[R4, #+0]
   \        0xE   0x2104             MOVS     R1,#+4
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x2028             MOVS     R0,#+40
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A1             STRB     R1,[R4, #+2]
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x6060             STR      R0,[R4, #+4]
   \       0x10   0x7021             STRB     R1,[R4, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x2028             MOVS     R0,#+40
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A1             STRB     R1,[R4, #+2]
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0xF040 0x0080      ORR      R0,R0,#0x80
   \        0xE   0x6060             STR      R0,[R4, #+4]
   \       0x10   0x7021             STRB     R1,[R4, #+0]
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6001             STR      R1,[R0, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine92: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \        0x2   0x8D2B             LDRH     R3,[R5, #+40]
   \        0x4   0xF100 0x0228      ADD      R2,R0,#+40
   \        0x8   0x6BA8             LDR      R0,[R5, #+56]
   \        0xA   0x....'....        B.W      HAL_DMA_Start_IT
   2164          
   2165          /**
   2166            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
   2167            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2168            *                the configuration information for the specified I2C.
   2169            * @param  pData Pointer to data buffer
   2170            * @param  Size Amount of data to be sent
   2171            * @retval HAL status
   2172            */

   \                                 In section .text, align 2, keep-with-next
   2173          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2174          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine93
   2175            HAL_StatusTypeDef dmaxferstatus;
   2176          
   2177            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_217: (+1)
   \        0x6   0xD133             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   2178            {
   2179              if ((pData == NULL) || (Size == 0U))
   \        0x8   0xB109             CBZ.N    R1,??HAL_I2C_Slave_Receive_DMA_1
   \        0xA   0x0010             MOVS     R0,R2
   \        0xC   0xD103             BNE.N    ??HAL_I2C_Slave_Receive_DMA_2
   2180              {
   2181                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \        0xE   0xF44F 0x7000      MOV      R0,#+512
   \       0x12   0x6060             STR      R0,[R4, #+4]
   2182                return  HAL_ERROR;
   \       0x14   0xE02A             B.N      ??CrossCallReturnLabel_13
   2183              }
   2184              /* Process Locked */
   2185              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \       0x16   0x7820             LDRB     R0,[R4, #+0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD029             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \       0x1C   0x2301             MOVS     R3,#+1
   \       0x1E   0x7023             STRB     R3,[R4, #+0]
   2186          
   2187              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x20   0x2022             MOVS     R0,#+34
   \       0x22   0x....'....        BL       ?Subroutine55
   2188              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   2189              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2190          
   2191              /* Prepare transfer parameters */
   2192              hi2c->pBuffPtr    = pData;
   2193              hi2c->XferCount   = Size;
   2194              hi2c->XferSize    = hi2c->XferCount;
   2195              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2196              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   2197          
   2198              if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_116: (+1)
   \       0x26   0x6BE8             LDR      R0,[R5, #+60]
   \       0x28   0xB1D8             CBZ.N    R0,??HAL_I2C_Slave_Receive_DMA_3
   2199              {
   2200                /* Set the I2C DMA transfer complete callback */
   2201                hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   \       0x2A   0x....'....        LDR.W    R2,??DataTable27
   \       0x2E   0x6282             STR      R2,[R0, #+40]
   2202          
   2203                /* Set the DMA error callback */
   2204                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x30   0x....'....        LDR.W    R0,??DataTable23_3
   \       0x34   0x6BEA             LDR      R2,[R5, #+60]
   \       0x36   0x6310             STR      R0,[R2, #+48]
   2205          
   2206                /* Set the unused DMA callbacks to NULL */
   2207                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x6BEA             LDR      R2,[R5, #+60]
   \       0x3C   0x62D0             STR      R0,[R2, #+44]
   2208                hi2c->hdmarx->XferAbortCallback = NULL;
   2209          
   2210                /* Enable the DMA channel */
   2211                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   2212              }
   2213              else
   2214              {
   2215                /* Update I2C state */
   2216                hi2c->State     = HAL_I2C_STATE_LISTEN;
   2217                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2218          
   2219                /* Update I2C error code */
   2220                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2221          
   2222                /* Process Unlocked */
   2223                __HAL_UNLOCK(hi2c);
   2224          
   2225                return HAL_ERROR;
   2226              }
   2227          
   2228              if (dmaxferstatus == HAL_OK)
   \       0x3E   0x460A             MOV      R2,R1
   \       0x40   0x6BEE             LDR      R6,[R5, #+60]
   \       0x42   0x6370             STR      R0,[R6, #+52]
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x48   0xF100 0x0124      ADD      R1,R0,#+36
   \       0x4C   0x6BE8             LDR      R0,[R5, #+60]
   \       0x4E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x52   0xB948             CBNZ.N   R0,??HAL_I2C_Slave_Receive_DMA_4
   2229              {
   2230                /* Enable Address Acknowledge */
   2231                hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \       0x54   0x....'....        BL       ?Subroutine50
   2232          
   2233                /* Process Unlocked */
   2234                __HAL_UNLOCK(hi2c);
   2235          
   2236                /* Note : The I2C interrupts must be enabled after unlocking current process
   2237                          to avoid the risk of I2C interrupt handle execution before current
   2238                          process unlock */
   2239                /* Enable ERR, STOP, NACK, ADDR interrupts */
   2240                I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   2241          
   2242                /* Enable DMA Request */
   2243                hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_100: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6801             LDR      R1,[R0, #+0]
   \       0x5C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x60   0x....             B.N      ?Subroutine2
   2244              }
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \       0x62   0x....'....        BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x66   0xE001             B.N      ??CrossCallReturnLabel_13
   2245              else
   2246              {
   2247                /* Update I2C state */
   2248                hi2c->State     = HAL_I2C_STATE_LISTEN;
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \       0x68   0x....'....        BL       ?Subroutine14
   2249                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2250          
   2251                /* Update I2C error code */
   2252                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2253          
   2254                /* Process Unlocked */
   2255                __HAL_UNLOCK(hi2c);
   2256          
   2257                return HAL_ERROR;
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xBD70             POP      {R4-R6,PC}
   2258              }
   2259          
   2260              return HAL_OK;
   2261            }
   2262            else
   2263            {
   2264              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0xBD70             POP      {R4-R6,PC}       ;; return
   2265            }
   2266          }
   2267          /**
   2268            * @brief  Write an amount of data in blocking mode to a specific memory address
   2269            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2270            *                the configuration information for the specified I2C.
   2271            * @param  DevAddress Target device address: The device 7 bits address value
   2272            *         in datasheet must be shifted to the left before calling the interface
   2273            * @param  MemAddress Internal memory address
   2274            * @param  MemAddSize Size of internal memory address
   2275            * @param  pData Pointer to data buffer
   2276            * @param  Size Amount of data to be sent
   2277            * @param  Timeout Timeout duration
   2278            * @retval HAL status
   2279            */

   \                                 In section .text, align 2, keep-with-next
   2280          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2281          {
   \                     HAL_I2C_Mem_Write: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x....'....        BL       ?Subroutine64
   2282            uint32_t tickstart;
   2283          
   2284            /* Check the parameters */
   2285            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2286          
   2287            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_137: (+1)
   \        0x8   0xD14E             BNE.N    ??HAL_I2C_Mem_Write_0
   \        0xA   0x9D0C             LDR      R5,[SP, #+48]
   2288            {
   2289              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9F0D             LDRNE    R7,[SP, #+52]
   \       0x12   0x2F00             CMPNE    R7,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Write_1
   2290              {
   2291                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6061             STR      R1,[R4, #+4]
   2292                return  HAL_ERROR;
   \       0x1C   0xE03F             B.N      ??HAL_I2C_Mem_Write_2
   2293              }
   2294          
   2295              /* Process Locked */
   2296              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \       0x1E   0x7820             LDRB     R0,[R4, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD041             BEQ.N    ??HAL_I2C_Mem_Write_0
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x7021             STRB     R1,[R4, #+0]
   2297          
   2298              /* Init tickstart for timeout management*/
   2299              tickstart = HAL_GetTick();
   \       0x28   0x....'....        BL       HAL_GetTick
   \       0x2C   0x....'....        BL       ?Subroutine69
   2300          
   2301              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_148: (+1)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD134             BNE.N    ??HAL_I2C_Mem_Write_2
   2302              {
   2303                return HAL_ERROR;
   2304              }
   2305          
   2306              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x34   0x2021             MOVS     R0,#+33
   \       0x36   0x....'....        BL       ?Subroutine53
   2307              hi2c->Mode      = HAL_I2C_MODE_MEM;
   2308              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2309          
   2310              /* Prepare transfer parameters */
   2311              hi2c->pBuffPtr  = pData;
   2312              hi2c->XferCount = Size;
   2313              hi2c->XferISR   = NULL;
   2314          
   2315              /* Send Slave Address and Memory Address */
   2316              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_111: (+1)
   \       0x3A   0x....'....        BL       I2C_RequestMemoryWrite
   \       0x3E   0xB110             CBZ.N    R0,??HAL_I2C_Mem_Write_3
   2317              {
   2318                /* Process Unlocked */
   2319                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7020             STRB     R0,[R4, #+0]
   2320                return HAL_ERROR;
   \       0x44   0xE02B             B.N      ??HAL_I2C_Mem_Write_2
   2321              }
   2322          
   2323              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
   2324              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \       0x46   0x8D70             LDRH     R0,[R6, #+42]
   \       0x48   0x25FF             MOVS     R5,#+255
   \       0x4A   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x4E   0xD319             BCC.N    ??HAL_I2C_Mem_Write_4
   2325              {
   2326                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x50   0x....'....        BL       ?Subroutine57
   2327                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2328              }
   \                     ??CrossCallReturnLabel_119: (+1)
   \       0x54   0x....'....        BL       ??Subroutine101_0
   \                     ??CrossCallReturnLabel_250: (+1)
   \       0x58   0x9F0E             LDR      R7,[SP, #+56]
   2329              else
   2330              {
   2331                hi2c->XferSize = hi2c->XferCount;
   2332                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2333              }
   2334          
   2335              do
   2336              {
   2337                /* Wait until TXIS flag is set */
   2338                if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \       0x5A   0x464A             MOV      R2,R9
   \       0x5C   0x4639             MOV      R1,R7
   \       0x5E   0x4630             MOV      R0,R6
   \       0x60   0x....'....        BL       I2C_WaitOnTXISFlagUntilTimeout
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD11A             BNE.N    ??HAL_I2C_Mem_Write_2
   2339                {
   2340                  return HAL_ERROR;
   2341                }
   2342          
   2343                /* Write data to TXDR */
   2344                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \       0x68   0x....'....        BL       ?Subroutine78
   2345          
   2346                /* Increment Buffer pointer */
   2347                hi2c->pBuffPtr++;
   2348          
   2349                hi2c->XferCount--;
   2350                hi2c->XferSize--;
   2351          
   2352                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   \                     ??CrossCallReturnLabel_174: (+1)
   \       0x6C   0xD011             BEQ.N    ??CrossCallReturnLabel_249
   \       0x6E   0xB289             UXTH     R1,R1
   \       0x70   0xB979             CBNZ.N   R1,??CrossCallReturnLabel_249
   2353                {
   2354                  /* Wait until TCR flag is set */
   2355                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x72   0x....'....        BL       ?Subroutine70
   \                     ??CrossCallReturnLabel_152: (+1)
   \       0x76   0xB990             CBNZ.N   R0,??HAL_I2C_Mem_Write_2
   2356                  {
   2357                    return HAL_ERROR;
   2358                  }
   2359          
   2360                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x78   0x....'....        BL       ?Subroutine82
   \                     ??CrossCallReturnLabel_183: (+1)
   \       0x7C   0xD305             BCC.N    ??HAL_I2C_Mem_Write_6
   2361                  {
   2362                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x7E   0x....'....        BL       ?Subroutine57
   2363                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2364                  }
   \                     ??CrossCallReturnLabel_120: (+1)
   \       0x82   0xE004             B.N      ??CrossCallReturnLabel_123
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \       0x84   0x....'....        BL       ?Subroutine58
   \                     ??CrossCallReturnLabel_122: (+1)
   \       0x88   0xE7E4             B.N      ??CrossCallReturnLabel_119
   2365                  else
   2366                  {
   2367                    hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine58
   2368                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2369                  }
   2370                }
   2371          
   2372              }
   \                     ??CrossCallReturnLabel_123: (+1)
   \       0x8E   0x....'....        BL       ??Subroutine101_0
   2373              while (hi2c->XferCount > 0U);
   \                     ??CrossCallReturnLabel_249: (+1)
   \       0x92   0x8D70             LDRH     R0,[R6, #+42]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD1E0             BNE.N    ??HAL_I2C_Mem_Write_5
   2374          
   2375              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2376              /* Wait until STOPF flag is reset */
   2377              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0x98   0x....'....        BL       ?Subroutine80
   \                     ??CrossCallReturnLabel_178: (+1)
   \       0x9C   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Write_7
   2378              {
   2379                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xE003             B.N      ??HAL_I2C_Mem_Write_8
   2380              }
   2381          
   2382              /* Clear STOP Flag */
   2383              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \       0xA2   0x....'....        BL       ?Subroutine61
   2384          
   2385              /* Clear Configuration Register 2 */
   2386              I2C_RESET_CR2(hi2c);
   2387          
   2388              hi2c->State = HAL_I2C_STATE_READY;
   2389              hi2c->Mode  = HAL_I2C_MODE_NONE;
   2390          
   2391              /* Process Unlocked */
   2392              __HAL_UNLOCK(hi2c);
   2393          
   2394              return HAL_OK;
   \                     ??CrossCallReturnLabel_131: (+1)
   \       0xA6   0xE000             B.N      ??HAL_I2C_Mem_Write_8
   2395            }
   2396            else
   2397            {
   2398              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \       0xA8   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \       0xAA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2399            }
   2400          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine80: (+1)
   \        0x0   0x464A             MOV      R2,R9
   \        0x2   0x4639             MOV      R1,R7
   \        0x4   0x4630             MOV      R0,R6
   \        0x6   0x....'....        B.W      I2C_WaitOnSTOPFlagUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine64: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0440      ADD      R4,R6,#+64
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x7860             LDRB     R0,[R4, #+1]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0x4692             MOV      R10,R2
   \        0xE   0x469B             MOV      R11,R3
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine58: (+1)
   \        0x0   0x8D72             LDRH     R2,[R6, #+42]
   \        0x2   0x8532             STRH     R2,[R6, #+40]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0xF04F 0x7300      MOV      R3,#+33554432
   \        0xC   0xB2D2             UXTB     R2,R2
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine57: (+1)
   \        0x0   0x8535             STRH     R5,[R6, #+40]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0xF04F 0x7380      MOV      R3,#+16777216
   \        0xA   0x22FF             MOVS     R2,#+255
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine53: (+1)
   \        0x0   0x7060             STRB     R0,[R4, #+1]
   \        0x2   0x2140             MOVS     R1,#+64
   \        0x4   0x70A1             STRB     R1,[R4, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6060             STR      R0,[R4, #+4]
   \        0xA   0x6275             STR      R5,[R6, #+36]
   \        0xC   0x8577             STRH     R7,[R6, #+42]
   \        0xE   0x6370             STR      R0,[R6, #+52]
   \       0x10   0x465B             MOV      R3,R11
   \       0x12   0x990E             LDR      R1,[SP, #+56]
   \       0x14   0x9100             STR      R1,[SP, #+0]
   \       0x16   0x4652             MOV      R2,R10
   \       0x18   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \       0x1C   0x4641             MOV      R1,R8
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x4770             BX       LR
   2401          
   2402          /**
   2403            * @brief  Read an amount of data in blocking mode from a specific memory address
   2404            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2405            *                the configuration information for the specified I2C.
   2406            * @param  DevAddress Target device address: The device 7 bits address value
   2407            *         in datasheet must be shifted to the left before calling the interface
   2408            * @param  MemAddress Internal memory address
   2409            * @param  MemAddSize Size of internal memory address
   2410            * @param  pData Pointer to data buffer
   2411            * @param  Size Amount of data to be sent
   2412            * @param  Timeout Timeout duration
   2413            * @retval HAL status
   2414            */

   \                                 In section .text, align 2, keep-with-next
   2415          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2416          {
   \                     HAL_I2C_Mem_Read: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x....'....        BL       ?Subroutine64
   2417            uint32_t tickstart;
   2418          
   2419            /* Check the parameters */
   2420            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2421          
   2422            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_138: (+1)
   \        0x8   0xD165             BNE.N    ??HAL_I2C_Mem_Read_0
   \        0xA   0x9D0C             LDR      R5,[SP, #+48]
   2423            {
   2424              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9F0D             LDRNE    R7,[SP, #+52]
   \       0x12   0x2F00             CMPNE    R7,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Read_1
   2425              {
   2426                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6061             STR      R1,[R4, #+4]
   2427                return  HAL_ERROR;
   \       0x1C   0xE056             B.N      ??HAL_I2C_Mem_Read_2
   2428              }
   2429          
   2430              /* Process Locked */
   2431              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \       0x1E   0x7820             LDRB     R0,[R4, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD058             BEQ.N    ??HAL_I2C_Mem_Read_0
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x7021             STRB     R1,[R4, #+0]
   2432          
   2433              /* Init tickstart for timeout management*/
   2434              tickstart = HAL_GetTick();
   \       0x28   0x....'....        BL       HAL_GetTick
   \       0x2C   0x4681             MOV      R9,R0
   2435          
   2436              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \       0x2E   0x6830             LDR      R0,[R6, #+0]
   \       0x30   0x6981             LDR      R1,[R0, #+24]
   \       0x32   0x0408             LSLS     R0,R1,#+16
   \       0x34   0xD50E             BPL.N    ??HAL_I2C_Mem_Read_4
   \       0x36   0x....'....        BL       HAL_GetTick
   \       0x3A   0xEBA0 0x0009      SUB      R0,R0,R9
   \       0x3E   0x281A             CMP      R0,#+26
   \       0x40   0xD3F5             BCC.N    ??HAL_I2C_Mem_Read_3
   \       0x42   0x6860             LDR      R0,[R4, #+4]
   \       0x44   0xF040 0x0020      ORR      R0,R0,#0x20
   \       0x48   0x6060             STR      R0,[R4, #+4]
   \       0x4A   0x2120             MOVS     R1,#+32
   \       0x4C   0x7061             STRB     R1,[R4, #+1]
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x70A0             STRB     R0,[R4, #+2]
   \       0x52   0xE006             B.N      ??HAL_I2C_Mem_Read_5
   2437              {
   2438                return HAL_ERROR;
   2439              }
   2440          
   2441              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \       0x54   0x2022             MOVS     R0,#+34
   \       0x56   0x....'....        BL       ?Subroutine53
   2442              hi2c->Mode      = HAL_I2C_MODE_MEM;
   2443              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2444          
   2445              /* Prepare transfer parameters */
   2446              hi2c->pBuffPtr  = pData;
   2447              hi2c->XferCount = Size;
   2448              hi2c->XferISR   = NULL;
   2449          
   2450              /* Send Slave Address and Memory Address */
   2451              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_112: (+1)
   \       0x5A   0x....'....        BL       I2C_RequestMemoryRead
   \       0x5E   0xB110             CBZ.N    R0,??HAL_I2C_Mem_Read_6
   2452              {
   2453                /* Process Unlocked */
   2454                __HAL_UNLOCK(hi2c);
   \       0x60   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \       0x62   0x7020             STRB     R0,[R4, #+0]
   2455                return HAL_ERROR;
   \       0x64   0xE032             B.N      ??HAL_I2C_Mem_Read_2
   2456              }
   2457          
   2458              /* Send Slave Address */
   2459              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2460              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \       0x66   0x8D71             LDRH     R1,[R6, #+42]
   \       0x68   0x....'....        LDR.W    R0,??DataTable24_1  ;; 0x80002400
   \       0x6C   0x25FF             MOVS     R5,#+255
   \       0x6E   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x72   0xD31C             BCC.N    ??HAL_I2C_Mem_Read_7
   2461              {
   2462                hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x74   0x8535             STRH     R5,[R6, #+40]
   2463                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \       0x76   0x....'....        BL       ?Subroutine75
   2464              }
   \                     ??CrossCallReturnLabel_168: (+1)
   \       0x7A   0x....'....        BL       ??Subroutine101_0
   \                     ??CrossCallReturnLabel_248: (+1)
   \       0x7E   0x9F0E             LDR      R7,[SP, #+56]
   2465              else
   2466              {
   2467                hi2c->XferSize = hi2c->XferCount;
   2468                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   2469              }
   2470          
   2471              do
   2472              {
   2473                /* Wait until RXNE flag is set */
   2474                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \       0x80   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x84   0x463B             MOV      R3,R7
   \       0x86   0x2200             MOVS     R2,#+0
   \       0x88   0x2104             MOVS     R1,#+4
   \       0x8A   0x....'....        BL       ??Subroutine72_0
   \                     ??CrossCallReturnLabel_155: (+1)
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD11C             BNE.N    ??HAL_I2C_Mem_Read_2
   2475                {
   2476                  return HAL_ERROR;
   2477                }
   2478          
   2479                /* Read data from RXDR */
   2480                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x92   0x....'....        BL       ?Subroutine79
   2481          
   2482                /* Increment Buffer pointer */
   2483                hi2c->pBuffPtr++;
   2484          
   2485                hi2c->XferSize--;
   2486                hi2c->XferCount--;
   2487          
   2488                if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   \                     ??CrossCallReturnLabel_176: (+1)
   \       0x96   0xB198             CBZ.N    R0,??CrossCallReturnLabel_247
   \       0x98   0xB289             UXTH     R1,R1
   \       0x9A   0xB989             CBNZ.N   R1,??CrossCallReturnLabel_247
   2489                {
   2490                  /* Wait until TCR flag is set */
   2491                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x9C   0x....'....        BL       ?Subroutine70
   \                     ??CrossCallReturnLabel_151: (+1)
   \       0xA0   0xB9A0             CBNZ.N   R0,??HAL_I2C_Mem_Read_2
   2492                  {
   2493                    return HAL_ERROR;
   2494                  }
   2495          
   2496                  if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0xA2   0x....'....        BL       ?Subroutine82
   \                     ??CrossCallReturnLabel_184: (+1)
   \       0xA6   0xD307             BCC.N    ??HAL_I2C_Mem_Read_9
   2497                  {
   2498                    hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0xA8   0x....'....        BL       ?Subroutine57
   2499                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2500                  }
   \                     ??CrossCallReturnLabel_121: (+1)
   \       0xAC   0xE006             B.N      ??CrossCallReturnLabel_124
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \       0xAE   0x8D72             LDRH     R2,[R6, #+42]
   \       0xB0   0x8532             STRH     R2,[R6, #+40]
   \       0xB2   0x....'....        BL       ?Subroutine74
   \                     ??CrossCallReturnLabel_165: (+1)
   \       0xB6   0xE7E0             B.N      ??CrossCallReturnLabel_168
   2501                  else
   2502                  {
   2503                    hi2c->XferSize = hi2c->XferCount;
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \       0xB8   0x....'....        BL       ?Subroutine58
   2504                    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2505                  }
   2506                }
   2507              }
   \                     ??CrossCallReturnLabel_124: (+1)
   \       0xBC   0x....'....        BL       ??Subroutine101_0
   2508              while (hi2c->XferCount > 0U);
   \                     ??CrossCallReturnLabel_247: (+1)
   \       0xC0   0x8D70             LDRH     R0,[R6, #+42]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD1DC             BNE.N    ??HAL_I2C_Mem_Read_8
   2509          
   2510              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2511              /* Wait until STOPF flag is reset */
   2512              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xC6   0x....'....        BL       ?Subroutine80
   \                     ??CrossCallReturnLabel_177: (+1)
   \       0xCA   0xB108             CBZ.N    R0,??HAL_I2C_Mem_Read_10
   2513              {
   2514                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xE003             B.N      ??HAL_I2C_Mem_Read_11
   2515              }
   2516          
   2517              /* Clear STOP Flag */
   2518              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \       0xD0   0x....'....        BL       ?Subroutine61
   2519          
   2520              /* Clear Configuration Register 2 */
   2521              I2C_RESET_CR2(hi2c);
   2522          
   2523              hi2c->State = HAL_I2C_STATE_READY;
   2524              hi2c->Mode  = HAL_I2C_MODE_NONE;
   2525          
   2526              /* Process Unlocked */
   2527              __HAL_UNLOCK(hi2c);
   2528          
   2529              return HAL_OK;
   \                     ??CrossCallReturnLabel_132: (+1)
   \       0xD4   0xE000             B.N      ??HAL_I2C_Mem_Read_11
   2530            }
   2531            else
   2532            {
   2533              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \       0xD6   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \       0xD8   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2534            }
   2535          }
   2536          /**
   2537            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2538            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2539            *                the configuration information for the specified I2C.
   2540            * @param  DevAddress Target device address: The device 7 bits address value
   2541            *         in datasheet must be shifted to the left before calling the interface
   2542            * @param  MemAddress Internal memory address
   2543            * @param  MemAddSize Size of internal memory address
   2544            * @param  pData Pointer to data buffer
   2545            * @param  Size Amount of data to be sent
   2546            * @retval HAL status
   2547            */

   \                                 In section .text, align 2, keep-with-next
   2548          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2549          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x....'....        BL       ?Subroutine68
   2550            uint32_t tickstart;
   2551            uint32_t xfermode;
   2552          
   2553            /* Check the parameters */
   2554            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2555          
   2556            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_146: (+1)
   \        0x8   0xD129             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2557            {
   2558              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9E0B             LDRNE    R6,[SP, #+44]
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Write_IT_1
   2559              {
   2560                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6069             STR      R1,[R5, #+4]
   2561                return  HAL_ERROR;
   \       0x1C   0xE012             B.N      ??HAL_I2C_Mem_Write_IT_2
   2562              }
   2563          
   2564              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x0408             LSLS     R0,R1,#+16
   \       0x24   0xD41B             BMI.N    ??HAL_I2C_Mem_Write_IT_0
   2565              {
   2566                return HAL_BUSY;
   2567              }
   2568          
   2569              /* Process Locked */
   2570              __HAL_LOCK(hi2c);
   \       0x26   0x7829             LDRB     R1,[R5, #+0]
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0xD018             BEQ.N    ??HAL_I2C_Mem_Write_IT_0
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x7028             STRB     R0,[R5, #+0]
   2571          
   2572              /* Init tickstart for timeout management*/
   2573              tickstart = HAL_GetTick();
   \       0x30   0x....'....        BL       HAL_GetTick
   2574          
   2575              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x34   0x2121             MOVS     R1,#+33
   \       0x36   0x....'....        BL       ?Subroutine9
   2576              hi2c->Mode        = HAL_I2C_MODE_MEM;
   2577              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2578          
   2579              /* Prepare transfer parameters */
   2580              hi2c->pBuffPtr    = pData;
   2581              hi2c->XferCount   = Size;
   2582              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2583              hi2c->XferISR     = I2C_Master_ISR_IT;
   2584          
   2585              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2586              {
   2587                hi2c->XferSize = MAX_NBYTE_SIZE;
   2588                xfermode = I2C_RELOAD_MODE;
   2589              }
   2590              else
   2591              {
   2592                hi2c->XferSize = hi2c->XferCount;
   2593                xfermode = I2C_AUTOEND_MODE;
   2594              }
   2595          
   2596              /* Send Slave Address and Memory Address */
   2597              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x3A   0x....'....        BL       I2C_RequestMemoryWrite
   \       0x3E   0xB118             CBZ.N    R0,??HAL_I2C_Mem_Write_IT_3
   2598              {
   2599                /* Process Unlocked */
   2600                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7028             STRB     R0,[R5, #+0]
   2601                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE00B             B.N      ??HAL_I2C_Mem_Write_IT_4
   2602              }
   2603          
   2604              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2605              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x....'....        BL       ?Subroutine76
   2606          
   2607              /* Process Unlocked */
   2608              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_170: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x7028             STRB     R0,[R5, #+0]
   2609          
   2610              /* Note : The I2C interrupts must be enabled after unlocking current process
   2611                        to avoid the risk of I2C interrupt handle execution before current
   2612                        process unlock */
   2613          
   2614              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   2615              /* possible to enable all of these */
   2616              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2617              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x4638             MOV      R0,R7
   \       0x56   0x....'....        BL       I2C_Enable_IRQ
   2618          
   2619              return HAL_OK;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_4
   2620            }
   2621            else
   2622            {
   2623              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \       0x5E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \       0x60   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2624            }
   2625          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine76: (+1)
   \        0x0   0x9100             STR      R1,[SP, #+0]
   \        0x2   0x4623             MOV      R3,R4
   \        0x4   0x8D3A             LDRH     R2,[R7, #+40]
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x4641             MOV      R1,R8
   \        0xA   0x4638             MOV      R0,R7
   \        0xC   0x....'....        B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine68: (+1)
   \        0x0   0x4607             MOV      R7,R0
   \        0x2   0xF107 0x0540      ADD      R5,R7,#+64
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0x4691             MOV      R9,R2
   \        0xE   0x469A             MOV      R10,R3
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x7069             STRB     R1,[R5, #+1]
   \        0x2   0x2240             MOVS     R2,#+64
   \        0x4   0x70AA             STRB     R2,[R5, #+2]
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6069             STR      R1,[R5, #+4]
   \        0xA   0x627C             STR      R4,[R7, #+36]
   \        0xC   0x857E             STRH     R6,[R7, #+42]
   \        0xE   0x....'....        LDR.W    R1,??DataTable22  ;; 0xffff0000
   \       0x12   0x....'....        ADR.W    R2,I2C_Master_ISR_IT
   \       0x16   0x62F9             STR      R1,[R7, #+44]
   \       0x18   0x637A             STR      R2,[R7, #+52]
   \       0x1A   0x8D79             LDRH     R1,[R7, #+42]
   \       0x1C   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x20   0xD304             BCC.N    ??Subroutine9_0
   \       0x22   0x22FF             MOVS     R2,#+255
   \       0x24   0x853A             STRH     R2,[R7, #+40]
   \       0x26   0xF04F 0x7480      MOV      R4,#+16777216
   \       0x2A   0xE003             B.N      ??Subroutine9_1
   \                     ??Subroutine9_0: (+1)
   \       0x2C   0x8D79             LDRH     R1,[R7, #+42]
   \       0x2E   0x8539             STRH     R1,[R7, #+40]
   \       0x30   0xF04F 0x7400      MOV      R4,#+33554432
   \                     ??Subroutine9_1: (+1)
   \       0x34   0x9001             STR      R0,[SP, #+4]
   \       0x36   0x4653             MOV      R3,R10
   \       0x38   0x2019             MOVS     R0,#+25
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x464A             MOV      R2,R9
   \       0x3E   0x4641             MOV      R1,R8
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x4770             BX       LR
   2626          
   2627          /**
   2628            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2629            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2630            *                the configuration information for the specified I2C.
   2631            * @param  DevAddress Target device address: The device 7 bits address value
   2632            *         in datasheet must be shifted to the left before calling the interface
   2633            * @param  MemAddress Internal memory address
   2634            * @param  MemAddSize Size of internal memory address
   2635            * @param  pData Pointer to data buffer
   2636            * @param  Size Amount of data to be sent
   2637            * @retval HAL status
   2638            */

   \                                 In section .text, align 2, keep-with-next
   2639          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2640          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x....'....        BL       ?Subroutine68
   2641            uint32_t tickstart;
   2642            uint32_t xfermode;
   2643          
   2644            /* Check the parameters */
   2645            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2646          
   2647            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_147: (+1)
   \        0x8   0xD12A             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2648            {
   2649              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9E0B             LDRNE    R6,[SP, #+44]
   \       0x12   0x2E00             CMPNE    R6,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Read_IT_1
   2650              {
   2651                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6069             STR      R1,[R5, #+4]
   2652                return  HAL_ERROR;
   \       0x1C   0xE012             B.N      ??HAL_I2C_Mem_Read_IT_2
   2653              }
   2654          
   2655              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x0408             LSLS     R0,R1,#+16
   \       0x24   0xD41C             BMI.N    ??HAL_I2C_Mem_Read_IT_0
   2656              {
   2657                return HAL_BUSY;
   2658              }
   2659          
   2660              /* Process Locked */
   2661              __HAL_LOCK(hi2c);
   \       0x26   0x7829             LDRB     R1,[R5, #+0]
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0xD019             BEQ.N    ??HAL_I2C_Mem_Read_IT_0
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x7028             STRB     R0,[R5, #+0]
   2662          
   2663              /* Init tickstart for timeout management*/
   2664              tickstart = HAL_GetTick();
   \       0x30   0x....'....        BL       HAL_GetTick
   2665          
   2666              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x34   0x2122             MOVS     R1,#+34
   \       0x36   0x....'....        BL       ?Subroutine9
   2667              hi2c->Mode        = HAL_I2C_MODE_MEM;
   2668              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2669          
   2670              /* Prepare transfer parameters */
   2671              hi2c->pBuffPtr    = pData;
   2672              hi2c->XferCount   = Size;
   2673              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2674              hi2c->XferISR     = I2C_Master_ISR_IT;
   2675          
   2676              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2677              {
   2678                hi2c->XferSize = MAX_NBYTE_SIZE;
   2679                xfermode = I2C_RELOAD_MODE;
   2680              }
   2681              else
   2682              {
   2683                hi2c->XferSize = hi2c->XferCount;
   2684                xfermode = I2C_AUTOEND_MODE;
   2685              }
   2686          
   2687              /* Send Slave Address and Memory Address */
   2688              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x3A   0x....'....        BL       I2C_RequestMemoryRead
   \       0x3E   0xB118             CBZ.N    R0,??HAL_I2C_Mem_Read_IT_3
   2689              {
   2690                /* Process Unlocked */
   2691                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7028             STRB     R0,[R5, #+0]
   2692                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE00C             B.N      ??HAL_I2C_Mem_Read_IT_4
   2693              }
   2694          
   2695              /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2696              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \       0x48   0x....'....        LDR.W    R1,??DataTable24_1  ;; 0x80002400
   \       0x4C   0x....'....        BL       ?Subroutine76
   2697          
   2698              /* Process Unlocked */
   2699              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_169: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x7028             STRB     R0,[R5, #+0]
   2700          
   2701              /* Note : The I2C interrupts must be enabled after unlocking current process
   2702                        to avoid the risk of I2C interrupt handle execution before current
   2703                        process unlock */
   2704          
   2705              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   2706              /* possible to enable all of these */
   2707              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2708              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x54   0x2102             MOVS     R1,#+2
   \       0x56   0x4638             MOV      R0,R7
   \       0x58   0x....'....        BL       I2C_Enable_IRQ
   2709          
   2710              return HAL_OK;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_4
   2711            }
   2712            else
   2713            {
   2714              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \       0x60   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \       0x62   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2715            }
   2716          }
   2717          /**
   2718            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2719            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2720            *                the configuration information for the specified I2C.
   2721            * @param  DevAddress Target device address: The device 7 bits address value
   2722            *         in datasheet must be shifted to the left before calling the interface
   2723            * @param  MemAddress Internal memory address
   2724            * @param  MemAddSize Size of internal memory address
   2725            * @param  pData Pointer to data buffer
   2726            * @param  Size Amount of data to be sent
   2727            * @retval HAL status
   2728            */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine71: (+1)
   \        0x0   0x9000             STR      R0,[SP, #+0]
   \        0x2   0x462B             MOV      R3,R5
   \        0x4   0x8D32             LDRH     R2,[R6, #+40]
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8                      REQUIRE ??Subroutine101_0
   \        0x8                      ;; // Fall through to label ??Subroutine101_0

   \                                 In section .text, align 2, keep-with-next
   2729          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2730          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x....'....        BL       ?Subroutine65
   2731            uint32_t tickstart;
   2732            uint32_t xfermode;
   2733            HAL_StatusTypeDef dmaxferstatus;
   2734          
   2735            /* Check the parameters */
   2736            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2737          
   2738            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_139: (+1)
   \        0x8   0xD145             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2739            {
   2740              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9D0B             LDRNE    R5,[SP, #+44]
   \       0x12   0x2D00             CMPNE    R5,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Write_DMA_1
   2741              {
   2742                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6079             STR      R1,[R7, #+4]
   2743                return  HAL_ERROR;
   \       0x1C   0xE039             B.N      ??HAL_I2C_Mem_Write_DMA_2
   2744              }
   2745          
   2746              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x0408             LSLS     R0,R1,#+16
   \       0x24   0xD437             BMI.N    ??HAL_I2C_Mem_Write_DMA_0
   2747              {
   2748                return HAL_BUSY;
   2749              }
   2750          
   2751              /* Process Locked */
   2752              __HAL_LOCK(hi2c);
   \       0x26   0x7839             LDRB     R1,[R7, #+0]
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0xD034             BEQ.N    ??HAL_I2C_Mem_Write_DMA_0
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x7038             STRB     R0,[R7, #+0]
   2753          
   2754              /* Init tickstart for timeout management*/
   2755              tickstart = HAL_GetTick();
   \       0x30   0x....'....        BL       HAL_GetTick
   2756          
   2757              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x34   0x2121             MOVS     R1,#+33
   \       0x36   0x....'....        BL       ?Subroutine10
   2758              hi2c->Mode        = HAL_I2C_MODE_MEM;
   2759              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2760          
   2761              /* Prepare transfer parameters */
   2762              hi2c->pBuffPtr    = pData;
   2763              hi2c->XferCount   = Size;
   2764              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2765              hi2c->XferISR     = I2C_Master_ISR_DMA;
   2766          
   2767              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2768              {
   2769                hi2c->XferSize = MAX_NBYTE_SIZE;
   2770                xfermode = I2C_RELOAD_MODE;
   2771              }
   2772              else
   2773              {
   2774                hi2c->XferSize = hi2c->XferCount;
   2775                xfermode = I2C_AUTOEND_MODE;
   2776              }
   2777          
   2778              /* Send Slave Address and Memory Address */
   2779              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x3A   0x....'....        BL       I2C_RequestMemoryWrite
   \       0x3E   0xB110             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_3
   2780              {
   2781                /* Process Unlocked */
   2782                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7038             STRB     R0,[R7, #+0]
   2783                return HAL_ERROR;
   \       0x44   0xE025             B.N      ??HAL_I2C_Mem_Write_DMA_2
   2784              }
   2785          
   2786          
   2787              if (hi2c->hdmatx != NULL)
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \       0x46   0x6BB0             LDR      R0,[R6, #+56]
   \       0x48   0xB1E0             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_4
   2788              {
   2789                /* Set the I2C DMA transfer complete callback */
   2790                hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \       0x4A   0x....'....        LDR.W    R1,??DataTable23_2
   \       0x4E   0x6281             STR      R1,[R0, #+40]
   2791          
   2792                /* Set the DMA error callback */
   2793                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x50   0x....'....        LDR.W    R0,??DataTable23_3
   \       0x54   0x6BB1             LDR      R1,[R6, #+56]
   \       0x56   0x6308             STR      R0,[R1, #+48]
   2794          
   2795                /* Set the unused DMA callbacks to NULL */
   2796                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6BB1             LDR      R1,[R6, #+56]
   \       0x5C   0x62C8             STR      R0,[R1, #+44]
   2797                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x5E   0x6BB1             LDR      R1,[R6, #+56]
   \       0x60   0x6348             STR      R0,[R1, #+52]
   2798          
   2799                /* Enable the DMA channel */
   2800                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   2801              }
   2802              else
   2803              {
   2804                /* Update I2C state */
   2805                hi2c->State     = HAL_I2C_STATE_READY;
   2806                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2807          
   2808                /* Update I2C error code */
   2809                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2810          
   2811                /* Process Unlocked */
   2812                __HAL_UNLOCK(hi2c);
   2813          
   2814                return HAL_ERROR;
   2815              }
   2816          
   2817              if (dmaxferstatus == HAL_OK)
   \       0x62   0x4621             MOV      R1,R4
   \       0x64   0x6830             LDR      R0,[R6, #+0]
   \       0x66   0x8D33             LDRH     R3,[R6, #+40]
   \       0x68   0xF100 0x0228      ADD      R2,R0,#+40
   \       0x6C   0x6BB0             LDR      R0,[R6, #+56]
   \       0x6E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x72   0xB950             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_5
   2818              {
   2819                /* Send Slave Address */
   2820                /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2821                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
   \       0x74   0x....'....        BL       ?Subroutine71
   2822          
   2823                /* Update XferCount value */
   2824                hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_254: (+1)
   \       0x78   0x....'....        BL       ?Subroutine16
   2825          
   2826                /* Process Unlocked */
   2827                __HAL_UNLOCK(hi2c);
   2828          
   2829                /* Note : The I2C interrupts must be enabled after unlocking current process
   2830                          to avoid the risk of I2C interrupt handle execution before current
   2831                          process unlock */
   2832                /* Enable ERR and NACK interrupts */
   2833                I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   2834          
   2835                /* Enable DMA Request */
   2836                hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x7C   0x6830             LDR      R0,[R6, #+0]
   \       0x7E   0x....'....        BL       ?Subroutine42
   2837              }
   2838              else
   2839              {
   2840                /* Update I2C state */
   2841                hi2c->State     = HAL_I2C_STATE_READY;
   2842                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2843          
   2844                /* Update I2C error code */
   2845                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2846          
   2847                /* Process Unlocked */
   2848                __HAL_UNLOCK(hi2c);
   2849          
   2850                return HAL_ERROR;
   2851              }
   2852          
   2853              return HAL_OK;
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x82   0xE009             B.N      ??HAL_I2C_Mem_Write_DMA_6
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \       0x84   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x88   0xE001             B.N      ??CrossCallReturnLabel_30
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine22
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x8E   0x6078             STR      R0,[R7, #+4]
   \       0x90   0x7039             STRB     R1,[R7, #+0]
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_6
   2854            }
   2855            else
   2856            {
   2857              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \       0x96   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \       0x98   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2858            }
   2859          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine65: (+1)
   \        0x0   0x4606             MOV      R6,R0
   \        0x2   0xF106 0x0740      ADD      R7,R6,#+64
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x7878             LDRB     R0,[R7, #+1]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0x4691             MOV      R9,R2
   \        0xE   0x469A             MOV      R10,R3
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7078             STRB     R0,[R7, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B9             STRB     R1,[R7, #+2]
   \        0x8   0x6878             LDR      R0,[R7, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7078             STRB     R0,[R7, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B9             STRB     R1,[R7, #+2]
   \        0x8   0x6878             LDR      R0,[R7, #+4]
   \        0xA   0xF040 0x0080      ORR      R0,R0,#0x80
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x8D71             LDRH     R1,[R6, #+42]
   \        0x2   0x8D30             LDRH     R0,[R6, #+40]
   \        0x4   0x1A09             SUBS     R1,R1,R0
   \        0x6   0x8571             STRH     R1,[R6, #+42]
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x7039             STRB     R1,[R7, #+0]
   \        0xE   0x2111             MOVS     R1,#+17
   \       0x10   0x....'....        B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x7079             STRB     R1,[R7, #+1]
   \        0x2   0x2240             MOVS     R2,#+64
   \        0x4   0x70BA             STRB     R2,[R7, #+2]
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6079             STR      R1,[R7, #+4]
   \        0xA   0x6274             STR      R4,[R6, #+36]
   \        0xC   0x8575             STRH     R5,[R6, #+42]
   \        0xE   0x....             LDR.N    R1,??DataTable22  ;; 0xffff0000
   \       0x10   0x....'....        ADR.W    R2,I2C_Master_ISR_DMA
   \       0x14   0x62F1             STR      R1,[R6, #+44]
   \       0x16   0x6372             STR      R2,[R6, #+52]
   \       0x18   0x8D71             LDRH     R1,[R6, #+42]
   \       0x1A   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x1E   0xD304             BCC.N    ??Subroutine10_0
   \       0x20   0x22FF             MOVS     R2,#+255
   \       0x22   0x8532             STRH     R2,[R6, #+40]
   \       0x24   0xF04F 0x7580      MOV      R5,#+16777216
   \       0x28   0xE003             B.N      ??Subroutine10_1
   \                     ??Subroutine10_0: (+1)
   \       0x2A   0x8D71             LDRH     R1,[R6, #+42]
   \       0x2C   0x8531             STRH     R1,[R6, #+40]
   \       0x2E   0xF04F 0x7500      MOV      R5,#+33554432
   \                     ??Subroutine10_1: (+1)
   \       0x32   0x9001             STR      R0,[SP, #+4]
   \       0x34   0x4653             MOV      R3,R10
   \       0x36   0x2019             MOVS     R0,#+25
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x464A             MOV      R2,R9
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x4630             MOV      R0,R6
   \       0x40   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine42: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   2860          
   2861          /**
   2862            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   2863            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2864            *                the configuration information for the specified I2C.
   2865            * @param  DevAddress Target device address: The device 7 bits address value
   2866            *         in datasheet must be shifted to the left before calling the interface
   2867            * @param  MemAddress Internal memory address
   2868            * @param  MemAddSize Size of internal memory address
   2869            * @param  pData Pointer to data buffer
   2870            * @param  Size Amount of data to be read
   2871            * @retval HAL status
   2872            */

   \                                 In section .text, align 2, keep-with-next
   2873          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2874          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x....'....        BL       ?Subroutine65
   2875            uint32_t tickstart;
   2876            uint32_t xfermode;
   2877            HAL_StatusTypeDef dmaxferstatus;
   2878          
   2879            /* Check the parameters */
   2880            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2881          
   2882            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_140: (+1)
   \        0x8   0xD147             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   \        0xA   0x9C0A             LDR      R4,[SP, #+40]
   2883            {
   2884              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xBF1C             ITT      NE
   \       0x10   0x9D0B             LDRNE    R5,[SP, #+44]
   \       0x12   0x2D00             CMPNE    R5,#+0
   \       0x14   0xD103             BNE.N    ??HAL_I2C_Mem_Read_DMA_1
   2885              {
   2886                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x16   0xF44F 0x7100      MOV      R1,#+512
   \       0x1A   0x6079             STR      R1,[R7, #+4]
   2887                return  HAL_ERROR;
   \       0x1C   0xE03B             B.N      ??HAL_I2C_Mem_Read_DMA_2
   2888              }
   2889          
   2890              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \       0x1E   0x6830             LDR      R0,[R6, #+0]
   \       0x20   0x6981             LDR      R1,[R0, #+24]
   \       0x22   0x0408             LSLS     R0,R1,#+16
   \       0x24   0xD439             BMI.N    ??HAL_I2C_Mem_Read_DMA_0
   2891              {
   2892                return HAL_BUSY;
   2893              }
   2894          
   2895              /* Process Locked */
   2896              __HAL_LOCK(hi2c);
   \       0x26   0x7839             LDRB     R1,[R7, #+0]
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0xD036             BEQ.N    ??HAL_I2C_Mem_Read_DMA_0
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x7038             STRB     R0,[R7, #+0]
   2897          
   2898              /* Init tickstart for timeout management*/
   2899              tickstart = HAL_GetTick();
   \       0x30   0x....'....        BL       HAL_GetTick
   2900          
   2901              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x34   0x2122             MOVS     R1,#+34
   \       0x36   0x....'....        BL       ?Subroutine10
   2902              hi2c->Mode        = HAL_I2C_MODE_MEM;
   2903              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   2904          
   2905              /* Prepare transfer parameters */
   2906              hi2c->pBuffPtr    = pData;
   2907              hi2c->XferCount   = Size;
   2908              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   2909              hi2c->XferISR     = I2C_Master_ISR_DMA;
   2910          
   2911              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   2912              {
   2913                hi2c->XferSize = MAX_NBYTE_SIZE;
   2914                xfermode = I2C_RELOAD_MODE;
   2915              }
   2916              else
   2917              {
   2918                hi2c->XferSize = hi2c->XferCount;
   2919                xfermode = I2C_AUTOEND_MODE;
   2920              }
   2921          
   2922              /* Send Slave Address and Memory Address */
   2923              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x3A   0x....'....        BL       I2C_RequestMemoryRead
   \       0x3E   0xB110             CBZ.N    R0,??HAL_I2C_Mem_Read_DMA_3
   2924              {
   2925                /* Process Unlocked */
   2926                __HAL_UNLOCK(hi2c);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7038             STRB     R0,[R7, #+0]
   2927                return HAL_ERROR;
   \       0x44   0xE027             B.N      ??HAL_I2C_Mem_Read_DMA_2
   2928              }
   2929          
   2930              if (hi2c->hdmarx != NULL)
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \       0x46   0x6BF0             LDR      R0,[R6, #+60]
   \       0x48   0xB1F0             CBZ.N    R0,??HAL_I2C_Mem_Read_DMA_4
   2931              {
   2932                /* Set the I2C DMA transfer complete callback */
   2933                hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \       0x4A   0x....'....        LDR.W    R1,??DataTable24
   \       0x4E   0x6281             STR      R1,[R0, #+40]
   2934          
   2935                /* Set the DMA error callback */
   2936                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   2937          
   2938                /* Set the unused DMA callbacks to NULL */
   2939                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   2940                hi2c->hdmarx->XferAbortCallback = NULL;
   2941          
   2942                /* Enable the DMA channel */
   2943                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   2944              }
   2945              else
   2946              {
   2947                /* Update I2C state */
   2948                hi2c->State     = HAL_I2C_STATE_READY;
   2949                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2950          
   2951                /* Update I2C error code */
   2952                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   2953          
   2954                /* Process Unlocked */
   2955                __HAL_UNLOCK(hi2c);
   2956          
   2957                return HAL_ERROR;
   2958              }
   2959          
   2960              if (dmaxferstatus == HAL_OK)
   \       0x50   0x4622             MOV      R2,R4
   \       0x52   0x6BF1             LDR      R1,[R6, #+60]
   \       0x54   0x....'....        LDR.W    R0,??DataTable23_3
   \       0x58   0x6308             STR      R0,[R1, #+48]
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6BF1             LDR      R1,[R6, #+60]
   \       0x5E   0x62C8             STR      R0,[R1, #+44]
   \       0x60   0x6BF1             LDR      R1,[R6, #+60]
   \       0x62   0x6348             STR      R0,[R1, #+52]
   \       0x64   0x6830             LDR      R0,[R6, #+0]
   \       0x66   0x8D33             LDRH     R3,[R6, #+40]
   \       0x68   0xF100 0x0124      ADD      R1,R0,#+36
   \       0x6C   0x6BF0             LDR      R0,[R6, #+60]
   \       0x6E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x72   0xB960             CBNZ.N   R0,??HAL_I2C_Mem_Read_DMA_5
   2961              {
   2962                /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
   2963                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
   \       0x74   0x....'....        LDR.W    R0,??DataTable24_1  ;; 0x80002400
   \       0x78   0x....'....        BL       ?Subroutine71
   2964          
   2965                /* Update XferCount value */
   2966                hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_253: (+1)
   \       0x7C   0x....'....        BL       ?Subroutine16
   2967          
   2968                /* Process Unlocked */
   2969                __HAL_UNLOCK(hi2c);
   2970          
   2971                /* Note : The I2C interrupts must be enabled after unlocking current process
   2972                          to avoid the risk of I2C interrupt handle execution before current
   2973                          process unlock */
   2974                /* Enable ERR and NACK interrupts */
   2975                I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   2976          
   2977                /* Enable DMA Request */
   2978                hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x80   0x6830             LDR      R0,[R6, #+0]
   \       0x82   0x....'....        BL       ?Subroutine44
   2979              }
   2980              else
   2981              {
   2982                /* Update I2C state */
   2983                hi2c->State     = HAL_I2C_STATE_READY;
   2984                hi2c->Mode      = HAL_I2C_MODE_NONE;
   2985          
   2986                /* Update I2C error code */
   2987                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   2988          
   2989                /* Process Unlocked */
   2990                __HAL_UNLOCK(hi2c);
   2991          
   2992                return HAL_ERROR;
   2993              }
   2994          
   2995              return HAL_OK;
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x86   0xE009             B.N      ??HAL_I2C_Mem_Read_DMA_6
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \       0x88   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x8C   0xE001             B.N      ??CrossCallReturnLabel_31
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \       0x8E   0x....'....        BL       ?Subroutine22
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x92   0x6078             STR      R0,[R7, #+4]
   \       0x94   0x7039             STRB     R1,[R7, #+0]
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_6
   2996            }
   2997            else
   2998            {
   2999              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \       0x9A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \       0x9C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3000            }
   3001          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine44: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
   3002          
   3003          /**
   3004            * @brief  Checks if target device is ready for communication.
   3005            * @note   This function is used with Memory devices
   3006            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3007            *                the configuration information for the specified I2C.
   3008            * @param  DevAddress Target device address: The device 7 bits address value
   3009            *         in datasheet must be shifted to the left before calling the interface
   3010            * @param  Trials Number of trials
   3011            * @param  Timeout Timeout duration
   3012            * @retval HAL status
   3013            */

   \                                 In section .text, align 2, keep-with-next
   3014          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   3015          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   3016            uint32_t tickstart;
   3017          
   3018            __IO uint32_t I2C_Trials = 0UL;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9001             STR      R0,[SP, #+4]
   3019          
   3020            FlagStatus tmp1;
   3021            FlagStatus tmp2;
   3022          
   3023            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0xA   0xF105 0x0640      ADD      R6,R5,#+64
   \        0xE   0x7870             LDRB     R0,[R6, #+1]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0xD177             BNE.N    ??HAL_I2C_IsDeviceReady_0
   3024            {
   3025              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \       0x14   0x682C             LDR      R4,[R5, #+0]
   \       0x16   0x69A0             LDR      R0,[R4, #+24]
   \       0x18   0x0404             LSLS     R4,R0,#+16
   \       0x1A   0xD473             BMI.N    ??HAL_I2C_IsDeviceReady_0
   3026              {
   3027                return HAL_BUSY;
   3028              }
   3029          
   3030              /* Process Locked */
   3031              __HAL_LOCK(hi2c);
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD070             BEQ.N    ??HAL_I2C_IsDeviceReady_0
   \       0x22   0x2401             MOVS     R4,#+1
   \       0x24   0x7034             STRB     R4,[R6, #+0]
   3032          
   3033              hi2c->State = HAL_I2C_STATE_BUSY;
   \       0x26   0x2024             MOVS     R0,#+36
   \       0x28   0x7070             STRB     R0,[R6, #+1]
   3034              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x2A   0xF3C1 0x0909      UBFX     R9,R1,#+0,#+10
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6070             STR      R0,[R6, #+4]
   \       0x32   0x4690             MOV      R8,R2
   \       0x34   0x461C             MOV      R4,R3
   3035          
   3036              do
   3037              {
   3038                /* Generate Start */
   3039                hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \       0x36   0x68E8             LDR      R0,[R5, #+12]
   \       0x38   0x6829             LDR      R1,[R5, #+0]
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xBF06             ITTE     EQ
   \       0x3E   0xF049 0x7000      ORREQ    R0,R9,#0x2000000
   \       0x42   0xF440 0x5000      ORREQ    R0,R0,#0x2000
   \       0x46   0xF449 0x5020      ORRNE    R0,R9,#0x2800
   \       0x4A   0x6048             STR      R0,[R1, #+4]
   3040          
   3041                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3042                /* Wait until STOPF flag is set or a NACK flag is set*/
   3043                tickstart = HAL_GetTick();
   \       0x4C   0x....'....        BL       HAL_GetTick
   \       0x50   0x4607             MOV      R7,R0
   3044          
   3045                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
   3046                tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   3047          
   3048                while ((tmp1 == RESET) && (tmp2 == RESET))
   3049                {
   3050                  if (Timeout != HAL_MAX_DELAY)
   3051                  {
   3052                    if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   3053                    {
   3054                      /* Update I2C state */
   3055                      hi2c->State = HAL_I2C_STATE_READY;
   3056          
   3057                      /* Update I2C error code */
   3058                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3059          
   3060                      /* Process Unlocked */
   3061                      __HAL_UNLOCK(hi2c);
   3062          
   3063                      return HAL_ERROR;
   3064                    }
   3065                  }
   3066          
   3067                  tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x6988             LDR      R0,[R1, #+24]
   3068                  tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \       0x56   0x6989             LDR      R1,[R1, #+24]
   \       0x58   0x0940             LSRS     R0,R0,#+5
   \       0x5A   0x0909             LSRS     R1,R1,#+4
   \       0x5C   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x60   0xF001 0x0101      AND      R1,R1,#0x1
   \       0x64   0x4308             ORRS     R0,R1,R0
   \       0x66   0xD112             BNE.N    ??HAL_I2C_IsDeviceReady_3
   \       0x68   0xF114 0x0F01      CMN      R4,#+1
   \       0x6C   0xD0F1             BEQ.N    ??HAL_I2C_IsDeviceReady_2
   \       0x6E   0x....'....        BL       HAL_GetTick
   \       0x72   0x1BC0             SUBS     R0,R0,R7
   \       0x74   0x4284             CMP      R4,R0
   \       0x76   0xD301             BCC.N    ??HAL_I2C_IsDeviceReady_4
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD1EA             BNE.N    ??HAL_I2C_IsDeviceReady_2
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \       0x7C   0x2020             MOVS     R0,#+32
   \       0x7E   0x7070             STRB     R0,[R6, #+1]
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6871             LDR      R1,[R6, #+4]
   \       0x84   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x88   0x6071             STR      R1,[R6, #+4]
   \       0x8A   0x7030             STRB     R0,[R6, #+0]
   \       0x8C   0xE038             B.N      ??HAL_I2C_IsDeviceReady_5
   3069                }
   3070          
   3071                /* Check if the NACKF flag has not been set */
   3072                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \       0x8E   0x6829             LDR      R1,[R5, #+0]
   \       0x90   0x6988             LDR      R0,[R1, #+24]
   \       0x92   0x9700             STR      R7,[SP, #+0]
   \       0x94   0x06C1             LSLS     R1,R0,#+27
   \       0x96   0x4623             MOV      R3,R4
   \       0x98   0xD528             BPL.N    ??HAL_I2C_IsDeviceReady_6
   3073                {
   3074                  /* Wait until STOPF flag is reset */
   3075                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
   3076                  {
   3077                    return HAL_ERROR;
   3078                  }
   3079          
   3080                  /* Clear STOP Flag */
   3081                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3082          
   3083                  /* Device is ready */
   3084                  hi2c->State = HAL_I2C_STATE_READY;
   3085          
   3086                  /* Process Unlocked */
   3087                  __HAL_UNLOCK(hi2c);
   3088          
   3089                  return HAL_OK;
   3090                }
   3091                else
   3092                {
   3093                  /* Wait until STOPF flag is reset */
   3094                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
   \       0x9A   0x....'....        BL       ?Subroutine66
   \                     ??CrossCallReturnLabel_143: (+1)
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD12E             BNE.N    ??HAL_I2C_IsDeviceReady_5
   3095                  {
   3096                    return HAL_ERROR;
   3097                  }
   3098          
   3099                  /* Clear NACK Flag */
   3100                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0xA2   0x6829             LDR      R1,[R5, #+0]
   \       0xA4   0x2010             MOVS     R0,#+16
   \       0xA6   0x61C8             STR      R0,[R1, #+28]
   3101          
   3102                  /* Clear STOP Flag, auto generated with autoend*/
   3103                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \       0xA8   0x2220             MOVS     R2,#+32
   \       0xAA   0x6828             LDR      R0,[R5, #+0]
   \       0xAC   0x61C2             STR      R2,[R0, #+28]
   3104                }
   3105          
   3106                /* Check if the maximum allowed number of trials has been reached */
   3107                if (I2C_Trials == Trials)
   \       0xAE   0x9901             LDR      R1,[SP, #+4]
   \       0xB0   0x4541             CMP      R1,R8
   \       0xB2   0xD10C             BNE.N    ??HAL_I2C_IsDeviceReady_7
   3108                {
   3109                  /* Generate Stop */
   3110                  hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x6841             LDR      R1,[R0, #+4]
   \       0xB8   0xF441 0x4180      ORR      R1,R1,#0x4000
   \       0xBC   0x6041             STR      R1,[R0, #+4]
   3111          
   3112                  /* Wait until STOPF flag is reset */
   3113                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
   \       0xBE   0x9700             STR      R7,[SP, #+0]
   \       0xC0   0x4623             MOV      R3,R4
   \       0xC2   0x....'....        BL       ?Subroutine66
   \                     ??CrossCallReturnLabel_142: (+1)
   \       0xC6   0xB9D8             CBNZ.N   R0,??HAL_I2C_IsDeviceReady_5
   3114                  {
   3115                    return HAL_ERROR;
   3116                  }
   3117          
   3118                  /* Clear STOP Flag */
   3119                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \       0xC8   0x6829             LDR      R1,[R5, #+0]
   \       0xCA   0x2020             MOVS     R0,#+32
   \       0xCC   0x61C8             STR      R0,[R1, #+28]
   3120                }
   3121          
   3122                /* Increment Trials */
   3123                I2C_Trials++;
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \       0xCE   0x9801             LDR      R0,[SP, #+4]
   \       0xD0   0x1C40             ADDS     R0,R0,#+1
   \       0xD2   0x9001             STR      R0,[SP, #+4]
   3124              }
   3125              while (I2C_Trials < Trials);
   \       0xD4   0x9801             LDR      R0,[SP, #+4]
   \       0xD6   0x4540             CMP      R0,R8
   \       0xD8   0xD3AD             BCC.N    ??HAL_I2C_IsDeviceReady_1
   3126          
   3127              /* Update I2C state */
   3128              hi2c->State = HAL_I2C_STATE_READY;
   \       0xDA   0x2120             MOVS     R1,#+32
   \       0xDC   0x7071             STRB     R1,[R6, #+1]
   3129          
   3130              /* Update I2C error code */
   3131              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3132          
   3133              /* Process Unlocked */
   3134              __HAL_UNLOCK(hi2c);
   \       0xDE   0x2100             MOVS     R1,#+0
   \       0xE0   0x6870             LDR      R0,[R6, #+4]
   \       0xE2   0xF040 0x0020      ORR      R0,R0,#0x20
   \       0xE6   0x6070             STR      R0,[R6, #+4]
   \       0xE8   0x7031             STRB     R1,[R6, #+0]
   3135          
   3136              return HAL_ERROR;
   \       0xEA   0xE009             B.N      ??HAL_I2C_IsDeviceReady_5
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \       0xEC   0x....'....        BL       ?Subroutine66
   \                     ??CrossCallReturnLabel_141: (+1)
   \       0xF0   0xB930             CBNZ.N   R0,??HAL_I2C_IsDeviceReady_5
   \       0xF2   0x6829             LDR      R1,[R5, #+0]
   \       0xF4   0x2020             MOVS     R0,#+32
   \       0xF6   0x61C8             STR      R0,[R1, #+28]
   \       0xF8   0x7070             STRB     R0,[R6, #+1]
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x7030             STRB     R0,[R6, #+0]
   \       0xFE   0xE002             B.N      ??HAL_I2C_IsDeviceReady_8
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \      0x100   0x2001             MOVS     R0,#+1
   \      0x102   0xE000             B.N      ??HAL_I2C_IsDeviceReady_8
   3137            }
   3138            else
   3139            {
   3140              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \      0x104   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \      0x106   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   3141            }
   3142          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine66: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x....'....        B.W      I2C_WaitOnFlagUntilTimeout
   3143          
   3144          /**
   3145            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.
   3146            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3147            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3148            *                the configuration information for the specified I2C.
   3149            * @param  DevAddress Target device address: The device 7 bits address value
   3150            *         in datasheet must be shifted to the left before calling the interface
   3151            * @param  pData Pointer to data buffer
   3152            * @param  Size Amount of data to be sent
   3153            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3154            * @retval HAL status
   3155            */

   \                                 In section .text, align 2, keep-with-next
   3156          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3157          {
   \                     HAL_I2C_Master_Seq_Transmit_IT: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine87
   3158            uint32_t xfermode;
   3159            uint32_t xferrequest = I2C_GENERATE_START_WRITE;
   3160          
   3161            /* Check the parameters */
   3162            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3163          
   3164            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_200: (+1)
   \        0x8   0x....             LDR.N    R6,??DataTable23_4  ;; 0x80002000
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD121             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   3165            {
   3166              /* Process Locked */
   3167              __HAL_LOCK(hi2c);
   \        0xE   0x7839             LDRB     R1,[R7, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD01E             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   \       0x14   0x9808             LDR      R0,[SP, #+32]
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x7039             STRB     R1,[R7, #+0]
   3168          
   3169              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x1A   0x2121             MOVS     R1,#+33
   \       0x1C   0x....'....        BL       ?Subroutine12
   3170              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3171              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3172          
   3173              /* Prepare transfer parameters */
   3174              hi2c->pBuffPtr    = pData;
   3175              hi2c->XferCount   = Size;
   3176              hi2c->XferOptions = XferOptions;
   3177              hi2c->XferISR     = I2C_Master_ISR_IT;
   3178          
   3179              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3180              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   3181              {
   3182                hi2c->XferSize = MAX_NBYTE_SIZE;
   3183                xfermode = I2C_RELOAD_MODE;
   3184              }
   3185              else
   3186              {
   3187                hi2c->XferSize = hi2c->XferCount;
   3188                xfermode = hi2c->XferOptions;
   3189              }
   3190          
   3191              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3192              /* Mean Previous state is same as current state */
   3193              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x20   0x2911             CMP      R1,#+17
   \       0x22   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_1
   \       0x24   0x28AA             CMP      R0,#+170
   \       0x26   0xBF1C             ITT      NE
   \       0x28   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x2C   0x2600             MOVNE    R6,#+0
   3194              {
   3195                xferrequest = I2C_NO_STARTSTOP;
   \       0x2E   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_2
   3196              }
   3197              else
   3198              {
   3199                /* Convert OTHER_xxx XferOptions if any */
   3200                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_1: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       I2C_ConvertOtherXferOptions
   3201          
   3202                /* Update xfermode accordingly if no reload is necessary */
   3203                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x36   0x8D60             LDRH     R0,[R4, #+42]
   \       0x38   0x28FF             CMP      R0,#+255
   \       0x3A   0xBF38             IT       CC
   \       0x3C   0x6AE5             LDRCC    R5,[R4, #+44]
   3204                {
   3205                  xfermode = hi2c->XferOptions;
   3206                }
   3207              }
   3208          
   3209              /* Send Slave Address and set NBYTES to write */
   3210              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_2: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine91
   \                     ??CrossCallReturnLabel_211: (+1)
   \       0x42   0x....'....        BL       ??Subroutine100_1
   3211          
   3212              /* Process Unlocked */
   3213              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_241: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x7038             STRB     R0,[R7, #+0]
   3214          
   3215              /* Note : The I2C interrupts must be enabled after unlocking current process
   3216                        to avoid the risk of I2C interrupt handle execution before current
   3217                        process unlock */
   3218              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x4A   0x....'....        BL       ??Subroutine31_0
   3219          
   3220              return HAL_OK;
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_3
   3221            }
   3222            else
   3223            {
   3224              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_0: (+1)
   \       0x52   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_3: (+1)
   \       0x54   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3225            }
   3226          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine91: (+1)
   \        0x0   0x9600             STR      R6,[SP, #+0]
   \        0x2   0x462B             MOV      R3,R5
   \        0x4   0x8D22             LDRH     R2,[R4, #+40]
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x4641             MOV      R1,R8
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine87: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF104 0x0740      ADD      R7,R4,#+64
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x7878             LDRB     R0,[R7, #+1]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x7079             STRB     R1,[R7, #+1]
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x70B9             STRB     R1,[R7, #+2]
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6079             STR      R1,[R7, #+4]
   \        0xA   0x6262             STR      R2,[R4, #+36]
   \        0xC   0x8563             STRH     R3,[R4, #+42]
   \        0xE   0x62E0             STR      R0,[R4, #+44]
   \       0x10   0x....'....        ADR.W    R1,I2C_Master_ISR_IT
   \       0x14   0x6361             STR      R1,[R4, #+52]
   \       0x16   0x8D62             LDRH     R2,[R4, #+42]
   \       0x18   0x2AFF             CMP      R2,#+255
   \       0x1A   0xD904             BLS.N    ??Subroutine12_0
   \       0x1C   0x21FF             MOVS     R1,#+255
   \       0x1E   0x8521             STRH     R1,[R4, #+40]
   \       0x20   0xF04F 0x7580      MOV      R5,#+16777216
   \       0x24   0xE002             B.N      ??Subroutine12_1
   \                     ??Subroutine12_0: (+1)
   \       0x26   0x8D61             LDRH     R1,[R4, #+42]
   \       0x28   0x8521             STRH     R1,[R4, #+40]
   \       0x2A   0x6AE5             LDR      R5,[R4, #+44]
   \                     ??Subroutine12_1: (+1)
   \       0x2C   0x6B21             LDR      R1,[R4, #+48]
   \       0x2E   0x4770             BX       LR
   3227          
   3228          /**
   3229            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.
   3230            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3231            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3232            *                the configuration information for the specified I2C.
   3233            * @param  DevAddress Target device address: The device 7 bits address value
   3234            *         in datasheet must be shifted to the left before calling the interface
   3235            * @param  pData Pointer to data buffer
   3236            * @param  Size Amount of data to be sent
   3237            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3238            * @retval HAL status
   3239            */

   \                                 In section .text, align 2, keep-with-next
   3240          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3241          {
   \                     HAL_I2C_Master_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   3242            uint32_t xfermode;
   3243            uint32_t xferrequest = I2C_GENERATE_START_WRITE;
   3244            HAL_StatusTypeDef dmaxferstatus;
   3245          
   3246            /* Check the parameters */
   3247            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3248          
   3249            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x6   0xF105 0x0440      ADD      R4,R5,#+64
   \        0xA   0x....'....        LDR.W    R10,??DataTable23_4  ;; 0x80002000
   \        0xE   0x7860             LDRB     R0,[R4, #+1]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0x4689             MOV      R9,R1
   \       0x14   0x4657             MOV      R7,R10
   \       0x16   0xD13B             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   3250            {
   3251              /* Process Locked */
   3252              __HAL_LOCK(hi2c);
   \       0x18   0x7821             LDRB     R1,[R4, #+0]
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xD038             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   \       0x1E   0x980A             LDR      R0,[SP, #+40]
   \       0x20   0x4690             MOV      R8,R2
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x7021             STRB     R1,[R4, #+0]
   3253          
   3254              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x26   0x2221             MOVS     R2,#+33
   \       0x28   0x....'....        BL       ?Subroutine11
   3255              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3256              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3257          
   3258              /* Prepare transfer parameters */
   3259              hi2c->pBuffPtr    = pData;
   3260              hi2c->XferCount   = Size;
   3261              hi2c->XferOptions = XferOptions;
   3262              hi2c->XferISR     = I2C_Master_ISR_DMA;
   3263          
   3264              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3265              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   3266              {
   3267                hi2c->XferSize = MAX_NBYTE_SIZE;
   3268                xfermode = I2C_RELOAD_MODE;
   3269              }
   3270              else
   3271              {
   3272                hi2c->XferSize = hi2c->XferCount;
   3273                xfermode = hi2c->XferOptions;
   3274              }
   3275          
   3276              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3277              /* Mean Previous state is same as current state */
   3278              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x2C   0x2911             CMP      R1,#+17
   \       0x2E   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_1
   \       0x30   0x28AA             CMP      R0,#+170
   \       0x32   0xBF1C             ITT      NE
   \       0x34   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x38   0x2700             MOVNE    R7,#+0
   3279              {
   3280                xferrequest = I2C_NO_STARTSTOP;
   \       0x3A   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_2
   3281              }
   3282              else
   3283              {
   3284                /* Convert OTHER_xxx XferOptions if any */
   3285                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_1: (+1)
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x....'....        BL       I2C_ConvertOtherXferOptions
   3286          
   3287                /* Update xfermode accordingly if no reload is necessary */
   3288                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x42   0x8D68             LDRH     R0,[R5, #+42]
   \       0x44   0x28FF             CMP      R0,#+255
   \       0x46   0xBF38             IT       CC
   \       0x48   0x6AEE             LDRCC    R6,[R5, #+44]
   3289                {
   3290                  xfermode = hi2c->XferOptions;
   3291                }
   3292              }
   3293          
   3294              if (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_2: (+1)
   \       0x4A   0x8D28             LDRH     R0,[R5, #+40]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD019             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_3
   3295              {
   3296                if (hi2c->hdmatx != NULL)
   \       0x50   0x6BA8             LDR      R0,[R5, #+56]
   \       0x52   0xB170             CBZ.N    R0,??HAL_I2C_Master_Seq_Transmit_DMA_4
   3297                {
   3298                  /* Set the I2C DMA transfer complete callback */
   3299                  hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \       0x54   0x....             LDR.N    R1,??DataTable23_2
   \       0x56   0x....'....        BL       ?Subroutine62
   3300          
   3301                  /* Set the DMA error callback */
   3302                  hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   3303          
   3304                  /* Set the unused DMA callbacks to NULL */
   3305                  hi2c->hdmatx->XferHalfCpltCallback = NULL;
   3306                  hi2c->hdmatx->XferAbortCallback = NULL;
   3307          
   3308                  /* Enable the DMA channel */
   3309                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   3310                }
   3311                else
   3312                {
   3313                  /* Update I2C state */
   3314                  hi2c->State     = HAL_I2C_STATE_READY;
   3315                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3316          
   3317                  /* Update I2C error code */
   3318                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   3319          
   3320                  /* Process Unlocked */
   3321                  __HAL_UNLOCK(hi2c);
   3322          
   3323                  return HAL_ERROR;
   3324                }
   3325          
   3326                if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_133: (+1)
   \       0x5A   0x4641             MOV      R1,R8
   \       0x5C   0x....'....        BL       ?Subroutine92
   \                     ??CrossCallReturnLabel_214: (+1)
   \       0x60   0xB950             CBNZ.N   R0,??HAL_I2C_Master_Seq_Transmit_DMA_5
   3327                {
   3328                  /* Send Slave Address and set NBYTES to write */
   3329                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \       0x62   0x....'....        BL       ?Subroutine77
   3330          
   3331                  /* Update XferCount value */
   3332                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_172: (+1)
   \       0x66   0x....'....        BL       ?Subroutine17
   3333          
   3334                  /* Process Unlocked */
   3335                  __HAL_UNLOCK(hi2c);
   3336          
   3337                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3338                            to avoid the risk of I2C interrupt handle execution before current
   3339                            process unlock */
   3340                  /* Enable ERR and NACK interrupts */
   3341                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   3342          
   3343                  /* Enable DMA Request */
   3344                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x....'....        BL       ?Subroutine43
   3345                }
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x70   0xE00C             B.N      ??CrossCallReturnLabel_126
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_4: (+1)
   \       0x72   0x....'....        BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x76   0xE001             B.N      ??CrossCallReturnLabel_34
   3346                else
   3347                {
   3348                  /* Update I2C state */
   3349                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_5: (+1)
   \       0x78   0x....'....        BL       ?Subroutine24
   3350                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3351          
   3352                  /* Update I2C error code */
   3353                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x7C   0x6060             STR      R0,[R4, #+4]
   3354          
   3355                  /* Process Unlocked */
   3356                  __HAL_UNLOCK(hi2c);
   \       0x7E   0x7021             STRB     R1,[R4, #+0]
   3357          
   3358                  return HAL_ERROR;
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE006             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_6
   3359                }
   3360              }
   3361              else
   3362              {
   3363                /* Update Transfer ISR function pointer */
   3364                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_3: (+1)
   \       0x84   0x....'....        BL       ?Subroutine73
   3365          
   3366                /* Send Slave Address */
   3367                /* Set NBYTES to write and generate START condition */
   3368                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   3369          
   3370                /* Process Unlocked */
   3371                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_162: (+1)
   \       0x88   0x....'....        BL       ?Subroutine59
   3372          
   3373                /* Note : The I2C interrupts must be enabled after unlocking current process
   3374                          to avoid the risk of I2C interrupt handle execution before current
   3375                          process unlock */
   3376                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   3377                /* possible to enable all of these */
   3378                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   3379                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   3380              }
   3381          
   3382              return HAL_OK;
   \                     ??CrossCallReturnLabel_126: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_6
   3383            }
   3384            else
   3385            {
   3386              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_0: (+1)
   \       0x90   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_6: (+1)
   \       0x92   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3387            }
   3388          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine77: (+1)
   \        0x0   0x9700             STR      R7,[SP, #+0]
   \        0x2   0x4633             MOV      R3,R6
   \        0x4   0x8D2A             LDRH     R2,[R5, #+40]
   \        0x6   0xB2D2             UXTB     R2,R2
   \        0x8   0x4649             MOV      R1,R9
   \        0xA   0x4628             MOV      R0,R5
   \        0xC   0x....'....        B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine73: (+1)
   \        0x0   0x....'....        ADR.W    R0,I2C_Master_ISR_IT
   \        0x4   0x6368             STR      R0,[R5, #+52]
   \        0x6   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \        0xA   0xF04F 0x7300      MOV      R3,#+33554432
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x4649             MOV      R1,R9
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x....'....        B.W      I2C_TransferConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine59: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7020             STRB     R0,[R4, #+0]
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....'....        B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A1             STRB     R1,[R4, #+2]
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x7060             STRB     R0,[R4, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70A1             STRB     R1,[R4, #+2]
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0xF040 0x0080      ORR      R0,R0,#0x80
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x8D69             LDRH     R1,[R5, #+42]
   \        0x2   0x8D28             LDRH     R0,[R5, #+40]
   \        0x4   0x1A09             SUBS     R1,R1,R0
   \        0x6   0x8569             STRH     R1,[R5, #+42]
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x7021             STRB     R1,[R4, #+0]
   \        0xE   0x2111             MOVS     R1,#+17
   \       0x10   0x....'....        B.W      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x7062             STRB     R2,[R4, #+1]
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x70A1             STRB     R1,[R4, #+2]
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6061             STR      R1,[R4, #+4]
   \        0xA   0xF8C5 0x8024      STR      R8,[R5, #+36]
   \        0xE   0x856B             STRH     R3,[R5, #+42]
   \       0x10   0x62E8             STR      R0,[R5, #+44]
   \       0x12   0x....'....        ADR.W    R1,I2C_Master_ISR_DMA
   \       0x16   0x6369             STR      R1,[R5, #+52]
   \       0x18   0x8D6A             LDRH     R2,[R5, #+42]
   \       0x1A   0x2AFF             CMP      R2,#+255
   \       0x1C   0xD904             BLS.N    ??Subroutine11_0
   \       0x1E   0x21FF             MOVS     R1,#+255
   \       0x20   0x8529             STRH     R1,[R5, #+40]
   \       0x22   0xF04F 0x7680      MOV      R6,#+16777216
   \       0x26   0xE002             B.N      ??Subroutine11_1
   \                     ??Subroutine11_0: (+1)
   \       0x28   0x8D69             LDRH     R1,[R5, #+42]
   \       0x2A   0x8529             STRH     R1,[R5, #+40]
   \       0x2C   0x6AEE             LDR      R6,[R5, #+44]
   \                     ??Subroutine11_1: (+1)
   \       0x2E   0x6B29             LDR      R1,[R5, #+48]
   \       0x30   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine62: (+1)
   \        0x0   0x6281             STR      R1,[R0, #+40]
   \        0x2   0x....'....        LDR.W    R0,??DataTable31
   \        0x6   0x6BA9             LDR      R1,[R5, #+56]
   \        0x8   0x6308             STR      R0,[R1, #+48]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x6BA9             LDR      R1,[R5, #+56]
   \        0xE   0x62C8             STR      R0,[R1, #+44]
   \       0x10   0x6BA9             LDR      R1,[R5, #+56]
   \       0x12   0x6348             STR      R0,[R1, #+52]
   \       0x14   0x4770             BX       LR
   3389          
   3390          /**
   3391            * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt
   3392            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3393            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3394            *                the configuration information for the specified I2C.
   3395            * @param  DevAddress Target device address: The device 7 bits address value
   3396            *         in datasheet must be shifted to the left before calling the interface
   3397            * @param  pData Pointer to data buffer
   3398            * @param  Size Amount of data to be sent
   3399            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3400            * @retval HAL status
   3401            */

   \                                 In section .text, align 2, keep-with-next
   3402          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3403          {
   \                     HAL_I2C_Master_Seq_Receive_IT: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine87
   3404            uint32_t xfermode;
   3405            uint32_t xferrequest = I2C_GENERATE_START_READ;
   3406          
   3407            /* Check the parameters */
   3408            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3409          
   3410            if (hi2c->State == HAL_I2C_STATE_READY)
   \                     ??CrossCallReturnLabel_201: (+1)
   \        0x8   0x....             LDR.N    R6,??DataTable24_1  ;; 0x80002400
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD122             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_0
   3411            {
   3412              /* Process Locked */
   3413              __HAL_LOCK(hi2c);
   \        0xE   0x7839             LDRB     R1,[R7, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD01F             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_0
   \       0x14   0x9808             LDR      R0,[SP, #+32]
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x7039             STRB     R1,[R7, #+0]
   3414          
   3415              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x1A   0x2122             MOVS     R1,#+34
   \       0x1C   0x....'....        BL       ?Subroutine12
   3416              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3417              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3418          
   3419              /* Prepare transfer parameters */
   3420              hi2c->pBuffPtr    = pData;
   3421              hi2c->XferCount   = Size;
   3422              hi2c->XferOptions = XferOptions;
   3423              hi2c->XferISR     = I2C_Master_ISR_IT;
   3424          
   3425              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3426              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   3427              {
   3428                hi2c->XferSize = MAX_NBYTE_SIZE;
   3429                xfermode = I2C_RELOAD_MODE;
   3430              }
   3431              else
   3432              {
   3433                hi2c->XferSize = hi2c->XferCount;
   3434                xfermode = hi2c->XferOptions;
   3435              }
   3436          
   3437              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3438              /* Mean Previous state is same as current state */
   3439              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x20   0x2912             CMP      R1,#+18
   \       0x22   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_1
   \       0x24   0x28AA             CMP      R0,#+170
   \       0x26   0xBF1C             ITT      NE
   \       0x28   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x2C   0x2600             MOVNE    R6,#+0
   3440              {
   3441                xferrequest = I2C_NO_STARTSTOP;
   \       0x2E   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_2
   3442              }
   3443              else
   3444              {
   3445                /* Convert OTHER_xxx XferOptions if any */
   3446                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_1: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       I2C_ConvertOtherXferOptions
   3447          
   3448                /* Update xfermode accordingly if no reload is necessary */
   3449                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x36   0x8D60             LDRH     R0,[R4, #+42]
   \       0x38   0x28FF             CMP      R0,#+255
   \       0x3A   0xBF38             IT       CC
   \       0x3C   0x6AE5             LDRCC    R5,[R4, #+44]
   3450                {
   3451                  xfermode = hi2c->XferOptions;
   3452                }
   3453              }
   3454          
   3455              /* Send Slave Address and set NBYTES to read */
   3456              I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_2: (+1)
   \       0x3E   0x....'....        BL       ?Subroutine91
   \                     ??CrossCallReturnLabel_212: (+1)
   \       0x42   0x....'....        BL       ??Subroutine100_1
   3457          
   3458              /* Process Unlocked */
   3459              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_240: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x7038             STRB     R0,[R7, #+0]
   3460          
   3461              /* Note : The I2C interrupts must be enabled after unlocking current process
   3462                        to avoid the risk of I2C interrupt handle execution before current
   3463                        process unlock */
   3464              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x4A   0x2102             MOVS     R1,#+2
   \       0x4C   0x....'....        BL       ??Subroutine31_1
   3465          
   3466              return HAL_OK;
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_IT_3
   3467            }
   3468            else
   3469            {
   3470              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_IT_0: (+1)
   \       0x54   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_IT_3: (+1)
   \       0x56   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3471            }
   3472          }
   3473          
   3474          /**
   3475            * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with DMA
   3476            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3477            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3478            *                the configuration information for the specified I2C.
   3479            * @param  DevAddress Target device address: The device 7 bits address value
   3480            *         in datasheet must be shifted to the left before calling the interface
   3481            * @param  pData Pointer to data buffer
   3482            * @param  Size Amount of data to be sent
   3483            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3484            * @retval HAL status
   3485            */

   \                                 In section .text, align 2, keep-with-next
   3486          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3487          {
   \                     HAL_I2C_Master_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   3488            uint32_t xfermode;
   3489            uint32_t xferrequest = I2C_GENERATE_START_READ;
   3490            HAL_StatusTypeDef dmaxferstatus;
   3491          
   3492            /* Check the parameters */
   3493            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3494          
   3495            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x6   0xF105 0x0440      ADD      R4,R5,#+64
   \        0xA   0x....'....        LDR.W    R10,??DataTable24_1  ;; 0x80002400
   \        0xE   0x7860             LDRB     R0,[R4, #+1]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0x4689             MOV      R9,R1
   \       0x14   0x4657             MOV      R7,R10
   \       0x16   0xD13C             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_0
   3496            {
   3497              /* Process Locked */
   3498              __HAL_LOCK(hi2c);
   \       0x18   0x7821             LDRB     R1,[R4, #+0]
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xD039             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_0
   \       0x1E   0x980A             LDR      R0,[SP, #+40]
   \       0x20   0x4690             MOV      R8,R2
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x7021             STRB     R1,[R4, #+0]
   3499          
   3500              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x26   0x2222             MOVS     R2,#+34
   \       0x28   0x....'....        BL       ?Subroutine11
   3501              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   3502              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3503          
   3504              /* Prepare transfer parameters */
   3505              hi2c->pBuffPtr    = pData;
   3506              hi2c->XferCount   = Size;
   3507              hi2c->XferOptions = XferOptions;
   3508              hi2c->XferISR     = I2C_Master_ISR_DMA;
   3509          
   3510              /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
   3511              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   3512              {
   3513                hi2c->XferSize = MAX_NBYTE_SIZE;
   3514                xfermode = I2C_RELOAD_MODE;
   3515              }
   3516              else
   3517              {
   3518                hi2c->XferSize = hi2c->XferCount;
   3519                xfermode = hi2c->XferOptions;
   3520              }
   3521          
   3522              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3523              /* Mean Previous state is same as current state */
   3524              if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x2C   0x2912             CMP      R1,#+18
   \       0x2E   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_1
   \       0x30   0x28AA             CMP      R0,#+170
   \       0x32   0xBF1C             ITT      NE
   \       0x34   0xF5B0 0x4F2A      CMPNE    R0,#+43520
   \       0x38   0x2700             MOVNE    R7,#+0
   3525              {
   3526                xferrequest = I2C_NO_STARTSTOP;
   \       0x3A   0xD106             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_2
   3527              }
   3528              else
   3529              {
   3530                /* Convert OTHER_xxx XferOptions if any */
   3531                I2C_ConvertOtherXferOptions(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_1: (+1)
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x....'....        BL       I2C_ConvertOtherXferOptions
   3532          
   3533                /* Update xfermode accordingly if no reload is necessary */
   3534                if (hi2c->XferCount < MAX_NBYTE_SIZE)
   \       0x42   0x8D68             LDRH     R0,[R5, #+42]
   \       0x44   0x28FF             CMP      R0,#+255
   \       0x46   0xBF38             IT       CC
   \       0x48   0x6AEE             LDRCC    R6,[R5, #+44]
   3535                {
   3536                  xfermode = hi2c->XferOptions;
   3537                }
   3538              }
   3539          
   3540              if (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_2: (+1)
   \       0x4A   0x8D28             LDRH     R0,[R5, #+40]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD01A             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_3
   3541              {
   3542                if (hi2c->hdmarx != NULL)
   \       0x50   0x6BE8             LDR      R0,[R5, #+60]
   \       0x52   0xB178             CBZ.N    R0,??HAL_I2C_Master_Seq_Receive_DMA_4
   3543                {
   3544                  /* Set the I2C DMA transfer complete callback */
   3545                  hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \       0x54   0x....             LDR.N    R1,??DataTable24
   \       0x56   0x6281             STR      R1,[R0, #+40]
   3546          
   3547                  /* Set the DMA error callback */
   3548                  hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   3549          
   3550                  /* Set the unused DMA callbacks to NULL */
   3551                  hi2c->hdmarx->XferHalfCpltCallback = NULL;
   3552                  hi2c->hdmarx->XferAbortCallback = NULL;
   3553          
   3554                  /* Enable the DMA channel */
   3555                  dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   3556                }
   3557                else
   3558                {
   3559                  /* Update I2C state */
   3560                  hi2c->State     = HAL_I2C_STATE_READY;
   3561                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3562          
   3563                  /* Update I2C error code */
   3564                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   3565          
   3566                  /* Process Unlocked */
   3567                  __HAL_UNLOCK(hi2c);
   3568          
   3569                  return HAL_ERROR;
   3570                }
   3571          
   3572                if (dmaxferstatus == HAL_OK)
   \       0x58   0x4642             MOV      R2,R8
   \       0x5A   0x....'....        BL       ?Subroutine54
   \                     ??CrossCallReturnLabel_114: (+1)
   \       0x5E   0xB960             CBNZ.N   R0,??HAL_I2C_Master_Seq_Receive_DMA_5
   3573                {
   3574                  /* Send Slave Address and set NBYTES to read */
   3575                  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
   \       0x60   0x....'....        BL       ?Subroutine77
   3576          
   3577                  /* Update XferCount value */
   3578                  hi2c->XferCount -= hi2c->XferSize;
   \                     ??CrossCallReturnLabel_171: (+1)
   \       0x64   0x....'....        BL       ?Subroutine17
   3579          
   3580                  /* Process Unlocked */
   3581                  __HAL_UNLOCK(hi2c);
   3582          
   3583                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3584                            to avoid the risk of I2C interrupt handle execution before current
   3585                            process unlock */
   3586                  /* Enable ERR and NACK interrupts */
   3587                  I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
   3588          
   3589                  /* Enable DMA Request */
   3590                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x68   0x6828             LDR      R0,[R5, #+0]
   \       0x6A   0x6801             LDR      R1,[R0, #+0]
   \       0x6C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \       0x70   0x6001             STR      R1,[R0, #+0]
   \       0x72   0xE00C             B.N      ??CrossCallReturnLabel_125
   3591                }
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_4: (+1)
   \       0x74   0x....'....        BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x78   0xE001             B.N      ??CrossCallReturnLabel_35
   3592                else
   3593                {
   3594                  /* Update I2C state */
   3595                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_5: (+1)
   \       0x7A   0x....'....        BL       ?Subroutine24
   3596                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   3597          
   3598                  /* Update I2C error code */
   3599                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x7E   0x6060             STR      R0,[R4, #+4]
   3600          
   3601                  /* Process Unlocked */
   3602                  __HAL_UNLOCK(hi2c);
   \       0x80   0x7021             STRB     R1,[R4, #+0]
   3603          
   3604                  return HAL_ERROR;
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xE006             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_6
   3605                }
   3606              }
   3607              else
   3608              {
   3609                /* Update Transfer ISR function pointer */
   3610                hi2c->XferISR = I2C_Master_ISR_IT;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_3: (+1)
   \       0x86   0x....'....        BL       ?Subroutine73
   3611          
   3612                /* Send Slave Address */
   3613                /* Set NBYTES to read and generate START condition */
   3614                I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   3615          
   3616                /* Process Unlocked */
   3617                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_161: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine59
   3618          
   3619                /* Note : The I2C interrupts must be enabled after unlocking current process
   3620                          to avoid the risk of I2C interrupt handle execution before current
   3621                          process unlock */
   3622                /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   3623                /* possible to enable all of these */
   3624                /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   3625                I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
   3626              }
   3627          
   3628              return HAL_OK;
   \                     ??CrossCallReturnLabel_125: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_6
   3629            }
   3630            else
   3631            {
   3632              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_0: (+1)
   \       0x92   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_6: (+1)
   \       0x94   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3633            }
   3634          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine54: (+1)
   \        0x0   0x6BE9             LDR      R1,[R5, #+60]
   \        0x2   0x....'....        ADR.W    R0,I2C_DMAError
   \        0x6   0x6308             STR      R0,[R1, #+48]
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x6BE9             LDR      R1,[R5, #+60]
   \        0xC   0x62C8             STR      R0,[R1, #+44]
   \        0xE   0x6BE9             LDR      R1,[R5, #+60]
   \       0x10   0x6348             STR      R0,[R1, #+52]
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x16   0xF100 0x0124      ADD      R1,R0,#+36
   \       0x1A   0x6BE8             LDR      R0,[R5, #+60]
   \       0x1C   0x....'....        B.W      HAL_DMA_Start_IT
   3635          
   3636          /**
   3637            * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with Interrupt
   3638            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3639            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3640            *                the configuration information for the specified I2C.
   3641            * @param  pData Pointer to data buffer
   3642            * @param  Size Amount of data to be sent
   3643            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3644            * @retval HAL status
   3645            */

   \                                 In section .text, align 2, keep-with-next
   3646          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3647          {
   \                     HAL_I2C_Slave_Seq_Transmit_IT: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine83
   3648            /* Check the parameters */
   3649            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3650          
   3651            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_185: (+1)
   \        0x8   0xD132             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_0
   3652            {
   3653              if ((pData == NULL) || (Size == 0U))
   \        0xA   0xB10C             CBZ.N    R4,??HAL_I2C_Slave_Seq_Transmit_IT_1
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_2
   3654              {
   3655                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_1: (+1)
   \       0x10   0x....'....        BL       ?Subroutine84
   3656                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_189: (+1)
   \       0x14   0xE02C             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_0
   3657              }
   3658          
   3659              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   3660              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_2: (+1)
   \       0x16   0x....'....        BL       ?Subroutine94
   3661          
   3662              /* Process Locked */
   3663              __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_225: (+1)
   \       0x1A   0x7830             LDRB     R0,[R6, #+0]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xBF08             IT       EQ
   \       0x20   0x2002             MOVEQ    R0,#+2
   \       0x22   0xD026             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_IT_3
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7030             STRB     R0,[R6, #+0]
   3664          
   3665              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   3666              /* and then toggle the HAL slave RX state to TX state */
   3667              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \       0x28   0x7871             LDRB     R1,[R6, #+1]
   \       0x2A   0x292A             CMP      R1,#+42
   \       0x2C   0xD112             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_4
   3668              {
   3669                /* Disable associated Interrupts */
   3670                I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0x....'....        BL       ??Subroutine94_0
   3671          
   3672                /* Abort DMA Xfer if any */
   3673                if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \                     ??CrossCallReturnLabel_223: (+1)
   \       0x34   0x6828             LDR      R0,[R5, #+0]
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0x040A             LSLS     R2,R1,#+16
   \       0x3A   0xD50B             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_IT_4
   3674                {
   3675                  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x3C   0x....'....        BL       ?Subroutine45
   3676          
   3677                  if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x40   0xB140             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_IT_4
   3678                  {
   3679                    /* Set the I2C DMA Abort callback :
   3680                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3681                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x42   0x....'....        LDR.W    R1,??DataTable36
   \       0x46   0x6341             STR      R1,[R0, #+52]
   3682          
   3683                    /* Abort DMA RX */
   3684                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x48   0x....'....        BL       ??Subroutine97_0
   \                     ??CrossCallReturnLabel_231: (+1)
   \       0x4C   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_IT_4
   3685                    {
   3686                      /* Call Directly XferAbortCallback function in case of error */
   3687                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x4E   0x6BE8             LDR      R0,[R5, #+60]
   \       0x50   0x6B41             LDR      R1,[R0, #+52]
   \       0x52   0x4788             BLX      R1
   3688                    }
   3689                  }
   3690                }
   3691              }
   3692          
   3693              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_4: (+1)
   \       0x54   0x2029             MOVS     R0,#+41
   \       0x56   0x....'....        BL       ?Subroutine47
   3694              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   3695              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3696          
   3697              /* Enable Address Acknowledge */
   3698              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   3699          
   3700              /* Prepare transfer parameters */
   3701              hi2c->pBuffPtr    = pData;
   3702              hi2c->XferCount   = Size;
   3703              hi2c->XferSize    = hi2c->XferCount;
   3704              hi2c->XferOptions = XferOptions;
   3705              hi2c->XferISR     = I2C_Slave_ISR_IT;
   3706          
   3707              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
   \                     ??CrossCallReturnLabel_94: (+1)
   \       0x5A   0xBF44             ITT      MI
   \       0x5C   0x2108             MOVMI    R1,#+8
   \       0x5E   0x61C1             STRMI    R1,[R0, #+28]
   3708              {
   3709                /* Clear ADDR flag after prepare the transfer parameters */
   3710                /* This action will generate an acknowledge to the Master */
   3711                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3712              }
   3713          
   3714              /* Process Unlocked */
   3715              __HAL_UNLOCK(hi2c);
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x7030             STRB     R0,[R6, #+0]
   3716          
   3717              /* Note : The I2C interrupts must be enabled after unlocking current process
   3718              to avoid the risk of I2C interrupt handle execution before current
   3719              process unlock */
   3720              /* REnable ADDR interrupt */
   3721              I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
   \       0x64   0x2105             MOVS     R1,#+5
   \       0x66   0x4628             MOV      R0,R5
   \       0x68   0x....'....        BL       I2C_Enable_IRQ
   3722          
   3723              return HAL_OK;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xE000             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_3
   3724            }
   3725            else
   3726            {
   3727              return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_0: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_3: (+1)
   \       0x72   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3728            }
   3729          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine97: (+1)
   \        0x0   0xF8C0 0x9034      STR      R9,[R0, #+52]
   \                     ??Subroutine97_0: (+1)
   \        0x4   0x6BE8             LDR      R0,[R5, #+60]
   \        0x6   0x....'....        B.W      HAL_DMA_Abort_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine94: (+1)
   \        0x0   0x2105             MOVS     R1,#+5
   \                     ??Subroutine94_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....'....        B.W      I2C_Disable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine84: (+1)
   \        0x0   0xF44F 0x7000      MOV      R0,#+512
   \        0x4   0x6070             STR      R0,[R6, #+4]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine83: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0xF105 0x0640      ADD      R6,R5,#+64
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x7870             LDRB     R0,[R6, #+1]
   \        0xA   0xF000 0x0028      AND      R0,R0,#0x28
   \        0xE   0x2828             CMP      R0,#+40
   \       0x10   0x4617             MOV      R7,R2
   \       0x12   0x4698             MOV      R8,R3
   \       0x14   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine47: (+1)
   \        0x0   0x7070             STRB     R0,[R6, #+1]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x70B1             STRB     R1,[R6, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6070             STR      R0,[R6, #+4]
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x6841             LDR      R1,[R0, #+4]
   \        0xE   0xF421 0x4100      BIC      R1,R1,#0x8000
   \       0x12   0x6041             STR      R1,[R0, #+4]
   \       0x14   0x626C             STR      R4,[R5, #+36]
   \       0x16   0x856F             STRH     R7,[R5, #+42]
   \       0x18   0x8D68             LDRH     R0,[R5, #+42]
   \       0x1A   0x....'....        ADR.W    R1,I2C_Slave_ISR_IT
   \       0x1E   0x8528             STRH     R0,[R5, #+40]
   \       0x20   0xF8C5 0x802C      STR      R8,[R5, #+44]
   \       0x24   0x6369             STR      R1,[R5, #+52]
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6981             LDR      R1,[R0, #+24]
   \       0x2A   0x03CA             LSLS     R2,R1,#+15
   \       0x2C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine45: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF421 0x4100      BIC      R1,R1,#0x8000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x6BE8             LDR      R0,[R5, #+60]
   \        0xA   0x4770             BX       LR
   3730          
   3731          /**
   3732            * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with DMA
   3733            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3734            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3735            *                the configuration information for the specified I2C.
   3736            * @param  pData Pointer to data buffer
   3737            * @param  Size Amount of data to be sent
   3738            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3739            * @retval HAL status
   3740            */

   \                                 In section .text, align 2, keep-with-next
   3741          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3742          {
   \                     HAL_I2C_Slave_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine83
   3743            HAL_StatusTypeDef dmaxferstatus;
   3744          
   3745            /* Check the parameters */
   3746            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3747          
   3748            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_186: (+1)
   \        0x8   0xD159             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_0
   3749            {
   3750              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2F00             CMPNE    R7,#+0
   \       0x10   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_1
   3751              {
   3752                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x12   0x....'....        BL       ?Subroutine84
   3753                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_190: (+1)
   \       0x16   0xE052             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_0
   3754              }
   3755          
   3756              /* Process Locked */
   3757              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_1: (+1)
   \       0x18   0x7830             LDRB     R0,[R6, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xBF08             IT       EQ
   \       0x1E   0x2002             MOVEQ    R0,#+2
   \       0x20   0xD04E             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x7030             STRB     R0,[R6, #+0]
   3758          
   3759              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   3760              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
   \       0x26   0x....'....        BL       ?Subroutine94
   3761          
   3762              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   3763              /* and then toggle the HAL slave RX state to TX state */
   3764              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??CrossCallReturnLabel_224: (+1)
   \       0x2A   0x7870             LDRB     R0,[R6, #+1]
   \       0x2C   0x....'....        LDR.W    R9,??DataTable36
   \       0x30   0x282A             CMP      R0,#+42
   \       0x32   0xD112             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   3765              {
   3766                /* Disable associated Interrupts */
   3767                I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x34   0x2102             MOVS     R1,#+2
   \       0x36   0x....'....        BL       ??Subroutine94_0
   3768          
   3769                if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \                     ??CrossCallReturnLabel_222: (+1)
   \       0x3A   0x6829             LDR      R1,[R5, #+0]
   \       0x3C   0x6808             LDR      R0,[R1, #+0]
   \       0x3E   0x0402             LSLS     R2,R0,#+16
   \       0x40   0xD51B             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3770                {
   3771                  /* Abort DMA Xfer if any */
   3772                  if (hi2c->hdmarx != NULL)
   \       0x42   0x6BE8             LDR      R0,[R5, #+60]
   \       0x44   0xB1C8             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3773                  {
   3774                    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x4C   0x600A             STR      R2,[R1, #+0]
   3775          
   3776                    /* Set the I2C DMA Abort callback :
   3777                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3778                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x4E   0x6BE8             LDR      R0,[R5, #+60]
   \       0x50   0x....'....        BL       ?Subroutine97
   3779          
   3780                    /* Abort DMA RX */
   3781                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \                     ??CrossCallReturnLabel_233: (+1)
   \       0x54   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3782                    {
   3783                      /* Call Directly XferAbortCallback function in case of error */
   3784                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x56   0x6BE8             LDR      R0,[R5, #+60]
   \       0x58   0xE00D             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_5
   3785                    }
   3786                  }
   3787                }
   3788              }
   3789              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_3: (+1)
   \       0x5A   0x7870             LDRB     R0,[R6, #+1]
   \       0x5C   0x2829             CMP      R0,#+41
   \       0x5E   0xD10C             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3790              {
   3791                if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \       0x60   0x6828             LDR      R0,[R5, #+0]
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x044A             LSLS     R2,R1,#+17
   \       0x66   0xD508             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3792                {
   3793                  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x68   0x....'....        BL       ?Subroutine46
   3794          
   3795                  /* Abort DMA Xfer if any */
   3796                  if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_92: (+1)
   \       0x6C   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3797                  {
   3798                    /* Set the I2C DMA Abort callback :
   3799                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3800                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x6E   0x....'....        BL       ?Subroutine98
   3801          
   3802                    /* Abort DMA TX */
   3803                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \                     ??CrossCallReturnLabel_236: (+1)
   \       0x72   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_4
   3804                    {
   3805                      /* Call Directly XferAbortCallback function in case of error */
   3806                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x74   0x6BA8             LDR      R0,[R5, #+56]
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_5: (+1)
   \       0x76   0x6B41             LDR      R1,[R0, #+52]
   \       0x78   0x4788             BLX      R1
   3807                    }
   3808                  }
   3809                }
   3810              }
   3811              else
   3812              {
   3813                /* Nothing to do */
   3814              }
   3815          
   3816              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_4: (+1)
   \       0x7A   0x2029             MOVS     R0,#+41
   \       0x7C   0x....'....        BL       ?Subroutine48
   3817              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   3818              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3819          
   3820              /* Enable Address Acknowledge */
   3821              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   3822          
   3823              /* Prepare transfer parameters */
   3824              hi2c->pBuffPtr    = pData;
   3825              hi2c->XferCount   = Size;
   3826              hi2c->XferSize    = hi2c->XferCount;
   3827              hi2c->XferOptions = XferOptions;
   3828              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   3829          
   3830              if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_96: (+1)
   \       0x80   0x6BA8             LDR      R0,[R5, #+56]
   \       0x82   0xB1A8             CBZ.N    R0,??HAL_I2C_Slave_Seq_Transmit_DMA_6
   3831              {
   3832                /* Set the I2C DMA transfer complete callback */
   3833                hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   \       0x84   0x....             LDR.N    R1,??DataTable26
   \       0x86   0x....'....        BL       ?Subroutine62
   3834          
   3835                /* Set the DMA error callback */
   3836                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   3837          
   3838                /* Set the unused DMA callbacks to NULL */
   3839                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   3840                hi2c->hdmatx->XferAbortCallback = NULL;
   3841          
   3842                /* Enable the DMA channel */
   3843                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   3844              }
   3845              else
   3846              {
   3847                /* Update I2C state */
   3848                hi2c->State     = HAL_I2C_STATE_LISTEN;
   3849                hi2c->Mode      = HAL_I2C_MODE_NONE;
   3850          
   3851                /* Update I2C error code */
   3852                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   3853          
   3854                /* Process Unlocked */
   3855                __HAL_UNLOCK(hi2c);
   3856          
   3857                return HAL_ERROR;
   3858              }
   3859          
   3860              if (dmaxferstatus == HAL_OK)
   \                     ??CrossCallReturnLabel_134: (+1)
   \       0x8A   0x4621             MOV      R1,R4
   \       0x8C   0x....'....        BL       ?Subroutine92
   \                     ??CrossCallReturnLabel_213: (+1)
   \       0x90   0xB988             CBNZ.N   R0,??HAL_I2C_Slave_Seq_Transmit_DMA_7
   3861              {
   3862                /* Update XferCount value */
   3863                hi2c->XferCount -= hi2c->XferSize;
   \       0x92   0x....'....        BL       ?Subroutine25
   3864          
   3865                /* Reset XferSize */
   3866                hi2c->XferSize = 0;
   3867              }
   3868              else
   3869              {
   3870                /* Update I2C state */
   3871                hi2c->State     = HAL_I2C_STATE_LISTEN;
   3872                hi2c->Mode      = HAL_I2C_MODE_NONE;
   3873          
   3874                /* Update I2C error code */
   3875                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   3876          
   3877                /* Process Unlocked */
   3878                __HAL_UNLOCK(hi2c);
   3879          
   3880                return HAL_ERROR;
   3881              }
   3882          
   3883              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x96   0xBF44             ITT      MI
   \       0x98   0x2108             MOVMI    R1,#+8
   \       0x9A   0x61C1             STRMI    R1,[R0, #+28]
   3884              {
   3885                /* Clear ADDR flag after prepare the transfer parameters */
   3886                /* This action will generate an acknowledge to the Master */
   3887                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3888              }
   3889          
   3890              /* Process Unlocked */
   3891              __HAL_UNLOCK(hi2c);
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x7030             STRB     R0,[R6, #+0]
   3892          
   3893              /* Note : The I2C interrupts must be enabled after unlocking current process
   3894              to avoid the risk of I2C interrupt handle execution before current
   3895              process unlock */
   3896              /* Enable ERR, STOP, NACK, ADDR interrupts */
   3897              I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \       0xA0   0x2104             MOVS     R1,#+4
   \       0xA2   0x4628             MOV      R0,R5
   \       0xA4   0x....'....        BL       I2C_Enable_IRQ
   3898          
   3899              /* Enable DMA Request */
   3900              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \       0xA8   0x6828             LDR      R0,[R5, #+0]
   \       0xAA   0x....'....        BL       ?Subroutine42
   3901          
   3902              return HAL_OK;
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0xAE   0xE007             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_6: (+1)
   \       0xB0   0x....'....        BL       ?Subroutine26
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0xB4   0xE001             B.N      ??CrossCallReturnLabel_40
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_7: (+1)
   \       0xB6   0x....'....        BL       ?Subroutine27
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0xBA   0x6070             STR      R0,[R6, #+4]
   \       0xBC   0x7031             STRB     R1,[R6, #+0]
   3903            }
   3904            else
   3905            {
   3906              return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_0: (+1)
   \       0xBE   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_2: (+1)
   \       0xC0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   3907            }
   3908          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine98: (+1)
   \        0x0   0xF8C0 0x9034      STR      R9,[R0, #+52]
   \                     ??Subroutine98_0: (+1)
   \        0x4   0x6BA8             LDR      R0,[R5, #+56]
   \        0x6   0x....'....        B.W      HAL_DMA_Abort_IT

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine46: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xF421 0x4180      BIC      R1,R1,#0x4000
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x6BA8             LDR      R0,[R5, #+56]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine48: (+1)
   \        0x0   0x7070             STRB     R0,[R6, #+1]
   \        0x2   0x2120             MOVS     R1,#+32
   \        0x4   0x70B1             STRB     R1,[R6, #+2]
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6070             STR      R0,[R6, #+4]
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x6841             LDR      R1,[R0, #+4]
   \        0xE   0xF421 0x4100      BIC      R1,R1,#0x8000
   \       0x12   0x6041             STR      R1,[R0, #+4]
   \       0x14   0x626C             STR      R4,[R5, #+36]
   \       0x16   0x856F             STRH     R7,[R5, #+42]
   \       0x18   0x8D68             LDRH     R0,[R5, #+42]
   \       0x1A   0x....'....        ADR.W    R1,I2C_Slave_ISR_DMA
   \       0x1E   0x8528             STRH     R0,[R5, #+40]
   \       0x20   0xF8C5 0x802C      STR      R8,[R5, #+44]
   \       0x24   0x6369             STR      R1,[R5, #+52]
   \       0x26   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \        0x0   0x2028             MOVS     R0,#+40
   \        0x2   0x7070             STRB     R0,[R6, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B1             STRB     R1,[R6, #+2]
   \        0x8   0x6870             LDR      R0,[R6, #+4]
   \        0xA   0xF040 0x0010      ORR      R0,R0,#0x10
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \        0x0   0x2028             MOVS     R0,#+40
   \        0x2   0x7070             STRB     R0,[R6, #+1]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x70B1             STRB     R1,[R6, #+2]
   \        0x8   0x6870             LDR      R0,[R6, #+4]
   \        0xA   0xF040 0x0080      ORR      R0,R0,#0x80
   \        0xE   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x8D69             LDRH     R1,[R5, #+42]
   \        0x2   0x8D28             LDRH     R0,[R5, #+40]
   \        0x4   0x1A09             SUBS     R1,R1,R0
   \        0x6   0x8569             STRH     R1,[R5, #+42]
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x8529             STRH     R1,[R5, #+40]
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x6981             LDR      R1,[R0, #+24]
   \       0x10   0x03CA             LSLS     R2,R1,#+15
   \       0x12   0x4770             BX       LR
   3909          
   3910          /**
   3911            * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with Interrupt
   3912            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3913            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3914            *                the configuration information for the specified I2C.
   3915            * @param  pData Pointer to data buffer
   3916            * @param  Size Amount of data to be sent
   3917            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   3918            * @retval HAL status
   3919            */

   \                                 In section .text, align 2, keep-with-next
   3920          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3921          {
   \                     HAL_I2C_Slave_Seq_Receive_IT: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine83
   3922            /* Check the parameters */
   3923            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3924          
   3925            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_187: (+1)
   \        0x8   0xD12F             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_0
   3926            {
   3927              if ((pData == NULL) || (Size == 0U))
   \        0xA   0xB10C             CBZ.N    R4,??HAL_I2C_Slave_Seq_Receive_IT_1
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_2
   3928              {
   3929                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_1: (+1)
   \       0x10   0x....'....        BL       ?Subroutine84
   3930                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_191: (+1)
   \       0x14   0xE029             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_0
   3931              }
   3932          
   3933              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   3934              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_2: (+1)
   \       0x16   0x2106             MOVS     R1,#+6
   \       0x18   0x....'....        BL       ??Subroutine94_0
   3935          
   3936              /* Process Locked */
   3937              __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_221: (+1)
   \       0x1C   0x7830             LDRB     R0,[R6, #+0]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xBF08             IT       EQ
   \       0x22   0x2002             MOVEQ    R0,#+2
   \       0x24   0xD022             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_IT_3
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x7030             STRB     R0,[R6, #+0]
   3938          
   3939              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   3940              /* and then toggle the HAL slave TX state to RX state */
   3941              if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \       0x2A   0x7871             LDRB     R1,[R6, #+1]
   \       0x2C   0x2929             CMP      R1,#+41
   \       0x2E   0xD112             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_4
   3942              {
   3943                /* Disable associated Interrupts */
   3944                I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x30   0x2101             MOVS     R1,#+1
   \       0x32   0x....'....        BL       ??Subroutine94_0
   3945          
   3946                if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \                     ??CrossCallReturnLabel_220: (+1)
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x044A             LSLS     R2,R1,#+17
   \       0x3C   0xD50B             BPL.N    ??HAL_I2C_Slave_Seq_Receive_IT_4
   3947                {
   3948                  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x3E   0x....'....        BL       ?Subroutine46
   3949          
   3950                  /* Abort DMA Xfer if any */
   3951                  if (hi2c->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_93: (+1)
   \       0x42   0xB140             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_IT_4
   3952                  {
   3953                    /* Set the I2C DMA Abort callback :
   3954                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   3955                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x44   0x....'....        LDR.W    R1,??DataTable37
   \       0x48   0x6341             STR      R1,[R0, #+52]
   3956          
   3957                    /* Abort DMA TX */
   3958                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x4A   0x....'....        BL       ??Subroutine98_0
   \                     ??CrossCallReturnLabel_234: (+1)
   \       0x4E   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_IT_4
   3959                    {
   3960                      /* Call Directly XferAbortCallback function in case of error */
   3961                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x50   0x6BA8             LDR      R0,[R5, #+56]
   \       0x52   0x6B41             LDR      R1,[R0, #+52]
   \       0x54   0x4788             BLX      R1
   3962                    }
   3963                  }
   3964                }
   3965              }
   3966          
   3967              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_4: (+1)
   \       0x56   0x202A             MOVS     R0,#+42
   \       0x58   0x....'....        BL       ?Subroutine47
   3968              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   3969              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3970          
   3971              /* Enable Address Acknowledge */
   3972              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   3973          
   3974              /* Prepare transfer parameters */
   3975              hi2c->pBuffPtr    = pData;
   3976              hi2c->XferCount   = Size;
   3977              hi2c->XferSize    = hi2c->XferCount;
   3978              hi2c->XferOptions = XferOptions;
   3979              hi2c->XferISR     = I2C_Slave_ISR_IT;
   3980          
   3981              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
   \                     ??CrossCallReturnLabel_95: (+1)
   \       0x5C   0xBF5C             ITT      PL
   \       0x5E   0x2108             MOVPL    R1,#+8
   \       0x60   0x61C1             STRPL    R1,[R0, #+28]
   3982              {
   3983                /* Clear ADDR flag after prepare the transfer parameters */
   3984                /* This action will generate an acknowledge to the Master */
   3985                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3986              }
   3987          
   3988              /* Process Unlocked */
   3989              __HAL_UNLOCK(hi2c);
   \       0x62   0x....'....        BL       ?Subroutine60
   3990          
   3991              /* Note : The I2C interrupts must be enabled after unlocking current process
   3992              to avoid the risk of I2C interrupt handle execution before current
   3993              process unlock */
   3994              /* REnable ADDR interrupt */
   3995              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
   3996          
   3997              return HAL_OK;
   \                     ??CrossCallReturnLabel_128: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE000             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_3
   3998            }
   3999            else
   4000            {
   4001              return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_0: (+1)
   \       0x6A   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_3: (+1)
   \       0x6C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4002            }
   4003          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine60: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x7030             STRB     R0,[R6, #+0]
   \        0x4   0x2106             MOVS     R1,#+6
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....'....        B.W      I2C_Enable_IRQ
   4004          
   4005          /**
   4006            * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with DMA
   4007            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4008            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4009            *                the configuration information for the specified I2C.
   4010            * @param  pData Pointer to data buffer
   4011            * @param  Size Amount of data to be sent
   4012            * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
   4013            * @retval HAL status
   4014            */

   \                                 In section .text, align 2, keep-with-next
   4015          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4016          {
   \                     HAL_I2C_Slave_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine83
   4017            HAL_StatusTypeDef dmaxferstatus;
   4018          
   4019            /* Check the parameters */
   4020            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4021          
   4022            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_188: (+1)
   \        0x8   0xD156             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_0
   4023            {
   4024              if ((pData == NULL) || (Size == 0U))
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xBF18             IT       NE
   \        0xE   0x2F00             CMPNE    R7,#+0
   \       0x10   0xD102             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_1
   4025              {
   4026                hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
   \       0x12   0x....'....        BL       ?Subroutine84
   4027                return  HAL_ERROR;
   \                     ??CrossCallReturnLabel_192: (+1)
   \       0x16   0xE04F             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_0
   4028              }
   4029          
   4030              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   4031              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_1: (+1)
   \       0x18   0x2106             MOVS     R1,#+6
   \       0x1A   0x....'....        BL       ??Subroutine94_0
   4032          
   4033              /* Process Locked */
   4034              __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_219: (+1)
   \       0x1E   0x7830             LDRB     R0,[R6, #+0]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xBF08             IT       EQ
   \       0x24   0x2002             MOVEQ    R0,#+2
   \       0x26   0xD048             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_2
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x7030             STRB     R0,[R6, #+0]
   4035          
   4036              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   4037              /* and then toggle the HAL slave TX state to RX state */
   4038              if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \       0x2C   0x7871             LDRB     R1,[R6, #+1]
   \       0x2E   0x....'....        LDR.W    R9,??DataTable37
   \       0x32   0x2929             CMP      R1,#+41
   \       0x34   0xD112             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4039              {
   4040                /* Disable associated Interrupts */
   4041                I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x....'....        BL       ??Subroutine94_0
   4042          
   4043                if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \                     ??CrossCallReturnLabel_218: (+1)
   \       0x3C   0x6829             LDR      R1,[R5, #+0]
   \       0x3E   0x6808             LDR      R0,[R1, #+0]
   \       0x40   0x0442             LSLS     R2,R0,#+17
   \       0x42   0xD51B             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_4
   4044                {
   4045                  /* Abort DMA Xfer if any */
   4046                  if (hi2c->hdmatx != NULL)
   \       0x44   0x6BA8             LDR      R0,[R5, #+56]
   \       0x46   0xB1C8             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_4
   4047                  {
   4048                    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x48   0x680A             LDR      R2,[R1, #+0]
   \       0x4A   0xF422 0x4280      BIC      R2,R2,#0x4000
   \       0x4E   0x600A             STR      R2,[R1, #+0]
   4049          
   4050                    /* Set the I2C DMA Abort callback :
   4051                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4052                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x50   0x6BA8             LDR      R0,[R5, #+56]
   \       0x52   0x....'....        BL       ?Subroutine98
   4053          
   4054                    /* Abort DMA TX */
   4055                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \                     ??CrossCallReturnLabel_235: (+1)
   \       0x56   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_4
   4056                    {
   4057                      /* Call Directly XferAbortCallback function in case of error */
   4058                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x58   0x6BA8             LDR      R0,[R5, #+56]
   \       0x5A   0xE00D             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_5
   4059                    }
   4060                  }
   4061                }
   4062              }
   4063              else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_3: (+1)
   \       0x5C   0x7870             LDRB     R0,[R6, #+1]
   \       0x5E   0x282A             CMP      R0,#+42
   \       0x60   0xD10C             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_4
   4064              {
   4065                if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0x040A             LSLS     R2,R1,#+16
   \       0x68   0xD508             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_4
   4066                {
   4067                  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x6A   0x....'....        BL       ?Subroutine45
   4068          
   4069                  /* Abort DMA Xfer if any */
   4070                  if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0x6E   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_4
   4071                  {
   4072                    /* Set the I2C DMA Abort callback :
   4073                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4074                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x70   0x....'....        BL       ?Subroutine97
   4075          
   4076                    /* Abort DMA RX */
   4077                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \                     ??CrossCallReturnLabel_232: (+1)
   \       0x74   0xB110             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_4
   4078                    {
   4079                      /* Call Directly XferAbortCallback function in case of error */
   4080                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x76   0x6BE8             LDR      R0,[R5, #+60]
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_5: (+1)
   \       0x78   0x6B41             LDR      R1,[R0, #+52]
   \       0x7A   0x4788             BLX      R1
   4081                    }
   4082                  }
   4083                }
   4084              }
   4085              else
   4086              {
   4087                /* Nothing to do */
   4088              }
   4089          
   4090              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_4: (+1)
   \       0x7C   0x202A             MOVS     R0,#+42
   \       0x7E   0x....'....        BL       ?Subroutine48
   4091              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   4092              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4093          
   4094              /* Enable Address Acknowledge */
   4095              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   4096          
   4097              /* Prepare transfer parameters */
   4098              hi2c->pBuffPtr    = pData;
   4099              hi2c->XferCount   = Size;
   4100              hi2c->XferSize    = hi2c->XferCount;
   4101              hi2c->XferOptions = XferOptions;
   4102              hi2c->XferISR     = I2C_Slave_ISR_DMA;
   4103          
   4104              if (hi2c->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_97: (+1)
   \       0x82   0x6BE8             LDR      R0,[R5, #+60]
   \       0x84   0xB188             CBZ.N    R0,??HAL_I2C_Slave_Seq_Receive_DMA_6
   4105              {
   4106                /* Set the I2C DMA transfer complete callback */
   4107                hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   \       0x86   0x....'....        ADR.W    R1,I2C_DMASlaveReceiveCplt
   \       0x8A   0x6281             STR      R1,[R0, #+40]
   4108          
   4109                /* Set the DMA error callback */
   4110                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   4111          
   4112                /* Set the unused DMA callbacks to NULL */
   4113                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   4114                hi2c->hdmarx->XferAbortCallback = NULL;
   4115          
   4116                /* Enable the DMA channel */
   4117                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   4118              }
   4119              else
   4120              {
   4121                /* Update I2C state */
   4122                hi2c->State     = HAL_I2C_STATE_LISTEN;
   4123                hi2c->Mode      = HAL_I2C_MODE_NONE;
   4124          
   4125                /* Update I2C error code */
   4126                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
   4127          
   4128                /* Process Unlocked */
   4129                __HAL_UNLOCK(hi2c);
   4130          
   4131                return HAL_ERROR;
   4132              }
   4133          
   4134              if (dmaxferstatus == HAL_OK)
   \       0x8C   0x4622             MOV      R2,R4
   \       0x8E   0x....'....        BL       ?Subroutine54
   \                     ??CrossCallReturnLabel_113: (+1)
   \       0x92   0xB968             CBNZ.N   R0,??HAL_I2C_Slave_Seq_Receive_DMA_7
   4135              {
   4136                /* Update XferCount value */
   4137                hi2c->XferCount -= hi2c->XferSize;
   \       0x94   0x....'....        BL       ?Subroutine25
   4138          
   4139                /* Reset XferSize */
   4140                hi2c->XferSize = 0;
   4141              }
   4142              else
   4143              {
   4144                /* Update I2C state */
   4145                hi2c->State     = HAL_I2C_STATE_LISTEN;
   4146                hi2c->Mode      = HAL_I2C_MODE_NONE;
   4147          
   4148                /* Update I2C error code */
   4149                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   4150          
   4151                /* Process Unlocked */
   4152                __HAL_UNLOCK(hi2c);
   4153          
   4154                return HAL_ERROR;
   4155              }
   4156          
   4157              if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x98   0xBF5C             ITT      PL
   \       0x9A   0x2108             MOVPL    R1,#+8
   \       0x9C   0x61C1             STRPL    R1,[R0, #+28]
   4158              {
   4159                /* Clear ADDR flag after prepare the transfer parameters */
   4160                /* This action will generate an acknowledge to the Master */
   4161                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   4162              }
   4163          
   4164              /* Process Unlocked */
   4165              __HAL_UNLOCK(hi2c);
   \       0x9E   0x....'....        BL       ?Subroutine60
   4166          
   4167              /* Note : The I2C interrupts must be enabled after unlocking current process
   4168              to avoid the risk of I2C interrupt handle execution before current
   4169              process unlock */
   4170              /* REnable ADDR interrupt */
   4171              I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
   4172          
   4173              /* Enable DMA Request */
   4174              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??CrossCallReturnLabel_127: (+1)
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0x....'....        BL       ?Subroutine44
   4175          
   4176              return HAL_OK;
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0xA8   0xE007             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_2
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_6: (+1)
   \       0xAA   0x....'....        BL       ?Subroutine26
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0xAE   0xE001             B.N      ??CrossCallReturnLabel_41
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_7: (+1)
   \       0xB0   0x....'....        BL       ?Subroutine27
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0xB4   0x6070             STR      R0,[R6, #+4]
   \       0xB6   0x7031             STRB     R1,[R6, #+0]
   4177            }
   4178            else
   4179            {
   4180              return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_0: (+1)
   \       0xB8   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_2: (+1)
   \       0xBA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   4181            }
   4182          }
   4183          
   4184          /**
   4185            * @brief  Enable the Address listen mode with Interrupt.
   4186            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4187            *                the configuration information for the specified I2C.
   4188            * @retval HAL status
   4189            */

   \                                 In section .text, align 2, keep-with-next
   4190          HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
   4191          {
   \                     HAL_I2C_EnableListen_IT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4192            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF100 0x0134      ADD      R1,R0,#+52
   \        0x6   0x7B4A             LDRB     R2,[R1, #+13]
   \        0x8   0x2A20             CMP      R2,#+32
   \        0xA   0xD109             BNE.N    ??HAL_I2C_EnableListen_IT_0
   4193            {
   4194              hi2c->State = HAL_I2C_STATE_LISTEN;
   \        0xC   0x2328             MOVS     R3,#+40
   \        0xE   0x734B             STRB     R3,[R1, #+13]
   4195              hi2c->XferISR = I2C_Slave_ISR_IT;
   \       0x10   0x....'....        ADR.W    R2,I2C_Slave_ISR_IT
   \       0x14   0x600A             STR      R2,[R1, #+0]
   4196          
   4197              /* Enable the Address Match interrupt */
   4198              I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \       0x16   0x2104             MOVS     R1,#+4
   \       0x18   0x....'....        BL       I2C_Enable_IRQ
   4199          
   4200              return HAL_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD02             POP      {R1,PC}
   4201            }
   4202            else
   4203            {
   4204              return HAL_BUSY;
   \                     ??HAL_I2C_EnableListen_IT_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xBD02             POP      {R1,PC}          ;; return
   4205            }
   4206          }
   4207          
   4208          /**
   4209            * @brief  Disable the Address listen mode with Interrupt.
   4210            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4211            *                the configuration information for the specified I2C
   4212            * @retval HAL status
   4213            */

   \                                 In section .text, align 2, keep-with-next
   4214          HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
   4215          {
   \                     HAL_I2C_DisableListen_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4216            /* Declaration of tmp to prevent undefined behavior of volatile usage */
   4217            uint32_t tmp;
   4218          
   4219            /* Disable Address listen mode only if a transfer is not ongoing */
   4220            if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \        0x2   0xF100 0x0241      ADD      R2,R0,#+65
   \        0x6   0x7811             LDRB     R1,[R2, #+0]
   \        0x8   0x2928             CMP      R1,#+40
   \        0xA   0xD10F             BNE.N    ??HAL_I2C_DisableListen_IT_0
   4221            {
   4222              tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
   \        0xC   0x7813             LDRB     R3,[R2, #+0]
   4223              hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
   \        0xE   0x7851             LDRB     R1,[R2, #+1]
   \       0x10   0xF003 0x0303      AND      R3,R3,#0x3
   \       0x14   0x430B             ORRS     R3,R1,R3
   \       0x16   0x6303             STR      R3,[R0, #+48]
   4224              hi2c->State = HAL_I2C_STATE_READY;
   4225              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x18   0x2400             MOVS     R4,#+0
   \       0x1A   0x2320             MOVS     R3,#+32
   \       0x1C   0x7013             STRB     R3,[R2, #+0]
   \       0x1E   0x7054             STRB     R4,[R2, #+1]
   4226              hi2c->XferISR = NULL;
   \       0x20   0x6344             STR      R4,[R0, #+52]
   4227          
   4228              /* Disable the Address Match interrupt */
   4229              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \       0x22   0x2104             MOVS     R1,#+4
   \       0x24   0x....'....        BL       I2C_Disable_IRQ
   4230          
   4231              return HAL_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD10             POP      {R4,PC}
   4232            }
   4233            else
   4234            {
   4235              return HAL_BUSY;
   \                     ??HAL_I2C_DisableListen_IT_0: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
   4236            }
   4237          }
   4238          
   4239          /**
   4240            * @brief  Abort a master I2C IT or DMA process communication with Interrupt.
   4241            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4242            *                the configuration information for the specified I2C.
   4243            * @param  DevAddress Target device address: The device 7 bits address value
   4244            *         in datasheet must be shifted to the left before calling the interface
   4245            * @retval HAL status
   4246            */

   \                                 In section .text, align 2, keep-with-next
   4247          HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
   4248          {
   \                     HAL_I2C_Master_Abort_IT: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine86
   4249            if (hi2c->Mode == HAL_I2C_MODE_MASTER)
   \                     ??CrossCallReturnLabel_195: (+1)
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x78A8             LDRB     R0,[R5, #+2]
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xD11C             BNE.N    ??HAL_I2C_Master_Abort_IT_0
   4250            {
   4251              /* Process Locked */
   4252              __HAL_LOCK(hi2c);
   \        0xE   0x7829             LDRB     R1,[R5, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD101             BNE.N    ??HAL_I2C_Master_Abort_IT_1
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??HAL_I2C_Master_Abort_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x7028             STRB     R0,[R5, #+0]
   4253          
   4254              /* Disable Interrupts */
   4255              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x1C   0x....'....        BL       ?Subroutine29
   4256              I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x....'....        BL       ??Subroutine29_0
   4257          
   4258              /* Set State at HAL_I2C_STATE_ABORT */
   4259              hi2c->State = HAL_I2C_STATE_ABORT;
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x26   0x2060             MOVS     R0,#+96
   \       0x28   0x7068             STRB     R0,[R5, #+1]
   4260          
   4261              /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
   4262              /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
   4263              I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
   \       0x2A   0xF04F 0x7300      MOV      R3,#+33554432
   \       0x2E   0x....'....        LDR.W    R1,??DataTable40  ;; 0x80004000
   \       0x32   0x9100             STR      R1,[SP, #+0]
   \       0x34   0x2201             MOVS     R2,#+1
   \       0x36   0x....'....        BL       ??Subroutine100_0
   4264          
   4265              /* Process Unlocked */
   4266              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_242: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x7028             STRB     R0,[R5, #+0]
   4267          
   4268              /* Note : The I2C interrupts must be enabled after unlocking current process
   4269                        to avoid the risk of I2C interrupt handle execution before current
   4270                        process unlock */
   4271              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   \       0x3E   0x2112             MOVS     R1,#+18
   \       0x40   0x....'....        BL       ??Subroutine31_1
   4272          
   4273              return HAL_OK;
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD76             POP      {R1,R2,R4-R6,PC}
   4274            }
   4275            else
   4276            {
   4277              /* Wrong usage of abort function */
   4278              /* This function should be used only in case of abort monitored by master device */
   4279              return HAL_ERROR;
   \                     ??HAL_I2C_Master_Abort_IT_0: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   4280            }
   4281          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine86: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF104 0x0540      ADD      R5,R4,#+64
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \                     ??Subroutine29_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....             B.N      I2C_Disable_IRQ
   4282          
   4283          /**
   4284            * @}
   4285            */
   4286          
   4287          /** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   4288           * @{
   4289           */
   4290          
   4291          /**
   4292            * @brief  This function handles I2C event interrupt request.
   4293            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4294            *                the configuration information for the specified I2C.
   4295            * @retval None
   4296            */

   \                                 In section .text, align 2, keep-with-next
   4297          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   4298          {
   4299            /* Get current IT Flags and IT sources value */
   4300            uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x6991             LDR      R1,[R2, #+24]
   4301            uint32_t itsources = READ_REG(hi2c->Instance->CR1);
   \        0x4   0x6812             LDR      R2,[R2, #+0]
   4302          
   4303            /* I2C events treatment -------------------------------------*/
   4304            if (hi2c->XferISR != NULL)
   \        0x6   0x6B43             LDR      R3,[R0, #+52]
   \        0x8   0x2B00             CMP      R3,#+0
   \        0xA   0xBF18             IT       NE
   4305            {
   4306              hi2c->XferISR(hi2c, itflags, itsources);
   \        0xC   0x4718             BXNE     R3
   4307            }
   4308          }
   \        0xE   0x4770             BX       LR               ;; return
   4309          
   4310          /**
   4311            * @brief  This function handles I2C error interrupt request.
   4312            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4313            *                the configuration information for the specified I2C.
   4314            * @retval None
   4315            */

   \                                 In section .text, align 2, keep-with-next
   4316          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   4317          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   4318            uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x698A             LDR      R2,[R1, #+24]
   4319            uint32_t itsources = READ_REG(hi2c->Instance->CR1);
   \        0x6   0x680B             LDR      R3,[R1, #+0]
   4320            uint32_t tmperror;
   4321          
   4322            /* I2C Bus error interrupt occurred ------------------------------------*/
   4323            if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
   \        0x8   0x05D4             LSLS     R4,R2,#+23
   \        0xA   0xD508             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \        0xC   0x061D             LSLS     R5,R3,#+24
   \        0xE   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   4324            {
   4325              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \       0x10   0x6C44             LDR      R4,[R0, #+68]
   \       0x12   0xF044 0x0401      ORR      R4,R4,#0x1
   \       0x16   0x6444             STR      R4,[R0, #+68]
   4326          
   4327              /* Clear BERR flag */
   4328              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \       0x18   0xF44F 0x7580      MOV      R5,#+256
   \       0x1C   0x61CD             STR      R5,[R1, #+28]
   4329            }
   4330          
   4331            /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
   4332            if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \       0x1E   0x0551             LSLS     R1,R2,#+21
   \       0x20   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \       0x22   0x061C             LSLS     R4,R3,#+24
   \       0x24   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   4333            {
   4334              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \       0x26   0x6C41             LDR      R1,[R0, #+68]
   \       0x28   0xF041 0x0108      ORR      R1,R1,#0x8
   \       0x2C   0x6441             STR      R1,[R0, #+68]
   4335          
   4336              /* Clear OVR flag */
   4337              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \       0x2E   0xF44F 0x6480      MOV      R4,#+1024
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0x61CC             STR      R4,[R1, #+28]
   4338            }
   4339          
   4340            /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
   4341            if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \       0x36   0x0591             LSLS     R1,R2,#+22
   \       0x38   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \       0x3A   0x061A             LSLS     R2,R3,#+24
   \       0x3C   0xD507             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   4342            {
   4343              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \       0x3E   0x6C41             LDR      R1,[R0, #+68]
   \       0x40   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x44   0x6441             STR      R1,[R0, #+68]
   4344          
   4345              /* Clear ARLO flag */
   4346              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \       0x46   0xF44F 0x7200      MOV      R2,#+512
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x61CA             STR      R2,[R1, #+28]
   4347            }
   4348          
   4349            /* Store current volatile hi2c->ErrorCode, misra rule */
   4350            tmperror = hi2c->ErrorCode;
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \       0x4E   0x6C41             LDR      R1,[R0, #+68]
   4351          
   4352            /* Call the Error Callback in case of Error detected */
   4353            if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
   \       0x50   0xF011 0x0F0B      TST      R1,#0xB
   \       0x54   0xD000             BEQ.N    ??HAL_I2C_ER_IRQHandler_3
   4354            {
   4355              I2C_ITError(hi2c, tmperror);
   \       0x56   0x....             B.N      ?Subroutine3
   4356            }
   4357          }
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \       0x58   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \        0x4   0x....             B.N      I2C_ITError
   4358          
   4359          /**
   4360            * @brief  Master Tx Transfer completed callback.
   4361            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4362            *                the configuration information for the specified I2C.
   4363            * @retval None
   4364            */

   \                                 In section .text, align 2
   4365          __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4366          {
   4367            /* Prevent unused argument(s) compilation warning */
   4368            UNUSED(hi2c);
   4369          
   4370            /* NOTE : This function should not be modified, when the callback is needed,
   4371                      the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   4372             */
   4373          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4374          
   4375          /**
   4376            * @brief  Master Rx Transfer completed callback.
   4377            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4378            *                the configuration information for the specified I2C.
   4379            * @retval None
   4380            */

   \                                 In section .text, align 2
   4381          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4382          {
   4383            /* Prevent unused argument(s) compilation warning */
   4384            UNUSED(hi2c);
   4385          
   4386            /* NOTE : This function should not be modified, when the callback is needed,
   4387                      the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   4388             */
   4389          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4390          
   4391          /** @brief  Slave Tx Transfer completed callback.
   4392            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4393            *                the configuration information for the specified I2C.
   4394            * @retval None
   4395            */

   \                                 In section .text, align 2
   4396          __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4397          {
   4398            /* Prevent unused argument(s) compilation warning */
   4399            UNUSED(hi2c);
   4400          
   4401            /* NOTE : This function should not be modified, when the callback is needed,
   4402                      the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   4403             */
   4404          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4405          
   4406          /**
   4407            * @brief  Slave Rx Transfer completed callback.
   4408            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4409            *                the configuration information for the specified I2C.
   4410            * @retval None
   4411            */

   \                                 In section .text, align 2
   4412          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4413          {
   4414            /* Prevent unused argument(s) compilation warning */
   4415            UNUSED(hi2c);
   4416          
   4417            /* NOTE : This function should not be modified, when the callback is needed,
   4418                      the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   4419             */
   4420          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4421          
   4422          /**
   4423            * @brief  Slave Address Match callback.
   4424            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4425            *                the configuration information for the specified I2C.
   4426            * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
   4427            * @param  AddrMatchCode Address Match Code
   4428            * @retval None
   4429            */

   \                                 In section .text, align 2
   4430          __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
   4431          {
   4432            /* Prevent unused argument(s) compilation warning */
   4433            UNUSED(hi2c);
   4434            UNUSED(TransferDirection);
   4435            UNUSED(AddrMatchCode);
   4436          
   4437            /* NOTE : This function should not be modified, when the callback is needed,
   4438                      the HAL_I2C_AddrCallback() could be implemented in the user file
   4439             */
   4440          }
   \                     HAL_I2C_AddrCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4441          
   4442          /**
   4443            * @brief  Listen Complete callback.
   4444            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4445            *                the configuration information for the specified I2C.
   4446            * @retval None
   4447            */

   \                                 In section .text, align 2
   4448          __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
   4449          {
   4450            /* Prevent unused argument(s) compilation warning */
   4451            UNUSED(hi2c);
   4452          
   4453            /* NOTE : This function should not be modified, when the callback is needed,
   4454                      the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   4455             */
   4456          }
   \                     HAL_I2C_ListenCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4457          
   4458          /**
   4459            * @brief  Memory Tx Transfer completed callback.
   4460            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4461            *                the configuration information for the specified I2C.
   4462            * @retval None
   4463            */

   \                                 In section .text, align 2
   4464          __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4465          {
   4466            /* Prevent unused argument(s) compilation warning */
   4467            UNUSED(hi2c);
   4468          
   4469            /* NOTE : This function should not be modified, when the callback is needed,
   4470                      the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   4471             */
   4472          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4473          
   4474          /**
   4475            * @brief  Memory Rx Transfer completed callback.
   4476            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4477            *                the configuration information for the specified I2C.
   4478            * @retval None
   4479            */

   \                                 In section .text, align 2
   4480          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4481          {
   4482            /* Prevent unused argument(s) compilation warning */
   4483            UNUSED(hi2c);
   4484          
   4485            /* NOTE : This function should not be modified, when the callback is needed,
   4486                      the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   4487             */
   4488          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4489          
   4490          /**
   4491            * @brief  I2C error callback.
   4492            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4493            *                the configuration information for the specified I2C.
   4494            * @retval None
   4495            */

   \                                 In section .text, align 2
   4496          __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   4497          {
   4498            /* Prevent unused argument(s) compilation warning */
   4499            UNUSED(hi2c);
   4500          
   4501            /* NOTE : This function should not be modified, when the callback is needed,
   4502                      the HAL_I2C_ErrorCallback could be implemented in the user file
   4503             */
   4504          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4505          
   4506          /**
   4507            * @brief  I2C abort callback.
   4508            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4509            *                the configuration information for the specified I2C.
   4510            * @retval None
   4511            */

   \                                 In section .text, align 2
   4512          __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
   4513          {
   4514            /* Prevent unused argument(s) compilation warning */
   4515            UNUSED(hi2c);
   4516          
   4517            /* NOTE : This function should not be modified, when the callback is needed,
   4518                      the HAL_I2C_AbortCpltCallback could be implemented in the user file
   4519             */
   4520          }
   \                     HAL_I2C_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   4521          
   4522          /**
   4523            * @}
   4524            */
   4525          
   4526          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
   4527           *  @brief   Peripheral State, Mode and Error functions
   4528           *
   4529          @verbatim
   4530           ===============================================================================
   4531                      ##### Peripheral State, Mode and Error functions #####
   4532           ===============================================================================
   4533              [..]
   4534              This subsection permit to get in run-time the status of the peripheral
   4535              and the data flow.
   4536          
   4537          @endverbatim
   4538            * @{
   4539            */
   4540          
   4541          /**
   4542            * @brief  Return the I2C handle state.
   4543            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4544            *                the configuration information for the specified I2C.
   4545            * @retval HAL state
   4546            */

   \                                 In section .text, align 2, keep-with-next
   4547          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   4548          {
   4549            /* Return I2C handle state */
   4550            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \        0x0   0xF890 0x0041      LDRB     R0,[R0, #+65]
   \        0x4   0x4770             BX       LR               ;; return
   4551          }
   4552          
   4553          /**
   4554            * @brief  Returns the I2C Master, Slave, Memory or no mode.
   4555            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4556            *         the configuration information for I2C module
   4557            * @retval HAL mode
   4558            */

   \                                 In section .text, align 2, keep-with-next
   4559          HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
   4560          {
   4561            return hi2c->Mode;
   \                     HAL_I2C_GetMode: (+1)
   \        0x0   0xF890 0x0042      LDRB     R0,[R0, #+66]
   \        0x4   0x4770             BX       LR               ;; return
   4562          }
   4563          
   4564          /**
   4565          * @brief  Return the I2C error code.
   4566            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4567            *              the configuration information for the specified I2C.
   4568          * @retval I2C Error Code
   4569          */

   \                                 In section .text, align 2, keep-with-next
   4570          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   4571          {
   4572            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \        0x0   0x6C40             LDR      R0,[R0, #+68]
   \        0x2   0x4770             BX       LR               ;; return
   4573          }
   4574          
   4575          /**
   4576            * @}
   4577            */
   4578          
   4579          /**
   4580            * @}
   4581            */
   4582          
   4583          /** @addtogroup I2C_Private_Functions
   4584            * @{
   4585            */
   4586          
   4587          /**
   4588            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with Interrupt.
   4589            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4590            *                the configuration information for the specified I2C.
   4591            * @param  ITFlags Interrupt flags to handle.
   4592            * @param  ITSources Interrupt sources enabled.
   4593            * @retval HAL status
   4594            */

   \                                 In section .text, align 4, keep-with-next
   4595          static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   4596          {
   \                     I2C_Master_ISR_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine86
   4597            uint16_t devaddress;
   4598            uint32_t tmpITFlags = ITFlags;
   4599          
   4600            /* Process Locked */
   4601            __HAL_LOCK(hi2c);
   \                     ??CrossCallReturnLabel_196: (+1)
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0xD101             BNE.N    ??I2C_Master_ISR_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??I2C_Master_ISR_IT_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   4602          
   4603            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \       0x16   0x06F1             LSLS     R1,R6,#+27
   \       0x18   0x7028             STRB     R0,[R5, #+0]
   \       0x1A   0xD507             BPL.N    ??I2C_Master_ISR_IT_1
   \       0x1C   0x06F8             LSLS     R0,R7,#+27
   \       0x1E   0xD505             BPL.N    ??I2C_Master_ISR_IT_1
   4604            {
   4605              /* Clear NACK Flag */
   4606              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x20   0x....'....        BL       ?Subroutine52
   4607          
   4608              /* Set corresponding Error Code */
   4609              /* No need to generate STOP, it is automatically done */
   4610              /* Error callback will be send during stop flag treatment */
   4611              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   4612          
   4613              /* Flush TX register */
   4614              I2C_Flush_TXDR(hi2c);
   \                     ??CrossCallReturnLabel_109: (+1)
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       I2C_Flush_TXDR
   \       0x2A   0xE068             B.N      ??I2C_Master_ISR_IT_2
   4615            }
   4616            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
   \                     ??I2C_Master_ISR_IT_1: (+1)
   \       0x2C   0x0770             LSLS     R0,R6,#+29
   \       0x2E   0xD50B             BPL.N    ??I2C_Master_ISR_IT_3
   \       0x30   0x0779             LSLS     R1,R7,#+29
   \       0x32   0xD509             BPL.N    ??I2C_Master_ISR_IT_3
   4617            {
   4618              /* Remove RXNE flag on temporary variable as read done */
   4619              tmpITFlags &= ~I2C_FLAG_RXNE;
   4620          
   4621              /* Read data from RXDR */
   4622              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6A41             LDR      R1,[R0, #+36]
   \       0x38   0x6A60             LDR      R0,[R4, #+36]
   \       0x3A   0x7001             STRB     R1,[R0, #+0]
   \       0x3C   0xF026 0x0604      BIC      R6,R6,#0x4
   4623          
   4624              /* Increment Buffer pointer */
   4625              hi2c->pBuffPtr++;
   \       0x40   0x6A61             LDR      R1,[R4, #+36]
   \       0x42   0x1C4A             ADDS     R2,R1,#+1
   \       0x44   0x6262             STR      R2,[R4, #+36]
   4626          
   4627              hi2c->XferSize--;
   \       0x46   0xE00A             B.N      ??I2C_Master_ISR_IT_4
   4628              hi2c->XferCount--;
   4629            }
   4630            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
   \                     ??I2C_Master_ISR_IT_3: (+1)
   \       0x48   0x07B0             LSLS     R0,R6,#+30
   \       0x4A   0xD50F             BPL.N    ??I2C_Master_ISR_IT_5
   \       0x4C   0x07B9             LSLS     R1,R7,#+30
   \       0x4E   0xD50D             BPL.N    ??I2C_Master_ISR_IT_5
   4631            {
   4632              /* Write data to TXDR */
   4633              hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \       0x50   0x6A60             LDR      R0,[R4, #+36]
   \       0x52   0x6822             LDR      R2,[R4, #+0]
   \       0x54   0x7801             LDRB     R1,[R0, #+0]
   \       0x56   0x6291             STR      R1,[R2, #+40]
   4634          
   4635              /* Increment Buffer pointer */
   4636              hi2c->pBuffPtr++;
   \       0x58   0x6A60             LDR      R0,[R4, #+36]
   \       0x5A   0x1C41             ADDS     R1,R0,#+1
   \       0x5C   0x6261             STR      R1,[R4, #+36]
   4637          
   4638              hi2c->XferSize--;
   \                     ??I2C_Master_ISR_IT_4: (+1)
   \       0x5E   0x8D20             LDRH     R0,[R4, #+40]
   \       0x60   0x1E41             SUBS     R1,R0,#+1
   \       0x62   0x8521             STRH     R1,[R4, #+40]
   4639              hi2c->XferCount--;
   \       0x64   0x8D60             LDRH     R0,[R4, #+42]
   \       0x66   0x1E41             SUBS     R1,R0,#+1
   \       0x68   0x8561             STRH     R1,[R4, #+42]
   \       0x6A   0xE048             B.N      ??I2C_Master_ISR_IT_2
   4640            }
   4641            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_IT_5: (+1)
   \       0x6C   0x0631             LSLS     R1,R6,#+24
   \       0x6E   0xF007 0x0040      AND      R0,R7,#0x40
   \       0x72   0x....'....        LDR.W    R3,??DataTable43  ;; 0xffff0000
   \       0x76   0xD529             BPL.N    ??I2C_Master_ISR_IT_6
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD027             BEQ.N    ??I2C_Master_ISR_IT_6
   4642            {
   4643              if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
   \       0x7C   0x8D60             LDRH     R0,[R4, #+42]
   \       0x7E   0xB300             CBZ.N    R0,??I2C_Master_ISR_IT_7
   \       0x80   0x8D20             LDRH     R0,[R4, #+40]
   \       0x82   0xB9F0             CBNZ.N   R0,??I2C_Master_ISR_IT_7
   4644              {
   4645                devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0x6849             LDR      R1,[R1, #+4]
   4646          
   4647                if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x88   0x....'....        BL       ?Subroutine88
   \                     ??CrossCallReturnLabel_204: (+1)
   \       0x8C   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \       0x90   0xD306             BCC.N    ??I2C_Master_ISR_IT_8
   4648                {
   4649                  hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x92   0x22FF             MOVS     R2,#+255
   \       0x94   0x8522             STRH     R2,[R4, #+40]
   4650                  I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x9000             STR      R0,[SP, #+0]
   \       0x9A   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x9E   0xE00D             B.N      ??I2C_Master_ISR_IT_9
   4651                }
   4652                else
   4653                {
   4654                  hi2c->XferSize = hi2c->XferCount;
   \                     ??I2C_Master_ISR_IT_8: (+1)
   \       0xA0   0x8D62             LDRH     R2,[R4, #+42]
   \       0xA2   0x8522             STRH     R2,[R4, #+40]
   4655                  if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
   \       0xA4   0x6AE0             LDR      R0,[R4, #+44]
   \       0xA6   0x4298             CMP      R0,R3
   \       0xA8   0xD003             BEQ.N    ??I2C_Master_ISR_IT_10
   4656                  {
   4657                    I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
   \       0xAA   0x2300             MOVS     R3,#+0
   \       0xAC   0x9300             STR      R3,[SP, #+0]
   \       0xAE   0x6AE3             LDR      R3,[R4, #+44]
   \       0xB0   0xE003             B.N      ??I2C_Master_ISR_IT_11
   4658                  }
   4659                  else
   4660                  {
   4661                    I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_Master_ISR_IT_10: (+1)
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x9000             STR      R0,[SP, #+0]
   \       0xB6   0xF04F 0x7300      MOV      R3,#+33554432
   \                     ??I2C_Master_ISR_IT_11: (+1)
   \       0xBA   0xB2D2             UXTB     R2,R2
   4662                  }
   4663                }
   4664              }
   \                     ??I2C_Master_ISR_IT_9: (+1)
   \       0xBC   0x....'....        BL       ??Subroutine100_1
   \                     ??CrossCallReturnLabel_239: (+1)
   \       0xC0   0xE01D             B.N      ??I2C_Master_ISR_IT_2
   4665              else
   4666              {
   4667                /* Call TxCpltCallback() if no stop mode is set */
   4668                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \                     ??I2C_Master_ISR_IT_7: (+1)
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6841             LDR      R1,[R0, #+4]
   \       0xC6   0x0188             LSLS     R0,R1,#+6
   \       0xC8   0xD415             BMI.N    ??I2C_Master_ISR_IT_12
   4669                {
   4670                  /* Call I2C Master Sequential complete process */
   4671                  I2C_ITMasterSeqCplt(hi2c);
   \       0xCA   0xE010             B.N      ??I2C_Master_ISR_IT_13
   4672                }
   4673                else
   4674                {
   4675                  /* Wrong size Status regarding TCR flag event */
   4676                  /* Call the corresponding callback to inform upper layer of End of Transfer */
   4677                  I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   4678                }
   4679              }
   4680            }
   4681            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_IT_6: (+1)
   \       0xCC   0x0671             LSLS     R1,R6,#+25
   \       0xCE   0xD516             BPL.N    ??I2C_Master_ISR_IT_2
   \       0xD0   0xB1A8             CBZ.N    R0,??I2C_Master_ISR_IT_2
   4682            {
   4683              if (hi2c->XferCount == 0U)
   \       0xD2   0x8D60             LDRH     R0,[R4, #+42]
   \       0xD4   0xB978             CBNZ.N   R0,??I2C_Master_ISR_IT_12
   4684              {
   4685                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x6841             LDR      R1,[R0, #+4]
   \       0xDA   0x018A             LSLS     R2,R1,#+6
   \       0xDC   0xD40F             BMI.N    ??I2C_Master_ISR_IT_2
   4686                {
   4687                  /* Generate a stop condition in case of no transfer option */
   4688                  if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
   \       0xDE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xE0   0x4299             CMP      R1,R3
   \       0xE2   0xD104             BNE.N    ??I2C_Master_ISR_IT_13
   4689                  {
   4690                    /* Generate Stop */
   4691                    hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \       0xE4   0x6842             LDR      R2,[R0, #+4]
   \       0xE6   0xF442 0x4280      ORR      R2,R2,#0x4000
   \       0xEA   0x6042             STR      R2,[R0, #+4]
   \       0xEC   0xE007             B.N      ??I2C_Master_ISR_IT_2
   4692                  }
   4693                  else
   4694                  {
   4695                    /* Call I2C Master Sequential complete process */
   4696                    I2C_ITMasterSeqCplt(hi2c);
   \                     ??I2C_Master_ISR_IT_13: (+1)
   \       0xEE   0x4620             MOV      R0,R4
   \       0xF0   0x....'....        BL       I2C_ITMasterSeqCplt
   \       0xF4   0xE003             B.N      ??I2C_Master_ISR_IT_2
   4697                  }
   4698                }
   4699              }
   4700              else
   4701              {
   4702                /* Wrong size Status regarding TC flag event */
   4703                /* Call the corresponding callback to inform upper layer of End of Transfer */
   4704                I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   \                     ??I2C_Master_ISR_IT_12: (+1)
   \       0xF6   0x2140             MOVS     R1,#+64
   \       0xF8   0x4620             MOV      R0,R4
   \       0xFA   0x....'....        BL       I2C_ITError
   4705              }
   4706            }
   4707            else
   4708            {
   4709              /* Nothing to do */
   4710            }
   4711          
   4712            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \                     ??I2C_Master_ISR_IT_2: (+1)
   \       0xFE   0x06B0             LSLS     R0,R6,#+26
   \      0x100   0xD505             BPL.N    ??I2C_Master_ISR_IT_14
   \      0x102   0x06B9             LSLS     R1,R7,#+26
   \      0x104   0xD503             BPL.N    ??I2C_Master_ISR_IT_14
   4713            {
   4714              /* Call I2C Master complete process */
   4715              I2C_ITMasterCplt(hi2c, tmpITFlags);
   \      0x106   0x4631             MOV      R1,R6
   \      0x108   0x4620             MOV      R0,R4
   \      0x10A   0x....'....        BL       I2C_ITMasterCplt
   4716            }
   4717          
   4718            /* Process Unlocked */
   4719            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Master_ISR_IT_14: (+1)
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x7028             STRB     R0,[R5, #+0]
   4720          
   4721            return HAL_OK;
   \      0x112   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4722          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine52: (+1)
   \        0x0   0x6822             LDR      R2,[R4, #+0]
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x61D1             STR      R1,[R2, #+28]
   \        0x6   0x6868             LDR      R0,[R5, #+4]
   \        0x8   0xF040 0x0004      ORR      R0,R0,#0x4
   \        0xC   0x6068             STR      R0,[R5, #+4]
   \        0xE   0x4770             BX       LR
   4723          
   4724          /**
   4725            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with Interrupt.
   4726            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4727            *                the configuration information for the specified I2C.
   4728            * @param  ITFlags Interrupt flags to handle.
   4729            * @param  ITSources Interrupt sources enabled.
   4730            * @retval HAL status
   4731            */

   \                                 In section .text, align 4, keep-with-next
   4732          static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   4733          {
   \                     I2C_Slave_ISR_IT: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   4734            uint32_t tmpoptions = hi2c->XferOptions;
   4735            uint32_t tmpITFlags = ITFlags;
   4736          
   4737            /* Process locked */
   4738            __HAL_LOCK(hi2c);
   \        0x6   0xF105 0x0640      ADD      R6,R5,#+64
   \        0xA   0xF8D5 0x802C      LDR      R8,[R5, #+44]
   \        0xE   0x7830             LDRB     R0,[R6, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0x460F             MOV      R7,R1
   \       0x14   0x4614             MOV      R4,R2
   \       0x16   0xBF08             IT       EQ
   \       0x18   0x2002             MOVEQ    R0,#+2
   \       0x1A   0xF000 0x807F      BEQ.W    ??I2C_Slave_ISR_IT_0
   \       0x1E   0x2001             MOVS     R0,#+1
   4739          
   4740            /* Check if STOPF is set */
   4741            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \       0x20   0x06B9             LSLS     R1,R7,#+26
   \       0x22   0x7030             STRB     R0,[R6, #+0]
   \       0x24   0xD505             BPL.N    ??I2C_Slave_ISR_IT_1
   \       0x26   0x06A0             LSLS     R0,R4,#+26
   \       0x28   0xD503             BPL.N    ??I2C_Slave_ISR_IT_1
   4742            {
   4743              /* Call I2C Slave complete process */
   4744              I2C_ITSlaveCplt(hi2c, tmpITFlags);
   \       0x2A   0x4639             MOV      R1,R7
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       I2C_ITSlaveCplt
   4745            }
   4746          
   4747            if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \                     ??I2C_Slave_ISR_IT_1: (+1)
   \       0x32   0x06F8             LSLS     R0,R7,#+27
   \       0x34   0x....'....        LDR.W    R1,??DataTable43  ;; 0xffff0000
   \       0x38   0xD530             BPL.N    ??I2C_Slave_ISR_IT_2
   \       0x3A   0x06E2             LSLS     R2,R4,#+27
   \       0x3C   0xD52E             BPL.N    ??I2C_Slave_ISR_IT_2
   4748            {
   4749              /* Check that I2C transfer finished */
   4750              /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
   4751              /* Mean XferCount == 0*/
   4752              /* So clear Flag NACKF only */
   4753              if (hi2c->XferCount == 0U)
   \       0x3E   0x8D68             LDRH     R0,[R5, #+42]
   \       0x40   0xB9D0             CBNZ.N   R0,??I2C_Slave_ISR_IT_3
   4754              {
   4755                if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
   \       0x42   0x7870             LDRB     R0,[R6, #+1]
   \       0x44   0x2828             CMP      R0,#+40
   \       0x46   0xBF08             IT       EQ
   \       0x48   0xF1B8 0x7F00      CMPEQ    R8,#+33554432
   \       0x4C   0xD104             BNE.N    ??I2C_Slave_ISR_IT_4
   4756                {
   4757                  /* Call I2C Listen complete process */
   4758                  I2C_ITListenCplt(hi2c, tmpITFlags);
   \       0x4E   0x4639             MOV      R1,R7
   \       0x50   0x4628             MOV      R0,R5
   \       0x52   0x....'....        BL       I2C_ITListenCplt
   \       0x56   0xE05F             B.N      ??I2C_Slave_ISR_IT_5
   4759                }
   4760                else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_Slave_ISR_IT_4: (+1)
   \       0x58   0x7870             LDRB     R0,[R6, #+1]
   \       0x5A   0x2829             CMP      R0,#+41
   \       0x5C   0xD108             BNE.N    ??I2C_Slave_ISR_IT_6
   \       0x5E   0x4588             CMP      R8,R1
   \       0x60   0xD006             BEQ.N    ??I2C_Slave_ISR_IT_6
   4761                {
   4762                  /* Clear NACK Flag */
   4763                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x2110             MOVS     R1,#+16
   \       0x66   0x61C1             STR      R1,[R0, #+28]
   4764          
   4765                  /* Flush TX register */
   4766                  I2C_Flush_TXDR(hi2c);
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x....'....        BL       I2C_Flush_TXDR
   4767          
   4768                  /* Last Byte is Transmitted */
   4769                  /* Call I2C Slave Sequential complete process */
   4770                  I2C_ITSlaveSeqCplt(hi2c);
   \       0x6E   0xE050             B.N      ??I2C_Slave_ISR_IT_7
   4771                }
   4772                else
   4773                {
   4774                  /* Clear NACK Flag */
   4775                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_IT_6: (+1)
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0x2010             MOVS     R0,#+16
   \       0x74   0x61C8             STR      R0,[R1, #+28]
   \       0x76   0xE04F             B.N      ??I2C_Slave_ISR_IT_5
   4776                }
   4777              }
   4778              else
   4779              {
   4780                /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
   4781                /* Clear NACK Flag */
   4782                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_IT_3: (+1)
   \       0x78   0x6829             LDR      R1,[R5, #+0]
   \       0x7A   0x2010             MOVS     R0,#+16
   \       0x7C   0x61C8             STR      R0,[R1, #+28]
   4783          
   4784                /* Set ErrorCode corresponding to a Non-Acknowledge */
   4785                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   4786          
   4787                if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
   \       0x7E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x82   0x6870             LDR      R0,[R6, #+4]
   \       0x84   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x88   0xBF18             IT       NE
   \       0x8A   0xF1B8 0x7F80      CMPNE    R8,#+16777216
   \       0x8E   0x6070             STR      R0,[R6, #+4]
   \       0x90   0xD142             BNE.N    ??I2C_Slave_ISR_IT_5
   4788                {
   4789                  /* Call the corresponding callback to inform upper layer of End of Transfer */
   4790                  I2C_ITError(hi2c, hi2c->ErrorCode);
   \       0x92   0x6871             LDR      R1,[R6, #+4]
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x....'....        BL       I2C_ITError
   \       0x9A   0xE03D             B.N      ??I2C_Slave_ISR_IT_5
   4791                }
   4792              }
   4793            }
   4794            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
   \                     ??I2C_Slave_ISR_IT_2: (+1)
   \       0x9C   0x0778             LSLS     R0,R7,#+29
   \       0x9E   0xD515             BPL.N    ??I2C_Slave_ISR_IT_8
   \       0xA0   0x0762             LSLS     R2,R4,#+29
   \       0xA2   0xD513             BPL.N    ??I2C_Slave_ISR_IT_8
   4795            {
   4796              if (hi2c->XferCount > 0U)
   \       0xA4   0x8D68             LDRH     R0,[R5, #+42]
   \       0xA6   0xB160             CBZ.N    R0,??I2C_Slave_ISR_IT_9
   4797              {
   4798                /* Read data from RXDR */
   4799                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0xA8   0x682A             LDR      R2,[R5, #+0]
   \       0xAA   0x6A50             LDR      R0,[R2, #+36]
   \       0xAC   0x6A6A             LDR      R2,[R5, #+36]
   \       0xAE   0x7010             STRB     R0,[R2, #+0]
   4800          
   4801                /* Increment Buffer pointer */
   4802                hi2c->pBuffPtr++;
   \       0xB0   0x6A68             LDR      R0,[R5, #+36]
   \       0xB2   0x1C43             ADDS     R3,R0,#+1
   4803          
   4804                hi2c->XferSize--;
   \       0xB4   0x8D28             LDRH     R0,[R5, #+40]
   \       0xB6   0x626B             STR      R3,[R5, #+36]
   \       0xB8   0x1E42             SUBS     R2,R0,#+1
   \       0xBA   0x852A             STRH     R2,[R5, #+40]
   4805                hi2c->XferCount--;
   \       0xBC   0x8D68             LDRH     R0,[R5, #+42]
   \       0xBE   0x1E42             SUBS     R2,R0,#+1
   \       0xC0   0x856A             STRH     R2,[R5, #+42]
   4806              }
   4807          
   4808              if ((hi2c->XferCount == 0U) && \
   4809                  (tmpoptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_Slave_ISR_IT_9: (+1)
   \       0xC2   0x8D68             LDRH     R0,[R5, #+42]
   \       0xC4   0xBB40             CBNZ.N   R0,??I2C_Slave_ISR_IT_5
   \       0xC6   0x4588             CMP      R8,R1
   \       0xC8   0xD026             BEQ.N    ??I2C_Slave_ISR_IT_5
   4810              {
   4811                /* Call I2C Slave Sequential complete process */
   4812                I2C_ITSlaveSeqCplt(hi2c);
   \       0xCA   0xE022             B.N      ??I2C_Slave_ISR_IT_7
   4813              }
   4814            }
   4815            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
   \                     ??I2C_Slave_ISR_IT_8: (+1)
   \       0xCC   0x0738             LSLS     R0,R7,#+28
   \       0xCE   0xD506             BPL.N    ??I2C_Slave_ISR_IT_10
   \       0xD0   0x0721             LSLS     R1,R4,#+28
   \       0xD2   0xD504             BPL.N    ??I2C_Slave_ISR_IT_10
   4816            {
   4817              I2C_ITAddrCplt(hi2c, tmpITFlags);
   \       0xD4   0x4639             MOV      R1,R7
   \       0xD6   0x4628             MOV      R0,R5
   \       0xD8   0x....'....        BL       I2C_ITAddrCplt
   \       0xDC   0xE01C             B.N      ??I2C_Slave_ISR_IT_5
   4818            }
   4819            else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
   \                     ??I2C_Slave_ISR_IT_10: (+1)
   \       0xDE   0x07B8             LSLS     R0,R7,#+30
   \       0xE0   0xD51A             BPL.N    ??I2C_Slave_ISR_IT_5
   \       0xE2   0x07A1             LSLS     R1,R4,#+30
   \       0xE4   0xD518             BPL.N    ??I2C_Slave_ISR_IT_5
   4820            {
   4821              /* Write data to TXDR only if XferCount not reach "0" */
   4822              /* A TXIS flag can be set, during STOP treatment      */
   4823              /* Check if all Datas have already been sent */
   4824              /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
   4825              if (hi2c->XferCount > 0U)
   \       0xE6   0x8D68             LDRH     R0,[R5, #+42]
   \       0xE8   0xB168             CBZ.N    R0,??I2C_Slave_ISR_IT_11
   4826              {
   4827                /* Write data to TXDR */
   4828                hi2c->Instance->TXDR = *hi2c->pBuffPtr;
   \       0xEA   0x6A68             LDR      R0,[R5, #+36]
   \       0xEC   0x682A             LDR      R2,[R5, #+0]
   \       0xEE   0x7801             LDRB     R1,[R0, #+0]
   \       0xF0   0x6291             STR      R1,[R2, #+40]
   4829          
   4830                /* Increment Buffer pointer */
   4831                hi2c->pBuffPtr++;
   \       0xF2   0x6A68             LDR      R0,[R5, #+36]
   \       0xF4   0x1C41             ADDS     R1,R0,#+1
   \       0xF6   0x6269             STR      R1,[R5, #+36]
   4832          
   4833                hi2c->XferCount--;
   \       0xF8   0x8D68             LDRH     R0,[R5, #+42]
   \       0xFA   0x1E41             SUBS     R1,R0,#+1
   \       0xFC   0x8569             STRH     R1,[R5, #+42]
   4834                hi2c->XferSize--;
   \       0xFE   0x8D28             LDRH     R0,[R5, #+40]
   \      0x100   0x1E41             SUBS     R1,R0,#+1
   \      0x102   0x8529             STRH     R1,[R5, #+40]
   \      0x104   0xE008             B.N      ??I2C_Slave_ISR_IT_5
   4835              }
   4836              else
   4837              {
   4838                if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
   \                     ??I2C_Slave_ISR_IT_11: (+1)
   \      0x106   0xF1B8 0x7F80      CMP      R8,#+16777216
   \      0x10A   0xBF18             IT       NE
   \      0x10C   0xF1B8 0x0F00      CMPNE    R8,#+0
   \      0x110   0xD102             BNE.N    ??I2C_Slave_ISR_IT_5
   4839                {
   4840                  /* Last Byte is Transmitted */
   4841                  /* Call I2C Slave Sequential complete process */
   4842                  I2C_ITSlaveSeqCplt(hi2c);
   \                     ??I2C_Slave_ISR_IT_7: (+1)
   \      0x112   0x4628             MOV      R0,R5
   \      0x114   0x....'....        BL       I2C_ITSlaveSeqCplt
   4843                }
   4844              }
   4845            }
   4846            else
   4847            {
   4848              /* Nothing to do */
   4849            }
   4850          
   4851            /* Process Unlocked */
   4852            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Slave_ISR_IT_5: (+1)
   \      0x118   0x2000             MOVS     R0,#+0
   \      0x11A   0x7030             STRB     R0,[R6, #+0]
   4853          
   4854            return HAL_OK;
   \                     ??I2C_Slave_ISR_IT_0: (+1)
   \      0x11C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4855          }
   4856          
   4857          /**
   4858            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with DMA.
   4859            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4860            *                the configuration information for the specified I2C.
   4861            * @param  ITFlags Interrupt flags to handle.
   4862            * @param  ITSources Interrupt sources enabled.
   4863            * @retval HAL status
   4864            */

   \                                 In section .text, align 4, keep-with-next
   4865          static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   4866          {
   \                     I2C_Master_ISR_DMA: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   4867            uint16_t devaddress;
   4868            uint32_t xfermode;
   4869          
   4870            /* Process Locked */
   4871            __HAL_LOCK(hi2c);
   \        0x4   0xF105 0x0440      ADD      R4,R5,#+64
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??I2C_Master_ISR_DMA_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??I2C_Master_ISR_DMA_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   4872          
   4873            if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \       0x14   0x06CB             LSLS     R3,R1,#+27
   \       0x16   0x7020             STRB     R0,[R4, #+0]
   \       0x18   0xD510             BPL.N    ??I2C_Master_ISR_DMA_1
   \       0x1A   0x06D0             LSLS     R0,R2,#+27
   \       0x1C   0xD50E             BPL.N    ??I2C_Master_ISR_DMA_1
   4874            {
   4875              /* Clear NACK Flag */
   4876              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x1E   0x682A             LDR      R2,[R5, #+0]
   \       0x20   0x2110             MOVS     R1,#+16
   \       0x22   0x61D1             STR      R1,[R2, #+28]
   4877          
   4878              /* Set corresponding Error Code */
   4879              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   4880          
   4881              /* No need to generate STOP, it is automatically done */
   4882              /* But enable STOP interrupt, to treat it */
   4883              /* Error callback will be send during stop flag treatment */
   4884              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   \       0x24   0x2112             MOVS     R1,#+18
   \       0x26   0x6860             LDR      R0,[R4, #+4]
   \       0x28   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x2C   0x6060             STR      R0,[R4, #+4]
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       I2C_Enable_IRQ
   4885          
   4886              /* Flush TX register */
   4887              I2C_Flush_TXDR(hi2c);
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x....'....        BL       I2C_Flush_TXDR
   \       0x3A   0xE05F             B.N      ??I2C_Master_ISR_DMA_2
   4888            }
   4889            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_DMA_1: (+1)
   \       0x3C   0x060E             LSLS     R6,R1,#+24
   \       0x3E   0xF002 0x0040      AND      R0,R2,#0x40
   \       0x42   0x....'....        LDR.W    R3,??DataTable43  ;; 0xffff0000
   \       0x46   0xD538             BPL.N    ??I2C_Master_ISR_DMA_3
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD036             BEQ.N    ??I2C_Master_ISR_DMA_3
   4890            {
   4891              /* Disable TC interrupt */
   4892              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0x6801             LDR      R1,[R0, #+0]
   \       0x50   0xF021 0x0140      BIC      R1,R1,#0x40
   \       0x54   0x6001             STR      R1,[R0, #+0]
   4893          
   4894              if (hi2c->XferCount != 0U)
   \       0x56   0x6829             LDR      R1,[R5, #+0]
   \       0x58   0x8D68             LDRH     R0,[R5, #+42]
   \       0x5A   0xB350             CBZ.N    R0,??I2C_Master_ISR_DMA_4
   4895              {
   4896                /* Recover Slave address */
   4897                devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
   \       0x5C   0x6849             LDR      R1,[R1, #+4]
   4898          
   4899                /* Prepare the new XferSize to transfer */
   4900                if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x5E   0x8D68             LDRH     R0,[R5, #+42]
   \       0x60   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x64   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \       0x68   0xD304             BCC.N    ??I2C_Master_ISR_DMA_5
   4901                {
   4902                  hi2c->XferSize = MAX_NBYTE_SIZE;
   \       0x6A   0x22FF             MOVS     R2,#+255
   \       0x6C   0x852A             STRH     R2,[R5, #+40]
   4903                  xfermode = I2C_RELOAD_MODE;
   \       0x6E   0xF04F 0x7380      MOV      R3,#+16777216
   \       0x72   0xE007             B.N      ??I2C_Master_ISR_DMA_6
   4904                }
   4905                else
   4906                {
   4907                  hi2c->XferSize = hi2c->XferCount;
   \                     ??I2C_Master_ISR_DMA_5: (+1)
   \       0x74   0x8D68             LDRH     R0,[R5, #+42]
   \       0x76   0x8528             STRH     R0,[R5, #+40]
   4908                  if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
   \       0x78   0x6AEA             LDR      R2,[R5, #+44]
   \       0x7A   0x429A             CMP      R2,R3
   \       0x7C   0xBF14             ITE      NE
   \       0x7E   0x6AEB             LDRNE    R3,[R5, #+44]
   \       0x80   0xF04F 0x7300      MOVEQ    R3,#+33554432
   4909                  {
   4910                    xfermode = hi2c->XferOptions;
   4911                  }
   4912                  else
   4913                  {
   4914                    xfermode = I2C_AUTOEND_MODE;
   4915                  }
   4916                }
   4917          
   4918                /* Set the new XferSize in Nbytes register */
   4919                I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
   \                     ??I2C_Master_ISR_DMA_6: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x9000             STR      R0,[SP, #+0]
   \       0x88   0x4628             MOV      R0,R5
   \       0x8A   0x8D2A             LDRH     R2,[R5, #+40]
   \       0x8C   0xB2D2             UXTB     R2,R2
   \       0x8E   0x....'....        BL       I2C_TransferConfig
   4920          
   4921                /* Update XferCount value */
   4922                hi2c->XferCount -= hi2c->XferSize;
   \       0x92   0x8D69             LDRH     R1,[R5, #+42]
   \       0x94   0x8D28             LDRH     R0,[R5, #+40]
   \       0x96   0x1A09             SUBS     R1,R1,R0
   \       0x98   0x8569             STRH     R1,[R5, #+42]
   4923          
   4924                /* Enable DMA Request */
   4925                if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0x7861             LDRB     R1,[R4, #+1]
   \       0x9E   0x2922             CMP      R1,#+34
   \       0xA0   0xD104             BNE.N    ??I2C_Master_ISR_DMA_7
   4926                {
   4927                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \       0xA2   0x6802             LDR      R2,[R0, #+0]
   \       0xA4   0xF442 0x4200      ORR      R2,R2,#0x8000
   \       0xA8   0x6002             STR      R2,[R0, #+0]
   \       0xAA   0xE027             B.N      ??I2C_Master_ISR_DMA_2
   4928                }
   4929                else
   4930                {
   4931                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_Master_ISR_DMA_7: (+1)
   \       0xAC   0x....'....        BL       ?Subroutine43
   4932                }
   4933              }
   \                     ??CrossCallReturnLabel_87: (+1)
   \       0xB0   0xE024             B.N      ??I2C_Master_ISR_DMA_2
   4934              else
   4935              {
   4936                /* Call TxCpltCallback() if no stop mode is set */
   4937                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \                     ??I2C_Master_ISR_DMA_4: (+1)
   \       0xB2   0x6848             LDR      R0,[R1, #+4]
   \       0xB4   0x0181             LSLS     R1,R0,#+6
   \       0xB6   0xD415             BMI.N    ??I2C_Master_ISR_DMA_8
   4938                {
   4939                  /* Call I2C Master Sequential complete process */
   4940                  I2C_ITMasterSeqCplt(hi2c);
   \       0xB8   0xE010             B.N      ??I2C_Master_ISR_DMA_9
   4941                }
   4942                else
   4943                {
   4944                  /* Wrong size Status regarding TCR flag event */
   4945                  /* Call the corresponding callback to inform upper layer of End of Transfer */
   4946                  I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   4947                }
   4948              }
   4949            }
   4950            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
   \                     ??I2C_Master_ISR_DMA_3: (+1)
   \       0xBA   0x064E             LSLS     R6,R1,#+25
   \       0xBC   0xD517             BPL.N    ??I2C_Master_ISR_DMA_10
   \       0xBE   0xB1B0             CBZ.N    R0,??I2C_Master_ISR_DMA_10
   4951            {
   4952              if (hi2c->XferCount == 0U)
   \       0xC0   0x8D68             LDRH     R0,[R5, #+42]
   \       0xC2   0xB978             CBNZ.N   R0,??I2C_Master_ISR_DMA_8
   4953              {
   4954                if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
   \       0xC4   0x6828             LDR      R0,[R5, #+0]
   \       0xC6   0x6841             LDR      R1,[R0, #+4]
   \       0xC8   0x018A             LSLS     R2,R1,#+6
   \       0xCA   0xD417             BMI.N    ??I2C_Master_ISR_DMA_2
   4955                {
   4956                  /* Generate a stop condition in case of no transfer option */
   4957                  if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
   \       0xCC   0x6AE9             LDR      R1,[R5, #+44]
   \       0xCE   0x4299             CMP      R1,R3
   \       0xD0   0xD104             BNE.N    ??I2C_Master_ISR_DMA_9
   4958                  {
   4959                    /* Generate Stop */
   4960                    hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \       0xD2   0x6842             LDR      R2,[R0, #+4]
   \       0xD4   0xF442 0x4280      ORR      R2,R2,#0x4000
   \       0xD8   0x6042             STR      R2,[R0, #+4]
   \       0xDA   0xE00F             B.N      ??I2C_Master_ISR_DMA_2
   4961                  }
   4962                  else
   4963                  {
   4964                    /* Call I2C Master Sequential complete process */
   4965                    I2C_ITMasterSeqCplt(hi2c);
   \                     ??I2C_Master_ISR_DMA_9: (+1)
   \       0xDC   0x4628             MOV      R0,R5
   \       0xDE   0x....'....        BL       I2C_ITMasterSeqCplt
   \       0xE2   0xE00B             B.N      ??I2C_Master_ISR_DMA_2
   4966                  }
   4967                }
   4968              }
   4969              else
   4970              {
   4971                /* Wrong size Status regarding TC flag event */
   4972                /* Call the corresponding callback to inform upper layer of End of Transfer */
   4973                I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
   \                     ??I2C_Master_ISR_DMA_8: (+1)
   \       0xE4   0x2140             MOVS     R1,#+64
   \       0xE6   0x4628             MOV      R0,R5
   \       0xE8   0x....'....        BL       I2C_ITError
   \       0xEC   0xE006             B.N      ??I2C_Master_ISR_DMA_2
   4974              }
   4975            }
   4976            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \                     ??I2C_Master_ISR_DMA_10: (+1)
   \       0xEE   0x0688             LSLS     R0,R1,#+26
   \       0xF0   0xD504             BPL.N    ??I2C_Master_ISR_DMA_2
   \       0xF2   0x0692             LSLS     R2,R2,#+26
   \       0xF4   0xBF44             ITT      MI
   4977            {
   4978              /* Call I2C Master complete process */
   4979              I2C_ITMasterCplt(hi2c, ITFlags);
   \       0xF6   0x4628             MOVMI    R0,R5
   \       0xF8   0x....'....        BLMI     I2C_ITMasterCplt
   4980            }
   4981            else
   4982            {
   4983              /* Nothing to do */
   4984            }
   4985          
   4986            /* Process Unlocked */
   4987            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Master_ISR_DMA_2: (+1)
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0x7020             STRB     R0,[R4, #+0]
   4988          
   4989            return HAL_OK;
   \      0x100   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   4990          }
   4991          
   4992          /**
   4993            * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with DMA.
   4994            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4995            *                the configuration information for the specified I2C.
   4996            * @param  ITFlags Interrupt flags to handle.
   4997            * @param  ITSources Interrupt sources enabled.
   4998            * @retval HAL status
   4999            */

   \                                 In section .text, align 4, keep-with-next
   5000          static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
   5001          {
   \                     I2C_Slave_ISR_DMA: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   5002            uint32_t tmpoptions = hi2c->XferOptions;
   5003            uint32_t treatdmanack = 0U;
   5004          
   5005            /* Process locked */
   5006            __HAL_LOCK(hi2c);
   \        0x6   0xF106 0x0740      ADD      R7,R6,#+64
   \        0xA   0xF8D6 0x902C      LDR      R9,[R6, #+44]
   \        0xE   0x7838             LDRB     R0,[R7, #+0]
   \       0x10   0x2500             MOVS     R5,#+0
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0x4688             MOV      R8,R1
   \       0x16   0x4614             MOV      R4,R2
   \       0x18   0xBF08             IT       EQ
   \       0x1A   0x2002             MOVEQ    R0,#+2
   \       0x1C   0xD05F             BEQ.N    ??I2C_Slave_ISR_DMA_0
   \       0x1E   0x2001             MOVS     R0,#+1
   5007          
   5008            /* Check if STOPF is set */
   5009            if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
   \       0x20   0xEA5F 0x6188      LSLS     R1,R8,#+26
   \       0x24   0x7038             STRB     R0,[R7, #+0]
   \       0x26   0xD505             BPL.N    ??I2C_Slave_ISR_DMA_1
   \       0x28   0x06A0             LSLS     R0,R4,#+26
   \       0x2A   0xD503             BPL.N    ??I2C_Slave_ISR_DMA_1
   5010            {
   5011              /* Call I2C Slave complete process */
   5012              I2C_ITSlaveCplt(hi2c, ITFlags);
   \       0x2C   0x4641             MOV      R1,R8
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0x....'....        BL       I2C_ITSlaveCplt
   5013            }
   5014          
   5015            if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
   \                     ??I2C_Slave_ISR_DMA_1: (+1)
   \       0x34   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \       0x38   0xD546             BPL.N    ??I2C_Slave_ISR_DMA_2
   \       0x3A   0x06E1             LSLS     R1,R4,#+27
   \       0x3C   0xD544             BPL.N    ??I2C_Slave_ISR_DMA_2
   5016            {
   5017              /* Check that I2C transfer finished */
   5018              /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
   5019              /* Mean XferCount == 0 */
   5020              /* So clear Flag NACKF only */
   5021              if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
   5022                  (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
   \       0x3E   0xF414 0x4F40      TST      R4,#0xC000
   \       0x42   0xD03D             BEQ.N    ??I2C_Slave_ISR_DMA_3
   5023              {
   5024                /* Split check of hdmarx, for MISRA compliance */
   5025                if (hi2c->hdmarx != NULL)
   \       0x44   0x6BF0             LDR      R0,[R6, #+60]
   \       0x46   0xB128             CBZ.N    R0,??I2C_Slave_ISR_DMA_4
   5026                {
   5027                  if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
   \       0x48   0x0421             LSLS     R1,R4,#+16
   \       0x4A   0xD503             BPL.N    ??I2C_Slave_ISR_DMA_4
   5028                  {
   5029                    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
   \       0x4C   0x6802             LDR      R2,[R0, #+0]
   \       0x4E   0x6850             LDR      R0,[R2, #+4]
   \       0x50   0xB900             CBNZ.N   R0,??I2C_Slave_ISR_DMA_4
   5030                    {
   5031                      treatdmanack = 1U;
   \       0x52   0x2501             MOVS     R5,#+1
   5032                    }
   5033                  }
   5034                }
   5035          
   5036                /* Split check of hdmatx, for MISRA compliance  */
   5037                if (hi2c->hdmatx != NULL)
   \                     ??I2C_Slave_ISR_DMA_4: (+1)
   \       0x54   0x6BB0             LDR      R0,[R6, #+56]
   \       0x56   0xB120             CBZ.N    R0,??I2C_Slave_ISR_DMA_5
   5038                {
   5039                  if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
   \       0x58   0x0461             LSLS     R1,R4,#+17
   \       0x5A   0xD502             BPL.N    ??I2C_Slave_ISR_DMA_5
   5040                  {
   5041                    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
   \       0x5C   0x6802             LDR      R2,[R0, #+0]
   \       0x5E   0x6850             LDR      R0,[R2, #+4]
   \       0x60   0xB100             CBZ.N    R0,??I2C_Slave_ISR_DMA_6
   5042                    {
   5043                      treatdmanack = 1U;
   5044                    }
   5045                  }
   5046                }
   5047          
   5048                if (treatdmanack == 1U)
   \                     ??I2C_Slave_ISR_DMA_5: (+1)
   \       0x62   0xB1DD             CBZ.N    R5,??I2C_Slave_ISR_DMA_7
   5049                {
   5050                  if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
   \                     ??I2C_Slave_ISR_DMA_6: (+1)
   \       0x64   0x7878             LDRB     R0,[R7, #+1]
   \       0x66   0x2828             CMP      R0,#+40
   \       0x68   0xBF08             IT       EQ
   \       0x6A   0xF1B9 0x7F00      CMPEQ    R9,#+33554432
   \       0x6E   0xD104             BNE.N    ??I2C_Slave_ISR_DMA_8
   5051                  {
   5052                    /* Call I2C Listen complete process */
   5053                    I2C_ITListenCplt(hi2c, ITFlags);
   \       0x70   0x4641             MOV      R1,R8
   \       0x72   0x4630             MOV      R0,R6
   \       0x74   0x....'....        BL       I2C_ITListenCplt
   \       0x78   0xE02F             B.N      ??I2C_Slave_ISR_DMA_9
   5054                  }
   5055                  else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_Slave_ISR_DMA_8: (+1)
   \       0x7A   0x7878             LDRB     R0,[R7, #+1]
   \       0x7C   0x2829             CMP      R0,#+41
   \       0x7E   0xD11F             BNE.N    ??I2C_Slave_ISR_DMA_3
   \       0x80   0x....'....        LDR.W    R1,??DataTable43  ;; 0xffff0000
   \       0x84   0x4589             CMP      R9,R1
   \       0x86   0xD01B             BEQ.N    ??I2C_Slave_ISR_DMA_3
   5056                  {
   5057                    /* Clear NACK Flag */
   5058                    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x88   0x6832             LDR      R2,[R6, #+0]
   \       0x8A   0x2010             MOVS     R0,#+16
   \       0x8C   0x61D0             STR      R0,[R2, #+28]
   5059          
   5060                    /* Flush TX register */
   5061                    I2C_Flush_TXDR(hi2c);
   \       0x8E   0x4630             MOV      R0,R6
   \       0x90   0x....'....        BL       I2C_Flush_TXDR
   5062          
   5063                    /* Last Byte is Transmitted */
   5064                    /* Call I2C Slave Sequential complete process */
   5065                    I2C_ITSlaveSeqCplt(hi2c);
   \       0x94   0x4630             MOV      R0,R6
   \       0x96   0x....'....        BL       I2C_ITSlaveSeqCplt
   \       0x9A   0xE01E             B.N      ??I2C_Slave_ISR_DMA_9
   5066                  }
   5067                  else
   5068                  {
   5069                    /* Clear NACK Flag */
   5070                    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   5071                  }
   5072                }
   5073                else
   5074                {
   5075                  /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
   5076                  /* Clear NACK Flag */
   5077                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_DMA_7: (+1)
   \       0x9C   0x6831             LDR      R1,[R6, #+0]
   \       0x9E   0x2010             MOVS     R0,#+16
   \       0xA0   0x61C8             STR      R0,[R1, #+28]
   5078          
   5079                  /* Set ErrorCode corresponding to a Non-Acknowledge */
   5080                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   5081          
   5082                  if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
   \       0xA2   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xA6   0x6878             LDR      R0,[R7, #+4]
   \       0xA8   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0xAC   0xBF18             IT       NE
   \       0xAE   0xF1B9 0x7F80      CMPNE    R9,#+16777216
   \       0xB2   0x6078             STR      R0,[R7, #+4]
   \       0xB4   0xD111             BNE.N    ??I2C_Slave_ISR_DMA_9
   5083                  {
   5084                    /* Call the corresponding callback to inform upper layer of End of Transfer */
   5085                    I2C_ITError(hi2c, hi2c->ErrorCode);
   \       0xB6   0x6879             LDR      R1,[R7, #+4]
   \       0xB8   0x4630             MOV      R0,R6
   \       0xBA   0x....'....        BL       I2C_ITError
   \       0xBE   0xE00C             B.N      ??I2C_Slave_ISR_DMA_9
   5086                  }
   5087                }
   5088              }
   5089              else
   5090              {
   5091                /* Only Clear NACK Flag, no DMA treatment is pending */
   5092                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_ISR_DMA_3: (+1)
   \       0xC0   0x6831             LDR      R1,[R6, #+0]
   \       0xC2   0x2010             MOVS     R0,#+16
   \       0xC4   0x61C8             STR      R0,[R1, #+28]
   \       0xC6   0xE008             B.N      ??I2C_Slave_ISR_DMA_9
   5093              }
   5094            }
   5095            else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
   \                     ??I2C_Slave_ISR_DMA_2: (+1)
   \       0xC8   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \       0xCC   0xD505             BPL.N    ??I2C_Slave_ISR_DMA_9
   \       0xCE   0x0721             LSLS     R1,R4,#+28
   \       0xD0   0xD503             BPL.N    ??I2C_Slave_ISR_DMA_9
   5096            {
   5097              I2C_ITAddrCplt(hi2c, ITFlags);
   \       0xD2   0x4641             MOV      R1,R8
   \       0xD4   0x4630             MOV      R0,R6
   \       0xD6   0x....'....        BL       I2C_ITAddrCplt
   5098            }
   5099            else
   5100            {
   5101              /* Nothing to do */
   5102            }
   5103          
   5104            /* Process Unlocked */
   5105            __HAL_UNLOCK(hi2c);
   \                     ??I2C_Slave_ISR_DMA_9: (+1)
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x7038             STRB     R0,[R7, #+0]
   5106          
   5107            return HAL_OK;
   \                     ??I2C_Slave_ISR_DMA_0: (+1)
   \       0xDE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   5108          }
   5109          
   5110          /**
   5111            * @brief  Master sends target device address followed by internal memory address for write request.
   5112            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5113            *                the configuration information for the specified I2C.
   5114            * @param  DevAddress Target device address: The device 7 bits address value
   5115            *         in datasheet must be shifted to the left before calling the interface
   5116            * @param  MemAddress Internal memory address
   5117            * @param  MemAddSize Size of internal memory address
   5118            * @param  Timeout Timeout duration
   5119            * @param  Tickstart Tick start value
   5120            * @retval HAL status
   5121            */

   \                                 In section .text, align 2, keep-with-next
   5122          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   5123          {
   \                     I2C_RequestMemoryWrite: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine96
   5124            I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \                     ??CrossCallReturnLabel_229: (+1)
   \        0x8   0xF04F 0x7380      MOV      R3,#+16777216
   \        0xC   0xB2EA             UXTB     R2,R5
   \        0xE   0x....'....        BL       I2C_TransferConfig
   5125          
   5126            /* Wait until TXIS flag is set */
   5127            if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x12   0x....'....        BL       ??Subroutine34_0
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0x16   0xB958             CBNZ.N   R0,??I2C_RequestMemoryWrite_0
   5128            {
   5129              return HAL_ERROR;
   5130            }
   5131          
   5132            /* If Memory address size is 8Bit */
   5133            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \       0x18   0x2D01             CMP      R5,#+1
   \       0x1A   0xD002             BEQ.N    ??I2C_RequestMemoryWrite_1
   5134            {
   5135              /* Send Memory Address */
   5136              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   5137            }
   5138            /* If Memory address size is 16Bit */
   5139            else
   5140            {
   5141              /* Send MSB of Memory Address */
   5142              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
   \       0x1C   0x....'....        BL       ?Subroutine34
   5143          
   5144              /* Wait until TXIS flag is set */
   5145              if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0x20   0xB930             CBNZ.N   R0,??I2C_RequestMemoryWrite_0
   5146              {
   5147                return HAL_ERROR;
   5148              }
   5149          
   5150              /* Send LSB of Memory Address */
   5151              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \       0x22   0x....'....        BL       ?Subroutine39
   5152            }
   5153          
   5154            /* Wait until TCR flag is set */
   5155            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x26   0x2180             MOVS     R1,#+128
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       I2C_WaitOnFlagUntilTimeout
   \       0x2E   0xB100             CBZ.N    R0,??I2C_RequestMemoryWrite_2
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   5156            {
   5157              return HAL_ERROR;
   5158            }
   5159          
   5160            return HAL_OK;
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \       0x32   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   5161          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine96: (+1)
   \        0x0   0x4617             MOV      R7,R2
   \        0x2   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \        0x6   0x9E09             LDR      R6,[SP, #+36]
   \        0x8   0x....'....        LDR.W    R2,??DataTable43_1  ;; 0x80002000
   \        0xC   0x9200             STR      R2,[SP, #+0]
   \        0xE   0x461D             MOV      R5,R3
   \       0x10   0x4604             MOV      R4,R0
   \       0x12   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine39: (+1)
   \        0x0   0x6820             LDR      R0,[R4, #+0]
   \        0x2   0xB2FF             UXTB     R7,R7
   \        0x4   0x6287             STR      R7,[R0, #+40]
   \        0x6   0x9600             STR      R6,[SP, #+0]
   \        0x8   0x4643             MOV      R3,R8
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine34: (+1)
   \        0x0   0x6821             LDR      R1,[R4, #+0]
   \        0x2   0x0A38             LSRS     R0,R7,#+8
   \        0x4   0x6288             STR      R0,[R1, #+40]
   \                     ??Subroutine34_0: (+1)
   \        0x6   0x4632             MOV      R2,R6
   \        0x8   0x4641             MOV      R1,R8
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x....             B.N      I2C_WaitOnTXISFlagUntilTimeout
   5162          
   5163          /**
   5164            * @brief  Master sends target device address followed by internal memory address for read request.
   5165            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5166            *                the configuration information for the specified I2C.
   5167            * @param  DevAddress Target device address: The device 7 bits address value
   5168            *         in datasheet must be shifted to the left before calling the interface
   5169            * @param  MemAddress Internal memory address
   5170            * @param  MemAddSize Size of internal memory address
   5171            * @param  Timeout Timeout duration
   5172            * @param  Tickstart Tick start value
   5173            * @retval HAL status
   5174            */

   \                                 In section .text, align 2, keep-with-next
   5175          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   5176          {
   \                     I2C_RequestMemoryRead: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine96
   5177            I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??CrossCallReturnLabel_230: (+1)
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0xB2EA             UXTB     R2,R5
   \        0xC   0x....'....        BL       I2C_TransferConfig
   5178          
   5179            /* Wait until TXIS flag is set */
   5180            if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x....'....        BL       ??Subroutine34_0
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x14   0xB958             CBNZ.N   R0,??I2C_RequestMemoryRead_0
   5181            {
   5182              return HAL_ERROR;
   5183            }
   5184          
   5185            /* If Memory address size is 8Bit */
   5186            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \       0x16   0x2D01             CMP      R5,#+1
   \       0x18   0xD002             BEQ.N    ??I2C_RequestMemoryRead_1
   5187            {
   5188              /* Send Memory Address */
   5189              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   5190            }
   5191            /* If Memory address size is 16Bit */
   5192            else
   5193            {
   5194              /* Send MSB of Memory Address */
   5195              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
   \       0x1A   0x....'....        BL       ?Subroutine34
   5196          
   5197              /* Wait until TXIS flag is set */
   5198              if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0x1E   0xB930             CBNZ.N   R0,??I2C_RequestMemoryRead_0
   5199              {
   5200                return HAL_ERROR;
   5201              }
   5202          
   5203              /* Send LSB of Memory Address */
   5204              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \       0x20   0x....'....        BL       ?Subroutine39
   5205            }
   5206          
   5207            /* Wait until TC flag is set */
   5208            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x24   0x2140             MOVS     R1,#+64
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       I2C_WaitOnFlagUntilTimeout
   \       0x2C   0xB100             CBZ.N    R0,??I2C_RequestMemoryRead_2
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   5209            {
   5210              return HAL_ERROR;
   5211            }
   5212          
   5213            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \       0x30   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   5214          }
   5215          
   5216          /**
   5217            * @brief  I2C Address complete process callback.
   5218            * @param  hi2c I2C handle.
   5219            * @param  ITFlags Interrupt flags to handle.
   5220            * @retval None
   5221            */

   \                                 In section .text, align 2, keep-with-next
   5222          static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5223          {
   \                     I2C_ITAddrCplt: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine86
   5224            uint8_t transferdirection;
   5225            uint16_t slaveaddrcode;
   5226            uint16_t ownadd1code;
   5227            uint16_t ownadd2code;
   5228          
   5229            /* Prevent unused argument(s) compilation warning */
   5230            UNUSED(ITFlags);
   5231          
   5232            /* In case of Listen state, need to inform upper layer of address match code event */
   5233            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??CrossCallReturnLabel_197: (+1)
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x7869             LDRB     R1,[R5, #+1]
   \        0xC   0xF001 0x0128      AND      R1,R1,#0x28
   \       0x10   0x2928             CMP      R1,#+40
   \       0x12   0xD136             BNE.N    ??I2C_ITAddrCplt_0
   5234            {
   5235              transferdirection = I2C_GET_DIR(hi2c);
   \       0x14   0x6986             LDR      R6,[R0, #+24]
   5236              slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
   \       0x16   0x6981             LDR      R1,[R0, #+24]
   5237              ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
   \       0x18   0x6882             LDR      R2,[R0, #+8]
   5238              ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
   \       0x1A   0x68C7             LDR      R7,[R0, #+12]
   \       0x1C   0x0C09             LSRS     R1,R1,#+16
   \       0x1E   0xF001 0x08FE      AND      R8,R1,#0xFE
   5239          
   5240              /* If 10bits addressing mode is selected */
   5241              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0x22   0x68E1             LDR      R1,[R4, #+12]
   \       0x24   0x0C36             LSRS     R6,R6,#+16
   \       0x26   0x2902             CMP      R1,#+2
   \       0x28   0xF006 0x0601      AND      R6,R6,#0x1
   \       0x2C   0xF3C2 0x0209      UBFX     R2,R2,#+0,#+10
   \       0x30   0xF007 0x07FE      AND      R7,R7,#0xFE
   \       0x34   0xD119             BNE.N    ??I2C_ITAddrCplt_1
   5242              {
   5243                if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
   \       0x36   0x09D1             LSRS     R1,R2,#+7
   \       0x38   0xF008 0x0306      AND      R3,R8,#0x6
   \       0x3C   0xF001 0x0106      AND      R1,R1,#0x6
   \       0x40   0x428B             CMP      R3,R1
   \       0x42   0xD10B             BNE.N    ??I2C_ITAddrCplt_2
   5244                {
   5245                  slaveaddrcode = ownadd1code;
   5246                  hi2c->AddrEventCount++;
   \       0x44   0x68A9             LDR      R1,[R5, #+8]
   \       0x46   0x1C49             ADDS     R1,R1,#+1
   \       0x48   0x60A9             STR      R1,[R5, #+8]
   5247                  if (hi2c->AddrEventCount == 2U)
   \       0x4A   0x68A9             LDR      R1,[R5, #+8]
   \       0x4C   0x2902             CMP      R1,#+2
   \       0x4E   0xD11C             BNE.N    ??I2C_ITAddrCplt_3
   5248                  {
   5249                    /* Reset Address Event counter */
   5250                    hi2c->AddrEventCount = 0U;
   \       0x50   0x2300             MOVS     R3,#+0
   \       0x52   0x60AB             STR      R3,[R5, #+8]
   5251          
   5252                    /* Clear ADDR flag */
   5253                    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0x54   0x2708             MOVS     R7,#+8
   \       0x56   0x61C7             STR      R7,[R0, #+28]
   5254          
   5255                    /* Process Unlocked */
   5256                    __HAL_UNLOCK(hi2c);
   \       0x58   0x702B             STRB     R3,[R5, #+0]
   5257          
   5258                    /* Call Slave Addr callback */
   5259          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5260                    hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
   5261          #else
   5262                    HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
   \       0x5A   0xE00C             B.N      ??I2C_ITAddrCplt_4
   5263          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5264                  }
   5265                }
   5266                else
   5267                {
   5268                  slaveaddrcode = ownadd2code;
   5269          
   5270                  /* Disable ADDR Interrupts */
   5271                  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \                     ??I2C_ITAddrCplt_2: (+1)
   \       0x5C   0x2104             MOVS     R1,#+4
   \       0x5E   0x....'....        BL       ??Subroutine29_0
   5272          
   5273                  /* Process Unlocked */
   5274                  __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_50: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x7028             STRB     R0,[R5, #+0]
   5275          
   5276                  /* Call Slave Addr callback */
   5277          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5278                  hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
   5279          #else
   5280                  HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
   \       0x66   0x463A             MOV      R2,R7
   \       0x68   0xE005             B.N      ??I2C_ITAddrCplt_4
   5281          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5282                }
   5283              }
   5284              /* else 7 bits addressing mode is selected */
   5285              else
   5286              {
   5287                /* Disable ADDR Interrupts */
   5288                I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
   \                     ??I2C_ITAddrCplt_1: (+1)
   \       0x6A   0x2104             MOVS     R1,#+4
   \       0x6C   0x....'....        BL       ??Subroutine29_0
   5289          
   5290                /* Process Unlocked */
   5291                __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_49: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7028             STRB     R0,[R5, #+0]
   5292          
   5293                /* Call Slave Addr callback */
   5294          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5295                hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
   5296          #else
   5297                HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
   \       0x74   0x4642             MOV      R2,R8
   \                     ??I2C_ITAddrCplt_4: (+1)
   \       0x76   0x4631             MOV      R1,R6
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x7E   0x....'....        B.W      HAL_I2C_AddrCallback
   5298          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5299              }
   5300            }
   5301            /* Else clear address flag only */
   5302            else
   5303            {
   5304              /* Clear ADDR flag */
   5305              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??I2C_ITAddrCplt_0: (+1)
   \       0x82   0x2108             MOVS     R1,#+8
   \       0x84   0x61C1             STR      R1,[R0, #+28]
   5306          
   5307              /* Process Unlocked */
   5308              __HAL_UNLOCK(hi2c);
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x7028             STRB     R0,[R5, #+0]
   5309            }
   5310          }
   \                     ??I2C_ITAddrCplt_3: (+1)
   \       0x8A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   5311          
   5312          /**
   5313            * @brief  I2C Master sequential complete process.
   5314            * @param  hi2c I2C handle.
   5315            * @retval None
   5316            */

   \                                 In section .text, align 2, keep-with-next
   5317          static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
   5318          {
   \                     I2C_ITMasterSeqCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....'....        BL       ?Subroutine86
   5319            /* Reset I2C handle mode */
   5320            hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??CrossCallReturnLabel_198: (+1)
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x70A8             STRB     R0,[R5, #+2]
   5321          
   5322            /* No Generate Stop, to permit restart mode */
   5323            /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
   5324            if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \        0xA   0x7869             LDRB     R1,[R5, #+1]
   \        0xC   0x2921             CMP      R1,#+33
   \        0xE   0xD10B             BNE.N    ??I2C_ITMasterSeqCplt_0
   5325            {
   5326              hi2c->State         = HAL_I2C_STATE_READY;
   \       0x10   0x2020             MOVS     R0,#+32
   \       0x12   0x7068             STRB     R0,[R5, #+1]
   5327              hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   \       0x14   0x2111             MOVS     R1,#+17
   \       0x16   0x6321             STR      R1,[R4, #+48]
   5328              hi2c->XferISR       = NULL;
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x6362             STR      R2,[R4, #+52]
   5329          
   5330              /* Disable Interrupts */
   5331              I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x....'....        BL       ??Subroutine29_0
   5332          
   5333              /* Process Unlocked */
   5334              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x702A             STRB     R2,[R5, #+0]
   5335          
   5336              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5337          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5338              hi2c->MasterTxCpltCallback(hi2c);
   5339          #else
   5340              HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x26   0x....             B.N      ?Subroutine5
   5341          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5342            }
   5343            /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
   5344            else
   5345            {
   5346              hi2c->State         = HAL_I2C_STATE_READY;
   \                     ??I2C_ITMasterSeqCplt_0: (+1)
   \       0x28   0x2020             MOVS     R0,#+32
   \       0x2A   0x7068             STRB     R0,[R5, #+1]
   5347              hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \       0x2C   0x2112             MOVS     R1,#+18
   \       0x2E   0x6321             STR      R1,[R4, #+48]
   5348              hi2c->XferISR       = NULL;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6360             STR      R0,[R4, #+52]
   5349          
   5350              /* Disable Interrupts */
   5351              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x34   0x....'....        BL       ?Subroutine29
   5352          
   5353              /* Process Unlocked */
   5354              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x7028             STRB     R0,[R5, #+0]
   5355          
   5356              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5357          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5358              hi2c->MasterRxCpltCallback(hi2c);
   5359          #else
   5360              HAL_I2C_MasterRxCpltCallback(hi2c);
   \       0x3C                      REQUIRE ?Subroutine4
   \       0x3C                      ;; // Fall through to label ?Subroutine4
   5361          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5362            }
   5363          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \        0x6   0x....'....        B.W      HAL_I2C_MasterRxCpltCallback

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \        0x6   0x....'....        B.W      HAL_I2C_MasterTxCpltCallback
   5364          
   5365          /**
   5366            * @brief  I2C Slave sequential complete process.
   5367            * @param  hi2c I2C handle.
   5368            * @retval None
   5369            */

   \                                 In section .text, align 2, keep-with-next
   5370          static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
   5371          {
   \                     I2C_ITSlaveSeqCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5372            /* Reset I2C handle mode */
   5373            hi2c->Mode = HAL_I2C_MODE_NONE;
   \        0x4   0xF104 0x0530      ADD      R5,R4,#+48
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x74A8             STRB     R0,[R5, #+18]
   5374          
   5375            if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \        0xC   0x7C69             LDRB     R1,[R5, #+17]
   \        0xE   0x2929             CMP      R1,#+41
   \       0x10   0xD10D             BNE.N    ??I2C_ITSlaveSeqCplt_0
   5376            {
   5377              /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
   5378              hi2c->State         = HAL_I2C_STATE_LISTEN;
   \       0x12   0x2228             MOVS     R2,#+40
   \       0x14   0x746A             STRB     R2,[R5, #+17]
   5379              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \       0x16   0x2321             MOVS     R3,#+33
   \       0x18   0x602B             STR      R3,[R5, #+0]
   5380          
   5381              /* Disable Interrupts */
   5382              I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x....'....        BL       ??Subroutine29_0
   5383          
   5384              /* Process Unlocked */
   5385              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_47: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x742A             STRB     R2,[R5, #+16]
   5386          
   5387              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5388          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5389              hi2c->SlaveTxCpltCallback(hi2c);
   5390          #else
   5391              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x2A   0x....'....        B.W      HAL_I2C_SlaveTxCpltCallback
   5392          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5393            }
   5394          
   5395            else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??I2C_ITSlaveSeqCplt_0: (+1)
   \       0x2E   0x7C68             LDRB     R0,[R5, #+17]
   \       0x30   0x282A             CMP      R0,#+42
   \       0x32   0xD10C             BNE.N    ??I2C_ITSlaveSeqCplt_1
   5396            {
   5397              /* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN */
   5398              hi2c->State         = HAL_I2C_STATE_LISTEN;
   \       0x34   0x2128             MOVS     R1,#+40
   \       0x36   0x7469             STRB     R1,[R5, #+17]
   5399              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   \       0x38   0x2022             MOVS     R0,#+34
   \       0x3A   0x6028             STR      R0,[R5, #+0]
   5400          
   5401              /* Disable Interrupts */
   5402              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
   \       0x3C   0x....'....        BL       ?Subroutine29
   5403          
   5404              /* Process Unlocked */
   5405              __HAL_UNLOCK(hi2c);
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7428             STRB     R0,[R5, #+16]
   5406          
   5407              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5408          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5409              hi2c->SlaveRxCpltCallback(hi2c);
   5410          #else
   5411              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x4A   0x....'....        B.W      HAL_I2C_SlaveRxCpltCallback
   5412          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5413            }
   5414            else
   5415            {
   5416              /* Nothing to do */
   5417            }
   5418          }
   \                     ??I2C_ITSlaveSeqCplt_1: (+1)
   \       0x4E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5419          
   5420          /**
   5421            * @brief  I2C Master complete process.
   5422            * @param  hi2c I2C handle.
   5423            * @param  ITFlags Interrupt flags to handle.
   5424            * @retval None
   5425            */

   \                                 In section .text, align 2, keep-with-next
   5426          static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5427          {
   \                     I2C_ITMasterCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5428            uint32_t tmperror;
   5429          
   5430            /* Clear STOP Flag */
   5431            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x6822             LDR      R2,[R4, #+0]
   \        0x8   0x61D0             STR      R0,[R2, #+28]
   5432          
   5433            /* Clear Configuration Register 2 */
   5434            I2C_RESET_CR2(hi2c);
   5435          
   5436            /* Reset handle parameters */
   5437            hi2c->PreviousState = I2C_STATE_NONE;
   5438            hi2c->XferISR       = NULL;
   5439            hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   5440          
   5441            if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET)
   \        0xA   0xF104 0x0540      ADD      R5,R4,#+64
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0x....'....        LDR.W    R0,??DataTable43_2  ;; 0xfe00e800
   \       0x14   0x6853             LDR      R3,[R2, #+4]
   \       0x16   0x4003             ANDS     R3,R0,R3
   \       0x18   0x6053             STR      R3,[R2, #+4]
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x6322             STR      R2,[R4, #+48]
   \       0x1E   0x6362             STR      R2,[R4, #+52]
   \       0x20   0x06C8             LSLS     R0,R1,#+27
   \       0x22   0x....'....        LDR.W    R2,??DataTable43  ;; 0xffff0000
   \       0x26   0x62E2             STR      R2,[R4, #+44]
   \       0x28   0xD501             BPL.N    ??CrossCallReturnLabel_110
   5442            {
   5443              /* Clear NACK Flag */
   5444              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x2A   0x....'....        BL       ?Subroutine52
   5445          
   5446              /* Set acknowledge error code */
   5447              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   5448            }
   5449          
   5450            /* Flush TX register */
   5451            I2C_Flush_TXDR(hi2c);
   \                     ??CrossCallReturnLabel_110: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        BL       I2C_Flush_TXDR
   5452          
   5453            /* Disable Interrupts */
   5454            I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_RX_IT);
   \       0x34   0x2103             MOVS     R1,#+3
   \       0x36   0x....'....        BL       ??Subroutine29_0
   5455          
   5456            /* Store current volatile hi2c->ErrorCode, misra rule */
   5457            tmperror = hi2c->ErrorCode;
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x3A   0x6868             LDR      R0,[R5, #+4]
   5458          
   5459            /* Call the corresponding callback to inform upper layer of End of Transfer */
   5460            if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
   \       0x3C   0x7869             LDRB     R1,[R5, #+1]
   \       0x3E   0x2960             CMP      R1,#+96
   \       0x40   0xD000             BEQ.N    ??I2C_ITMasterCplt_0
   \       0x42   0xB110             CBZ.N    R0,??I2C_ITMasterCplt_1
   5461            {
   5462              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5463              I2C_ITError(hi2c, hi2c->ErrorCode);
   \                     ??I2C_ITMasterCplt_0: (+1)
   \       0x44   0x6869             LDR      R1,[R5, #+4]
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x....             B.N      ?Subroutine3
   5464            }
   5465            /* hi2c->State == HAL_I2C_STATE_BUSY_TX */
   5466            else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \                     ??I2C_ITMasterCplt_1: (+1)
   \       0x4A   0x7868             LDRB     R0,[R5, #+1]
   \       0x4C   0x2821             CMP      R0,#+33
   \       0x4E   0xD10E             BNE.N    ??I2C_ITMasterCplt_2
   5467            {
   5468              hi2c->State = HAL_I2C_STATE_READY;
   \       0x50   0x2120             MOVS     R1,#+32
   \       0x52   0x7069             STRB     R1,[R5, #+1]
   5469          
   5470              if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0x54   0x78A8             LDRB     R0,[R5, #+2]
   \       0x56   0x2840             CMP      R0,#+64
   \       0x58   0xD106             BNE.N    ??I2C_ITMasterCplt_3
   5471              {
   5472                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x5A   0x....'....        BL       ?Subroutine20
   5473          
   5474                /* Process Unlocked */
   5475                __HAL_UNLOCK(hi2c);
   5476          
   5477                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5478          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5479                hi2c->MemTxCpltCallback(hi2c);
   5480          #else
   5481                HAL_I2C_MemTxCpltCallback(hi2c);
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x64   0x....'....        B.W      HAL_I2C_MemTxCpltCallback
   5482          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5483              }
   5484              else
   5485              {
   5486                hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_ITMasterCplt_3: (+1)
   \       0x68   0x....'....        BL       ?Subroutine20
   5487          
   5488                /* Process Unlocked */
   5489                __HAL_UNLOCK(hi2c);
   5490          
   5491                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5492          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5493                hi2c->MasterTxCpltCallback(hi2c);
   5494          #else
   5495                HAL_I2C_MasterTxCpltCallback(hi2c);
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x6C   0x....             B.N      ?Subroutine5
   5496          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5497              }
   5498            }
   5499            /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
   5500            else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \                     ??I2C_ITMasterCplt_2: (+1)
   \       0x6E   0x7868             LDRB     R0,[R5, #+1]
   \       0x70   0x2822             CMP      R0,#+34
   \       0x72   0xD10E             BNE.N    ??I2C_ITMasterCplt_4
   5501            {
   5502              hi2c->State = HAL_I2C_STATE_READY;
   \       0x74   0x2120             MOVS     R1,#+32
   \       0x76   0x7069             STRB     R1,[R5, #+1]
   5503          
   5504              if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0x78   0x78A8             LDRB     R0,[R5, #+2]
   \       0x7A   0x2840             CMP      R0,#+64
   \       0x7C   0xD106             BNE.N    ??I2C_ITMasterCplt_5
   5505              {
   5506                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x7E   0x....'....        BL       ?Subroutine20
   5507          
   5508                /* Process Unlocked */
   5509                __HAL_UNLOCK(hi2c);
   5510          
   5511                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5512          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5513                hi2c->MemRxCpltCallback(hi2c);
   5514          #else
   5515                HAL_I2C_MemRxCpltCallback(hi2c);
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x82   0x4620             MOV      R0,R4
   \       0x84   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x88   0x....'....        B.W      HAL_I2C_MemRxCpltCallback
   5516          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5517              }
   5518              else
   5519              {
   5520                hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_ITMasterCplt_5: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine20
   5521          
   5522                /* Process Unlocked */
   5523                __HAL_UNLOCK(hi2c);
   5524          
   5525                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5526          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5527                hi2c->MasterRxCpltCallback(hi2c);
   5528          #else
   5529                HAL_I2C_MasterRxCpltCallback(hi2c);
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x90   0x....             B.N      ?Subroutine4
   5530          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5531              }
   5532            }
   5533            else
   5534            {
   5535              /* Nothing to do */
   5536            }
   5537          }
   \                     ??I2C_ITMasterCplt_4: (+1)
   \       0x92   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x70A9             STRB     R1,[R5, #+2]
   \        0x4   0x7029             STRB     R1,[R5, #+0]
   \        0x6   0x4770             BX       LR
   5538          
   5539          /**
   5540            * @brief  I2C Slave complete process.
   5541            * @param  hi2c I2C handle.
   5542            * @param  ITFlags Interrupt flags to handle.
   5543            * @retval None
   5544            */

   \                                 In section .text, align 2, keep-with-next
   5545          static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5546          {
   \                     I2C_ITSlaveCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   5547            uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
   5548            uint32_t tmpITFlags = ITFlags;
   5549          
   5550            /* Clear STOP Flag */
   5551            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x6806             LDR      R6,[R0, #+0]
   \        0xA   0x61C2             STR      R2,[R0, #+28]
   \        0xC   0x460D             MOV      R5,R1
   5552          
   5553            /* Disable all interrupts */
   5554            I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
   \        0xE   0x2107             MOVS     R1,#+7
   \       0x10   0x....'....        BL       ??Subroutine29_0
   5555          
   5556            /* Disable Address Acknowledge */
   5557            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....'....        BL       ??Subroutine51_1
   5558          
   5559            /* Clear Configuration Register 2 */
   5560            I2C_RESET_CR2(hi2c);
   \                     ??CrossCallReturnLabel_108: (+1)
   \       0x1A   0x....'....        LDR.W    R0,??DataTable43_2  ;; 0xfe00e800
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x684A             LDR      R2,[R1, #+4]
   \       0x22   0x4002             ANDS     R2,R0,R2
   \       0x24   0x604A             STR      R2,[R1, #+4]
   5561          
   5562            /* Flush TX register */
   5563            I2C_Flush_TXDR(hi2c);
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       I2C_Flush_TXDR
   5564          
   5565            /* If a DMA is ongoing, Update handle size context */
   5566            if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
   \       0x2C   0x0470             LSLS     R0,R6,#+17
   \       0x2E   0xBF48             IT       MI
   \       0x30   0x6BA0             LDRMI    R0,[R4, #+56]
   5567            {
   5568              if (hi2c->hdmatx != NULL)
   \       0x32   0xD402             BMI.N    ??I2C_ITSlaveCplt_0
   5569              {
   5570                hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
   5571              }
   5572            }
   5573            else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
   \       0x34   0x0430             LSLS     R0,R6,#+16
   \       0x36   0xD504             BPL.N    ??I2C_ITSlaveCplt_1
   5574            {
   5575              if (hi2c->hdmarx != NULL)
   \       0x38   0x6BE0             LDR      R0,[R4, #+60]
   \                     ??I2C_ITSlaveCplt_0: (+1)
   \       0x3A   0xB110             CBZ.N    R0,??I2C_ITSlaveCplt_1
   5576              {
   5577                hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0x6841             LDR      R1,[R0, #+4]
   \       0x40   0x8561             STRH     R1,[R4, #+42]
   5578              }
   5579            }
   5580            else
   5581            {
   5582              /* Do nothing */
   5583            }
   5584          
   5585            /* Store Last receive data if any */
   5586            if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
   \                     ??I2C_ITSlaveCplt_1: (+1)
   \       0x42   0x0768             LSLS     R0,R5,#+29
   \       0x44   0xD50C             BPL.N    ??CrossCallReturnLabel_237
   5587            {
   5588              /* Remove RXNE flag on temporary variable as read done */
   5589              tmpITFlags &= ~I2C_FLAG_RXNE;
   5590          
   5591              /* Read data from RXDR */
   5592              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6A48             LDR      R0,[R1, #+36]
   \       0x4A   0x6A61             LDR      R1,[R4, #+36]
   \       0x4C   0x7008             STRB     R0,[R1, #+0]
   \       0x4E   0xF025 0x0504      BIC      R5,R5,#0x4
   5593          
   5594              /* Increment Buffer pointer */
   5595              hi2c->pBuffPtr++;
   \       0x52   0x6A60             LDR      R0,[R4, #+36]
   \       0x54   0x1C42             ADDS     R2,R0,#+1
   5596          
   5597              if ((hi2c->XferSize > 0U))
   \       0x56   0x8D20             LDRH     R0,[R4, #+40]
   \       0x58   0x6262             STR      R2,[R4, #+36]
   \       0x5A   0xB108             CBZ.N    R0,??CrossCallReturnLabel_237
   5598              {
   5599                hi2c->XferSize--;
   \       0x5C   0x....'....        BL       ?Subroutine99
   5600                hi2c->XferCount--;
   5601              }
   5602            }
   5603          
   5604            /* All data are not transferred, so set error code accordingly */
   5605            if (hi2c->XferCount != 0U)
   \                     ??CrossCallReturnLabel_237: (+1)
   \       0x60   0xF104 0x0640      ADD      R6,R4,#+64
   \       0x64   0x8D60             LDRH     R0,[R4, #+42]
   \       0x66   0xB118             CBZ.N    R0,??I2C_ITSlaveCplt_2
   5606            {
   5607              /* Set ErrorCode corresponding to a Non-Acknowledge */
   5608              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x68   0x6870             LDR      R0,[R6, #+4]
   \       0x6A   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x6E   0x6070             STR      R0,[R6, #+4]
   5609            }
   5610          
   5611            hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_ITSlaveCplt_2: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6320             STR      R0,[R4, #+48]
   5612            hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x74   0x70B0             STRB     R0,[R6, #+2]
   5613            hi2c->XferISR = NULL;
   \       0x76   0x2200             MOVS     R2,#+0
   \       0x78   0x6362             STR      R2,[R4, #+52]
   5614          
   5615            if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \       0x7A   0x6870             LDR      R0,[R6, #+4]
   \       0x7C   0xB158             CBZ.N    R0,??I2C_ITSlaveCplt_3
   5616            {
   5617              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5618              I2C_ITError(hi2c, hi2c->ErrorCode);
   \       0x7E   0x6871             LDR      R1,[R6, #+4]
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0x....'....        BL       I2C_ITError
   5619          
   5620              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   5621              if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \       0x86   0x7870             LDRB     R0,[R6, #+1]
   \       0x88   0x2828             CMP      R0,#+40
   \       0x8A   0xD129             BNE.N    ??I2C_ITSlaveCplt_4
   5622              {
   5623                /* Call I2C Listen complete process */
   5624                I2C_ITListenCplt(hi2c, tmpITFlags);
   \       0x8C   0x4629             MOV      R1,R5
   \       0x8E   0x4620             MOV      R0,R4
   \       0x90   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x94   0x....             B.N      I2C_ITListenCplt
   5625              }
   5626            }
   5627            else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
   \                     ??I2C_ITSlaveCplt_3: (+1)
   \       0x96   0x6AE0             LDR      R0,[R4, #+44]
   \       0x98   0x....'....        LDR.W    R5,??DataTable43  ;; 0xffff0000
   \       0x9C   0x42A8             CMP      R0,R5
   \       0x9E   0xD00C             BEQ.N    ??I2C_ITSlaveCplt_5
   5628            {
   5629              /* Call the Sequential Complete callback, to inform upper layer of the end of Tranfer */
   5630              I2C_ITSlaveSeqCplt(hi2c);
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x....'....        BL       I2C_ITSlaveSeqCplt
   5631          
   5632              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xA6   0x62E5             STR      R5,[R4, #+44]
   5633              hi2c->State = HAL_I2C_STATE_READY;
   \       0xA8   0x2020             MOVS     R0,#+32
   \       0xAA   0x7070             STRB     R0,[R6, #+1]
   5634          
   5635              /* Process Unlocked */
   5636              __HAL_UNLOCK(hi2c);
   \       0xAC   0x2100             MOVS     R1,#+0
   \       0xAE   0x7031             STRB     R1,[R6, #+0]
   5637          
   5638              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   5639          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5640              hi2c->ListenCpltCallback(hi2c);
   5641          #else
   5642              HAL_I2C_ListenCpltCallback(hi2c);
   \       0xB0   0x4620             MOV      R0,R4
   \       0xB2   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xB6   0x....'....        B.W      HAL_I2C_ListenCpltCallback
   5643          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5644            }
   5645            /* Call the corresponding callback to inform upper layer of End of Transfer */
   5646            else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \                     ??I2C_ITSlaveCplt_5: (+1)
   \       0xBA   0x7870             LDRB     R0,[R6, #+1]
   \       0xBC   0x2822             CMP      R0,#+34
   \       0xBE   0xD107             BNE.N    ??I2C_ITSlaveCplt_6
   5647            {
   5648              hi2c->State = HAL_I2C_STATE_READY;
   \       0xC0   0x2120             MOVS     R1,#+32
   \       0xC2   0x7071             STRB     R1,[R6, #+1]
   5649          
   5650              /* Process Unlocked */
   5651              __HAL_UNLOCK(hi2c);
   \       0xC4   0x7032             STRB     R2,[R6, #+0]
   5652          
   5653              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5654          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5655              hi2c->SlaveRxCpltCallback(hi2c);
   5656          #else
   5657              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0xC6   0x4620             MOV      R0,R4
   \       0xC8   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xCC   0x....'....        B.W      HAL_I2C_SlaveRxCpltCallback
   5658          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5659            }
   5660            else
   5661            {
   5662              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_ITSlaveCplt_6: (+1)
   \       0xD0   0x2120             MOVS     R1,#+32
   \       0xD2   0x7071             STRB     R1,[R6, #+1]
   5663          
   5664              /* Process Unlocked */
   5665              __HAL_UNLOCK(hi2c);
   \       0xD4   0x7032             STRB     R2,[R6, #+0]
   5666          
   5667              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5668          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5669              hi2c->SlaveTxCpltCallback(hi2c);
   5670          #else
   5671              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0xD6   0x4620             MOV      R0,R4
   \       0xD8   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xDC   0x....'....        B.W      HAL_I2C_SlaveTxCpltCallback
   5672          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5673            }
   5674          }
   \                     ??I2C_ITSlaveCplt_4: (+1)
   \       0xE0   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine99: (+1)
   \        0x0   0x1E40             SUBS     R0,R0,#+1
   \        0x2   0x8520             STRH     R0,[R4, #+40]
   \        0x4   0x8D61             LDRH     R1,[R4, #+42]
   \        0x6   0x1E48             SUBS     R0,R1,#+1
   \        0x8   0x8560             STRH     R0,[R4, #+42]
   \        0xA   0x4770             BX       LR
   5675          
   5676          /**
   5677            * @brief  I2C Listen complete process.
   5678            * @param  hi2c I2C handle.
   5679            * @param  ITFlags Interrupt flags to handle.
   5680            * @retval None
   5681            */

   \                                 In section .text, align 2, keep-with-next
   5682          static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
   5683          {
   \                     I2C_ITListenCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   5684            /* Reset handle parameters */
   5685            hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \        0x4   0x....'....        LDR.W    R0,??DataTable43  ;; 0xffff0000
   \        0x8   0x62E0             STR      R0,[R4, #+44]
   5686            hi2c->PreviousState = I2C_STATE_NONE;
   \        0xA   0x2200             MOVS     R2,#+0
   5687            hi2c->State = HAL_I2C_STATE_READY;
   \        0xC   0xF104 0x0540      ADD      R5,R4,#+64
   \       0x10   0x6322             STR      R2,[R4, #+48]
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0x7068             STRB     R0,[R5, #+1]
   5688            hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x16   0x70AA             STRB     R2,[R5, #+2]
   5689            hi2c->XferISR = NULL;
   5690          
   5691            /* Store Last receive data if any */
   5692            if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
   \       0x18   0x0749             LSLS     R1,R1,#+29
   \       0x1A   0x6362             STR      R2,[R4, #+52]
   \       0x1C   0xD50E             BPL.N    ??I2C_ITListenCplt_0
   5693            {
   5694              /* Read data from RXDR */
   5695              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6A41             LDR      R1,[R0, #+36]
   \       0x22   0x6A60             LDR      R0,[R4, #+36]
   \       0x24   0x7001             STRB     R1,[R0, #+0]
   5696          
   5697              /* Increment Buffer pointer */
   5698              hi2c->pBuffPtr++;
   \       0x26   0x6A61             LDR      R1,[R4, #+36]
   5699          
   5700              if ((hi2c->XferSize > 0U))
   \       0x28   0x8D20             LDRH     R0,[R4, #+40]
   \       0x2A   0x1C4A             ADDS     R2,R1,#+1
   \       0x2C   0x6262             STR      R2,[R4, #+36]
   \       0x2E   0xB128             CBZ.N    R0,??I2C_ITListenCplt_0
   5701              {
   5702                hi2c->XferSize--;
   \       0x30   0x....'....        BL       ?Subroutine99
   5703                hi2c->XferCount--;
   5704          
   5705                /* Set ErrorCode corresponding to a Non-Acknowledge */
   5706                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \                     ??CrossCallReturnLabel_238: (+1)
   \       0x34   0x6869             LDR      R1,[R5, #+4]
   \       0x36   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x3A   0x6069             STR      R1,[R5, #+4]
   5707              }
   5708            }
   5709          
   5710            /* Disable all Interrupts*/
   5711            I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
   \                     ??I2C_ITListenCplt_0: (+1)
   \       0x3C   0x2107             MOVS     R1,#+7
   \       0x3E   0x....'....        BL       ??Subroutine29_0
   5712          
   5713            /* Clear NACK Flag */
   5714            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x2210             MOVS     R2,#+16
   \       0x46   0x61C2             STR      R2,[R0, #+28]
   5715          
   5716            /* Process Unlocked */
   5717            __HAL_UNLOCK(hi2c);
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x7029             STRB     R1,[R5, #+0]
   5718          
   5719            /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   5720          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5721            hi2c->ListenCpltCallback(hi2c);
   5722          #else
   5723            HAL_I2C_ListenCpltCallback(hi2c);
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x52   0x....'....        B.W      HAL_I2C_ListenCpltCallback
   5724          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5725          }
   5726          
   5727          /**
   5728            * @brief  I2C interrupts error process.
   5729            * @param  hi2c I2C handle.
   5730            * @param  ErrorCode Error code to handle.
   5731            * @retval None
   5732            */

   \                                 In section .text, align 2, keep-with-next
   5733          static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
   5734          {
   \                     I2C_ITError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....'....        BL       ?Subroutine86
   5735            HAL_I2C_StateTypeDef tmpstate = hi2c->State;
   5736          
   5737            /* Reset handle parameters */
   5738            hi2c->Mode          = HAL_I2C_MODE_NONE;
   \                     ??CrossCallReturnLabel_199: (+1)
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   5739            hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   \        0xA   0x....'....        LDR.W    R3,??DataTable43  ;; 0xffff0000
   \        0xE   0x70AA             STRB     R2,[R5, #+2]
   \       0x10   0x62E3             STR      R3,[R4, #+44]
   5740            hi2c->XferCount     = 0U;
   \       0x12   0x8562             STRH     R2,[R4, #+42]
   5741          
   5742            /* Set new error code */
   5743            hi2c->ErrorCode |= ErrorCode;
   \       0x14   0x686B             LDR      R3,[R5, #+4]
   \       0x16   0x4319             ORRS     R1,R1,R3
   5744          
   5745            /* Disable Interrupts */
   5746            if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
   5747                (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
   5748                (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \       0x18   0x2828             CMP      R0,#+40
   \       0x1A   0xBF1C             ITT      NE
   \       0x1C   0x2829             CMPNE    R0,#+41
   \       0x1E   0x282A             CMPNE    R0,#+42
   \       0x20   0x6069             STR      R1,[R5, #+4]
   \       0x22   0xD10A             BNE.N    ??I2C_ITError_0
   5749            {
   5750              /* Disable all interrupts, except interrupts related to LISTEN state */
   5751              I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
   \       0x24   0x2103             MOVS     R1,#+3
   \       0x26   0x....'....        BL       ??Subroutine29_0
   5752          
   5753              /* keep HAL_I2C_STATE_LISTEN if set */
   5754              hi2c->State         = HAL_I2C_STATE_LISTEN;
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x2A   0x2228             MOVS     R2,#+40
   \       0x2C   0x706A             STRB     R2,[R5, #+1]
   5755              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6320             STR      R0,[R4, #+48]
   5756              hi2c->XferISR       = I2C_Slave_ISR_IT;
   \       0x32   0x....'....        LDR.W    R1,??DataTable43_3
   \       0x36   0x6361             STR      R1,[R4, #+52]
   \       0x38   0xE00A             B.N      ??I2C_ITError_1
   5757            }
   5758            else
   5759            {
   5760              /* Disable all interrupts */
   5761              I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
   \                     ??I2C_ITError_0: (+1)
   \       0x3A   0x2107             MOVS     R1,#+7
   \       0x3C   0x....'....        BL       ??Subroutine29_0
   5762          
   5763              /* If state is an abort treatment on goind, don't change state */
   5764              /* This change will be do later */
   5765              if (hi2c->State != HAL_I2C_STATE_ABORT)
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x40   0x7868             LDRB     R0,[R5, #+1]
   \       0x42   0x2860             CMP      R0,#+96
   \       0x44   0xBF1C             ITT      NE
   \       0x46   0x2120             MOVNE    R1,#+32
   \       0x48   0x7069             STRBNE   R1,[R5, #+1]
   5766              {
   5767                /* Set HAL_I2C_STATE_READY */
   5768                hi2c->State         = HAL_I2C_STATE_READY;
   5769              }
   5770              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x6320             STR      R0,[R4, #+48]
   5771              hi2c->XferISR       = NULL;
   \       0x4E   0x6360             STR      R0,[R4, #+52]
   5772            }
   5773          
   5774            /* Abort DMA TX transfer if any */
   5775            if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
   \                     ??I2C_ITError_1: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x....'....        ADR.W    R1,I2C_DMAAbort
   \       0x56   0x6802             LDR      R2,[R0, #+0]
   \       0x58   0x0453             LSLS     R3,R2,#+17
   \       0x5A   0x6802             LDR      R2,[R0, #+0]
   \       0x5C   0xD50D             BPL.N    ??I2C_ITError_2
   5776            {
   5777              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \       0x5E   0xF422 0x4280      BIC      R2,R2,#0x4000
   \       0x62   0x6002             STR      R2,[R0, #+0]
   5778          
   5779              if (hi2c->hdmatx != NULL)
   \       0x64   0x6BA0             LDR      R0,[R4, #+56]
   \       0x66   0xB378             CBZ.N    R0,??I2C_ITError_3
   5780              {
   5781                /* Set the I2C DMA Abort callback :
   5782                 will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   5783                hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x68   0x6341             STR      R1,[R0, #+52]
   5784          
   5785                /* Process Unlocked */
   5786                __HAL_UNLOCK(hi2c);
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x7028             STRB     R0,[R5, #+0]
   5787          
   5788                /* Abort DMA TX */
   5789                if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x6E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x70   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x74   0xB340             CBZ.N    R0,??I2C_ITError_3
   5790                {
   5791                  /* Call Directly XferAbortCallback function in case of error */
   5792                  hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0x76   0x6BA0             LDR      R0,[R4, #+56]
   \       0x78   0xE00F             B.N      ??I2C_ITError_4
   5793                }
   5794              }
   5795            }
   5796            /* Abort DMA RX transfer if any */
   5797            else if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
   \                     ??I2C_ITError_2: (+1)
   \       0x7A   0x0413             LSLS     R3,R2,#+16
   \       0x7C   0xD511             BPL.N    ??I2C_ITError_5
   5798            {
   5799              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x7E   0x6802             LDR      R2,[R0, #+0]
   \       0x80   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x84   0x6002             STR      R2,[R0, #+0]
   5800          
   5801              if (hi2c->hdmarx != NULL)
   \       0x86   0x6BE0             LDR      R0,[R4, #+60]
   \       0x88   0xB1F0             CBZ.N    R0,??I2C_ITError_3
   5802              {
   5803                /* Set the I2C DMA Abort callback :
   5804                  will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   5805                hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x8A   0x6341             STR      R1,[R0, #+52]
   5806          
   5807                /* Process Unlocked */
   5808                __HAL_UNLOCK(hi2c);
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x7028             STRB     R0,[R5, #+0]
   5809          
   5810                /* Abort DMA RX */
   5811                if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x90   0x6BE0             LDR      R0,[R4, #+60]
   \       0x92   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x96   0xB1B8             CBZ.N    R0,??I2C_ITError_3
   5812                {
   5813                  /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
   5814                  hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x98   0x6BE0             LDR      R0,[R4, #+60]
   \                     ??I2C_ITError_4: (+1)
   \       0x9A   0x6B41             LDR      R1,[R0, #+52]
   \       0x9C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0xA0   0x4708             BX       R1
   5815                }
   5816              }
   5817            }
   5818            else if (hi2c->State == HAL_I2C_STATE_ABORT)
   \                     ??I2C_ITError_5: (+1)
   \       0xA2   0x7868             LDRB     R0,[R5, #+1]
   \       0xA4   0x2860             CMP      R0,#+96
   \       0xA6   0xD108             BNE.N    ??I2C_ITError_6
   5819            {
   5820              hi2c->State = HAL_I2C_STATE_READY;
   \       0xA8   0x2120             MOVS     R1,#+32
   \       0xAA   0x7069             STRB     R1,[R5, #+1]
   5821          
   5822              /* Process Unlocked */
   5823              __HAL_UNLOCK(hi2c);
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x7028             STRB     R0,[R5, #+0]
   5824          
   5825              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5826          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5827              hi2c->AbortCpltCallback(hi2c);
   5828          #else
   5829              HAL_I2C_AbortCpltCallback(hi2c);
   \       0xB0   0x4620             MOV      R0,R4
   \       0xB2   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0xB6   0x....'....        B.W      HAL_I2C_AbortCpltCallback
   5830          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5831            }
   5832            else
   5833            {
   5834              /* Process Unlocked */
   5835              __HAL_UNLOCK(hi2c);
   \                     ??I2C_ITError_6: (+1)
   \       0xBA   0x2100             MOVS     R1,#+0
   \       0xBC   0x7029             STRB     R1,[R5, #+0]
   5836          
   5837              /* Call the corresponding callback to inform upper layer of End of Transfer */
   5838          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5839              hi2c->ErrorCallback(hi2c);
   5840          #else
   5841              HAL_I2C_ErrorCallback(hi2c);
   \       0xBE   0x4620             MOV      R0,R4
   \       0xC0   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0xC4   0x....'....        B.W      HAL_I2C_ErrorCallback
   5842          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5843            }
   5844          }
   \                     ??I2C_ITError_3: (+1)
   \       0xC8   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5845          
   5846          /**
   5847            * @brief  I2C Tx data register flush process.
   5848            * @param  hi2c I2C handle.
   5849            * @retval None
   5850            */

   \                                 In section .text, align 2, keep-with-next
   5851          static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
   5852          {
   5853            /* If a pending TXIS flag is set */
   5854            /* Write a dummy data in TXDR to clear it */
   5855            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
   \                     I2C_Flush_TXDR: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6981             LDR      R1,[R0, #+24]
   \        0x4   0x078A             LSLS     R2,R1,#+30
   \        0x6   0xBF44             ITT      MI
   \        0x8   0x2100             MOVMI    R1,#+0
   \        0xA   0x6281             STRMI    R1,[R0, #+40]
   5856            {
   5857              hi2c->Instance->TXDR = 0x00U;
   5858            }
   5859          
   5860            /* Flush TX register if not empty */
   5861            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \        0xC   0x6981             LDR      R1,[R0, #+24]
   \        0xE   0x07CA             LSLS     R2,R1,#+31
   \       0x10   0xD403             BMI.N    ??I2C_Flush_TXDR_0
   5862            {
   5863              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
   \       0x12   0x6981             LDR      R1,[R0, #+24]
   \       0x14   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0x18   0x6181             STR      R1,[R0, #+24]
   5864            }
   5865          }
   \                     ??I2C_Flush_TXDR_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   5866          
   5867          /**
   5868            * @brief  DMA I2C master transmit process complete callback.
   5869            * @param  hdma DMA handle
   5870            * @retval None
   5871            */

   \                                 In section .text, align 2, keep-with-next
   5872          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
   5873          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5874            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A44             LDR      R4,[R0, #+36]
   5875          
   5876            /* Disable DMA Request */
   5877            hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xF422 0x4280      BIC      R2,R2,#0x4000
   \        0xC   0x6002             STR      R2,[R0, #+0]
   5878          
   5879            /* If last transfer, enable STOP interrupt */
   5880            if (hi2c->XferCount == 0U)
   \        0xE   0x8D61             LDRH     R1,[R4, #+42]
   \       0x10   0xB171             CBZ.N    R1,??I2C_DMAMasterTransmitCplt_0
   5881            {
   5882              /* Enable STOP interrupt */
   5883              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   5884            }
   5885            /* else prepare a new DMA transfer and enable TCReload interrupt */
   5886            else
   5887            {
   5888              /* Update Buffer pointer */
   5889              hi2c->pBuffPtr += hi2c->XferSize;
   \       0x12   0x6A60             LDR      R0,[R4, #+36]
   \       0x14   0x8D21             LDRH     R1,[R4, #+40]
   \       0x16   0x4401             ADD      R1,R0,R1
   \       0x18   0x6261             STR      R1,[R4, #+36]
   5890          
   5891              /* Set the XferSize to transfer */
   5892              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x1A   0x....'....        BL       ?Subroutine88
   \                     ??CrossCallReturnLabel_205: (+1)
   \       0x1E   0xBF27             ITTEE    CS
   \       0x20   0x22FF             MOVCS    R2,#+255
   \       0x22   0x8522             STRHCS   R2,[R4, #+40]
   \       0x24   0x8D60             LDRHCC   R0,[R4, #+42]
   \       0x26   0x8520             STRHCC   R0,[R4, #+40]
   5893              {
   5894                hi2c->XferSize = MAX_NBYTE_SIZE;
   5895              }
   5896              else
   5897              {
   5898                hi2c->XferSize = hi2c->XferCount;
   5899              }
   5900          
   5901              /* Enable the DMA channel */
   5902              if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
   \       0x28   0x....'....        BL       ?Subroutine36
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0x2C   0xB100             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_0
   5903              {
   5904                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5905                I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
   \       0x2E   0x....             B.N      ?Subroutine7
   5906              }
   5907              else
   5908              {
   5909                /* Enable TC interrupts */
   5910                I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \       0x30   0x....             B.N      ?Subroutine6
   5911              }
   5912            }
   5913          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0xE8BD 0x4010      POP      {R4,LR}
   \        0x6   0x2112             MOVS     R1,#+18
   \        0x8   0x....             B.N      I2C_Enable_IRQ

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0xE8BD 0x4010      POP      {R4,LR}
   \                     ??Subroutine7_0: (+1)
   \        0x6   0x2110             MOVS     R1,#+16
   \        0x8   0x....             B.N      I2C_ITError
   5914          
   5915          /**
   5916            * @brief  DMA I2C slave transmit process complete callback.
   5917            * @param  hdma DMA handle
   5918            * @retval None
   5919            */

   \                                 In section .text, align 2, keep-with-next
   5920          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
   5921          {
   5922            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \        0x0   0x6A40             LDR      R0,[R0, #+36]
   5923            uint32_t tmpoptions = hi2c->XferOptions;
   \        0x2   0x6AC1             LDR      R1,[R0, #+44]
   5924          
   5925            if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
   \        0x4   0xF1B1 0x7F80      CMP      R1,#+16777216
   \        0x8   0xBF18             IT       NE
   \        0xA   0x2900             CMPNE    R1,#+0
   \        0xC   0xD105             BNE.N    ??I2C_DMASlaveTransmitCplt_0
   5926            {
   5927              /* Disable DMA Request */
   5928              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x680A             LDR      R2,[R1, #+0]
   \       0x12   0xF422 0x4280      BIC      R2,R2,#0x4000
   \       0x16   0x600A             STR      R2,[R1, #+0]
   5929          
   5930              /* Last Byte is Transmitted */
   5931              /* Call I2C Slave Sequential complete process */
   5932              I2C_ITSlaveSeqCplt(hi2c);
   \       0x18   0x....             B.N      I2C_ITSlaveSeqCplt
   5933            }
   5934            else
   5935            {
   5936              /* No specific action, Master fully manage the generation of STOP condition */
   5937              /* Mean that this generation can arrive at any time, at the end or during DMA process */
   5938              /* So STOP condition should be manage through Interrupt treatment */
   5939            }
   5940          }
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
   5941          
   5942          /**
   5943            * @brief DMA I2C master receive process complete callback.
   5944            * @param  hdma DMA handle
   5945            * @retval None
   5946            */

   \                                 In section .text, align 2, keep-with-next
   5947          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
   5948          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5949            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A44             LDR      R4,[R0, #+36]
   5950          
   5951            /* Disable DMA Request */
   5952            hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xF422 0x4200      BIC      R2,R2,#0x8000
   \        0xC   0x6002             STR      R2,[R0, #+0]
   5953          
   5954            /* If last transfer, enable STOP interrupt */
   5955            if (hi2c->XferCount == 0U)
   \        0xE   0x8D61             LDRH     R1,[R4, #+42]
   \       0x10   0xB171             CBZ.N    R1,??I2C_DMAMasterReceiveCplt_0
   5956            {
   5957              /* Enable STOP interrupt */
   5958              I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
   5959            }
   5960            /* else prepare a new DMA transfer and enable TCReload interrupt */
   5961            else
   5962            {
   5963              /* Update Buffer pointer */
   5964              hi2c->pBuffPtr += hi2c->XferSize;
   \       0x12   0x6A60             LDR      R0,[R4, #+36]
   \       0x14   0x8D21             LDRH     R1,[R4, #+40]
   \       0x16   0x1842             ADDS     R2,R0,R1
   \       0x18   0x6262             STR      R2,[R4, #+36]
   5965          
   5966              /* Set the XferSize to transfer */
   5967              if (hi2c->XferCount > MAX_NBYTE_SIZE)
   \       0x1A   0x....'....        BL       ?Subroutine88
   \                     ??CrossCallReturnLabel_206: (+1)
   \       0x1E   0xBF27             ITTEE    CS
   \       0x20   0x21FF             MOVCS    R1,#+255
   \       0x22   0x8521             STRHCS   R1,[R4, #+40]
   \       0x24   0x8D60             LDRHCC   R0,[R4, #+42]
   \       0x26   0x8520             STRHCC   R0,[R4, #+40]
   5968              {
   5969                hi2c->XferSize = MAX_NBYTE_SIZE;
   5970              }
   5971              else
   5972              {
   5973                hi2c->XferSize = hi2c->XferCount;
   5974              }
   5975          
   5976              /* Enable the DMA channel */
   5977              if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
   \       0x28   0x....'....        BL       ?Subroutine37
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0x2C   0xB100             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_0
   5978              {
   5979                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5980                I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
   \       0x2E   0x....             B.N      ?Subroutine7
   5981              }
   5982              else
   5983              {
   5984                /* Enable TC interrupts */
   5985                I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \       0x30                      REQUIRE ?Subroutine6
   \       0x30                      ;; // Fall through to label ?Subroutine6
   5986              }
   5987            }
   5988          }
   5989          
   5990          /**
   5991            * @brief  DMA I2C slave receive process complete callback.
   5992            * @param  hdma DMA handle
   5993            * @retval None
   5994            */

   \                                 In section .text, align 4, keep-with-next
   5995          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
   5996          {
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5997            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x2   0x6A40             LDR      R0,[R0, #+36]
   5998            uint32_t tmpoptions = hi2c->XferOptions;
   \        0x4   0x6AC2             LDR      R2,[R0, #+44]
   5999          
   6000            if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
   6001                (tmpoptions != I2C_NO_OPTION_FRAME))
   \        0x6   0x6BC3             LDR      R3,[R0, #+60]
   \        0x8   0x681C             LDR      R4,[R3, #+0]
   \        0xA   0x6861             LDR      R1,[R4, #+4]
   \        0xC   0xB951             CBNZ.N   R1,??I2C_DMASlaveReceiveCplt_0
   \        0xE   0x....             LDR.N    R3,??DataTable43  ;; 0xffff0000
   \       0x10   0x429A             CMP      R2,R3
   \       0x12   0xD007             BEQ.N    ??I2C_DMASlaveReceiveCplt_0
   6002            {
   6003              /* Disable DMA Request */
   6004              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0xF422 0x4200      BIC      R2,R2,#0x8000
   \       0x1C   0x600A             STR      R2,[R1, #+0]
   6005          
   6006              /* Call I2C Slave Sequential complete process */
   6007              I2C_ITSlaveSeqCplt(hi2c);
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x....             B.N      I2C_ITSlaveSeqCplt
   6008            }
   6009            else
   6010            {
   6011              /* No specific action, Master fully manage the generation of STOP condition */
   6012              /* Mean that this generation can arrive at any time, at the end or during DMA process */
   6013              /* So STOP condition should be manage through Interrupt treatment */
   6014            }
   6015          }
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
   6016          
   6017          /**
   6018            * @brief  DMA I2C communication error callback.
   6019            * @param hdma DMA handle
   6020            * @retval None
   6021            */

   \                                 In section .text, align 4, keep-with-next
   6022          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   6023          {
   6024            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \                     I2C_DMAError: (+1)
   \        0x0   0x6A40             LDR      R0,[R0, #+36]
   6025          
   6026            /* Disable Acknowledge */
   6027            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x684A             LDR      R2,[R1, #+4]
   \        0x6   0xF442 0x4200      ORR      R2,R2,#0x8000
   \        0xA   0x604A             STR      R2,[R1, #+4]
   6028          
   6029            /* Call the corresponding callback to inform upper layer of End of Transfer */
   6030            I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
   \        0xC   0x....             B.N      ??Subroutine7_0
   6031          }
   6032          
   6033          /**
   6034            * @brief DMA I2C communication abort callback
   6035            *        (To be called at end of DMA Abort procedure).
   6036            * @param hdma DMA handle.
   6037            * @retval None
   6038            */

   \                                 In section .text, align 4, keep-with-next
   6039          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
   6040          {
   6041            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \                     I2C_DMAAbort: (+1)
   \        0x0   0x6A40             LDR      R0,[R0, #+36]
   6042          
   6043            /* Reset AbortCpltCallback */
   6044            hi2c->hdmatx->XferAbortCallback = NULL;
   \        0x2   0x6B82             LDR      R2,[R0, #+56]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6351             STR      R1,[R2, #+52]
   6045            hi2c->hdmarx->XferAbortCallback = NULL;
   \        0x8   0x6BC2             LDR      R2,[R0, #+60]
   \        0xA   0x6351             STR      R1,[R2, #+52]
   6046          
   6047            /* Check if come from abort from user */
   6048            if (hi2c->State == HAL_I2C_STATE_ABORT)
   \        0xC   0xF890 0x1041      LDRB     R1,[R0, #+65]
   \       0x10   0x2960             CMP      R1,#+96
   \       0x12   0xBF18             IT       NE
   6049            {
   6050              hi2c->State = HAL_I2C_STATE_READY;
   6051          
   6052              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6053          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6054              hi2c->AbortCpltCallback(hi2c);
   6055          #else
   6056              HAL_I2C_AbortCpltCallback(hi2c);
   6057          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6058            }
   6059            else
   6060            {
   6061              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6062          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6063              hi2c->ErrorCallback(hi2c);
   6064          #else
   6065              HAL_I2C_ErrorCallback(hi2c);
   \       0x14   0x....'....        BNE.W    HAL_I2C_ErrorCallback
   6066          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6067            }
   \       0x18   0x2220             MOVS     R2,#+32
   \       0x1A   0xF880 0x2041      STRB     R2,[R0, #+65]
   \       0x1E   0x....'....        B.W      HAL_I2C_AbortCpltCallback
   6068          }
   6069          
   6070          /**
   6071            * @brief  This function handles I2C Communication Timeout.
   6072            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6073            *                the configuration information for the specified I2C.
   6074            * @param  Flag Specifies the I2C flag to check.
   6075            * @param  Status The new Flag status (SET or RESET).
   6076            * @param  Timeout Timeout duration
   6077            * @param  Tickstart Tick start value
   6078            * @retval HAL status
   6079            */

   \                                 In section .text, align 2, keep-with-next
   6080          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
   6081          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x9F06             LDR      R7,[SP, #+24]
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x461C             MOV      R4,R3
   6082            while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x6981             LDR      R1,[R0, #+24]
   \       0x12   0x4031             ANDS     R1,R6,R1
   \       0x14   0x42B1             CMP      R1,R6
   \       0x16   0xBF0C             ITE      EQ
   \       0x18   0x2001             MOVEQ    R0,#+1
   \       0x1A   0x2000             MOVNE    R0,#+0
   \       0x1C   0x4540             CMP      R0,R8
   \       0x1E   0xD10D             BNE.N    ??I2C_WaitOnFlagUntilTimeout_1
   6083            {
   6084              /* Check for the Timeout */
   6085              if (Timeout != HAL_MAX_DELAY)
   \       0x20   0xF114 0x0F01      CMN      R4,#+1
   \       0x24   0xD0F3             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   6086              {
   6087                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x26   0x....'....        BL       HAL_GetTick
   \       0x2A   0x1BC0             SUBS     R0,R0,R7
   \       0x2C   0x4284             CMP      R4,R0
   \       0x2E   0xD301             BCC.N    ??I2C_WaitOnFlagUntilTimeout_2
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD1EC             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   6088                {
   6089                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \       0x34   0x....'....        BL       ?Subroutine28
   6090                  hi2c->State = HAL_I2C_STATE_READY;
   6091                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6092          
   6093                  /* Process Unlocked */
   6094                  __HAL_UNLOCK(hi2c);
   6095                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_255: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   6096                }
   6097              }
   6098            }
   6099            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   6100          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \        0x0   0xF105 0x0040      ADD      R0,R5,#+64
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0x6841             LDR      R1,[R0, #+4]
   \        0x8   0xF041 0x0120      ORR      R1,R1,#0x20
   \        0xC   0x6041             STR      R1,[R0, #+4]
   \        0xE                      REQUIRE ??Subroutine102_0
   \        0xE                      ;; // Fall through to label ??Subroutine102_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine102_0: (+1)
   \        0x0   0x7042             STRB     R2,[R0, #+1]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x7081             STRB     R1,[R0, #+2]
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   \        0x8   0x4770             BX       LR
   6101          
   6102          /**
   6103            * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.
   6104            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6105            *                the configuration information for the specified I2C.
   6106            * @param  Timeout Timeout duration
   6107            * @param  Tickstart Tick start value
   6108            * @retval HAL status
   6109            */

   \                                 In section .text, align 2, keep-with-next
   6110          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6111          {
   \                     I2C_WaitOnTXISFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6112            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x0788             LSLS     R0,R1,#+30
   \        0xE   0xD411             BMI.N    ??I2C_WaitOnTXISFlagUntilTimeout_1
   6113            {
   6114              /* Check if a NACK is detected */
   6115              if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x....'....        BL       ?Subroutine95
   \                     ??CrossCallReturnLabel_228: (+1)
   \       0x14   0xB108             CBZ.N    R0,??I2C_WaitOnTXISFlagUntilTimeout_2
   6116              {
   6117                return HAL_ERROR;
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_3: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD70             POP      {R4-R6,PC}       ;; return
   6118              }
   6119          
   6120              /* Check for the Timeout */
   6121              if (Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_2: (+1)
   \       0x1A   0xF114 0x0F01      CMN      R4,#+1
   \       0x1E   0xD0F3             BEQ.N    ??I2C_WaitOnTXISFlagUntilTimeout_0
   6122              {
   6123                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x20   0x....'....        BL       HAL_GetTick
   \       0x24   0x1B80             SUBS     R0,R0,R6
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD301             BCC.N    ??I2C_WaitOnTXISFlagUntilTimeout_4
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD1EC             BNE.N    ??I2C_WaitOnTXISFlagUntilTimeout_0
   6124                {
   6125                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_4: (+1)
   \       0x2E   0x....'....        BL       ?Subroutine28
   6126                  hi2c->State = HAL_I2C_STATE_READY;
   6127                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6128          
   6129                  /* Process Unlocked */
   6130                  __HAL_UNLOCK(hi2c);
   6131          
   6132                  return HAL_ERROR;
   \                     ??CrossCallReturnLabel_256: (+1)
   \       0x32   0xE7F0             B.N      ??I2C_WaitOnTXISFlagUntilTimeout_3
   6133                }
   6134              }
   6135            }
   6136            return HAL_OK;
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_1: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD70             POP      {R4-R6,PC}
   6137          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine95: (+1)
   \        0x0   0x4632             MOV      R2,R6
   \        0x2   0x4621             MOV      R1,R4
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x....             B.N      I2C_IsAcknowledgeFailed
   6138          
   6139          /**
   6140            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   6141            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6142            *                the configuration information for the specified I2C.
   6143            * @param  Timeout Timeout duration
   6144            * @param  Tickstart Tick start value
   6145            * @retval HAL status
   6146            */

   \                                 In section .text, align 2, keep-with-next
   6147          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6148          {
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6149            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x0688             LSLS     R0,R1,#+26
   \        0xE   0xD40D             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   6150            {
   6151              /* Check if a NACK is detected */
   6152              if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x....'....        BL       ?Subroutine95
   \                     ??CrossCallReturnLabel_227: (+1)
   \       0x14   0xB940             CBNZ.N   R0,??CrossCallReturnLabel_257
   6153              {
   6154                return HAL_ERROR;
   6155              }
   6156          
   6157              /* Check for the Timeout */
   6158              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x16   0x....'....        BL       HAL_GetTick
   \       0x1A   0x1B80             SUBS     R0,R0,R6
   \       0x1C   0x4284             CMP      R4,R0
   \       0x1E   0xD301             BCC.N    ??I2C_WaitOnSTOPFlagUntilTimeout_2
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD1F1             BNE.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   6159              {
   6160                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \       0x24   0x....'....        BL       ?Subroutine28
   6161                hi2c->State = HAL_I2C_STATE_READY;
   6162                hi2c->Mode = HAL_I2C_MODE_NONE;
   6163          
   6164                /* Process Unlocked */
   6165                __HAL_UNLOCK(hi2c);
   6166          
   6167                return HAL_ERROR;
   6168              }
   \                     ??CrossCallReturnLabel_257: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xBD70             POP      {R4-R6,PC}       ;; return
   6169            }
   6170            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD70             POP      {R4-R6,PC}
   6171          }
   6172          
   6173          /**
   6174            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   6175            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6176            *                the configuration information for the specified I2C.
   6177            * @param  Timeout Timeout duration
   6178            * @param  Tickstart Tick start value
   6179            * @retval HAL status
   6180            */

   \                                 In section .text, align 2, keep-with-next
   6181          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6182          {
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   6183            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6981             LDR      R1,[R0, #+24]
   \        0xC   0x0748             LSLS     R0,R1,#+29
   \        0xE   0xD42D             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   6184            {
   6185              /* Check if a NACK is detected */
   6186              if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x10   0x....'....        BL       ?Subroutine95
   \                     ??CrossCallReturnLabel_226: (+1)
   \       0x14   0xBB40             CBNZ.N   R0,??I2C_WaitOnRXNEFlagUntilTimeout_2
   6187              {
   6188                return HAL_ERROR;
   6189              }
   6190          
   6191              /* Check if a STOPF is detected */
   6192              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \       0x16   0x6829             LDR      R1,[R5, #+0]
   \       0x18   0x6988             LDR      R0,[R1, #+24]
   \       0x1A   0x0682             LSLS     R2,R0,#+26
   \       0x1C   0xD410             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_3
   6193              {
   6194                /* Check if an RXNE is pending */
   6195                /* Store Last receive data if any */
   6196                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
   6197                {
   6198                  /* Return HAL_OK */
   6199                  /* The Reading of data from RXDR will be done in caller function */
   6200                  return HAL_OK;
   6201                }
   6202                else
   6203                {
   6204                  /* Clear STOP Flag */
   6205                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   6206          
   6207                  /* Clear Configuration Register 2 */
   6208                  I2C_RESET_CR2(hi2c);
   6209          
   6210                  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   6211                  hi2c->State = HAL_I2C_STATE_READY;
   6212                  hi2c->Mode = HAL_I2C_MODE_NONE;
   6213          
   6214                  /* Process Unlocked */
   6215                  __HAL_UNLOCK(hi2c);
   6216          
   6217                  return HAL_ERROR;
   6218                }
   6219              }
   6220          
   6221              /* Check for the Timeout */
   6222              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x1E   0x....'....        BL       HAL_GetTick
   \       0x22   0x1B80             SUBS     R0,R0,R6
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD301             BCC.N    ??I2C_WaitOnRXNEFlagUntilTimeout_4
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD1ED             BNE.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   6223              {
   6224                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_4: (+1)
   \       0x2C   0xF105 0x0040      ADD      R0,R5,#+64
   6225                hi2c->State = HAL_I2C_STATE_READY;
   \       0x30   0x2220             MOVS     R2,#+32
   \       0x32   0x6841             LDR      R1,[R0, #+4]
   \       0x34   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x38   0x6041             STR      R1,[R0, #+4]
   \       0x3A   0x7042             STRB     R2,[R0, #+1]
   6226          
   6227                /* Process Unlocked */
   6228                __HAL_UNLOCK(hi2c);
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0xE012             B.N      ??I2C_WaitOnRXNEFlagUntilTimeout_5
   6229          
   6230                return HAL_ERROR;
   6231              }
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \       0x40   0x6988             LDR      R0,[R1, #+24]
   \       0x42   0x0742             LSLS     R2,R0,#+29
   \       0x44   0xD501             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_6
   \       0x46   0x8D28             LDRH     R0,[R5, #+40]
   \       0x48   0xB980             CBNZ.N   R0,??I2C_WaitOnRXNEFlagUntilTimeout_1
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_6: (+1)
   \       0x4A   0x2220             MOVS     R2,#+32
   \       0x4C   0x61CA             STR      R2,[R1, #+28]
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x....             LDR.N    R0,??DataTable43_2  ;; 0xfe00e800
   \       0x52   0x684A             LDR      R2,[R1, #+4]
   \       0x54   0x4002             ANDS     R2,R0,R2
   \       0x56   0x604A             STR      R2,[R1, #+4]
   \       0x58   0xF105 0x0040      ADD      R0,R5,#+64
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x6041             STR      R1,[R0, #+4]
   \       0x60   0x2220             MOVS     R2,#+32
   \       0x62   0x7042             STRB     R2,[R0, #+1]
   \       0x64   0x7081             STRB     R1,[R0, #+2]
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_5: (+1)
   \       0x66   0x7001             STRB     R1,[R0, #+0]
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   6232            }
   6233            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
   6234          }
   6235          
   6236          /**
   6237            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   6238            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6239            *                the configuration information for the specified I2C.
   6240            * @param  Timeout Timeout duration
   6241            * @param  Tickstart Tick start value
   6242            * @retval HAL status
   6243            */

   \                                 In section .text, align 2, keep-with-next
   6244          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   6245          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   6246            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x6981             LDR      R1,[R0, #+24]
   \        0xA   0x06C8             LSLS     R0,R1,#+27
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0xD52B             BPL.N    ??I2C_IsAcknowledgeFailed_0
   6247            {
   6248              /* Wait until STOP Flag is reset */
   6249              /* AutoEnd should be initiate after AF */
   6250              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x6981             LDR      R1,[R0, #+24]
   \       0x14   0x068A             LSLS     R2,R1,#+26
   \       0x16   0xD40F             BMI.N    ??I2C_IsAcknowledgeFailed_2
   6251              {
   6252                /* Check for the Timeout */
   6253                if (Timeout != HAL_MAX_DELAY)
   \       0x18   0xF114 0x0F01      CMN      R4,#+1
   \       0x1C   0xD0F8             BEQ.N    ??I2C_IsAcknowledgeFailed_1
   6254                {
   6255                  if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x1E   0x....'....        BL       HAL_GetTick
   \       0x22   0x1B80             SUBS     R0,R0,R6
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD301             BCC.N    ??I2C_IsAcknowledgeFailed_3
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD1F1             BNE.N    ??I2C_IsAcknowledgeFailed_1
   6256                  {
   6257                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_IsAcknowledgeFailed_3: (+1)
   \       0x2C   0xF105 0x0040      ADD      R0,R5,#+64
   \       0x30   0x6841             LDR      R1,[R0, #+4]
   \       0x32   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x36   0xE011             B.N      ??I2C_IsAcknowledgeFailed_4
   6258                    hi2c->State = HAL_I2C_STATE_READY;
   6259                    hi2c->Mode = HAL_I2C_MODE_NONE;
   6260          
   6261                    /* Process Unlocked */
   6262                    __HAL_UNLOCK(hi2c);
   6263          
   6264                    return HAL_ERROR;
   6265                  }
   6266                }
   6267              }
   6268          
   6269              /* Clear NACKF Flag */
   6270              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_IsAcknowledgeFailed_2: (+1)
   \       0x38   0x2110             MOVS     R1,#+16
   \       0x3A   0x61C1             STR      R1,[R0, #+28]
   6271          
   6272              /* Clear STOP Flag */
   6273              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \       0x3C   0x2020             MOVS     R0,#+32
   \       0x3E   0x682A             LDR      R2,[R5, #+0]
   \       0x40   0x61D0             STR      R0,[R2, #+28]
   6274          
   6275              /* Flush TX register */
   6276              I2C_Flush_TXDR(hi2c);
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x....'....        BL       I2C_Flush_TXDR
   6277          
   6278              /* Clear Configuration Register 2 */
   6279              I2C_RESET_CR2(hi2c);
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x....             LDR.N    R2,??DataTable43_2  ;; 0xfe00e800
   \       0x4C   0x6841             LDR      R1,[R0, #+4]
   \       0x4E   0x4011             ANDS     R1,R2,R1
   \       0x50   0x6041             STR      R1,[R0, #+4]
   6280          
   6281              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x52   0xF105 0x0040      ADD      R0,R5,#+64
   \       0x56   0x6841             LDR      R1,[R0, #+4]
   \       0x58   0xF041 0x0104      ORR      R1,R1,#0x4
   \                     ??I2C_IsAcknowledgeFailed_4: (+1)
   \       0x5C   0x6041             STR      R1,[R0, #+4]
   6282              hi2c->State = HAL_I2C_STATE_READY;
   \       0x5E   0x2220             MOVS     R2,#+32
   \       0x60   0x....'....        BL       ??Subroutine102_0
   6283              hi2c->Mode = HAL_I2C_MODE_NONE;
   6284          
   6285              /* Process Unlocked */
   6286              __HAL_UNLOCK(hi2c);
   6287          
   6288              return HAL_ERROR;
   \                     ??CrossCallReturnLabel_258: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xBD70             POP      {R4-R6,PC}
   6289            }
   6290            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD70             POP      {R4-R6,PC}       ;; return
   6291          }
   6292          
   6293          /**
   6294            * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
   6295            * @param  hi2c I2C handle.
   6296            * @param  DevAddress Specifies the slave address to be programmed.
   6297            * @param  Size Specifies the number of bytes to be programmed.
   6298            *   This parameter must be a value between 0 and 255.
   6299            * @param  Mode New state of the I2C START condition generation.
   6300            *   This parameter can be one of the following values:
   6301            *     @arg @ref I2C_RELOAD_MODE Enable Reload mode .
   6302            *     @arg @ref I2C_AUTOEND_MODE Enable Automatic end mode.
   6303            *     @arg @ref I2C_SOFTEND_MODE Enable Software end mode.
   6304            * @param  Request New state of the I2C START condition generation.
   6305            *   This parameter can be one of the following values:
   6306            *     @arg @ref I2C_NO_STARTSTOP Don't Generate stop and start condition.
   6307            *     @arg @ref I2C_GENERATE_STOP Generate stop condition (Size should be set to 0).
   6308            *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
   6309            *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
   6310            * @retval None
   6311            */

   \                                 In section .text, align 2, keep-with-next
   6312          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
   6313          {
   \                     I2C_TransferConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6314            /* Check the parameters */
   6315            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
   6316            assert_param(IS_TRANSFER_MODE(Mode));
   6317            assert_param(IS_TRANSFER_REQUEST(Request));
   6318          
   6319            /* update CR2 register */
   6320            MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
   6321                       (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x9C04             LDR      R4,[SP, #+16]
   \        0x6   0x6845             LDR      R5,[R0, #+4]
   \        0x8   0x....             LDR.N    R6,??DataTable43_4  ;; 0x3ff63ff
   \        0xA   0xEA46 0x5654      ORR      R6,R6,R4, LSR #+21
   \        0xE   0x43B5             BICS     R5,R5,R6
   \       0x10   0xF3C1 0x0109      UBFX     R1,R1,#+0,#+10
   \       0x14   0x4329             ORRS     R1,R1,R5
   \       0x16   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \       0x1A   0x4319             ORRS     R1,R3,R1
   \       0x1C   0x4321             ORRS     R1,R4,R1
   \       0x1E   0x6041             STR      R1,[R0, #+4]
   6322          }
   \       0x20   0xBD70             POP      {R4-R6,PC}       ;; return
   6323          
   6324          /**
   6325            * @brief  Manage the enabling of Interrupts.
   6326            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6327            *                the configuration information for the specified I2C.
   6328            * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
   6329            * @retval None
   6330            */

   \                                 In section .text, align 2, keep-with-next
   6331          static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
   6332          {
   \                     I2C_Enable_IRQ: (+1)
   \        0x0   0xB5D0             PUSH     {R4,R6,R7,LR}
   6333            uint32_t tmpisr = 0U;
   6334          
   6335            if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
   6336                (hi2c->XferISR == I2C_Slave_ISR_DMA))
   \        0x2   0x6B43             LDR      R3,[R0, #+52]
   \        0x4   0x....             LDR.N    R6,??DataTable43_5
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x42B3             CMP      R3,R6
   \        0xA   0xBF1C             ITT      NE
   \        0xC   0x....             LDRNE.N  R7,??DataTable43_6
   \        0xE   0x42BB             CMPNE    R3,R7
   \       0x10   0x460C             MOV      R4,R1
   \       0x12   0xD111             BNE.N    ??I2C_Enable_IRQ_0
   6337            {
   6338              if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
   \       0x14   0x0749             LSLS     R1,R1,#+29
   \       0x16   0xBF48             IT       MI
   \       0x18   0x22B8             MOVMI    R2,#+184
   6339              {
   6340                /* Enable ERR, STOP, NACK and ADDR interrupts */
   6341                tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6342              }
   6343          
   6344              if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
   \       0x1A   0xF004 0x0111      AND      R1,R4,#0x11
   \       0x1E   0x2911             CMP      R1,#+17
   \       0x20   0xBF08             IT       EQ
   \       0x22   0xF042 0x0290      ORREQ    R2,R2,#0x90
   6345              {
   6346                /* Enable ERR and NACK interrupts */
   6347                tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
   6348              }
   6349          
   6350              if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
   \       0x26   0xF004 0x0412      AND      R4,R4,#0x12
   \       0x2A   0x2C12             CMP      R4,#+18
   \       0x2C   0xD115             BNE.N    ??I2C_Enable_IRQ_1
   \       0x2E   0xF042 0x0220      ORR      R2,R2,#0x20
   6351              {
   6352                /* Enable STOP interrupts */
   6353                tmpisr |= I2C_IT_STOPI;
   6354              }
   6355          
   6356              if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
   6357              {
   6358                /* Enable TC interrupts */
   6359                tmpisr |= I2C_IT_TCI;
   \       0x32   0xF042 0x0240      ORR      R2,R2,#0x40
   \       0x36   0xE010             B.N      ??I2C_Enable_IRQ_1
   6360              }
   6361            }
   6362            else
   6363            {
   6364              if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
   \                     ??I2C_Enable_IRQ_0: (+1)
   \       0x38   0x074B             LSLS     R3,R1,#+29
   \       0x3A   0xBF48             IT       MI
   \       0x3C   0x22B8             MOVMI    R2,#+184
   6365              {
   6366                /* Enable ERR, STOP, NACK, and ADDR interrupts */
   6367                tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6368              }
   6369          
   6370              if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
   \       0x3E   0x07CB             LSLS     R3,R1,#+31
   \       0x40   0xBF48             IT       MI
   \       0x42   0xF042 0x02F2      ORRMI    R2,R2,#0xF2
   6371              {
   6372                /* Enable ERR, TC, STOP, NACK and RXI interrupts */
   6373                tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
   6374              }
   6375          
   6376              if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
   \       0x46   0x0789             LSLS     R1,R1,#+30
   \       0x48   0xBF48             IT       MI
   \       0x4A   0xF042 0x02F4      ORRMI    R2,R2,#0xF4
   6377              {
   6378                /* Enable ERR, TC, STOP, NACK and TXI interrupts */
   6379                tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
   6380              }
   6381          
   6382              if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
   \       0x4E   0xF004 0x0412      AND      R4,R4,#0x12
   \       0x52   0x2C12             CMP      R4,#+18
   \       0x54   0xBF08             IT       EQ
   \       0x56   0xF042 0x0220      ORREQ    R2,R2,#0x20
   6383              {
   6384                /* Enable STOP interrupts */
   6385                tmpisr |= I2C_IT_STOPI;
   6386              }
   6387            }
   6388          
   6389            /* Enable interrupts only at the end */
   6390            /* to avoid the risk of I2C interrupt handle execution before */
   6391            /* all interrupts requested done */
   6392            __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
   \                     ??I2C_Enable_IRQ_1: (+1)
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0x430A             ORRS     R2,R2,R1
   \       0x60   0x6002             STR      R2,[R0, #+0]
   6393          }
   \       0x62   0xBDD0             POP      {R4,R6,R7,PC}    ;; return
   6394          
   6395          /**
   6396            * @brief  Manage the disabling of Interrupts.
   6397            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6398            *                the configuration information for the specified I2C.
   6399            * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
   6400            * @retval None
   6401            */

   \                                 In section .text, align 2, keep-with-next
   6402          static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
   6403          {
   6404            uint32_t tmpisr = 0U;
   \                     I2C_Disable_IRQ: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   6405          
   6406            if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
   \        0x2   0x07CB             LSLS     R3,R1,#+31
   \        0x4   0xD507             BPL.N    ??I2C_Disable_IRQ_0
   6407            {
   6408              /* Disable TC and TXI interrupts */
   6409              tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
   6410          
   6411              if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x6   0xF890 0x3041      LDRB     R3,[R0, #+65]
   \        0xA   0x2242             MOVS     R2,#+66
   \        0xC   0xF003 0x0328      AND      R3,R3,#0x28
   \       0x10   0x2B28             CMP      R3,#+40
   \       0x12   0xBF18             IT       NE
   \       0x14   0x22F2             MOVNE    R2,#+242
   6412              {
   6413                /* Disable NACK and STOP interrupts */
   6414                tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6415              }
   6416            }
   6417          
   6418            if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
   \                     ??I2C_Disable_IRQ_0: (+1)
   \       0x16   0x078B             LSLS     R3,R1,#+30
   \       0x18   0xD509             BPL.N    ??I2C_Disable_IRQ_1
   6419            {
   6420              /* Disable TC and RXI interrupts */
   6421              tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
   6422          
   6423              if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
   \       0x1A   0xF890 0x3041      LDRB     R3,[R0, #+65]
   \       0x1E   0xF003 0x0328      AND      R3,R3,#0x28
   \       0x22   0xF042 0x0244      ORR      R2,R2,#0x44
   \       0x26   0x2B28             CMP      R3,#+40
   \       0x28   0xBF18             IT       NE
   \       0x2A   0xF042 0x02B0      ORRNE    R2,R2,#0xB0
   6424              {
   6425                /* Disable NACK and STOP interrupts */
   6426                tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6427              }
   6428            }
   6429          
   6430            if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
   \                     ??I2C_Disable_IRQ_1: (+1)
   \       0x2E   0x074B             LSLS     R3,R1,#+29
   \       0x30   0xBF48             IT       MI
   \       0x32   0xF042 0x02B8      ORRMI    R2,R2,#0xB8
   6431            {
   6432              /* Disable ADDR, NACK and STOP interrupts */
   6433              tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
   6434            }
   6435          
   6436            if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
   \       0x36   0xF001 0x0311      AND      R3,R1,#0x11
   6437            {
   6438              /* Enable ERR and NACK interrupts */
   6439              tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
   6440            }
   6441          
   6442            if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
   6443            {
   6444              /* Enable STOP interrupts */
   6445              tmpisr |= I2C_IT_STOPI;
   6446            }
   6447          
   6448            if ((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
   6449            {
   6450              /* Enable TC interrupts */
   6451              tmpisr |= I2C_IT_TCI;
   6452            }
   6453          
   6454            /* Disable interrupts only at the end */
   6455            /* to avoid a breaking situation like at "t" time */
   6456            /* all disable interrupts request are not done */
   6457            __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x2B11             CMP      R3,#+17
   \       0x3E   0xBF08             IT       EQ
   \       0x40   0xF042 0x0290      ORREQ    R2,R2,#0x90
   \       0x44   0xF001 0x0112      AND      R1,R1,#0x12
   \       0x48   0x2912             CMP      R1,#+18
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xBF04             ITT      EQ
   \       0x4E   0xF042 0x0220      ORREQ    R2,R2,#0x20
   \       0x52   0xF042 0x0240      ORREQ    R2,R2,#0x40
   \       0x56   0xEA21 0x0202      BIC      R2,R1,R2
   \       0x5A   0x6002             STR      R2,[R0, #+0]
   6458          }
   \       0x5C   0x4770             BX       LR               ;; return
   6459          
   6460          /**
   6461            * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
   6462            * @param  hi2c I2C handle.
   6463            * @retval None
   6464            */

   \                                 In section .text, align 2, keep-with-next
   6465          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
   6466          {
   6467            /* if user set XferOptions to I2C_OTHER_FRAME            */
   6468            /* it request implicitly to generate a restart condition */
   6469            /* set XferOptions to I2C_FIRST_FRAME                    */
   6470            if (hi2c->XferOptions == I2C_OTHER_FRAME)
   \                     I2C_ConvertOtherXferOptions: (+1)
   \        0x0   0x6AC1             LDR      R1,[R0, #+44]
   \        0x2   0x29AA             CMP      R1,#+170
   \        0x4   0xBF08             IT       EQ
   \        0x6   0x2200             MOVEQ    R2,#+0
   6471            {
   6472              hi2c->XferOptions = I2C_FIRST_FRAME;
   \        0x8   0xD005             BEQ.N    ??I2C_ConvertOtherXferOptions_0
   6473            }
   6474            /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
   6475            /* it request implicitly to generate a restart condition    */
   6476            /* then generate a stop condition at the end of transfer    */
   6477            /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
   6478            else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
   \        0xA   0x6AC1             LDR      R1,[R0, #+44]
   \        0xC   0xF5B1 0x4F2A      CMP      R1,#+43520
   \       0x10   0xD102             BNE.N    ??I2C_ConvertOtherXferOptions_1
   6479            {
   6480              hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
   \       0x12   0xF04F 0x7200      MOV      R2,#+33554432
   \                     ??I2C_ConvertOtherXferOptions_0: (+1)
   \       0x16   0x62C2             STR      R2,[R0, #+44]
   6481            }
   6482            else
   6483            {
   6484              /* Nothing to do */
   6485            }
   6486          }
   \                     ??I2C_ConvertOtherXferOptions_1: (+1)
   \       0x18   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x8000'2000        DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x8000'2400        DC32     0x80002400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x....'....        DC32     I2C_Master_ISR_IT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_IT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x....'....        DC32     I2C_Master_ISR_DMA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0x....'....        DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0x8000'2000        DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x8000'2400        DC32     0x80002400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_DMA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0xFE00'E800        DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x....'....        DC32     I2C_DMAAbort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x....'....        DC32     I2C_DMAAbort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \        0x0   0x8000'4000        DC32     0x80004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \        0x0   0x8000'2000        DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_2:
   \        0x0   0xFE00'E800        DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_3:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_IT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_4:
   \        0x0   0x03FF'63FF        DC32     0x3ff63ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_5:
   \        0x0   0x....'....        DC32     I2C_Master_ISR_DMA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_6:
   \        0x0   0x....'....        DC32     I2C_Slave_ISR_DMA
   6487          
   6488          /**
   6489            * @}
   6490            */
   6491          
   6492          #endif /* HAL_I2C_MODULE_ENABLED */
   6493          /**
   6494            * @}
   6495            */
   6496          
   6497          /**
   6498            * @}
   6499            */
   6500          
   6501          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2C_AbortCpltCallback
       0   HAL_I2C_AddrCallback
      16   HAL_I2C_DeInit
        16   -> HAL_I2C_MspDeInit
       8   HAL_I2C_DisableListen_IT
         8   -> I2C_Disable_IRQ
      16   HAL_I2C_ER_IRQHandler
         0   -> I2C_ITError
       0   HAL_I2C_EV_IRQHandler
         0   -- Indirect call
       8   HAL_I2C_EnableListen_IT
         8   -> I2C_Enable_IRQ
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetMode
       0   HAL_I2C_GetState
      16   HAL_I2C_Init
        16   -> HAL_I2C_MspInit
      40   HAL_I2C_IsDeviceReady
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_ListenCpltCallback
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      24   HAL_I2C_Master_Abort_IT
        24   -> I2C_Disable_IRQ
        24   -> I2C_Enable_IRQ
        24   -> I2C_TransferConfig
      32   HAL_I2C_Master_Receive
        32   -> HAL_GetTick
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      32   HAL_I2C_Master_Receive_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      24   HAL_I2C_Master_Receive_IT
        24   -> I2C_Enable_IRQ
        24   -> I2C_TransferConfig
      40   HAL_I2C_Master_Seq_Receive_DMA
        40   -> HAL_DMA_Start_IT
        40   -> I2C_ConvertOtherXferOptions
        40   -> I2C_Enable_IRQ
        40   -> I2C_TransferConfig
      32   HAL_I2C_Master_Seq_Receive_IT
        32   -> I2C_ConvertOtherXferOptions
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      40   HAL_I2C_Master_Seq_Transmit_DMA
        40   -> HAL_DMA_Start_IT
        40   -> I2C_ConvertOtherXferOptions
        40   -> I2C_Enable_IRQ
        40   -> I2C_TransferConfig
      32   HAL_I2C_Master_Seq_Transmit_IT
        32   -> I2C_ConvertOtherXferOptions
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      32   HAL_I2C_Master_Transmit
        32   -> HAL_GetTick
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      32   HAL_I2C_Master_Transmit_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Enable_IRQ
        32   -> I2C_TransferConfig
      24   HAL_I2C_Master_Transmit_IT
        24   -> I2C_Enable_IRQ
        24   -> I2C_TransferConfig
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      48   HAL_I2C_Mem_Read
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryRead
        48   -> I2C_TransferConfig
        48   -> I2C_WaitOnFlagUntilTimeout
        48   -> I2C_WaitOnSTOPFlagUntilTimeout
      40   HAL_I2C_Mem_Read_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryRead
        40   -> I2C_TransferConfig
      40   HAL_I2C_Mem_Read_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryRead
        40   -> I2C_TransferConfig
      48   HAL_I2C_Mem_Write
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryWrite
        48   -> I2C_TransferConfig
        48   -> I2C_WaitOnFlagUntilTimeout
        48   -> I2C_WaitOnSTOPFlagUntilTimeout
        48   -> I2C_WaitOnTXISFlagUntilTimeout
      40   HAL_I2C_Mem_Write_DMA
        40   -> HAL_DMA_Start_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_TransferConfig
      40   HAL_I2C_Mem_Write_IT
        40   -> HAL_GetTick
        40   -> I2C_Enable_IRQ
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_TransferConfig
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      16   HAL_I2C_Slave_Receive_DMA
        16   -> HAL_DMA_Start_IT
        16   -> I2C_Enable_IRQ
      16   HAL_I2C_Slave_Receive_IT
        16   -> I2C_Enable_IRQ
      32   HAL_I2C_Slave_Seq_Receive_DMA
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Disable_IRQ
        32   -> I2C_Enable_IRQ
      24   HAL_I2C_Slave_Seq_Receive_IT
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> I2C_Disable_IRQ
        24   -> I2C_Enable_IRQ
      32   HAL_I2C_Slave_Seq_Transmit_DMA
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_DMA_Start_IT
        32   -> I2C_Disable_IRQ
        32   -> I2C_Enable_IRQ
      24   HAL_I2C_Slave_Seq_Transmit_IT
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> I2C_Disable_IRQ
        24   -> I2C_Enable_IRQ
      32   HAL_I2C_Slave_Transmit
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      16   HAL_I2C_Slave_Transmit_DMA
        16   -> HAL_DMA_Start_IT
        16   -> I2C_Enable_IRQ
      16   HAL_I2C_Slave_Transmit_IT
        16   -> I2C_Enable_IRQ
       0   I2C_ConvertOtherXferOptions
       0   I2C_DMAAbort
         0   -> HAL_I2C_AbortCpltCallback
         0   -> HAL_I2C_ErrorCallback
       0   I2C_DMAError
         0   -> I2C_ITError
       8   I2C_DMAMasterReceiveCplt
         8   -> HAL_DMA_Start_IT
         0   -> I2C_Enable_IRQ
         0   -> I2C_ITError
       8   I2C_DMAMasterTransmitCplt
         8   -> HAL_DMA_Start_IT
         0   -> I2C_Enable_IRQ
         0   -> I2C_ITError
       8   I2C_DMASlaveReceiveCplt
         0   -> I2C_ITSlaveSeqCplt
       0   I2C_DMASlaveTransmitCplt
         0   -> I2C_ITSlaveSeqCplt
       0   I2C_Disable_IRQ
      16   I2C_Enable_IRQ
       0   I2C_Flush_TXDR
      24   I2C_ITAddrCplt
         0   -> HAL_I2C_AddrCallback
        24   -> I2C_Disable_IRQ
      16   I2C_ITError
         0   -- Indirect call
        16   -> HAL_DMA_Abort_IT
         0   -> HAL_I2C_AbortCpltCallback
         0   -> HAL_I2C_ErrorCallback
        16   -> I2C_Disable_IRQ
      16   I2C_ITListenCplt
         0   -> HAL_I2C_ListenCpltCallback
        16   -> I2C_Disable_IRQ
      16   I2C_ITMasterCplt
         0   -> HAL_I2C_MasterRxCpltCallback
         0   -> HAL_I2C_MasterTxCpltCallback
         0   -> HAL_I2C_MemRxCpltCallback
         0   -> HAL_I2C_MemTxCpltCallback
        16   -> I2C_Disable_IRQ
        16   -> I2C_Flush_TXDR
         0   -> I2C_ITError
      16   I2C_ITMasterSeqCplt
         0   -> HAL_I2C_MasterRxCpltCallback
         0   -> HAL_I2C_MasterTxCpltCallback
        16   -> I2C_Disable_IRQ
      16   I2C_ITSlaveCplt
         0   -> HAL_I2C_ListenCpltCallback
         0   -> HAL_I2C_SlaveRxCpltCallback
         0   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_Disable_IRQ
        16   -> I2C_Flush_TXDR
        16   -> I2C_ITError
         0   -> I2C_ITListenCplt
        16   -> I2C_ITSlaveSeqCplt
      16   I2C_ITSlaveSeqCplt
         0   -> HAL_I2C_SlaveRxCpltCallback
         0   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_Disable_IRQ
      16   I2C_IsAcknowledgeFailed
        16   -> HAL_GetTick
        16   -> I2C_Flush_TXDR
      24   I2C_Master_ISR_DMA
        24   -> I2C_Enable_IRQ
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITError
        24   -> I2C_ITMasterCplt
        24   -> I2C_ITMasterSeqCplt
        24   -> I2C_TransferConfig
      24   I2C_Master_ISR_IT
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITError
        24   -> I2C_ITMasterCplt
        24   -> I2C_ITMasterSeqCplt
        24   -> I2C_TransferConfig
      32   I2C_RequestMemoryRead
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      32   I2C_Slave_ISR_DMA
        32   -> I2C_Flush_TXDR
        32   -> I2C_ITAddrCplt
        32   -> I2C_ITError
        32   -> I2C_ITListenCplt
        32   -> I2C_ITSlaveCplt
        32   -> I2C_ITSlaveSeqCplt
      24   I2C_Slave_ISR_IT
        24   -> I2C_Flush_TXDR
        24   -> I2C_ITAddrCplt
        24   -> I2C_ITError
        24   -> I2C_ITListenCplt
        24   -> I2C_ITSlaveCplt
        24   -> I2C_ITSlaveSeqCplt
      16   I2C_TransferConfig
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnTXISFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable31
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable40
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable43_2
       4  ??DataTable43_3
       4  ??DataTable43_4
       4  ??DataTable43_5
       4  ??DataTable43_6
       8  ??Subroutine100_0
       8  ??Subroutine101_0
      10  ??Subroutine102_0
       8  ?Subroutine0
       8  ?Subroutine1
      66  ?Subroutine10
      50  ?Subroutine11
      48  ?Subroutine12
      20  ?Subroutine13
      20  ?Subroutine14
      20  ?Subroutine15
      20  ?Subroutine16
      20  ?Subroutine17
      16  ?Subroutine18
      16  ?Subroutine19
       6  ?Subroutine2
       8  ?Subroutine20
      16  ?Subroutine21
      16  ?Subroutine22
      16  ?Subroutine23
      16  ?Subroutine24
      20  ?Subroutine25
      16  ?Subroutine26
      16  ?Subroutine27
      14  ?Subroutine28
       6  ?Subroutine29
       6  ?Subroutine3
      12  ?Subroutine30
      12  ?Subroutine31
      16  ?Subroutine32
      12  ?Subroutine33
      14  ?Subroutine34
      54  ?Subroutine35
      14  ?Subroutine36
      14  ?Subroutine37
      14  ?Subroutine38
      14  ?Subroutine39
      10  ?Subroutine4
      14  ?Subroutine40
      12  ?Subroutine41
      12  ?Subroutine42
      10  ?Subroutine43
      12  ?Subroutine44
      12  ?Subroutine45
      12  ?Subroutine46
      46  ?Subroutine47
      40  ?Subroutine48
      22  ?Subroutine49
      10  ?Subroutine5
      22  ?Subroutine50
      14  ?Subroutine51
      16  ?Subroutine52
      34  ?Subroutine53
      32  ?Subroutine54
      32  ?Subroutine55
      24  ?Subroutine56
      14  ?Subroutine57
      16  ?Subroutine58
      12  ?Subroutine59
      10  ?Subroutine6
      12  ?Subroutine60
      30  ?Subroutine61
      22  ?Subroutine62
      18  ?Subroutine63
      18  ?Subroutine64
      18  ?Subroutine65
      10  ?Subroutine66
      14  ?Subroutine67
      18  ?Subroutine68
      20  ?Subroutine69
      10  ?Subroutine7
      16  ?Subroutine70
       8  ?Subroutine71
      12  ?Subroutine72
      24  ?Subroutine73
      10  ?Subroutine74
      10  ?Subroutine75
      16  ?Subroutine76
      16  ?Subroutine77
      32  ?Subroutine78
      30  ?Subroutine79
      14  ?Subroutine8
      10  ?Subroutine80
      12  ?Subroutine81
       8  ?Subroutine82
      22  ?Subroutine83
       8  ?Subroutine84
      12  ?Subroutine85
       8  ?Subroutine86
      12  ?Subroutine87
       8  ?Subroutine88
      12  ?Subroutine89
      68  ?Subroutine9
      46  ?Subroutine90
      12  ?Subroutine91
      14  ?Subroutine92
      12  ?Subroutine93
       8  ?Subroutine94
       8  ?Subroutine95
      20  ?Subroutine96
      10  ?Subroutine97
      10  ?Subroutine98
      12  ?Subroutine99
       2  HAL_I2C_AbortCpltCallback
       2  HAL_I2C_AddrCallback
      38  HAL_I2C_DeInit
      48  HAL_I2C_DisableListen_IT
      90  HAL_I2C_ER_IRQHandler
      16  HAL_I2C_EV_IRQHandler
      36  HAL_I2C_EnableListen_IT
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetMode
       6  HAL_I2C_GetState
     160  HAL_I2C_Init
     266  HAL_I2C_IsDeviceReady
       2  HAL_I2C_ListenCpltCallback
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
      76  HAL_I2C_Master_Abort_IT
     142  HAL_I2C_Master_Receive
     174  HAL_I2C_Master_Receive_DMA
      52  HAL_I2C_Master_Receive_IT
     152  HAL_I2C_Master_Seq_Receive_DMA
      90  HAL_I2C_Master_Seq_Receive_IT
     150  HAL_I2C_Master_Seq_Transmit_DMA
      88  HAL_I2C_Master_Seq_Transmit_IT
     140  HAL_I2C_Master_Transmit
     172  HAL_I2C_Master_Transmit_DMA
      52  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     220  HAL_I2C_Mem_Read
     160  HAL_I2C_Mem_Read_DMA
     102  HAL_I2C_Mem_Read_IT
     174  HAL_I2C_Mem_Write
     156  HAL_I2C_Mem_Write_DMA
     100  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     212  HAL_I2C_Slave_Receive
     116  HAL_I2C_Slave_Receive_DMA
      36  HAL_I2C_Slave_Receive_IT
     190  HAL_I2C_Slave_Seq_Receive_DMA
     112  HAL_I2C_Slave_Seq_Receive_IT
     196  HAL_I2C_Slave_Seq_Transmit_DMA
     118  HAL_I2C_Slave_Seq_Transmit_IT
     220  HAL_I2C_Slave_Transmit
     104  HAL_I2C_Slave_Transmit_DMA
      36  HAL_I2C_Slave_Transmit_IT
      26  I2C_ConvertOtherXferOptions
      34  I2C_DMAAbort
      14  I2C_DMAError
      48  I2C_DMAMasterReceiveCplt
      50  I2C_DMAMasterTransmitCplt
      38  I2C_DMASlaveReceiveCplt
      28  I2C_DMASlaveTransmitCplt
      94  I2C_Disable_IRQ
     100  I2C_Enable_IRQ
      28  I2C_Flush_TXDR
     142  I2C_ITAddrCplt
     202  I2C_ITError
      86  I2C_ITListenCplt
     148  I2C_ITMasterCplt
      60  I2C_ITMasterSeqCplt
     226  I2C_ITSlaveCplt
      80  I2C_ITSlaveSeqCplt
     108  I2C_IsAcknowledgeFailed
     258  I2C_Master_ISR_DMA
     276  I2C_Master_ISR_IT
      52  I2C_RequestMemoryRead
      54  I2C_RequestMemoryWrite
     226  I2C_Slave_ISR_DMA
     288  I2C_Slave_ISR_IT
      34  I2C_TransferConfig
      66  I2C_WaitOnFlagUntilTimeout
     112  I2C_WaitOnRXNEFlagUntilTimeout
      48  I2C_WaitOnSTOPFlagUntilTimeout
      56  I2C_WaitOnTXISFlagUntilTimeout

 
 9'138 bytes in section .text
 
 9'114 bytes of CODE memory (+ 24 bytes shared)

Errors: none
Warnings: none
