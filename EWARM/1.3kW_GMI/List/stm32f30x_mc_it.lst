###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:07
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Src\stm32f30x_mc_it.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW3720.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Src\stm32f30x_mc_it.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\stm32f30x_mc_it.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\stm32f30x_mc_it.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Src\stm32f30x_mc_it.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    stm32f30x_mc_it.c 
      5            * @author  Motor Control SDK Team, ST Microelectronics
      6            * @brief   Main Interrupt Service Routines.
      7            *          This file provides exceptions handler and peripherals interrupt 
      8            *          service routine related to Motor Control for the STM32F3 Family.
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     13            * All rights reserved.</center></h2>
     14            *
     15            * This software component is licensed by ST under Ultimate Liberty license
     16            * SLA0044, the "License"; You may not use this file except in compliance with
     17            * the License. You may obtain a copy of the License at:
     18            *                             www.st.com/SLA0044
     19            *
     20            ******************************************************************************
     21            * @ingroup STM32F30x_IRQ_Handlers
     22            */ 
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "mc_type.h"
     26          #include "mc_tasks.h"
     27          #include "ui_task.h"
     28          #include "parameters_conversion.h"
     29          #include "motorcontrol.h"
     30          #include "stm32f3xx_it.h"
     31          
     32          /* USER CODE BEGIN Includes */
     33          
     34          /* USER CODE END Includes */
     35          
     36          /** @addtogroup MCSDK
     37            * @{
     38            */
     39          
     40          /** @addtogroup STM32F30x_IRQ_Handlers STM32F30x IRQ Handlers
     41            * @{
     42            */
     43            
     44          /* USER CODE BEGIN PRIVATE */
     45            
     46          /* Private typedef -----------------------------------------------------------*/
     47          /* Private define ------------------------------------------------------------*/
     48          #define SYSTICK_DIVIDER (SYS_TICK_FREQUENCY/1000)
     49          
     50          /* Private macro -------------------------------------------------------------*/
     51          /* Private variables ---------------------------------------------------------*/
     52          /* Private function prototypes -----------------------------------------------*/
     53          /* Private functions ---------------------------------------------------------*/
     54          
     55          /* USER CODE END PRIVATE */
     56          
     57          /* Public prototypes of IRQ handlers called from assembly code ---------------*/
     58          void ADC1_2_IRQHandler(void);
     59          void TIMx_UP_M1_IRQHandler(void);
     60          void TIMx_BRK_M1_IRQHandler(void);
     61          //void SPD_TIM_M1_IRQHandler(void);
     62          void USART_IRQHandler(void);
     63          void HardFault_Handler(void);
     64          void SysTick_Handler(void);
     65          
     66          #if defined (CCMRAM)
     67          #if defined (__ICCARM__)
     68          #pragma location = ".ccmram"
     69          #elif defined (__CC_ARM) || defined(__GNUC__)
     70          __attribute__((section (".ccmram")))
     71          #endif
     72          #endif
     73          /**
     74            * @brief  This function handles ADC1/ADC2 interrupt request.
     75            * @param  None
     76            * @retval None
     77            */

   \                                 In section .text, align 2, keep-with-next
     78          void ADC1_2_IRQHandler(void)
     79          {
   \                     ADC1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     80            /* USER CODE BEGIN ADC1_2_IRQn 0 */
     81          
     82            /* USER CODE END ADC1_2_IRQn 0 */
     83            
     84            // Clear Flags M1
     85            LL_ADC_ClearFlag_JEOS( ADC1 );
   \        0x2   0xF04F 0x41A0      MOV      R1,#+1342177280
   \        0x6   0x2040             MOVS     R0,#+64
   \        0x8   0x6008             STR      R0,[R1, #+0]
     86          
     87            // Highfrequency task 
     88            UI_DACUpdate(TSK_HighFrequencyTask());
   \        0xA   0x....'....        BL       TSK_HighFrequencyTask
   \        0xE   0xE8BD 0x4002      POP      {R1,LR}
   \       0x12   0x....'....        B.W      UI_DACUpdate
     89           /* USER CODE BEGIN HighFreq */
     90          
     91           /* USER CODE END HighFreq  */  
     92           
     93           /* USER CODE BEGIN ADC1_2_IRQn 1 */
     94          
     95           /* USER CODE END ADC1_2_IRQn 1 */
     96          }
     97          
     98          /**
     99            * @brief  This function handles first motor TIMx Update interrupt request.
    100            * @param  None
    101            * @retval None 
    102            */

   \                                 In section .text, align 2, keep-with-next
    103          void TIMx_UP_M1_IRQHandler(void)
    104          {
    105           /* USER CODE BEGIN TIMx_UP_M1_IRQn 0 */
    106          
    107           /* USER CODE END  TIMx_UP_M1_IRQn 0 */ 
    108           
    109              LL_TIM_ClearFlag_UPDATE(TIM1);
   \                     TIM1_UP_TIM16_IRQHandler: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable5  ;; 0x40012c10
   \        0x2   0xF06F 0x0001      MVN      R0,#+1
   \        0x6   0x6008             STR      R0,[R1, #+0]
    110              R3_1_TIMx_UP_IRQHandler(&PWM_Handle_M1);    
   \        0x8   0x....             LDR.N    R0,??DataTable5_1
   \        0xA   0x....'....        B.W      R3_1_TIMx_UP_IRQHandler
    111          
    112           /* USER CODE BEGIN TIMx_UP_M1_IRQn 1 */
    113          
    114           /* USER CODE END  TIMx_UP_M1_IRQn 1 */ 
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          void TIMx_BRK_M1_IRQHandler(void)
    118          {
   \                     TIM1_BRK_TIM15_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    119            /* USER CODE BEGIN TIMx_BRK_M1_IRQn 0 */
    120          
    121            /* USER CODE END TIMx_BRK_M1_IRQn 0 */ 
    122            if (LL_TIM_IsActiveFlag_BRK(TIM1))
   \        0x2   0x....             LDR.N    R4,??DataTable5  ;; 0x40012c10
   \        0x4   0x....             LDR.N    R5,??DataTable5_1
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x0601             LSLS     R1,R0,#+24
   \        0xA   0xD505             BPL.N    ??TIM1_BRK_TIM15_IRQHandler_0
    123            {
    124              LL_TIM_ClearFlag_BRK(TIM1);
   \        0xC   0xF06F 0x0080      MVN      R0,#+128
   \       0x10   0x6020             STR      R0,[R4, #+0]
    125              R3_1_BRK_IRQHandler(&PWM_Handle_M1);    
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x....'....        BL       R3_1_BRK_IRQHandler
    126            }
    127            if (LL_TIM_IsActiveFlag_BRK2(TIM1))
   \                     ??TIM1_BRK_TIM15_IRQHandler_0: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x05C0             LSLS     R0,R0,#+23
   \       0x1C   0xD505             BPL.N    ??TIM1_BRK_TIM15_IRQHandler_1
    128            {
    129              LL_TIM_ClearFlag_BRK2(TIM1);  
   \       0x1E   0xF46F 0x7180      MVN      R1,#+256
   \       0x22   0x6021             STR      R1,[R4, #+0]
    130              R3_1_BRK2_IRQHandler(&PWM_Handle_M1);    
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       R3_1_BRK2_IRQHandler
    131            }
    132            /* Systick is not executed due low priority so is necessary to call MC_Scheduler here.*/
    133            MC_Scheduler();
   \                     ??TIM1_BRK_TIM15_IRQHandler_1: (+1)
   \       0x2A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x2E   0x....'....        B.W      MC_Scheduler
    134            
    135            /* USER CODE BEGIN TIMx_BRK_M1_IRQn 1 */
    136          
    137            /* USER CODE END TIMx_BRK_M1_IRQn 1 */ 
    138          }
    139          
    140          /**
    141            * @brief  This function handles TIMx global interrupt request for M1 Speed Sensor.
    142            * @param  None
    143            * @retval None
    144            */
    145          //void SPD_TIM_M1_IRQHandler(void)
    146          //{
    147            /* USER CODE BEGIN SPD_TIM_M1_IRQn 0 */
    148          
    149            /* USER CODE END SPD_TIM_M1_IRQn 0 */ 
    150            
    151            /* HALL Timer Update IT always enabled, no need to check enable UPDATE state */
    152            //if (LL_TIM_IsActiveFlag_UPDATE(HALL_M1.TIMx) != 0)
    153            //{
    154              //LL_TIM_ClearFlag_UPDATE(HALL_M1.TIMx);
    155              //HALL_TIMx_UP_IRQHandler(&HALL_M1);
    156              /* USER CODE BEGIN M1 HALL_Update */
    157          
    158              /* USER CODE END M1 HALL_Update   */ 
    159            //}
    160            //else
    161            //{
    162              /* Nothing to do */
    163            //}
    164            /* HALL Timer CC1 IT always enabled, no need to check enable CC1 state */
    165            //if (LL_TIM_IsActiveFlag_CC1 (HALL_M1.TIMx)) 
    166            //{
    167              //LL_TIM_ClearFlag_CC1(HALL_M1.TIMx);
    168              //HALL_TIMx_CC_IRQHandler(&HALL_M1);
    169              /* USER CODE BEGIN M1 HALL_CC1 */
    170          
    171              /* USER CODE END M1 HALL_CC1 */ 
    172            //}
    173            //else
    174            //{
    175            /* Nothing to do */
    176            //}
    177            /* USER CODE BEGIN SPD_TIM_M1_IRQn 1 */
    178          
    179            /* USER CODE END SPD_TIM_M1_IRQn 1 */ 
    180          //}
    181          
    182          /*Start here***********************************************************/
    183          /*GUI, this section is present only if serial communication is enabled*/
    184          /**
    185            * @brief  This function handles USART interrupt request.
    186            * @param  None
    187            * @retval None
    188            */

   \                                 In section .text, align 2, keep-with-next
    189          void USART_IRQHandler(void)
    190          {
   \                     USART1_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    191          
    192           /* USER CODE BEGIN USART_IRQn 0 */
    193          
    194            /* USER CODE END USART_IRQn 0 */
    195            if (LL_USART_IsActiveFlag_RXNE(pUSART.USARTx)) /* Valid data have been received */
   \        0x2   0x....             LDR.N    R4,??DataTable5_2
   \        0x4   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \        0x8   0x69C1             LDR      R1,[R0, #+28]
   \        0xA   0x068A             LSLS     R2,R1,#+26
   \        0xC   0xD50B             BPL.N    ??USART1_IRQHandler_0
    196            {
    197              uint16_t retVal;
    198              retVal = *(uint16_t*)UFCP_RX_IRQ_Handler(&pUSART,LL_USART_ReceiveData8(pUSART.USARTx));
   \        0xE   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x12   0x8800             LDRH     R0,[R0, #+0]
    199              if (retVal == 1)
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD102             BNE.N    ??USART1_IRQHandler_1
    200              {
    201                UI_SerialCommunicationTimeOutStart();
   \       0x18   0x....'....        BL       UI_SerialCommunicationTimeOutStart
   \       0x1C   0xE003             B.N      ??USART1_IRQHandler_0
    202              }
    203              if (retVal == 2)
   \                     ??USART1_IRQHandler_1: (+1)
   \       0x1E   0x2802             CMP      R0,#+2
   \       0x20   0xBF08             IT       EQ
    204              {
    205                UI_SerialCommunicationTimeOutStop();
   \       0x22   0x....'....        BLEQ     UI_SerialCommunicationTimeOutStop
    206              }
    207            /* USER CODE BEGIN USART_RXNE */
    208          
    209            /* USER CODE END USART_RXNE  */ 
    210            }
    211          
    212            if (LL_USART_IsActiveFlag_TXE(pUSART.USARTx))
   \                     ??USART1_IRQHandler_0: (+1)
   \       0x26   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x2A   0x69C0             LDR      R0,[R0, #+28]
   \       0x2C   0x0600             LSLS     R0,R0,#+24
   \       0x2E   0xBF44             ITT      MI
    213            {
    214              UFCP_TX_IRQ_Handler(&pUSART);
   \       0x30   0x4620             MOVMI    R0,R4
   \       0x32   0x....'....        BLMI     UFCP_TX_IRQ_Handler
    215              /* USER CODE BEGIN USART_TXE */
    216          
    217              /* USER CODE END USART_TXE   */
    218            }
    219            
    220            if (LL_USART_IsActiveFlag_ORE(pUSART.USARTx)) /* Overrun error occurs */
   \       0x36   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x3A   0x69C0             LDR      R0,[R0, #+28]
   \       0x3C   0x0700             LSLS     R0,R0,#+28
   \       0x3E   0xD50A             BPL.N    ??USART1_IRQHandler_2
    221            {
    222              /* Send Overrun message */
    223              UFCP_OVR_IRQ_Handler(&pUSART);
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       UFCP_OVR_IRQ_Handler
    224              LL_USART_ClearFlag_ORE(pUSART.USARTx); /* Clear overrun flag */
   \       0x46   0xF8D4 0x1120      LDR      R1,[R4, #+288]
   \       0x4A   0x2008             MOVS     R0,#+8
   \       0x4C   0x6208             STR      R0,[R1, #+32]
    225              UI_SerialCommunicationTimeOutStop();
   \       0x4E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x52   0x....'....        B.W      UI_SerialCommunicationTimeOutStop
    226              /* USER CODE BEGIN USART_ORE */
    227          
    228              /* USER CODE END USART_ORE   */   
    229            }
    230            /* USER CODE BEGIN USART_IRQn 1 */
    231            
    232            /* USER CODE END USART_IRQn 1 */
    233          
    234          }
   \                     ??USART1_IRQHandler_2: (+1)
   \       0x56   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x8C81             LDRH     R1,[R0, #+36]
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        B.W      UFCP_RX_IRQ_Handler
    235          /*End here***********************************************************/
    236          
    237          /**
    238            * @brief  This function handles Hard Fault exception.
    239            * @param  None
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void HardFault_Handler(void)
    243          {
   \                     HardFault_Handler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    244           /* USER CODE BEGIN HardFault_IRQn 0 */
    245          
    246           /* USER CODE END HardFault_IRQn 0 */
    247            TSK_HardwareFaultTask();
   \        0x2   0x....'....        BL       TSK_HardwareFaultTask
   \        0x6   0x....             LDR.N    R4,??DataTable5_2
   \        0x8   0xE003             B.N      ??HardFault_Handler_0
    248            
    249            /* Go to infinite loop when Hard Fault exception occurs */
    250            while (1)
    251            {
    252              {
    253                if (LL_USART_IsActiveFlag_ORE(pUSART.USARTx)) /* Overrun error occurs */
    254                {
    255                  /* Send Overrun message */
    256                  UFCP_OVR_IRQ_Handler(&pUSART);
    257                  LL_USART_ClearFlag_ORE(pUSART.USARTx); /* Clear overrun flag */
    258                  UI_SerialCommunicationTimeOutStop();
    259                }
    260                
    261                if (LL_USART_IsActiveFlag_TXE(pUSART.USARTx))
    262                {   
    263                  UFCP_TX_IRQ_Handler(&pUSART);
    264                }  
    265                
    266                if (LL_USART_IsActiveFlag_RXNE(pUSART.USARTx)) /* Valid data have been received */
    267                {
    268                  uint16_t retVal;
    269                  retVal = *(uint16_t*)(UFCP_RX_IRQ_Handler(&pUSART,LL_USART_ReceiveData8(pUSART.USARTx)));
    270                  if (retVal == 1)
    271                  {
    272                    UI_SerialCommunicationTimeOutStart();
    273                  }
    274                  if (retVal == 2)
   \                     ??HardFault_Handler_1: (+1)
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xBF08             IT       EQ
    275                  {
    276                    UI_SerialCommunicationTimeOutStop();
   \        0xE   0x....'....        BLEQ     UI_SerialCommunicationTimeOutStop
    277                  }
   \                     ??HardFault_Handler_0: (+1)
   \       0x12   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x16   0x69C0             LDR      R0,[R0, #+28]
   \       0x18   0x0700             LSLS     R0,R0,#+28
   \       0x1A   0xD508             BPL.N    ??HardFault_Handler_2
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       UFCP_OVR_IRQ_Handler
   \       0x22   0xF8D4 0x1120      LDR      R1,[R4, #+288]
   \       0x26   0x2008             MOVS     R0,#+8
   \       0x28   0x6208             STR      R0,[R1, #+32]
   \       0x2A   0x....'....        BL       UI_SerialCommunicationTimeOutStop
   \                     ??HardFault_Handler_2: (+1)
   \       0x2E   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x32   0x69C0             LDR      R0,[R0, #+28]
   \       0x34   0x0600             LSLS     R0,R0,#+24
   \       0x36   0xBF44             ITT      MI
   \       0x38   0x4620             MOVMI    R0,R4
   \       0x3A   0x....'....        BLMI     UFCP_TX_IRQ_Handler
   \       0x3E   0xF8D4 0x0120      LDR      R0,[R4, #+288]
   \       0x42   0x69C1             LDR      R1,[R0, #+28]
   \       0x44   0x0689             LSLS     R1,R1,#+26
   \       0x46   0xD5E4             BPL.N    ??HardFault_Handler_0
   \       0x48   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x4C   0x8800             LDRH     R0,[R0, #+0]
   \       0x4E   0x2801             CMP      R0,#+1
   \       0x50   0xD1DB             BNE.N    ??HardFault_Handler_1
   \       0x52   0x....'....        BL       UI_SerialCommunicationTimeOutStart
   \       0x56   0xE7DC             B.N      ??HardFault_Handler_0
    278                }
    279                else
    280                {
    281                }
    282              }  
    283            }
    284           /* USER CODE BEGIN HardFault_IRQn 1 */
    285          
    286           /* USER CODE END HardFault_IRQn 1 */
    287          
    288          }
    289          

   \                                 In section .text, align 2, keep-with-next
    290          void SysTick_Handler(void)
    291          {
   \                     SysTick_Handler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    292          
    293          #ifdef MC_HAL_IS_USED
    294          static uint8_t SystickDividerCounter = SYSTICK_DIVIDER;
    295            /* USER CODE BEGIN SysTick_IRQn 0 */
    296          
    297            /* USER CODE END SysTick_IRQn 0 */
    298            if (SystickDividerCounter == SYSTICK_DIVIDER)
   \        0x2   0x....             LDR.N    R4,??DataTable5_3
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD105             BNE.N    ??SysTick_Handler_0
    299            {
    300              HAL_IncTick();
   \        0xA   0x....'....        BL       HAL_IncTick
    301              HAL_SYSTICK_IRQHandler();
   \        0xE   0x....'....        BL       HAL_SYSTICK_IRQHandler
    302              SystickDividerCounter = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x7020             STRB     R0,[R4, #+0]
    303            }
    304            SystickDividerCounter ++;  
   \                     ??SysTick_Handler_0: (+1)
   \       0x16   0x7821             LDRB     R1,[R4, #+0]
   \       0x18   0x1C49             ADDS     R1,R1,#+1
   \       0x1A   0x7021             STRB     R1,[R4, #+0]
    305          #endif /* MC_HAL_IS_USED */
    306          
    307            /* USER CODE BEGIN SysTick_IRQn 1 */
    308            /* USER CODE END SysTick_IRQn 1 */
    309              MC_RunMotorControlTasks();
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x....'....        B.W      MC_RunMotorControlTasks
    310          
    311            /* USER CODE BEGIN SysTick_IRQn 2 */
    312            /* USER CODE END SysTick_IRQn 2 */
    313          }

   \                                 In section .data, align 1
   \                     `SysTick_Handler::SystickDividerCounter`:
   \        0x0   0x02               DC8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x4001'2C10        DC32     0x40012c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     PWM_Handle_M1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     pUSART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     `SysTick_Handler::SystickDividerCounter`
    314          
    315          /* USER CODE BEGIN 1 */
    316          
    317          /* USER CODE END 1 */
    318          
    319          /**
    320            * @}
    321            */
    322          
    323          /**
    324            * @}
    325            */
    326          
    327          /******************* (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ADC1_IRQHandler
         8   -> TSK_HighFrequencyTask
         0   -> UI_DACUpdate
       8   HardFault_Handler
         8   -> TSK_HardwareFaultTask
         8   -> UFCP_OVR_IRQ_Handler
         8   -> UFCP_RX_IRQ_Handler
         8   -> UFCP_TX_IRQ_Handler
         8   -> UI_SerialCommunicationTimeOutStart
         8   -> UI_SerialCommunicationTimeOutStop
       8   SysTick_Handler
         8   -> HAL_IncTick
         8   -> HAL_SYSTICK_IRQHandler
         0   -> MC_RunMotorControlTasks
      16   TIM1_BRK_TIM15_IRQHandler
         0   -> MC_Scheduler
        16   -> R3_1_BRK2_IRQHandler
        16   -> R3_1_BRK_IRQHandler
       0   TIM1_UP_TIM16_IRQHandler
         0   -> R3_1_TIMx_UP_IRQHandler
       8   USART1_IRQHandler
         8   -> UFCP_OVR_IRQ_Handler
         8   -> UFCP_RX_IRQ_Handler
         8   -> UFCP_TX_IRQ_Handler
         8   -> UI_SerialCommunicationTimeOutStart
         0   -> UI_SerialCommunicationTimeOutStop
         8   -> UI_SerialCommunicationTimeOutStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
      10  ?Subroutine0
      22  ADC1_IRQHandler
      88  HardFault_Handler
      36  SysTick_Handler
       1  SystickDividerCounter
      50  TIM1_BRK_TIM15_IRQHandler
      14  TIM1_UP_TIM16_IRQHandler
      88  USART1_IRQHandler

 
   1 byte  in section .data
 324 bytes in section .text
 
 324 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
