###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:01
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\r_divider_bus_voltage_sensor.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW22C1.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\r_divider_bus_voltage_sensor.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\r_divider_bus_voltage_sensor.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\r_divider_bus_voltage_sensor.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\r_divider_bus_voltage_sensor.c
      1          /**
      2            ******************************************************************************
      3            * @file    r_divider_bus_voltage_sensor.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the  features
      6            *          of the Resistor Divider Bus Voltage Sensor component of the Motor
      7            *          Control SDK:
      8            *
      9            ******************************************************************************
     10            * @attention
     11            *
     12            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     13            * All rights reserved.</center></h2>
     14            *
     15            * This software component is licensed by ST under Ultimate Liberty license
     16            * SLA0044, the "License"; You may not use this file except in compliance with
     17            * the License. You may obtain a copy of the License at:
     18            *                             www.st.com/SLA0044
     19            *
     20            ******************************************************************************
     21            */
     22          
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "r_divider_bus_voltage_sensor.h"
     25          #include "regular_conversion_manager.h"
     26          
     27          
     28          /** @addtogroup MCSDK
     29            * @{
     30            */
     31          
     32          /** @addtogroup BusVoltageSensor
     33            * @{
     34            */
     35          
     36          /** @defgroup RDividerBusVoltageSensor Resistor Divider Bus Voltage Sensor
     37            * @brief Resistor Divider Bus Voltage Sensor implementation
     38            *
     39            * @todo Document the Resistor Divider Bus Voltage Sensor "module".
     40            *
     41            * @{
     42            */
     43          
     44          /**
     45            * @brief  It initializes bus voltage conversion (ADC, ADC channel, conversion time. 
     46              It must be called only after PWMC_Init.
     47            * @param  pHandle related RDivider_Handle_t
     48            * @retval none
     49            */

   \                                 In section .text, align 2
     50          __weak void RVBS_Init( RDivider_Handle_t * pHandle )
     51          {
   \                     RVBS_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
     52            /* Need to be register with RegularConvManager */
     53            pHandle->convHandle = RCM_RegisterRegConv(&pHandle->VbusRegConv);
   \        0x4   0xF104 0x000C      ADD      R0,R4,#+12
   \        0x8   0x....'....        BL       RCM_RegisterRegConv
   \        0xC   0xF884 0x0026      STRB     R0,[R4, #+38]
     54            /* Check */
     55            RVBS_Clear( pHandle );
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4010      POP      {R4,LR}
   \       0x16   0x....'....        B.W      RVBS_Clear
     56          }
     57          
     58          
     59          /**
     60            * @brief  It clears bus voltage FW variable containing average bus voltage
     61            *         value
     62            * @param  pHandle related RDivider_Handle_t
     63            * @retval none
     64            */

   \                                 In section .text, align 2
     65          __weak void RVBS_Clear( RDivider_Handle_t * pHandle )
     66          {
   \                     RVBS_Clear: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     67            uint16_t aux;
     68            uint16_t index;
     69          
     70            aux = ( pHandle->OverVoltageThreshold + pHandle->UnderVoltageThreshold ) / 2u;
   \        0x2   0x8B41             LDRH     R1,[R0, #+26]
   \        0x4   0x8B82             LDRH     R2,[R0, #+28]
   \        0x6   0x1851             ADDS     R1,R2,R1
   \        0x8   0x0849             LSRS     R1,R1,#+1
     71            for ( index = 0u; index < pHandle->LowPassFilterBW; index++ )
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0xE004             B.N      ??RVBS_Clear_0
     72            {
     73              pHandle->aBuffer[index] = aux;
   \                     ??RVBS_Clear_1: (+1)
   \        0xE   0x6A03             LDR      R3,[R0, #+32]
   \       0x10   0xB294             UXTH     R4,R2
   \       0x12   0xF823 0x1014      STRH     R1,[R3, R4, LSL #+1]
     74            }
   \       0x16   0x1C52             ADDS     R2,R2,#+1
   \                     ??RVBS_Clear_0: (+1)
   \       0x18   0x8B04             LDRH     R4,[R0, #+24]
   \       0x1A   0xB293             UXTH     R3,R2
   \       0x1C   0x42A3             CMP      R3,R4
   \       0x1E   0xD3F6             BCC.N    ??RVBS_Clear_1
     75            pHandle->_Super.LatestConv = aux;
   \       0x20   0x8081             STRH     R1,[R0, #+4]
     76            pHandle->_Super.AvBusVoltage_d = aux;
   \       0x22   0x80C1             STRH     R1,[R0, #+6]
     77            pHandle->index = 0;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0xF880 0x1025      STRB     R1,[R0, #+37]
     78          }
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
     79          
     80          static uint16_t RVBS_ConvertVbusFiltrered( RDivider_Handle_t * pHandle )
     81          {
     82            uint16_t hAux;
     83            uint8_t vindex;
     84            uint16_t max = 0, min = 0;
     85            uint32_t tot = 0u;
     86          
     87            for ( vindex = 0; vindex < pHandle->LowPassFilterBW; )
     88            {
     89              hAux = RCM_ExecRegularConv(pHandle->convHandle);
     90          
     91              if ( hAux != 0xFFFFu )
     92              {
     93                if ( vindex == 0 )
     94                {
     95                  min = hAux;
     96                  max = hAux;
     97                }
     98                else
     99                {
    100                  if ( hAux < min )
    101                  {
    102                    min = hAux;
    103                  }
    104                  if ( hAux > max )
    105                  {
    106                    max = hAux;
    107                  }
    108                }
    109                vindex++;
    110          
    111                tot += hAux;
    112              }
    113            }
    114          
    115            tot -= max;
    116            tot -= min;
    117            return ( uint16_t )( tot / ( pHandle->LowPassFilterBW - 2u ) );
    118          }
    119          
    120          /**
    121            * @brief  It actually performes the Vbus ADC conversion and updates average
    122            *         value
    123            * @param  pHandle related RDivider_Handle_t
    124            * @retval uint16_t Fault code error
    125            */

   \                                 In section .text, align 2
    126          __weak uint16_t RVBS_CalcAvVbusFilt( RDivider_Handle_t * pHandle )
    127          {
   \                     RVBS_CalcAvVbusFilt: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
    128            uint32_t wtemp;
    129            uint16_t hAux;
    130            uint8_t i;
    131          
    132            hAux = RVBS_ConvertVbusFiltrered( pHandle );
   \        0x6   0xF04F 0x0800      MOV      R8,#+0
   \        0xA   0x46C1             MOV      R9,R8
   \        0xC   0x46C2             MOV      R10,R8
   \        0xE   0x2700             MOVS     R7,#+0
   \       0x10   0xF104 0x0525      ADD      R5,R4,#+37
   \       0x14   0xF64F 0x76FF      MOVW     R6,#+65535
   \       0x18   0xE007             B.N      ??RVBS_CalcAvVbusFilt_0
   \                     ??RVBS_CalcAvVbusFilt_1: (+1)
   \       0x1A   0x4548             CMP      R0,R9
   \       0x1C   0xBF98             IT       LS
   \       0x1E   0x4681             MOVLS    R9,R0
   \       0x20   0x4540             CMP      R0,R8
   \       0x22   0xD300             BCC.N    ??RVBS_CalcAvVbusFilt_2
   \                     ??RVBS_CalcAvVbusFilt_3: (+1)
   \       0x24   0x4680             MOV      R8,R0
   \                     ??RVBS_CalcAvVbusFilt_2: (+1)
   \       0x26   0x1C7F             ADDS     R7,R7,#+1
   \       0x28   0x4482             ADD      R10,R10,R0
   \                     ??RVBS_CalcAvVbusFilt_0: (+1)
   \       0x2A   0x8B20             LDRH     R0,[R4, #+24]
   \       0x2C   0xB2F9             UXTB     R1,R7
   \       0x2E   0x4281             CMP      R1,R0
   \       0x30   0xD209             BCS.N    ??RVBS_CalcAvVbusFilt_4
   \       0x32   0x7868             LDRB     R0,[R5, #+1]
   \       0x34   0x....'....        BL       RCM_ExecRegularConv
   \       0x38   0x42B0             CMP      R0,R6
   \       0x3A   0xD0F6             BEQ.N    ??RVBS_CalcAvVbusFilt_0
   \       0x3C   0xB2F9             UXTB     R1,R7
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD1EB             BNE.N    ??RVBS_CalcAvVbusFilt_1
   \       0x42   0x4681             MOV      R9,R0
   \       0x44   0xE7EE             B.N      ??RVBS_CalcAvVbusFilt_3
   \                     ??RVBS_CalcAvVbusFilt_4: (+1)
   \       0x46   0xEBAA 0x0108      SUB      R1,R10,R8
   \       0x4A   0xEBA1 0x0109      SUB      R1,R1,R9
   \       0x4E   0x1E80             SUBS     R0,R0,#+2
   \       0x50   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    133          
    134            if ( hAux != 0xFFFF )
   \       0x54   0xB281             UXTH     R1,R0
   \       0x56   0x42B1             CMP      R1,R6
   \       0x58   0xD01A             BEQ.N    ??RVBS_CalcAvVbusFilt_5
    135            {
    136              pHandle->aBuffer[pHandle->index] = hAux;
   \       0x5A   0x6A21             LDR      R1,[R4, #+32]
   \       0x5C   0x782A             LDRB     R2,[R5, #+0]
   \       0x5E   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
    137              wtemp = 0;
   \       0x62   0x2200             MOVS     R2,#+0
    138              for ( i = 0; i < pHandle->LowPassFilterBW; i++ )
   \       0x64   0x8B26             LDRH     R6,[R4, #+24]
   \       0x66   0x2300             MOVS     R3,#+0
   \       0x68   0xE003             B.N      ??RVBS_CalcAvVbusFilt_6
    139              {
    140                wtemp += pHandle->aBuffer[i];
   \                     ??RVBS_CalcAvVbusFilt_7: (+1)
   \       0x6A   0xF831 0x7017      LDRH     R7,[R1, R7, LSL #+1]
   \       0x6E   0x19D2             ADDS     R2,R2,R7
    141              }
   \       0x70   0x1C5B             ADDS     R3,R3,#+1
   \                     ??RVBS_CalcAvVbusFilt_6: (+1)
   \       0x72   0xB2DF             UXTB     R7,R3
   \       0x74   0x42B7             CMP      R7,R6
   \       0x76   0xD3F8             BCC.N    ??RVBS_CalcAvVbusFilt_7
    142              wtemp /= pHandle->LowPassFilterBW;
    143              pHandle->_Super.AvBusVoltage_d = ( uint16_t )wtemp;
   \       0x78   0xFBB2 0xF1F6      UDIV     R1,R2,R6
    144              pHandle->_Super.LatestConv = hAux;
   \       0x7C   0x80A0             STRH     R0,[R4, #+4]
   \       0x7E   0x80E1             STRH     R1,[R4, #+6]
    145          
    146              if ( pHandle->index < pHandle->LowPassFilterBW - 1 )
   \       0x80   0x8B22             LDRH     R2,[R4, #+24]
   \       0x82   0x7828             LDRB     R0,[R5, #+0]
   \       0x84   0x1E52             SUBS     R2,R2,#+1
   \       0x86   0x4290             CMP      R0,R2
   \       0x88   0xBFB4             ITE      LT
   \       0x8A   0x1C40             ADDLT    R0,R0,#+1
   \       0x8C   0x2000             MOVGE    R0,#+0
    147              {
    148                pHandle->index++;
    149              }
    150              else
    151              {
    152                pHandle->index = 0;
   \       0x8E   0x7028             STRB     R0,[R5, #+0]
    153              }
    154            }
    155          
    156            pHandle->_Super.FaultState = RVBS_CheckFaultState( pHandle );
   \                     ??RVBS_CalcAvVbusFilt_5: (+1)
   \       0x90   0x4620             MOV      R0,R4
   \       0x92   0x....'....        BL       RVBS_CheckFaultState
    157          
    158            return ( pHandle->_Super.FaultState );
   \       0x96   0x8120             STRH     R0,[R4, #+8]
   \       0x98   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    159          }
    160          
    161          /**
    162            * @brief  It actually performes the Vbus ADC conversion and updates average
    163            *         value
    164            * @param  pHandle related RDivider_Handle_t
    165            * @retval uint16_t Fault code error
    166            */

   \                                 In section .text, align 2
    167          __weak uint16_t RVBS_CalcAvVbus( RDivider_Handle_t * pHandle )
    168          {
   \                     RVBS_CalcAvVbus: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    169            uint32_t wtemp;
    170            uint16_t hAux;
    171            uint8_t i;
    172          
    173            hAux = RCM_ExecRegularConv(pHandle->convHandle);
   \        0x4   0xF104 0x0525      ADD      R5,R4,#+37
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   \        0xA   0x....'....        BL       RCM_ExecRegularConv
    174          
    175            if ( hAux != 0xFFFF )
   \        0xE   0xF64F 0x72FF      MOVW     R2,#+65535
   \       0x12   0x4290             CMP      R0,R2
   \       0x14   0xD01A             BEQ.N    ??RVBS_CalcAvVbus_0
    176            {
    177              pHandle->aBuffer[pHandle->index] = hAux;
   \       0x16   0x6A21             LDR      R1,[R4, #+32]
   \       0x18   0x782A             LDRB     R2,[R5, #+0]
   \       0x1A   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
    178              wtemp = 0;
   \       0x1E   0x2200             MOVS     R2,#+0
    179              for ( i = 0; i < pHandle->LowPassFilterBW; i++ )
   \       0x20   0x8B26             LDRH     R6,[R4, #+24]
   \       0x22   0x2300             MOVS     R3,#+0
   \       0x24   0xE003             B.N      ??RVBS_CalcAvVbus_1
    180              {
    181                wtemp += pHandle->aBuffer[i];
   \                     ??RVBS_CalcAvVbus_2: (+1)
   \       0x26   0xF831 0x7017      LDRH     R7,[R1, R7, LSL #+1]
   \       0x2A   0x19D2             ADDS     R2,R2,R7
    182              }
   \       0x2C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??RVBS_CalcAvVbus_1: (+1)
   \       0x2E   0xB2DF             UXTB     R7,R3
   \       0x30   0x42B7             CMP      R7,R6
   \       0x32   0xD3F8             BCC.N    ??RVBS_CalcAvVbus_2
    183              wtemp /= pHandle->LowPassFilterBW;
    184              pHandle->_Super.AvBusVoltage_d = ( uint16_t )wtemp;
   \       0x34   0xFBB2 0xF1F6      UDIV     R1,R2,R6
    185              pHandle->_Super.LatestConv = hAux;
   \       0x38   0x80A0             STRH     R0,[R4, #+4]
   \       0x3A   0x80E1             STRH     R1,[R4, #+6]
    186          
    187              if ( pHandle->index < pHandle->LowPassFilterBW - 1 )
   \       0x3C   0x8B22             LDRH     R2,[R4, #+24]
   \       0x3E   0x7828             LDRB     R0,[R5, #+0]
   \       0x40   0x1E52             SUBS     R2,R2,#+1
   \       0x42   0x4290             CMP      R0,R2
   \       0x44   0xBFB4             ITE      LT
   \       0x46   0x1C40             ADDLT    R0,R0,#+1
   \       0x48   0x2000             MOVGE    R0,#+0
    188              {
    189                pHandle->index++;
    190              }
    191              else
    192              {
    193                pHandle->index = 0;
   \       0x4A   0x7028             STRB     R0,[R5, #+0]
    194              }
    195            }
    196          
    197            pHandle->_Super.FaultState = RVBS_CheckFaultState( pHandle );
   \                     ??RVBS_CalcAvVbus_0: (+1)
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       RVBS_CheckFaultState
    198          
    199            return ( pHandle->_Super.FaultState );
   \       0x52   0x8120             STRH     R0,[R4, #+8]
   \       0x54   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    200          }
    201          
    202          /**
    203            * @brief  It returns MC_OVER_VOLT, MC_UNDER_VOLT or MC_NO_ERROR depending on
    204            *         bus voltage and protection threshold values
    205            * @param  pHandle related RDivider_Handle_t
    206            * @retval uint16_t Fault code error
    207            */

   \                                 In section .text, align 2
    208          __weak uint16_t RVBS_CheckFaultState( RDivider_Handle_t * pHandle )
    209          {
    210            uint16_t fault;
    211          
    212            if ( pHandle->_Super.AvBusVoltage_d > pHandle->OverVoltageThreshold )
   \                     RVBS_CheckFaultState: (+1)
   \        0x0   0x88C1             LDRH     R1,[R0, #+6]
   \        0x2   0x8B42             LDRH     R2,[R0, #+26]
   \        0x4   0x428A             CMP      R2,R1
   \        0x6   0xD201             BCS.N    ??RVBS_CheckFaultState_0
    213            {
    214              fault = MC_OVER_VOLT;
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0x4770             BX       LR
    215            }
    216            else if ( pHandle->_Super.AvBusVoltage_d < pHandle->UnderVoltageThreshold )
   \                     ??RVBS_CheckFaultState_0: (+1)
   \        0xC   0x8B80             LDRH     R0,[R0, #+28]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD201             BCS.N    ??RVBS_CheckFaultState_1
    217            {
    218              fault = MC_UNDER_VOLT;
   \       0x12   0x2004             MOVS     R0,#+4
   \       0x14   0x4770             BX       LR
    219            }
    220            else
    221            {
    222              fault = MC_NO_ERROR;
   \                     ??RVBS_CheckFaultState_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
    223            }
    224            return fault;
   \       0x18   0x4770             BX       LR               ;; return
    225          }
    226          
    227          
    228          /**
    229            * @}
    230            */
    231          
    232          /**
    233            * @}
    234            */
    235          
    236          /** @} */
    237          
    238          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/
    239          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RVBS_CalcAvVbus
        24   -> RCM_ExecRegularConv
        24   -> RVBS_CheckFaultState
      32   RVBS_CalcAvVbusFilt
        32   -> RCM_ExecRegularConv
        32   -> RVBS_CheckFaultState
       0   RVBS_CheckFaultState
       8   RVBS_Clear
       8   RVBS_Init
         8   -> RCM_RegisterRegConv
         0   -> RVBS_Clear


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      86  RVBS_CalcAvVbus
     156  RVBS_CalcAvVbusFilt
      26  RVBS_CheckFaultState
      44  RVBS_Clear
      26  RVBS_Init

 
 338 bytes in section .text
 
 0 bytes of CODE memory (+ 338 bytes shared)

Errors: none
Warnings: none
