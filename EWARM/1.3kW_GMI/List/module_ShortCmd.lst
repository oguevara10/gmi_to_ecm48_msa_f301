###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:37
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_ShortCmd.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW5A2C.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_ShortCmd.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\module_ShortCmd.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\module_ShortCmd.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_ShortCmd.c
      1          /**
      2            ***************************************************************************************************
      3            * @file    module_ShortCmd.c 
      4            * @author  Regal Pamela Lee
      5            * @version V1.0
      6            * @date    1-Jul-2020
      7            * @brief   Decode and perform group 1 and 2 CMD
      8            * @note    This App decode Group1 and 2 CMD in Universal protocol
      9            ***************************************************************************************************
     10            */
     11          #include "pmsm_motor_parameters.h"
     12          #include "module_ShortCmd.h"

   \                                 In section .bss, align 4
   \   static __absolute uint8_t reallocError
   \                     reallocError:
   \        0x0                      DS8 1
   \        0x1                      DS8 3
     13          #include "mc_api.h"
     14          #include "driver_usart1.h"
     15          #include "ab_module_Mc_StateMachine.h"
     16          
     17          
     18          extern uint64_t getSysCount(void);
     19          /* SysCon handle declaration */
     20          extern ProcessInfo processInfoTable[];
     21          
     22          Usart1_Control* usart1Control_ShortCmd;
   \                     usart1Control_ShortCmd:
   \        0x4                      DS8 4
     23          Module_StateMachineControl*  module_StateMachineControl_ShortCmd;
   \                     module_StateMachineControl_ShortCmd:
   \        0x8                      DS8 4
     24          
     25          enum AppStates {
     26              INIT_APP,
     27              RUN_APP,
     28              // additional states to be added here as necessary.
     29              IRQ_APP = DEFAULT_IRQ_STATE,
     30              STOP_APP = KILL_APP
     31          };
     32          
     33          //uint16_t adcFilterVal = 0;
     34          unsigned char* protocolBuf_ShortCmd ;
   \                     protocolBuf_ShortCmd:
   \        0xC                      DS8 4
     35          //^**Tips: APPs/Drivers adding process example step7 (Add the Additional funtion itself)

   \                                 In section .text, align 2, keep-with-next
     36          uint8_t moduleShortCmd_u32(uint8_t module_id_u8, uint8_t prev_state_u8, uint8_t next_State_u8,
     37                                  uint8_t irq_id_u8)                 
     38          { 
   \                     moduleShortCmd_u32: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
     39            uint8_t     returnStage = 0;  
   \        0x2   0x2000             MOVS     R0,#+0
     40            
     41            switch (next_State_u8)
   \        0x4   0x....             LDR.N    R4,??DataTable0
   \        0x6   0xB132             CBZ.N    R2,??moduleShortCmd_u32_0
   \        0x8   0x2A01             CMP      R2,#+1
   \        0xA   0xD019             BEQ.N    ??moduleShortCmd_u32_1
   \        0xC   0x2AC8             CMP      R2,#+200
   \        0xE   0xD06D             BEQ.N    ??CrossCallReturnLabel_1
   \       0x10   0x2AFF             CMP      R2,#+255
   \       0x12   0xD06E             BEQ.N    ??moduleShortCmd_u32_2
   \       0x14   0xE06C             B.N      ??moduleShortCmd_u32_3
     42              {
     43                case INIT_APP:                                                              //initial stage
     44                  {
     45                    /*Attach Uart2 shared memory into this App*/
     46                    uint8_t Usart1index  = getProcessInfoIndex(MODULE_USART1);              //return Process index from processInfo array with the Uart2 driver
   \                     ??moduleShortCmd_u32_0: (+1)
   \       0x16   0x....'....        BL       getProcessInfoIndex
     47                    usart1Control_ShortCmd = (Usart1_Control*) ((*(processInfoTable[Usart1index].Sched_ModuleData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x1A   0x2516             MOVS     R5,#+22
   \       0x1C   0x....             LDR.N    R6,??DataTable0_1
   \       0x1E   0xF106 0x020B      ADD      R2,R6,#+11
   \       0x22   0x4368             MULS     R0,R5,R0
   \       0x24   0x5811             LDR      R1,[R2, R0]
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0x6060             STR      R0,[R4, #+4]
     48                    uint8_t Mc_StateMachineindex  = getProcessInfoIndex(MODULE_MC_STATEMACHINE);              //return Process index from processInfo array with the MC_statemachine module
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x....'....        BL       getProcessInfoIndex
     49                    module_StateMachineControl_ShortCmd = (Module_StateMachineControl*) ((*(processInfoTable[Mc_StateMachineindex].Sched_ModuleData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x30   0xF106 0x010B      ADD      R1,R6,#+11
   \       0x34   0xFB15 0xF500      SMULBB   R5,R5,R0
   \       0x38   0x5948             LDR      R0,[R1, R5]
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x60A0             STR      R0,[R4, #+8]
   \       0x3E   0xE055             B.N      ??CrossCallReturnLabel_1
     50                    
     51                    returnStage = RUN_APP ;
     52                    break;
     53                  }       
     54                case RUN_APP:
     55                  { 
     56                    unsigned int DataLen2 = (unsigned int)UniHeaderlen;
     57                    if(RingBuf_GetUsedNumOfElements((*usart1Control_ShortCmd).seqMemRXG1_2_u32) >= DataLen2 )
   \                     ??moduleShortCmd_u32_1: (+1)
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x2107             MOVS     R1,#+7
   \       0x44   0x9100             STR      R1,[SP, #+0]
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x4C   0x9900             LDR      R1,[SP, #+0]
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD346             BCC.N    ??moduleShortCmd_u32_4
     58                    {        
     59                      if((protocolBuf_ShortCmd = (unsigned char*) realloc(protocolBuf_ShortCmd,DataLen2)) == NULL) reallocError++;     
   \       0x52   0x68E0             LDR      R0,[R4, #+12]
   \       0x54   0x....'....        BL       realloc
   \       0x58   0x0001             MOVS     R1,R0
   \       0x5A   0xD102             BNE.N    ??moduleShortCmd_u32_5
   \       0x5C   0x7820             LDRB     R0,[R4, #+0]
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0x7020             STRB     R0,[R4, #+0]
     60                      RingBuf_Observe((*usart1Control_ShortCmd).seqMemRXG1_2_u32, protocolBuf_ShortCmd, 0, &DataLen2);  
   \                     ??moduleShortCmd_u32_5: (+1)
   \       0x62   0x60E1             STR      R1,[R4, #+12]
   \       0x64   0x466B             MOV      R3,SP
   \       0x66   0x6860             LDR      R0,[R4, #+4]
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x....'....        BL       RingBuf_Observe
     61                      //calculate the total number of frame
     62                      DataLen2 = ((unsigned int)protocolBuf_ShortCmd[1] & 0x3F) + (unsigned int)UniHeaderlen;
   \       0x70   0x68E0             LDR      R0,[R4, #+12]
   \       0x72   0x7841             LDRB     R1,[R0, #+1]
   \       0x74   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x78   0x1DC9             ADDS     R1,R1,#+7
   \       0x7A   0x9100             STR      R1,[SP, #+0]
     63                      if((protocolBuf_ShortCmd = (unsigned char*) realloc(protocolBuf_ShortCmd,DataLen2)) == NULL) reallocError++;     //allocate the right frame size of memory for buffer
   \       0x7C   0x....'....        BL       realloc
   \       0x80   0x....'....        BL       ?Subroutine0
     64                      RingBuf_ReadBlock((*usart1Control_ShortCmd).seqMemRXG1_2_u32, protocolBuf_ShortCmd, &DataLen2); //extract the whole frame
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x84   0x4601             MOV      R1,R0
   \       0x86   0x6860             LDR      R0,[R4, #+4]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x466A             MOV      R2,SP
   \       0x8C   0x....'....        BL       RingBuf_ReadBlock
     65                      //decode and perform the CMD function
     66                      switch(protocolBuf_ShortCmd[2])
   \       0x90   0x68E0             LDR      R0,[R4, #+12]
   \       0x92   0x7881             LDRB     R1,[R0, #+2]
   \       0x94   0xB141             CBZ.N    R1,??moduleShortCmd_u32_6
   \       0x96   0x2901             CMP      R1,#+1
   \       0x98   0xD009             BEQ.N    ??moduleShortCmd_u32_7
   \       0x9A   0x2902             CMP      R1,#+2
   \       0x9C   0xD00A             BEQ.N    ??moduleShortCmd_u32_8
   \       0x9E   0x2903             CMP      R1,#+3
   \       0xA0   0xD00B             BEQ.N    ??moduleShortCmd_u32_9
   \       0xA2   0x2921             CMP      R1,#+33
   \       0xA4   0xD00C             BEQ.N    ??moduleShortCmd_u32_10
   \       0xA6   0xE01B             B.N      ??moduleShortCmd_u32_4
     67                      {
     68                        case 0x00:
     69                          {
     70                            MC_StartMotor1();
   \                     ??moduleShortCmd_u32_6: (+1)
   \       0xA8   0x....'....        BL       MC_StartMotor1
     71                            break;
   \       0xAC   0xE018             B.N      ??moduleShortCmd_u32_4
     72                          }
     73                        case 0x01:
     74                          {
     75                            MC_StopMotor1();                  
   \                     ??moduleShortCmd_u32_7: (+1)
   \       0xAE   0x....'....        BL       MC_StopMotor1
     76                            break;
   \       0xB2   0xE015             B.N      ??moduleShortCmd_u32_4
     77                          }
     78                        case 0x02:
     79                          {
     80                            MC_StopRampMotor1();
   \                     ??moduleShortCmd_u32_8: (+1)
   \       0xB4   0x....'....        BL       MC_StopRampMotor1
     81                            break;
   \       0xB8   0xE012             B.N      ??moduleShortCmd_u32_4
     82                          }
     83                        case 0x03:
     84                          {
     85                            MC_AcknowledgeFaultMotor1();
   \                     ??moduleShortCmd_u32_9: (+1)
   \       0xBA   0x....'....        BL       MC_AcknowledgeFaultMotor1
     86                            break;
   \       0xBE   0xE00F             B.N      ??moduleShortCmd_u32_4
     87                          }
     88                        case 0x21:
     89                          {
     90                            int32_t speed_target = protocolBuf_ShortCmd[6];
     91                            speed_target += (int16_t) protocolBuf_ShortCmd[5] << 8;
     92                            (*module_StateMachineControl_ShortCmd).command_Speed = speed_target;
   \                     ??moduleShortCmd_u32_10: (+1)
   \       0xC0   0x68A1             LDR      R1,[R4, #+8]
   \       0xC2   0x7982             LDRB     R2,[R0, #+6]
   \       0xC4   0x7943             LDRB     R3,[R0, #+5]
   \       0xC6   0xEB02 0x2503      ADD      R5,R2,R3, LSL #+8
   \       0xCA   0x600D             STR      R5,[R1, #+0]
     93                            
     94                            uint8_t dir_target = (uint8_t) protocolBuf_ShortCmd[7];
   \       0xCC   0x79C0             LDRB     R0,[R0, #+7]
     95                            
     96                            if (dir_target == 6)(*module_StateMachineControl_ShortCmd).motorDir = 1;
   \       0xCE   0x2806             CMP      R0,#+6
   \       0xD0   0xBF08             IT       EQ
   \       0xD2   0x2001             MOVEQ    R0,#+1
   \       0xD4   0xD003             BEQ.N    ??moduleShortCmd_u32_11
     97                            if (dir_target == 9) (*module_StateMachineControl_ShortCmd).motorDir = -1;
   \       0xD6   0x2809             CMP      R0,#+9
   \       0xD8   0xD102             BNE.N    ??moduleShortCmd_u32_4
   \       0xDA   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??moduleShortCmd_u32_11: (+1)
   \       0xDE   0x71C8             STRB     R0,[R1, #+7]
     98                            
     99                            break;
    100                          }
    101                        default:
    102                          break;
    103                      }
    104          
    105                    }
    106                    if((protocolBuf_ShortCmd = (unsigned char*) realloc(protocolBuf_ShortCmd,1)) == NULL) reallocError++;;
   \                     ??moduleShortCmd_u32_4: (+1)
   \       0xE0   0x68E0             LDR      R0,[R4, #+12]
   \       0xE2   0x2101             MOVS     R1,#+1
   \       0xE4   0x....'....        BL       realloc
   \       0xE8   0x....'....        BL       ?Subroutine0
    107                    returnStage = RUN_APP;
    108                    break;
    109                  }
    110                case IRQ_APP:
    111                  {
    112                    //if more than 1 driver interrupt attached to this APP
    113          //           uint8_t index = getProcessInfoIndex(interruptIdentfer);         //return Process index from processInfo array of the driver interrupt call, APP can response respectively
    114                    returnStage = RUN_APP;
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xEC   0x2001             MOVS     R0,#+1
    115                    break;
   \       0xEE   0xBD76             POP      {R1,R2,R4-R6,PC}
    116                  }               
    117                case STOP_APP:
    118                  {
    119                    returnStage = INIT_APP;
    120                    break;
    121                  }
    122                default:
    123                  returnStage = STOP_APP;   
   \                     ??moduleShortCmd_u32_3: (+1)
   \       0xF0   0x20FF             MOVS     R0,#+255
    124              }
    125            return returnStage;
   \                     ??moduleShortCmd_u32_2: (+1)
   \       0xF2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    126          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB910             CBNZ.N   R0,??Subroutine0_0
   \        0x2   0x7821             LDRB     R1,[R4, #+0]
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   \                     ??Subroutine0_0: (+1)
   \        0x8   0x60E0             STR      R0,[R4, #+12]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     reallocError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \        0x0   0x....'....        DC32     processInfoTable
    127          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   moduleShortCmd_u32
        24   -> MC_AcknowledgeFaultMotor1
        24   -> MC_StartMotor1
        24   -> MC_StopMotor1
        24   -> MC_StopRampMotor1
        24   -> RingBuf_GetUsedNumOfElements
        24   -> RingBuf_Observe
        24   -> RingBuf_ReadBlock
        24   -> getProcessInfoIndex
        24   -> realloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      12  ?Subroutine0
     244  moduleShortCmd_u32
      16  reallocError
          usart1Control_ShortCmd
          module_StateMachineControl_ShortCmd
          protocolBuf_ShortCmd

 
  16 bytes in section .bss
 264 bytes in section .text
 
 264 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
