###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:03
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\ramp_ext_mngr.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW2831.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\ramp_ext_mngr.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\ramp_ext_mngr.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\ramp_ext_mngr.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\ramp_ext_mngr.c
      1          /**
      2            ******************************************************************************
      3            * @file    ramp_ext_mngr.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the features
      6            *          of the Ramp Extended Manager component of the Motor Control SDK:
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "ramp_ext_mngr.h"
     24          
     25          /** @addtogroup MCSDK
     26            * @{
     27            */
     28          
     29          /** @defgroup RampExtMngr Ramp Manager
     30            * @brief Ramp Extended Manager component of the Motor Control SDK
     31            *
     32            * @todo Document the Ramp Extended Manager "module".
     33            *
     34            * @{
     35            */
     36          /* Private function prototypes -----------------------------------------------*/
     37          uint32_t getScalingFactor( int32_t Target );
     38          
     39          /**
     40            * @brief  It reset the state variable to zero.
     41            * @param  pHandle related Handle of struct RampMngr_Handle_t
     42            * @retval none.
     43            */

   \                                 In section .text, align 2, keep-with-next
     44          void REMNG_Init( RampExtMngr_Handle_t * pHandle )
     45          {
     46            pHandle->Ext = 0;
   \                     REMNG_Init: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6081             STR      R1,[R0, #+8]
     47            pHandle->TargetFinal = 0;
   \        0x4   0x6041             STR      R1,[R0, #+4]
     48            pHandle->RampRemainingStep = 0u;
   \        0x6   0x60C1             STR      R1,[R0, #+12]
     49            pHandle->IncDecAmount = 0;
   \        0x8   0x6101             STR      R1,[R0, #+16]
     50            pHandle->ScalingFactor = 1u;
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x6141             STR      R1,[R0, #+20]
     51          
     52          #ifdef FASTDIV
     53            FD_Init( & ( pHandle->fd ) );
     54          #endif
     55          
     56          }
   \        0xE   0x4770             BX       LR               ;; return
     57          
     58          /**
     59            * @brief  Exec the ramp calculations and returns the current value of the
     60                      state variable.
     61                      It must be called at fixed interval defined in the hExecFreq.
     62            * @param  pHandle related Handle of struct RampMngr_Handle_t
     63            * @retval int32_t value of the state variable
     64            */

   \                                 In section .text, align 2
     65          __weak int32_t REMNG_Calc( RampExtMngr_Handle_t * pHandle )
     66          {
     67            int32_t ret_val;
     68            int32_t current_ref;
     69          
     70            current_ref = pHandle->Ext;
     71          
     72            /* Update the variable and terminates the ramp if needed. */
     73            if ( pHandle->RampRemainingStep > 1u )
   \                     REMNG_Calc: (+1)
   \        0x0   0x68C3             LDR      R3,[R0, #+12]
   \        0x2   0x6882             LDR      R2,[R0, #+8]
   \        0x4   0x2B01             CMP      R3,#+1
   \        0x6   0xD903             BLS.N    ??REMNG_Calc_0
     74            {
     75              /* Increment/decrement the reference value. */
     76              current_ref += pHandle->IncDecAmount;
   \        0x8   0x6901             LDR      R1,[R0, #+16]
   \        0xA   0x188A             ADDS     R2,R1,R2
     77          
     78              /* Decrement the number of remaining steps */
     79              pHandle->RampRemainingStep --;
   \        0xC   0x1E5B             SUBS     R3,R3,#+1
   \        0xE   0xE004             B.N      ??REMNG_Calc_1
     80            }
     81            else if ( pHandle->RampRemainingStep == 1u )
   \                     ??REMNG_Calc_0: (+1)
   \       0x10   0xD104             BNE.N    ??REMNG_Calc_2
     82            {
     83              /* Set the backup value of TargetFinal. */
     84              current_ref = pHandle->TargetFinal * ( int32_t )( pHandle->ScalingFactor );
   \       0x12   0x6842             LDR      R2,[R0, #+4]
   \       0x14   0x6941             LDR      R1,[R0, #+20]
   \       0x16   0x434A             MULS     R2,R1,R2
     85              pHandle->RampRemainingStep = 0u;
   \       0x18   0x2300             MOVS     R3,#+0
   \                     ??REMNG_Calc_1: (+1)
   \       0x1A   0x60C3             STR      R3,[R0, #+12]
     86            }
     87            else
     88            {
     89              /* Do nothing. */
     90            }
     91          
     92            pHandle->Ext = current_ref;
     93          
     94          #ifdef FASTDIV
     95            ret_val = FD_FastDiv( & ( pHandle->fd ), pHandle->Ext, ( int32_t )( pHandle->ScalingFactor ) );
     96          #else
     97            ret_val = pHandle->Ext / ( int32_t )( pHandle->ScalingFactor );
     98          #endif
     99          
    100            return ret_val;
   \                     ??REMNG_Calc_2: (+1)
   \       0x1C   0x6082             STR      R2,[R0, #+8]
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \       0x24   0x4770             BX       LR               ;; return
    101          }
    102          
    103          /**
    104            * @brief  Setup the ramp to be executed
    105            * @param  pHandle related Handle of struct RampMngr_Handle_t
    106            * @param  hTargetFinal (signed 32bit) final value of state variable at the end
    107            *         of the ramp.
    108            * @param  hDurationms (unsigned 32bit) the duration of the ramp expressed in
    109            *         milliseconds. It is possible to set 0 to perform an instantaneous
    110            *         change in the value.
    111            * @retval bool It returns true is command is valid, false otherwise
    112            */

   \                                 In section .text, align 2
    113          __weak bool REMNG_ExecRamp( RampExtMngr_Handle_t * pHandle, int32_t TargetFinal, uint32_t Durationms )
    114          {
   \                     REMNG_ExecRamp: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
    115            uint32_t aux;
    116            int32_t aux1;
    117            int32_t current_ref;
    118            bool retVal = true;
    119          
    120            /* Get current state */
    121          #ifdef FASTDIV
    122            current_ref = FD_FastDiv( &( pHandle->fd ), pHandle->Ext, ( int32_t )( pHandle->ScalingFactor ) );
    123          #else
    124            current_ref = pHandle->Ext / ( int32_t )( pHandle->ScalingFactor );
   \        0x8   0x68A8             LDR      R0,[R5, #+8]
   \        0xA   0x6969             LDR      R1,[R5, #+20]
   \        0xC   0xEA5F 0x0802      MOVS     R8,R2
   \       0x10   0xFB90 0xF4F1      SDIV     R4,R0,R1
    125          #endif
    126          
    127            if ( Durationms == 0u )
   \       0x14   0xD108             BNE.N    ??REMNG_ExecRamp_0
    128            {
    129              pHandle->ScalingFactor = getScalingFactor( TargetFinal );
   \       0x16   0x4638             MOV      R0,R7
   \       0x18   0x....'....        BL       getScalingFactor
   \       0x1C   0x6168             STR      R0,[R5, #+20]
    130              pHandle->Ext = TargetFinal * ( int32_t )( pHandle->ScalingFactor );
   \       0x1E   0x4347             MULS     R7,R0,R7
   \       0x20   0x60AF             STR      R7,[R5, #+8]
    131              pHandle->RampRemainingStep = 0u;
   \       0x22   0x2100             MOVS     R1,#+0
    132              pHandle->IncDecAmount = 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE023             B.N      ??REMNG_ExecRamp_1
    133            }
    134            else
    135            {
    136              uint32_t wScalingFactor = getScalingFactor( TargetFinal - current_ref );
   \                     ??REMNG_ExecRamp_0: (+1)
   \       0x28   0x1B3E             SUBS     R6,R7,R4
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x....'....        BL       getScalingFactor
   \       0x30   0x4681             MOV      R9,R0
    137              uint32_t wScalingFactor2 = getScalingFactor( current_ref );
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       getScalingFactor
   \       0x38   0x4682             MOV      R10,R0
    138              uint32_t wScalingFactor3 = getScalingFactor( TargetFinal );
   \       0x3A   0x4638             MOV      R0,R7
   \       0x3C   0x....'....        BL       getScalingFactor
    139              uint32_t wScalingFactorMin;
    140          
    141              if ( wScalingFactor <  wScalingFactor2 )
   \       0x40   0x45D1             CMP      R9,R10
   \       0x42   0xBF28             IT       CS
   \       0x44   0x46D1             MOVCS    R9,R10
    142              {
    143                if ( wScalingFactor < wScalingFactor3 )
    144                {
    145                  wScalingFactorMin = wScalingFactor;
    146                }
    147                else
    148                {
    149                  wScalingFactorMin = wScalingFactor3;
    150                }
    151              }
    152              else
    153              {
    154                if ( wScalingFactor2 < wScalingFactor3 )
   \       0x46   0x4581             CMP      R9,R0
   \       0x48   0xBF88             IT       HI
   \       0x4A   0x4681             MOVHI    R9,R0
    155                {
    156                  wScalingFactorMin = wScalingFactor2;
    157                }
    158                else
    159                {
    160                  wScalingFactorMin = wScalingFactor3;
    161                }
    162              }
    163          
    164              pHandle->ScalingFactor = wScalingFactorMin;
    165              pHandle->Ext = current_ref * ( int32_t )( pHandle->ScalingFactor );
   \       0x4C   0xFB09 0xF404      MUL      R4,R9,R4
   \       0x50   0x60AC             STR      R4,[R5, #+8]
    166          
    167              /* Store the TargetFinal to be applied in the last step */
    168              pHandle->TargetFinal = TargetFinal;
   \       0x52   0xF8C5 0x9014      STR      R9,[R5, #+20]
   \       0x56   0x606F             STR      R7,[R5, #+4]
    169          
    170              /* Compute the (wRampRemainingStep) number of steps remaining to complete
    171              the ramp. */
    172              aux = Durationms * ( uint32_t )pHandle->FrequencyHz; /* Check for overflow and use prescaler */
    173              aux /= 1000u;
    174              pHandle->RampRemainingStep = aux;
    175              pHandle->RampRemainingStep++;
   \       0x58   0xF44F 0x717A      MOV      R1,#+1000
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0xFB00 0xF008      MUL      R0,R0,R8
   \       0x62   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    176          
    177              /* Compute the increment/decrement amount (wIncDecAmount) to be applied to
    178              the reference value at each CalcTorqueReference. */
    179              aux1 = ( TargetFinal - current_ref ) * ( int32_t )( pHandle->ScalingFactor );
    180              aux1 /= ( int32_t )( pHandle->RampRemainingStep );
    181              pHandle->IncDecAmount = aux1;
   \       0x66   0x6968             LDR      R0,[R5, #+20]
   \       0x68   0x1C49             ADDS     R1,R1,#+1
   \       0x6A   0x4346             MULS     R6,R0,R6
   \       0x6C   0xFB96 0xF0F1      SDIV     R0,R6,R1
    182            }
    183          
    184            return retVal;
   \                     ??REMNG_ExecRamp_1: (+1)
   \       0x70   0x6128             STR      R0,[R5, #+16]
   \       0x72   0x60E9             STR      R1,[R5, #+12]
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    185          }
    186          
    187          /**
    188            * @brief  Returns the current value of the state variable.
    189            * @param  pHandle related Handle of struct RampMngr_Handle_t
    190            * @retval int32_t value of the state variable
    191            */

   \                                 In section .text, align 2
    192          __weak int32_t REMNG_GetValue( RampExtMngr_Handle_t * pHandle )
    193          {
    194            int32_t ret_val;
    195            ret_val = pHandle->Ext / ( int32_t )( pHandle->ScalingFactor );
    196            return ret_val;
   \                     REMNG_GetValue: (+1)
   \        0x0   0x6881             LDR      R1,[R0, #+8]
   \        0x2   0x6940             LDR      R0,[R0, #+20]
   \        0x4   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \        0x8   0x4770             BX       LR               ;; return
    197          }
    198          
    199          /**
    200            * @brief  Check if the settled ramp has been completed.
    201            * @param  pHandle related Handle of struct RampMngr_Handle_t.
    202            * @retval bool It returns true if the ramp is completed, false otherwise.
    203            */

   \                                 In section .text, align 2
    204          __weak bool REMNG_RampCompleted( RampExtMngr_Handle_t * pHandle )
    205          {
   \                     REMNG_RampCompleted: (+1)
   \        0x0   0x4601             MOV      R1,R0
    206            bool retVal = false;
   \        0x2   0x2000             MOVS     R0,#+0
    207            if ( pHandle->RampRemainingStep == 0u )
   \        0x4   0x68C9             LDR      R1,[R1, #+12]
   \        0x6   0xB901             CBNZ.N   R1,??REMNG_RampCompleted_0
    208            {
    209              retVal = true;
   \        0x8   0x2001             MOVS     R0,#+1
    210            }
    211            return retVal;
   \                     ??REMNG_RampCompleted_0: (+1)
   \        0xA   0x4770             BX       LR               ;; return
    212          }
    213          
    214          /**
    215            * @brief  Stop the execution of the ramp keeping the last reached value.
    216            * @param  pHandle related Handle of struct RampMngr_Handle_t.
    217            * @retval none
    218            */

   \                                 In section .text, align 2
    219          __weak void REMNG_StopRamp( RampExtMngr_Handle_t * pHandle )
    220          {
    221            pHandle->RampRemainingStep = 0u;
   \                     REMNG_StopRamp: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x60C1             STR      R1,[R0, #+12]
    222            pHandle->IncDecAmount = 0;
   \        0x4   0x6101             STR      R1,[R0, #+16]
    223          }
   \        0x6   0x4770             BX       LR               ;; return
    224          
    225          /**
    226            * @brief  Calculating the scaling factor to maximixe the resolution. It
    227            *         perform the 2^int(31-log2(Target)) with an iterative approach.
    228            *         It allows to keep Target * Scaling factor inside int32_t type.
    229            * @param  Target Input data.
    230            * @retval uint32_t It returns the optimized scaling factor.
    231            */

   \                                 In section .text, align 2
    232          __weak uint32_t getScalingFactor( int32_t Target )
    233          {
   \                     getScalingFactor: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0001             MOVS     R1,R0
    234            uint8_t i;
    235            uint32_t TargetAbs;
    236            int32_t aux;
    237          
    238            if ( Target < 0 )
   \        0x4   0xBF48             IT       MI
   \        0x6   0x4249             RSBMI    R1,R1,#+0
    239            {
    240              aux = -Target;
    241              TargetAbs = ( uint32_t )( aux );
    242            }
    243            else
    244            {
    245              TargetAbs = ( uint32_t )( Target );
    246            }
    247            for ( i = 1u; i < 32u; i++ )
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x2001             MOVS     R0,#+1
    248            {
    249              uint32_t limit = ( ( uint32_t )( 1 ) << ( 31u - i ) );
    250              if ( TargetAbs >= limit )
   \                     ??getScalingFactor_0: (+1)
   \        0xC   0xF1C2 0x031F      RSB      R3,R2,#+31
   \       0x10   0xFA00 0xF303      LSL      R3,R0,R3
   \       0x14   0x4299             CMP      R1,R3
   \       0x16   0xBF3E             ITTT     CC
   \       0x18   0x1C52             ADDCC    R2,R2,#+1
   \       0x1A   0xB2D4             UXTBCC   R4,R2
   \       0x1C   0x2C20             CMPCC    R4,#+32
    251              {
    252                break;
    253              }
    254            }
   \       0x1E   0xD3F5             BCC.N    ??getScalingFactor_0
    255            return ( ( uint32_t )( 1u ) << ( i - 1u ) );
   \       0x20   0x1E51             SUBS     R1,R2,#+1
   \       0x22   0x4088             LSLS     R0,R0,R1
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    256          }
    257          
    258          /**
    259           * @}
    260           */
    261          
    262          /**
    263           * @}
    264           */
    265          
    266          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   REMNG_Calc
      32   REMNG_ExecRamp
        32   -> getScalingFactor
       0   REMNG_GetValue
       0   REMNG_Init
       0   REMNG_RampCompleted
       0   REMNG_StopRamp
       8   getScalingFactor


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  REMNG_Calc
     122  REMNG_ExecRamp
      10  REMNG_GetValue
      16  REMNG_Init
      12  REMNG_RampCompleted
       8  REMNG_StopRamp
      38  getScalingFactor

 
 244 bytes in section .text
 
 16 bytes of CODE memory (+ 228 bytes shared)

Errors: none
Warnings: none
