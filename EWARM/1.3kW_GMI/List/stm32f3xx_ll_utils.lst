###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:19
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_utils.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW67CF.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_utils.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\stm32f3xx_ll_utils.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\stm32f3xx_ll_utils.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_utils.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_ll_utils.c
      4            * @author  MCD Application Team
      5            * @brief   UTILS LL module driver.
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          /* Includes ------------------------------------------------------------------*/
     20          #include "stm32f3xx_ll_rcc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp uint32_t LL_RCC_PLL_IsReady(void)
   \                     LL_RCC_PLL_IsReady: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable8  ;; 0x40021000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0E40             LSRS     R0,R0,#+25
   \        0x6   0xF000 0x0001      AND      R0,R0,#0x1
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp void LL_RCC_PLL_ConfigDomain_SYS(uint32_t, uint32_t)
   \                     LL_RCC_PLL_ConfigDomain_SYS: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             LDR.N    R3,??DataTable8_1  ;; 0x40021004
   \        0x4   0x681C             LDR      R4,[R3, #+0]
   \        0x6   0xF424 0x1474      BIC      R4,R4,#0x3D0000
   \        0xA   0xF400 0x3280      AND      R2,R0,#0x10000
   \        0xE   0x4314             ORRS     R4,R2,R4
   \       0x10   0x4321             ORRS     R1,R1,R4
   \       0x12   0x6019             STR      R1,[R3, #+0]
   \       0x14   0xF000 0x000F      AND      R0,R0,#0xF
   \       0x18   0x6A99             LDR      R1,[R3, #+40]
   \       0x1A   0x0909             LSRS     R1,R1,#+4
   \       0x1C   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \       0x20   0x6298             STR      R0,[R3, #+40]
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
     21          #include "stm32f3xx_ll_utils.h"
     22          #include "stm32f3xx_ll_system.h"
     23          #include "stm32f3xx_ll_pwr.h"
     24          #ifdef  USE_FULL_ASSERT
     25          #include "stm32_assert.h"
     26          #else
     27          #define assert_param(expr) ((void)0U)
     28          #endif
     29          
     30          /** @addtogroup STM32F3xx_LL_Driver
     31            * @{
     32            */
     33          
     34          /** @addtogroup UTILS_LL
     35            * @{
     36            */
     37          
     38          /* Private types -------------------------------------------------------------*/
     39          /* Private variables ---------------------------------------------------------*/
     40          /* Private constants ---------------------------------------------------------*/
     41          /** @addtogroup UTILS_LL_Private_Constants
     42            * @{
     43            */
     44          
     45          /* Defines used for PLL range */
     46          #define UTILS_PLL_OUTPUT_MAX        72000000U    /*!< Frequency max for PLL output, in Hz  */
     47          
     48          /* Defines used for HSE range */
     49          #define UTILS_HSE_FREQUENCY_MIN      4000000U       /*!< Frequency min for HSE frequency, in Hz   */
     50          #define UTILS_HSE_FREQUENCY_MAX     32000000U       /*!< Frequency max for HSE frequency, in Hz   */
     51          
     52          /* Defines used for FLASH latency according to SYSCLK Frequency */
     53          #define UTILS_LATENCY1_FREQ         24000000U        /*!< SYSCLK frequency to set FLASH latency 1 */
     54          #define UTILS_LATENCY2_FREQ         48000000U        /*!< SYSCLK frequency to set FLASH latency 2 */
     55          /**
     56            * @}
     57            */
     58          /* Private macros ------------------------------------------------------------*/
     59          /** @addtogroup UTILS_LL_Private_Macros
     60            * @{
     61            */
     62          #define IS_LL_UTILS_SYSCLK_DIV(__VALUE__) (((__VALUE__) == LL_RCC_SYSCLK_DIV_1)   \
     63                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_2)   \
     64                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_4)   \
     65                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_8)   \
     66                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_16)  \
     67                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_64)  \
     68                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_128) \
     69                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_256) \
     70                                                  || ((__VALUE__) == LL_RCC_SYSCLK_DIV_512))
     71          
     72          #define IS_LL_UTILS_APB1_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB1_DIV_1) \
     73                                                || ((__VALUE__) == LL_RCC_APB1_DIV_2) \
     74                                                || ((__VALUE__) == LL_RCC_APB1_DIV_4) \
     75                                                || ((__VALUE__) == LL_RCC_APB1_DIV_8) \
     76                                                || ((__VALUE__) == LL_RCC_APB1_DIV_16))
     77          
     78          #define IS_LL_UTILS_APB2_DIV(__VALUE__) (((__VALUE__) == LL_RCC_APB2_DIV_1) \
     79                                                || ((__VALUE__) == LL_RCC_APB2_DIV_2) \
     80                                                || ((__VALUE__) == LL_RCC_APB2_DIV_4) \
     81                                                || ((__VALUE__) == LL_RCC_APB2_DIV_8) \
     82                                                || ((__VALUE__) == LL_RCC_APB2_DIV_16))
     83          
     84          #define IS_LL_UTILS_PLLMUL_VALUE(__VALUE__) (((__VALUE__) == LL_RCC_PLL_MUL_2) \
     85                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_3) \
     86                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_4) \
     87                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_5) \
     88                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_6) \
     89                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_7) \
     90                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_8) \
     91                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_9) \
     92                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_10) \
     93                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_11) \
     94                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_12) \
     95                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_13) \
     96                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_14) \
     97                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_15) \
     98                                                    || ((__VALUE__) == LL_RCC_PLL_MUL_16))
     99          
    100          #define IS_LL_UTILS_PREDIV_VALUE(__VALUE__) (((__VALUE__) == LL_RCC_PREDIV_DIV_1)  || ((__VALUE__) == LL_RCC_PREDIV_DIV_2)   || \
    101                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_3)  || ((__VALUE__) == LL_RCC_PREDIV_DIV_4)   || \
    102                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_5)  || ((__VALUE__) == LL_RCC_PREDIV_DIV_6)   || \
    103                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_7)  || ((__VALUE__) == LL_RCC_PREDIV_DIV_8)   || \
    104                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_9)  || ((__VALUE__) == LL_RCC_PREDIV_DIV_10)  || \
    105                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_11) || ((__VALUE__) == LL_RCC_PREDIV_DIV_12)  || \
    106                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_13) || ((__VALUE__) == LL_RCC_PREDIV_DIV_14)  || \
    107                                                       ((__VALUE__) == LL_RCC_PREDIV_DIV_15) || ((__VALUE__) == LL_RCC_PREDIV_DIV_16))
    108          
    109          #define IS_LL_UTILS_PLL_FREQUENCY(__VALUE__) ((__VALUE__) <= UTILS_PLL_OUTPUT_MAX)
    110          
    111          
    112          #define IS_LL_UTILS_HSE_BYPASS(__STATE__) (((__STATE__) == LL_UTILS_HSEBYPASS_ON) \
    113                                                  || ((__STATE__) == LL_UTILS_HSEBYPASS_OFF))
    114          
    115          #define IS_LL_UTILS_HSE_FREQUENCY(__FREQUENCY__) (((__FREQUENCY__) >= UTILS_HSE_FREQUENCY_MIN) && ((__FREQUENCY__) <= UTILS_HSE_FREQUENCY_MAX))
    116          /**
    117            * @}
    118            */
    119          /* Private function prototypes -----------------------------------------------*/
    120          /** @defgroup UTILS_LL_Private_Functions UTILS Private functions
    121            * @{
    122            */
    123          static uint32_t    UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency,
    124                                                         LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct);
    125          #if defined(FLASH_ACR_LATENCY)
    126          static ErrorStatus UTILS_SetFlashLatency(uint32_t Frequency);
    127          #endif /* FLASH_ACR_LATENCY */
    128          static ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct);
    129          static ErrorStatus UTILS_PLL_IsBusy(void);
    130          /**
    131            * @}
    132            */
    133          
    134          /* Exported functions --------------------------------------------------------*/
    135          /** @addtogroup UTILS_LL_Exported_Functions
    136            * @{
    137            */
    138          
    139          /** @addtogroup UTILS_LL_EF_DELAY
    140            * @{
    141            */
    142          
    143          /**
    144            * @brief  This function configures the Cortex-M SysTick source to have 1ms time base.
    145            * @note   When a RTOS is used, it is recommended to avoid changing the Systick
    146            *         configuration by calling this function, for a delay use rather osDelay RTOS service.
    147            * @param  HCLKFrequency HCLK frequency in Hz
    148            * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq
    149            * @retval None
    150            */

   \                                 In section .text, align 2, keep-with-next
    151          void LL_Init1msTick(uint32_t HCLKFrequency)
    152          {
    153            /* Use frequency provided in argument */
    154            LL_InitTick(HCLKFrequency, 1000U);
   \                     LL_Init1msTick: (+1)
   \        0x0   0xF44F 0x727A      MOV      R2,#+1000
   \        0x4   0x....             LDR.N    R1,??DataTable8_2  ;; 0xe000e010
   \        0x6   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \        0xA   0x1E40             SUBS     R0,R0,#+1
   \        0xC   0x6048             STR      R0,[R1, #+4]
   \        0xE   0x2300             MOVS     R3,#+0
   \       0x10   0x608B             STR      R3,[R1, #+8]
   \       0x12   0x2005             MOVS     R0,#+5
   \       0x14   0x6008             STR      R0,[R1, #+0]
    155          }
   \       0x16   0x4770             BX       LR               ;; return
    156          
    157          /**
    158            * @brief  This function provides accurate delay (in milliseconds) based
    159            *         on SysTick counter flag
    160            * @note   When a RTOS is used, it is recommended to avoid using blocking delay
    161            *         and use rather osDelay service.
    162            * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which
    163            *         will configure Systick to 1ms
    164            * @param  Delay specifies the delay time length, in milliseconds.
    165            * @retval None
    166            */

   \                                 In section .text, align 2, keep-with-next
    167          void LL_mDelay(uint32_t Delay)
    168          {
    169            __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
   \                     LL_mDelay: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable8_2  ;; 0xe000e010
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x9200             STR      R2,[SP, #+0]
    170            /* Add this code to indicate that local variable is not used */
    171            ((void)tmp);
    172          
    173            /* Add a period to guaranty minimum wait */
    174            if (Delay < LL_MAX_DELAY)
   \        0x8   0xF110 0x0F01      CMN      R0,#+1
   \        0xC   0x9B00             LDR      R3,[SP, #+0]
   \        0xE   0xD001             BEQ.N    ??LL_mDelay_0
    175            {
    176              Delay++;
   \       0x10   0x1C40             ADDS     R0,R0,#+1
    177            }
    178          
    179            while (Delay)
   \                     ??LL_mDelay_1: (+1)
   \       0x12   0xB120             CBZ.N    R0,??LL_mDelay_2
    180            {
    181              if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
   \                     ??LL_mDelay_0: (+1)
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0x03D3             LSLS     R3,R2,#+15
   \       0x18   0xD5FC             BPL.N    ??LL_mDelay_0
    182              {
    183                Delay--;
   \       0x1A   0x1E40             SUBS     R0,R0,#+1
   \       0x1C   0xE7F9             B.N      ??LL_mDelay_1
    184              }
    185            }
    186          }
   \                     ??LL_mDelay_2: (+1)
   \       0x1E   0xB001             ADD      SP,SP,#+4
   \       0x20   0x4770             BX       LR               ;; return
    187          
    188          /**
    189            * @}
    190            */
    191          
    192          /** @addtogroup UTILS_EF_SYSTEM
    193            *  @brief    System Configuration functions
    194            *
    195            @verbatim
    196           ===============================================================================
    197                     ##### System Configuration functions #####
    198           ===============================================================================
    199              [..]
    200                   System, AHB and APB buses clocks configuration
    201          
    202                   (+) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 72000000 Hz.
    203            @endverbatim
    204            @internal
    205                       Depending on the SYSCLK frequency, the flash latency should be adapted accordingly:
    206                       (++) +-----------------------------------------------+
    207                       (++) | Latency       | SYSCLK clock frequency (MHz)  |
    208                       (++) |---------------|-------------------------------|
    209                       (++) |0WS(1CPU cycle)|       0 < SYSCLK <= 24        |
    210                       (++) |---------------|-------------------------------|
    211                       (++) |1WS(2CPU cycle)|      24 < SYSCLK <= 48        |
    212                       (++) |---------------|-------------------------------|
    213                       (++) |2WS(3CPU cycle)|      48 < SYSCLK <= 72        |
    214                       (++) +-----------------------------------------------+
    215            @endinternal
    216            * @{
    217            */
    218          
    219          /**
    220            * @brief  This function sets directly SystemCoreClock CMSIS variable.
    221            * @note   Variable can be calculated also through SystemCoreClockUpdate function.
    222            * @param  HCLKFrequency HCLK frequency in Hz (can be calculated thanks to RCC helper macro)
    223            * @retval None
    224            */

   \                                 In section .text, align 2, keep-with-next
    225          void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
    226          {
    227            /* HCLK clock frequency */
    228            SystemCoreClock = HCLKFrequency;
   \                     LL_SetSystemCoreClock: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable8_3
   \        0x2   0x6008             STR      R0,[R1, #+0]
    229          }
   \        0x4   0x4770             BX       LR               ;; return
    230          
    231          /**
    232            * @brief  This function configures system clock with HSI as clock source of the PLL
    233            * @note   The application need to ensure that PLL is disabled.
    234            * @note   Function is based on the following formula:
    235            *         - PLL output frequency = ((HSI frequency / PREDIV) * PLLMUL)
    236            *         - PREDIV: Set to 2 for few devices
    237            *         - PLLMUL: The application software must set correctly the PLL multiplication factor to 
    238            *                   not exceed 72MHz
    239            * @note   FLASH latency can be modified through this function. 
    240            * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains
    241            *                             the configuration information for the PLL.
    242            * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains
    243            *                             the configuration information for the BUS prescalers.
    244            * @retval An ErrorStatus enumeration value:
    245            *          - SUCCESS: Max frequency configuration done
    246            *          - ERROR: Max frequency configuration not done
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          ErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
    249                                                   LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
    250          {
   \                     LL_PLL_ConfigSystemClock_HSI: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    251            ErrorStatus status = SUCCESS;
    252            uint32_t pllfreq = 0U;
    253          
    254            /* Check if one of the PLL is enabled */
    255            if (UTILS_PLL_IsBusy() == SUCCESS)
   \        0x6   0x....'....        BL       UTILS_PLL_IsBusy
   \        0xA   0xB9D0             CBNZ.N   R0,??LL_PLL_ConfigSystemClock_HSI_0
    256            {
    257          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
    258              /* Check PREDIV value */
    259              assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->PLLDiv));
    260          #else
    261              /* Force PREDIV value to 2 */
    262              UTILS_PLLInitStruct->Prediv = LL_RCC_PREDIV_DIV_2;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x6068             STR      R0,[R5, #+4]
    263          #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
    264              /* Calculate the new PLL output frequency */
    265              pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x....             LDR.N    R0,??DataTable8_4  ;; 0x7a1200
   \       0x14   0x....'....        BL       UTILS_GetPLLOutputFrequency
   \       0x18   0x4606             MOV      R6,R0
    266          
    267              /* Enable HSI if not enabled */
    268              if (LL_RCC_HSI_IsReady() != 1U)
   \       0x1A   0x....             LDR.N    R0,??DataTable8  ;; 0x40021000
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x0789             LSLS     R1,R1,#+30
   \       0x20   0xD406             BMI.N    ??LL_PLL_ConfigSystemClock_HSI_1
    269              {
    270                LL_RCC_HSI_Enable();
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0xF042 0x0201      ORR      R2,R2,#0x1
   \       0x28   0x6002             STR      R2,[R0, #+0]
    271                while (LL_RCC_HSI_IsReady() != 1U)
   \                     ??LL_PLL_ConfigSystemClock_HSI_2: (+1)
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
    272                {
    273                  /* Wait for HSI ready */
    274                }
    275              }
   \       0x2C   0x0789             LSLS     R1,R1,#+30
   \       0x2E   0xD5FC             BPL.N    ??LL_PLL_ConfigSystemClock_HSI_2
    276          
    277              /* Configure PLL */
    278          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
    279              LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, UTILS_PLLInitStruct->PLLMul, UTILS_PLLInitStruct->PLLDiv);
    280          #else
    281              LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI_DIV_2, UTILS_PLLInitStruct->PLLMul);
   \                     ??LL_PLL_ConfigSystemClock_HSI_1: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6829             LDR      R1,[R5, #+0]
   \       0x34   0x....'....        BL       LL_RCC_PLL_ConfigDomain_SYS
    282          #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
    283          
    284              /* Enable PLL and switch system clock to PLL */
    285              status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
   \       0x38   0x4621             MOV      R1,R4
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x40   0x....             B.N      UTILS_EnablePLLAndSwitchSystem
    286            }
    287            else
    288            {
    289              /* Current PLL configuration cannot be modified */
    290              status = ERROR;
   \                     ??LL_PLL_ConfigSystemClock_HSI_0: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
    291            }
    292          
    293            return status;
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
    294          }
    295          
    296          /**
    297            * @brief  This function configures system clock with HSE as clock source of the PLL
    298            * @note   The application need to ensure that PLL is disabled.
    299            * @note   Function is based on the following formula:
    300            *         - PLL output frequency = ((HSI frequency / PREDIV) * PLLMUL)
    301            *         - PREDIV: Set to 2 for few devices
    302            *         - PLLMUL: The application software must set correctly the PLL multiplication factor to 
    303            *                   not exceed @ref UTILS_PLL_OUTPUT_MAX
    304            * @note   FLASH latency can be modified through this function. 
    305            * @param  HSEFrequency Value between Min_Data = 4000000 and Max_Data = 32000000
    306            * @param  HSEBypass This parameter can be one of the following values:
    307            *         @arg @ref LL_UTILS_HSEBYPASS_ON
    308            *         @arg @ref LL_UTILS_HSEBYPASS_OFF
    309            * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains
    310            *                             the configuration information for the PLL.
    311            * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains
    312            *                             the configuration information for the BUS prescalers.
    313            * @retval An ErrorStatus enumeration value:
    314            *          - SUCCESS: Max frequency configuration done
    315            *          - ERROR: Max frequency configuration not done
    316            */

   \                                 In section .text, align 2, keep-with-next
    317          ErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
    318                                                   LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
    319          {
   \                     LL_PLL_ConfigSystemClock_HSE: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461C             MOV      R4,R3
    320            ErrorStatus status = SUCCESS;
    321            uint32_t pllfreq = 0U;
    322          
    323            /* Check the parameters */
    324            assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));
    325            assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));
    326          
    327            /* Check if one of the PLL is enabled */
    328            if (UTILS_PLL_IsBusy() == SUCCESS)
   \        0xA   0x....'....        BL       UTILS_PLL_IsBusy
   \        0xE   0xBB28             CBNZ.N   R0,??LL_PLL_ConfigSystemClock_HSE_0
    329            {
    330              /* Check PREDIV value */
    331          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
    332              assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->PLLDiv));
    333          #else
    334              assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->Prediv));
    335          #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
    336          
    337              /* Calculate the new PLL output frequency */
    338              pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0x....'....        BL       UTILS_GetPLLOutputFrequency
   \       0x18   0x4606             MOV      R6,R0
    339          
    340              /* Enable HSE if not enabled */
    341              if (LL_RCC_HSE_IsReady() != 1U)
   \       0x1A   0x....             LDR.N    R0,??DataTable8  ;; 0x40021000
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x0389             LSLS     R1,R1,#+14
   \       0x20   0xD411             BMI.N    ??LL_PLL_ConfigSystemClock_HSE_1
    342              {
    343                /* Check if need to enable HSE bypass feature or not */
    344                if (HSEBypass == LL_UTILS_HSEBYPASS_ON)
   \       0x22   0x2F01             CMP      R7,#+1
   \       0x24   0xD104             BNE.N    ??LL_PLL_ConfigSystemClock_HSE_2
    345                {
    346                  LL_RCC_HSE_EnableBypass();
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xF441 0x2180      ORR      R1,R1,#0x40000
   \       0x2C   0x6001             STR      R1,[R0, #+0]
    347                }
   \       0x2E   0xE003             B.N      ??LL_PLL_ConfigSystemClock_HSE_3
    348                else
    349                {
    350                  LL_RCC_HSE_DisableBypass();
   \                     ??LL_PLL_ConfigSystemClock_HSE_2: (+1)
   \       0x30   0x6802             LDR      R2,[R0, #+0]
   \       0x32   0xF422 0x2280      BIC      R2,R2,#0x40000
   \       0x36   0x6002             STR      R2,[R0, #+0]
    351                }
    352          
    353                /* Enable HSE */
    354                LL_RCC_HSE_Enable();
   \                     ??LL_PLL_ConfigSystemClock_HSE_3: (+1)
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0xF441 0x3180      ORR      R1,R1,#0x10000
   \       0x3E   0x6001             STR      R1,[R0, #+0]
    355                while (LL_RCC_HSE_IsReady() != 1U)
   \                     ??LL_PLL_ConfigSystemClock_HSE_4: (+1)
   \       0x40   0x6801             LDR      R1,[R0, #+0]
    356                {
    357                  /* Wait for HSE ready */
    358                }
    359              }
   \       0x42   0x0389             LSLS     R1,R1,#+14
   \       0x44   0xD5FC             BPL.N    ??LL_PLL_ConfigSystemClock_HSE_4
    360          
    361                /* Configure PLL */
    362          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
    363                LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, UTILS_PLLInitStruct->PLLMul, UTILS_PLLInitStruct->PLLDiv);
    364          #else
    365              LL_RCC_PLL_ConfigDomain_SYS((RCC_CFGR_PLLSRC_HSE_PREDIV | UTILS_PLLInitStruct->Prediv), UTILS_PLLInitStruct->PLLMul);
   \                     ??LL_PLL_ConfigSystemClock_HSE_1: (+1)
   \       0x46   0x6868             LDR      R0,[R5, #+4]
   \       0x48   0x6829             LDR      R1,[R5, #+0]
   \       0x4A   0xF440 0x3080      ORR      R0,R0,#0x10000
   \       0x4E   0x....'....        BL       LL_RCC_PLL_ConfigDomain_SYS
    366          #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
    367          
    368              /* Enable PLL and switch system clock to PLL */
    369              status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
   \       0x52   0x4621             MOV      R1,R4
   \       0x54   0x4630             MOV      R0,R6
   \       0x56   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x5A   0x....             B.N      UTILS_EnablePLLAndSwitchSystem
    370            }
    371            else
    372            {
    373              /* Current PLL configuration cannot be modified */
    374              status = ERROR;
   \                     ??LL_PLL_ConfigSystemClock_HSE_0: (+1)
   \       0x5C   0x2001             MOVS     R0,#+1
    375            }
    376          
    377            return status;
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    378          }
    379          
    380          /**
    381            * @}
    382            */
    383          
    384          /**
    385            * @}
    386            */
    387          
    388          /** @addtogroup UTILS_LL_Private_Functions
    389            * @{
    390            */
    391          /**
    392            * @brief  Update number of Flash wait states in line with new frequency and current
    393                      voltage range.
    394            * @param  Frequency  SYSCLK frequency
    395            * @retval An ErrorStatus enumeration value:
    396            *          - SUCCESS: Latency has been modified
    397            *          - ERROR: Latency cannot be modified
    398            */
    399          #if defined(FLASH_ACR_LATENCY)

   \                                 In section .text, align 2, keep-with-next
    400          static ErrorStatus UTILS_SetFlashLatency(uint32_t Frequency)
    401          {
   \                     UTILS_SetFlashLatency: (+1)
   \        0x0   0x4601             MOV      R1,R0
    402            ErrorStatus status = SUCCESS;
   \        0x2   0x2000             MOVS     R0,#+0
    403          
    404            uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
   \        0x4   0x2200             MOVS     R2,#+0
    405          
    406            /* Frequency cannot be equal to 0 */
    407            if (Frequency == 0U)
   \        0x6   0xB199             CBZ.N    R1,??UTILS_SetFlashLatency_0
    408            {
    409              status = ERROR;
    410            }
    411            else
    412            {
    413              if (Frequency > UTILS_LATENCY2_FREQ)
   \        0x8   0x....             LDR.N    R3,??DataTable8_5  ;; 0x2dc6c01
   \        0xA   0x4299             CMP      R1,R3
   \        0xC   0xBF28             IT       CS
   \        0xE   0x2202             MOVCS    R2,#+2
    414              {
    415                /* 48 < SYSCLK <= 72 => 2WS (3 CPU cycles) */
    416                latency = LL_FLASH_LATENCY_2;
   \       0x10   0xD203             BCS.N    ??UTILS_SetFlashLatency_1
    417              }
    418              else
    419              {
    420                if (Frequency > UTILS_LATENCY1_FREQ)
   \       0x12   0x....             LDR.N    R3,??DataTable8_6  ;; 0x16e3601
   \       0x14   0x4299             CMP      R1,R3
   \       0x16   0xBF28             IT       CS
   \       0x18   0x2201             MOVCS    R2,#+1
    421                {
    422                  /* 24 < SYSCLK <= 48 => 1WS (2 CPU cycles) */
    423                  latency = LL_FLASH_LATENCY_1;
    424                }
    425                /* else SYSCLK < 24MHz default LL_FLASH_LATENCY_0 0WS */
    426              }
    427          
    428              LL_FLASH_SetLatency(latency);
   \                     ??UTILS_SetFlashLatency_1: (+1)
   \       0x1A   0x....             LDR.N    R1,??DataTable8_7  ;; 0x40022000
   \       0x1C   0x680B             LDR      R3,[R1, #+0]
   \       0x1E   0x08DB             LSRS     R3,R3,#+3
   \       0x20   0xEA42 0x03C3      ORR      R3,R2,R3, LSL #+3
   \       0x24   0x600B             STR      R3,[R1, #+0]
    429          
    430              /* Check that the new number of wait states is taken into account to access the Flash
    431                 memory by reading the FLASH_ACR register */
    432              if (LL_FLASH_GetLatency() != latency)
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0xF001 0x0107      AND      R1,R1,#0x7
   \       0x2C   0x4291             CMP      R1,R2
   \       0x2E   0xD000             BEQ.N    ??UTILS_SetFlashLatency_2
    433              {
    434                status = ERROR;
   \                     ??UTILS_SetFlashLatency_0: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
    435              }
    436            }
    437            return status;
   \                     ??UTILS_SetFlashLatency_2: (+1)
   \       0x32   0x4770             BX       LR               ;; return
    438          }
    439          #endif /* FLASH_ACR_LATENCY */
    440          
    441          /**
    442            * @brief  Function to check that PLL can be modified
    443            * @param  PLL_InputFrequency  PLL input frequency (in Hz)
    444            * @param  UTILS_PLLInitStruct pointer to a @ref LL_UTILS_PLLInitTypeDef structure that contains
    445            *                             the configuration information for the PLL.
    446            * @retval PLL output frequency (in Hz)
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          static uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)
    449          {
    450            uint32_t pllfreq = 0U;
    451          
    452            /* Check the parameters */
    453            assert_param(IS_LL_UTILS_PLLMUL_VALUE(UTILS_PLLInitStruct->PLLMul));
    454          
    455            /* Check different PLL parameters according to RM                          */
    456            /* The application software must set correctly the PLL multiplication factor to 
    457               not exceed @ref UTILS_PLL_OUTPUT_MAX */
    458          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
    459            pllfreq = __LL_RCC_CALC_PLLCLK_FREQ(PLL_InputFrequency, UTILS_PLLInitStruct->PLLMul, UTILS_PLLInitStruct->PLLDiv);
    460          #else
    461            pllfreq = __LL_RCC_CALC_PLLCLK_FREQ(PLL_InputFrequency / (UTILS_PLLInitStruct->Prediv + 1U), UTILS_PLLInitStruct->PLLMul);
    462          #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
    463            assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));
    464          
    465            return pllfreq;
   \                     UTILS_GetPLLOutputFrequency: (+1)
   \        0x0   0x684A             LDR      R2,[R1, #+4]
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x1C52             ADDS     R2,R2,#+1
   \        0x6   0xF3C1 0x4183      UBFX     R1,R1,#+18,#+4
   \        0xA   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \        0xE   0x1C89             ADDS     R1,R1,#+2
   \       0x10   0x4348             MULS     R0,R1,R0
   \       0x12   0x4770             BX       LR               ;; return
    466          }
    467          
    468          /**
    469            * @brief  Function to check that PLL can be modified
    470            * @retval An ErrorStatus enumeration value:
    471            *          - SUCCESS: PLL modification can be done
    472            *          - ERROR: PLL is busy
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          static ErrorStatus UTILS_PLL_IsBusy(void)
    475          {
   \                     UTILS_PLL_IsBusy: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    476            ErrorStatus status = SUCCESS;
    477          
    478            /* Check if PLL is busy*/
    479            if (LL_RCC_PLL_IsReady() != 0U)
   \        0x2   0x....'....        BL       LL_RCC_PLL_IsReady
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0xB100             CBZ.N    R0,??UTILS_PLL_IsBusy_0
    480            {
    481              /* PLL configuration cannot be modified */
    482              status = ERROR;
   \        0xA   0x2401             MOVS     R4,#+1
    483            }
    484          
    485            return status;
   \                     ??UTILS_PLL_IsBusy_0: (+1)
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0xBD10             POP      {R4,PC}          ;; return
    486          }
    487          
    488          /**
    489            * @brief  Function to enable PLL and switch system clock to PLL
    490            * @param  SYSCLK_Frequency SYSCLK frequency
    491            * @param  UTILS_ClkInitStruct pointer to a @ref LL_UTILS_ClkInitTypeDef structure that contains
    492            *                             the configuration information for the BUS prescalers.
    493            * @retval An ErrorStatus enumeration value:
    494            *          - SUCCESS: No problem to switch system to PLL
    495            *          - ERROR: Problem to switch system to PLL
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          static ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
    498          {
   \                     UTILS_EnablePLLAndSwitchSystem: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    499            ErrorStatus status = SUCCESS;
    500            uint32_t sysclk_frequency_current = 0U;
    501          
    502            assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));
    503            assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));
    504            assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));
    505          
    506            /* Calculate current SYSCLK frequency */
    507            sysclk_frequency_current = (SystemCoreClock << AHBPrescTable[LL_RCC_GetAHBPrescaler() >> RCC_POSITION_HPRE]);
   \        0x4   0x....             LDR.N    R6,??DataTable8  ;; 0x40021000
   \        0x6   0x....'....        LDR.W    R8,??DataTable8_8
   \        0xA   0x....             LDR.N    R7,??DataTable8_3
   \        0xC   0x4604             MOV      R4,R0
   \        0xE   0x6870             LDR      R0,[R6, #+4]
   \       0x10   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \       0x14   0x460D             MOV      R5,R1
   \       0x16   0x6839             LDR      R1,[R7, #+0]
   \       0x18   0xF818 0x0000      LDRB     R0,[R8, R0]
   \       0x1C   0xFA01 0xF900      LSL      R9,R1,R0
    508          
    509            /* Increasing the number of wait states because of higher CPU frequency */
    510            if (sysclk_frequency_current < SYSCLK_Frequency)
   \       0x20   0x45A1             CMP      R9,R4
   \       0x22   0xF04F 0x0A00      MOV      R10,#+0
   \       0x26   0xD204             BCS.N    ??UTILS_EnablePLLAndSwitchSystem_0
    511            {
    512              /* Set FLASH latency to highest latency */
    513              status = UTILS_SetFlashLatency(SYSCLK_Frequency);
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       UTILS_SetFlashLatency
   \       0x2E   0x4682             MOV      R10,R0
    514            }
    515          
    516            /* Update system clock configuration */
    517            if (status == SUCCESS)
   \       0x30   0xBB50             CBNZ.N   R0,??UTILS_EnablePLLAndSwitchSystem_1
    518            {
    519              /* Enable PLL */
    520              LL_RCC_PLL_Enable();
   \                     ??UTILS_EnablePLLAndSwitchSystem_0: (+1)
   \       0x32   0x6830             LDR      R0,[R6, #+0]
   \       0x34   0xF040 0x7080      ORR      R0,R0,#0x1000000
   \       0x38   0x6030             STR      R0,[R6, #+0]
    521              while (LL_RCC_PLL_IsReady() != 1U)
   \                     ??UTILS_EnablePLLAndSwitchSystem_2: (+1)
   \       0x3A   0x....'....        BL       LL_RCC_PLL_IsReady
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD1FB             BNE.N    ??UTILS_EnablePLLAndSwitchSystem_2
    522              {
    523                /* Wait for PLL ready */
    524              }
    525          
    526              /* Sysclk activation on the main PLL */
    527              LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
   \       0x42   0x6871             LDR      R1,[R6, #+4]
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0xF021 0x01F0      BIC      R1,R1,#0xF0
   \       0x4A   0x4301             ORRS     R1,R0,R1
   \       0x4C   0x6071             STR      R1,[R6, #+4]
    528              LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
   \       0x4E   0x6871             LDR      R1,[R6, #+4]
   \       0x50   0x0889             LSRS     R1,R1,#+2
   \       0x52   0x0089             LSLS     R1,R1,#+2
   \       0x54   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x58   0x6071             STR      R1,[R6, #+4]
    529              while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
   \                     ??UTILS_EnablePLLAndSwitchSystem_3: (+1)
   \       0x5A   0x6870             LDR      R0,[R6, #+4]
   \       0x5C   0xF000 0x000C      AND      R0,R0,#0xC
   \       0x60   0x2808             CMP      R0,#+8
   \       0x62   0xD1FA             BNE.N    ??UTILS_EnablePLLAndSwitchSystem_3
    530              {
    531                /* Wait for system clock switch to PLL */
    532              }
    533          
    534              /* Set APB1 & APB2 prescaler*/
    535              LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);
   \       0x64   0x6871             LDR      R1,[R6, #+4]
   \       0x66   0x6868             LDR      R0,[R5, #+4]
   \       0x68   0xF421 0x61E0      BIC      R1,R1,#0x700
   \       0x6C   0x4301             ORRS     R1,R0,R1
   \       0x6E   0x6071             STR      R1,[R6, #+4]
    536              LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);
   \       0x70   0x6871             LDR      R1,[R6, #+4]
   \       0x72   0x68A8             LDR      R0,[R5, #+8]
   \       0x74   0xF421 0x5160      BIC      R1,R1,#0x3800
   \       0x78   0x4301             ORRS     R1,R0,R1
    537            }
    538          
    539            /* Decreasing the number of wait states because of lower CPU frequency */
    540            if (sysclk_frequency_current > SYSCLK_Frequency)
   \       0x7A   0x454C             CMP      R4,R9
   \       0x7C   0x6071             STR      R1,[R6, #+4]
   \       0x7E   0xD203             BCS.N    ??UTILS_EnablePLLAndSwitchSystem_1
    541            {
    542              /* Set FLASH latency to lowest latency */
    543              status = UTILS_SetFlashLatency(SYSCLK_Frequency);
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0x....'....        BL       UTILS_SetFlashLatency
   \       0x86   0x4682             MOV      R10,R0
    544            }
    545          
    546            /* Update SystemCoreClock variable */
    547            if (status == SUCCESS)
   \                     ??UTILS_EnablePLLAndSwitchSystem_1: (+1)
   \       0x88   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x8C   0xD106             BNE.N    ??UTILS_EnablePLLAndSwitchSystem_4
    548            {
    549              LL_SetSystemCoreClock(__LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider));
   \       0x8E   0x6828             LDR      R0,[R5, #+0]
   \       0x90   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \       0x94   0xF818 0x1000      LDRB     R1,[R8, R0]
   \       0x98   0x40CC             LSRS     R4,R4,R1
   \       0x9A   0x603C             STR      R4,[R7, #+0]
    550            }
    551          
    552            return status;
   \                     ??UTILS_EnablePLLAndSwitchSystem_4: (+1)
   \       0x9C   0x4650             MOV      R0,R10
   \       0x9E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    553          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4002'1004        DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x007A'1200        DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x02DC'6C01        DC32     0x2dc6c01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x016E'3601        DC32     0x16e3601

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     AHBPrescTable
    554          
    555          /**
    556            * @}
    557            */
    558          
    559          /**
    560            * @}
    561            */
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LL_Init1msTick
      24   LL_PLL_ConfigSystemClock_HSE
        24   -> LL_RCC_PLL_ConfigDomain_SYS
         0   -> UTILS_EnablePLLAndSwitchSystem
        24   -> UTILS_GetPLLOutputFrequency
        24   -> UTILS_PLL_IsBusy
      16   LL_PLL_ConfigSystemClock_HSI
        16   -> LL_RCC_PLL_ConfigDomain_SYS
         0   -> UTILS_EnablePLLAndSwitchSystem
        16   -> UTILS_GetPLLOutputFrequency
        16   -> UTILS_PLL_IsBusy
       8   LL_RCC_PLL_ConfigDomain_SYS
       0   LL_RCC_PLL_IsReady
       0   LL_SetSystemCoreClock
       4   LL_mDelay
      32   UTILS_EnablePLLAndSwitchSystem
        32   -> LL_RCC_PLL_IsReady
        32   -> UTILS_SetFlashLatency
       0   UTILS_GetPLLOutputFrequency
       8   UTILS_PLL_IsBusy
         8   -> LL_RCC_PLL_IsReady
       0   UTILS_SetFlashLatency


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
      24  LL_Init1msTick
      96  LL_PLL_ConfigSystemClock_HSE
      70  LL_PLL_ConfigSystemClock_HSI
      36  LL_RCC_PLL_ConfigDomain_SYS
      12  LL_RCC_PLL_IsReady
       6  LL_SetSystemCoreClock
      34  LL_mDelay
     162  UTILS_EnablePLLAndSwitchSystem
      20  UTILS_GetPLLOutputFrequency
      16  UTILS_PLL_IsBusy
      52  UTILS_SetFlashLatency

 
 564 bytes in section .text
 
 564 bytes of CODE memory

Errors: none
Warnings: none
