###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:12
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_rcc.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW549F.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_rcc.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\stm32f3xx_ll_rcc.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\stm32f3xx_ll_rcc.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_ll_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_ll_rcc.c
      4            * @author  MCD Application Team
      5            * @brief   RCC LL module driver.
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          #if defined(USE_FULL_LL_DRIVER)
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f3xx_ll_rcc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __vfp uint32_t LL_RCC_GetTIMClockSource(uint32_t)
   \                     LL_RCC_GetTIMClockSource: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x....             LDR.N    R0,??DataTable12  ;; 0x40021030
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xF44F 0x7280      MOV      R2,#+256
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x4010             ANDS     R0,R2,R0
   \        0xE   0xEA40 0x60C1      ORR      R0,R0,R1, LSL #+27
   \       0x12   0x4770             BX       LR               ;; return
     23          #ifdef  USE_FULL_ASSERT
     24            #include "stm32_assert.h"
     25          #else
     26            #define assert_param(expr) ((void)0U)
     27          #endif /* USE_FULL_ASSERT */
     28          /** @addtogroup STM32F3xx_LL_Driver
     29            * @{
     30            */
     31          
     32          #if defined(RCC)
     33          
     34          /** @defgroup RCC_LL RCC
     35            * @{
     36            */
     37          
     38          /* Private types -------------------------------------------------------------*/
     39          /* Private variables ---------------------------------------------------------*/
     40          /** @addtogroup RCC_LL_Private_Variables
     41            * @{
     42            */
     43          #if defined(RCC_CFGR2_ADC1PRES) || defined(RCC_CFGR2_ADCPRE12) || defined(RCC_CFGR2_ADCPRE34)

   \                                 In section .text, align 4, keep-with-next
     44          const uint16_t aADCPrescTable[16]       = {1U, 2U, 4U, 6U, 8U, 10U, 12U, 16U, 32U, 64U, 128U, 256U, 256U, 256U, 256U, 256U};
   \                     aADCPrescTable:
   \        0x0   0x0001 0x0002      DC16 1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256, 256, 256, 256, 256

   \               0x0004 0x000

   \              6 0x0008 0x00

   \              0A 0x000C 0x0

   \              010 0x0020 0x

   \              0040 0x0080 0

   \              x0100 0x0100 

   \              0x0100 0x0100

   \               0x0100
     45          #endif /* RCC_CFGR2_ADC1PRES || RCC_CFGR2_ADCPRE12 || RCC_CFGR2_ADCPRE34 */
     46          #if defined(RCC_CFGR_SDPRE)
     47          const uint8_t aSDADCPrescTable[16]       = {2U, 4U, 6U, 8U, 10U, 12U, 14U, 16U, 20U, 24U, 28U, 32U, 36U, 40U, 44U, 48U};
     48          #endif /* RCC_CFGR_SDPRE */
     49          /**
     50            * @}
     51            */
     52          
     53          
     54          /* Private constants ---------------------------------------------------------*/
     55          /* Private macros ------------------------------------------------------------*/
     56          /** @addtogroup RCC_LL_Private_Macros
     57            * @{
     58            */
     59          #if defined(RCC_CFGR3_USART2SW) && defined(RCC_CFGR3_USART3SW)
     60          #define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE) \
     61                                                      || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE) \
     62                                                      || ((__VALUE__) == LL_RCC_USART3_CLKSOURCE))
     63          #elif defined(RCC_CFGR3_USART2SW) && !defined(RCC_CFGR3_USART3SW)
     64          #define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE) \
     65                                                      || ((__VALUE__) == LL_RCC_USART2_CLKSOURCE))
     66          #elif defined(RCC_CFGR3_USART3SW) && !defined(RCC_CFGR3_USART2SW)
     67          #define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE) \
     68                                                      || ((__VALUE__) == LL_RCC_USART3_CLKSOURCE))
     69          #else
     70          #define IS_LL_RCC_USART_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_USART1_CLKSOURCE))
     71          #endif /* RCC_CFGR3_USART2SW && RCC_CFGR3_USART3SW */
     72          
     73          #if defined(UART4) && defined(UART5)
     74          #define IS_LL_RCC_UART_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_UART4_CLKSOURCE) \
     75                                                       || ((__VALUE__) == LL_RCC_UART5_CLKSOURCE))
     76          #elif defined(UART4)
     77          #define IS_LL_RCC_UART_INSTANCE(__VALUE__)     ((__VALUE__) == LL_RCC_UART4_CLKSOURCE)
     78          #elif defined(UART5)
     79          #define IS_LL_RCC_UART_INSTANCE(__VALUE__)     ((__VALUE__) == LL_RCC_UART5_CLKSOURCE)
     80          #endif /* UART4 && UART5*/
     81          
     82          #if defined(RCC_CFGR3_I2C2SW) && defined(RCC_CFGR3_I2C3SW)
     83          #define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \
     84                                                      || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE) \
     85                                                      || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))
     86          
     87          #elif defined(RCC_CFGR3_I2C2SW) && !defined(RCC_CFGR3_I2C3SW)
     88          #define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \
     89                                                      || ((__VALUE__) == LL_RCC_I2C2_CLKSOURCE))
     90          
     91          #elif defined(RCC_CFGR3_I2C3SW) && !defined(RCC_CFGR3_I2C2SW)
     92          #define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_I2C1_CLKSOURCE) \
     93                                                      || ((__VALUE__) == LL_RCC_I2C3_CLKSOURCE))
     94          
     95          #else
     96          #define IS_LL_RCC_I2C_CLKSOURCE(__VALUE__)     ((__VALUE__) == LL_RCC_I2C1_CLKSOURCE)
     97          #endif /* RCC_CFGR3_I2C2SW && RCC_CFGR3_I2C3SW */
     98          
     99          #define IS_LL_RCC_I2S_CLKSOURCE(__VALUE__)     ((__VALUE__) == LL_RCC_I2S_CLKSOURCE)
    100          
    101          #if defined(USB)
    102          #define IS_LL_RCC_USB_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_USB_CLKSOURCE))
    103          #endif /* USB */
    104          
    105          #if defined(RCC_CFGR_ADCPRE)
    106          #define IS_LL_RCC_ADC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_ADC_CLKSOURCE))
    107          #else
    108          #if defined(RCC_CFGR2_ADC1PRES)
    109          #define IS_LL_RCC_ADC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_ADC1_CLKSOURCE))
    110          #elif  defined(RCC_CFGR2_ADCPRE12) && defined(RCC_CFGR2_ADCPRE34)
    111          #define IS_LL_RCC_ADC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_ADC12_CLKSOURCE) \
    112                                                      || ((__VALUE__) == LL_RCC_ADC34_CLKSOURCE))
    113          #else /* RCC_CFGR2_ADCPRE12 */
    114          #define IS_LL_RCC_ADC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_ADC12_CLKSOURCE))
    115          #endif /* RCC_CFGR2_ADC1PRES */
    116          #endif /* RCC_CFGR_ADCPRE */
    117          
    118          #if defined(RCC_CFGR_SDPRE)
    119          #define IS_LL_RCC_SDADC_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_SDADC_CLKSOURCE))
    120          #endif /* RCC_CFGR_SDPRE */
    121          
    122          #if defined(CEC)
    123          #define IS_LL_RCC_CEC_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_CEC_CLKSOURCE))
    124          #endif /* CEC */
    125          
    126          #if defined(RCC_CFGR3_TIMSW)
    127          #if defined(RCC_CFGR3_TIM8SW) && defined(RCC_CFGR3_TIM15SW) && defined(RCC_CFGR3_TIM16SW) \
    128           && defined(RCC_CFGR3_TIM17SW) && defined(RCC_CFGR3_TIM20SW) && defined(RCC_CFGR3_TIM2SW) \
    129           && defined(RCC_CFGR3_TIM34SW)
    130          
    131          #define IS_LL_RCC_TIM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_TIM1_CLKSOURCE)  \
    132                                                      || ((__VALUE__) == LL_RCC_TIM2_CLKSOURCE)  \
    133                                                      || ((__VALUE__) == LL_RCC_TIM8_CLKSOURCE)  \
    134                                                      || ((__VALUE__) == LL_RCC_TIM15_CLKSOURCE) \
    135                                                      || ((__VALUE__) == LL_RCC_TIM16_CLKSOURCE) \
    136                                                      || ((__VALUE__) == LL_RCC_TIM17_CLKSOURCE) \
    137                                                      || ((__VALUE__) == LL_RCC_TIM20_CLKSOURCE) \
    138                                                      || ((__VALUE__) == LL_RCC_TIM34_CLKSOURCE))
    139          
    140          #elif !defined(RCC_CFGR3_TIM8SW) && defined(RCC_CFGR3_TIM15SW) && defined(RCC_CFGR3_TIM16SW) \
    141           && defined(RCC_CFGR3_TIM17SW) && !defined(RCC_CFGR3_TIM20SW) && defined(RCC_CFGR3_TIM2SW) \
    142           && defined(RCC_CFGR3_TIM34SW)
    143          
    144          #define IS_LL_RCC_TIM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_TIM1_CLKSOURCE)  \
    145                                                      || ((__VALUE__) == LL_RCC_TIM2_CLKSOURCE)  \
    146                                                      || ((__VALUE__) == LL_RCC_TIM15_CLKSOURCE) \
    147                                                      || ((__VALUE__) == LL_RCC_TIM16_CLKSOURCE) \
    148                                                      || ((__VALUE__) == LL_RCC_TIM17_CLKSOURCE) \
    149                                                      || ((__VALUE__) == LL_RCC_TIM34_CLKSOURCE))
    150          
    151          #elif defined(RCC_CFGR3_TIM8SW) && !defined(RCC_CFGR3_TIM15SW) && !defined(RCC_CFGR3_TIM16SW) \
    152           && !defined(RCC_CFGR3_TIM17SW) && !defined(RCC_CFGR3_TIM20SW) && !defined(RCC_CFGR3_TIM2SW) \
    153           && !defined(RCC_CFGR3_TIM34SW)
    154          
    155          #define IS_LL_RCC_TIM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_TIM1_CLKSOURCE)  \
    156                                                      || ((__VALUE__) == LL_RCC_TIM8_CLKSOURCE))
    157          
    158          #elif !defined(RCC_CFGR3_TIM8SW) && defined(RCC_CFGR3_TIM15SW) && defined(RCC_CFGR3_TIM16SW) \
    159           && defined(RCC_CFGR3_TIM17SW) && !defined(RCC_CFGR3_TIM20SW) && !defined(RCC_CFGR3_TIM2SW) \
    160           && !defined(RCC_CFGR3_TIM34SW)
    161          
    162          #define IS_LL_RCC_TIM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_TIM1_CLKSOURCE)  \
    163                                                      || ((__VALUE__) == LL_RCC_TIM15_CLKSOURCE) \
    164                                                      || ((__VALUE__) == LL_RCC_TIM16_CLKSOURCE) \
    165                                                      || ((__VALUE__) == LL_RCC_TIM17_CLKSOURCE))
    166          
    167          #elif !defined(RCC_CFGR3_TIM8SW) && !defined(RCC_CFGR3_TIM15SW) && !defined(RCC_CFGR3_TIM16SW) \
    168           && !defined(RCC_CFGR3_TIM17SW) && !defined(RCC_CFGR3_TIM20SW) && !defined(RCC_CFGR3_TIM2SW) \
    169           && !defined(RCC_CFGR3_TIM34SW)
    170          
    171          #define IS_LL_RCC_TIM_CLKSOURCE(__VALUE__)    (((__VALUE__) == LL_RCC_TIM1_CLKSOURCE))
    172          
    173          #else
    174          #error "Miss macro"
    175          #endif /* RCC_CFGR3_TIMxSW */
    176          #endif /* RCC_CFGR3_TIMSW */
    177          
    178          #if defined(HRTIM1)
    179          #define IS_LL_RCC_HRTIM_CLKSOURCE(__VALUE__)  (((__VALUE__) == LL_RCC_HRTIM1_CLKSOURCE))
    180          #endif /* HRTIM1 */
    181          
    182          /**
    183            * @}
    184            */
    185          
    186          /* Private function prototypes -----------------------------------------------*/
    187          /** @defgroup RCC_LL_Private_Functions RCC Private functions
    188            * @{
    189            */
    190          uint32_t RCC_GetSystemClockFreq(void);
    191          uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency);
    192          uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency);
    193          uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency);
    194          uint32_t RCC_PLL_GetFreqDomain_SYS(void);
    195          /**
    196            * @}
    197            */
    198          
    199          
    200          /* Exported functions --------------------------------------------------------*/
    201          /** @addtogroup RCC_LL_Exported_Functions
    202            * @{
    203            */
    204          
    205          /** @addtogroup RCC_LL_EF_Init
    206            * @{
    207            */
    208          
    209          /**
    210            * @brief  Reset the RCC clock configuration to the default reset state.
    211            * @note   The default reset state of the clock configuration is given below:
    212            *         - HSI ON and used as system clock source
    213            *         - HSE and PLL OFF
    214            *         - AHB, APB1 and APB2 prescaler set to 1.
    215            *         - CSS, MCO OFF
    216            *         - All interrupts disabled
    217            * @note   This function doesn't modify the configuration of the
    218            *         - Peripheral clocks
    219            *         - LSI, LSE and RTC clocks
    220            * @retval An ErrorStatus enumeration value:
    221            *          - SUCCESS: RCC registers are de-initialized
    222            *          - ERROR: not applicable
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          ErrorStatus LL_RCC_DeInit(void)
    225          {
    226            __IO uint32_t vl_mask;
    227          
    228            /* Set HSION bit */
    229            LL_RCC_HSI_Enable();
   \                     LL_RCC_DeInit: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40021000
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0xF040 0x0001      ORR      R0,R0,#0x1
   \        0xA   0x6008             STR      R0,[R1, #+0]
    230          
    231            /* Wait for HSI READY bit */
    232            while(LL_RCC_HSI_IsReady() != 1U)
   \                     ??LL_RCC_DeInit_0: (+1)
   \        0xC   0x6808             LDR      R0,[R1, #+0]
   \        0xE   0x0780             LSLS     R0,R0,#+30
   \       0x10   0xD5FC             BPL.N    ??LL_RCC_DeInit_0
    233            {}
    234          
    235            /* Set HSITRIM bits to the reset value*/
    236            LL_RCC_HSI_SetCalibTrimming(0x10U);
    237          
    238            /* Reset SW, HPRE, PPRE and MCOSEL bits */
    239            vl_mask = 0xFFFFFFFFU;
   \       0x12   0xF04F 0x30FF      MOV      R0,#-1
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0xF022 0x02F8      BIC      R2,R2,#0xF8
   \       0x1C   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0x20   0x600A             STR      R2,[R1, #+0]
   \       0x22   0x9000             STR      R0,[SP, #+0]
    240            CLEAR_BIT(vl_mask, (RCC_CFGR_SW | RCC_CFGR_HPRE | RCC_CFGR_PPRE1 |\
    241                                RCC_CFGR_PPRE2 | RCC_CFGR_MCOSEL));
   \       0x24   0x9A00             LDR      R2,[SP, #+0]
   \       0x26   0x....             LDR.N    R0,??DataTable12_2  ;; 0xf8ffc00c
   \       0x28   0x4002             ANDS     R2,R0,R2
   \       0x2A   0x9200             STR      R2,[SP, #+0]
    242           
    243            /* Write new value in CFGR register */
    244            LL_RCC_WriteReg(CFGR, vl_mask);
   \       0x2C   0x9A00             LDR      R2,[SP, #+0]
   \       0x2E   0x604A             STR      R2,[R1, #+4]
    245          
    246            /* Wait till system clock source is ready */
    247            while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI)
   \                     ??LL_RCC_DeInit_1: (+1)
   \       0x30   0x6848             LDR      R0,[R1, #+4]
   \       0x32   0xF010 0x0F0C      TST      R0,#0xC
   \       0x36   0xD1FB             BNE.N    ??LL_RCC_DeInit_1
    248            {}
    249          
    250            /* Read CR register */
    251            vl_mask = LL_RCC_ReadReg(CR);
   \       0x38   0x6808             LDR      R0,[R1, #+0]
   \       0x3A   0x9000             STR      R0,[SP, #+0]
    252            
    253            /* Reset HSEON, CSSON, PLLON bits */
    254            CLEAR_BIT(vl_mask, (RCC_CR_PLLON | RCC_CR_CSSON | RCC_CR_HSEON));
   \       0x3C   0x9A00             LDR      R2,[SP, #+0]
   \       0x3E   0x....             LDR.N    R0,??DataTable12_3  ;; 0xfef6ffff
   \       0x40   0x4002             ANDS     R2,R0,R2
   \       0x42   0x9200             STR      R2,[SP, #+0]
    255           
    256             /* Write new value in CR register */
    257            LL_RCC_WriteReg(CR, vl_mask);
   \       0x44   0x9A00             LDR      R2,[SP, #+0]
   \       0x46   0x600A             STR      R2,[R1, #+0]
    258          
    259            /* Wait for PLL READY bit to be reset */
    260            while(LL_RCC_PLL_IsReady() != 0U)
   \                     ??LL_RCC_DeInit_2: (+1)
   \       0x48   0x6808             LDR      R0,[R1, #+0]
   \       0x4A   0x0E40             LSRS     R0,R0,#+25
   \       0x4C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x50   0xD1FA             BNE.N    ??LL_RCC_DeInit_2
    261            {}
    262          
    263            /* Reset HSEBYP bit */
    264            LL_RCC_HSE_DisableBypass();
    265          
    266            /* Reset CFGR register */
    267            LL_RCC_WriteReg(CFGR, 0x00000000U);
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x6808             LDR      R0,[R1, #+0]
   \       0x56   0xF420 0x2080      BIC      R0,R0,#0x40000
   \       0x5A   0x6008             STR      R0,[R1, #+0]
   \       0x5C   0x604A             STR      R2,[R1, #+4]
    268          
    269            /* Reset CFGR2 register */
    270            LL_RCC_WriteReg(CFGR2, 0x00000000U);
   \       0x5E   0x62CA             STR      R2,[R1, #+44]
    271          
    272            /* Reset CFGR3 register */
    273            LL_RCC_WriteReg(CFGR3, 0x00000000U);
   \       0x60   0x630A             STR      R2,[R1, #+48]
    274          
    275            /* Clear pending flags */
    276            vl_mask = (LL_RCC_CIR_LSIRDYC | LL_RCC_CIR_LSERDYC | LL_RCC_CIR_HSIRDYC |\
    277                       LL_RCC_CIR_HSERDYC | LL_RCC_CIR_PLLRDYC | LL_RCC_CIR_CSSC);
   \       0x62   0xF44F 0x001F      MOV      R0,#+10420224
   \       0x66   0x9000             STR      R0,[SP, #+0]
    278          
    279            /* Write new value in CIR register */
    280            LL_RCC_WriteReg(CIR, vl_mask);
    281          
    282            /* Disable all interrupts */
    283            LL_RCC_WriteReg(CIR, 0x00000000U);
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x9A00             LDR      R2,[SP, #+0]
   \       0x6C   0x608A             STR      R2,[R1, #+8]
   \       0x6E   0x6088             STR      R0,[R1, #+8]
    284          
    285            /* Clear reset flags */
    286            LL_RCC_ClearResetFlags();
   \       0x70   0x6A4A             LDR      R2,[R1, #+36]
   \       0x72   0xF042 0x7280      ORR      R2,R2,#0x1000000
   \       0x76   0x624A             STR      R2,[R1, #+36]
    287          
    288            return SUCCESS;
   \       0x78   0xB001             ADD      SP,SP,#+4
   \       0x7A   0x4770             BX       LR               ;; return
    289          }
    290          
    291          /**
    292            * @}
    293            */
    294          
    295          /** @addtogroup RCC_LL_EF_Get_Freq
    296            * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks
    297            *         and different peripheral clocks available on the device.
    298            * @note   If SYSCLK source is HSI, function returns values based on HSI_VALUE(**)
    299            * @note   If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)
    300            * @note   If SYSCLK source is PLL, function returns values based on 
    301            *         HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.
    302            * @note   (**) HSI_VALUE is a defined constant but the real value may vary 
    303            *              depending on the variations in voltage and temperature.
    304            * @note   (***) HSE_VALUE is a defined constant, user has to ensure that
    305            *               HSE_VALUE is same as the real frequency of the crystal used.
    306            *               Otherwise, this function may have wrong result.
    307            * @note   The result of this function could be incorrect when using fractional
    308            *         value for HSE crystal.
    309            * @note   This function can be used by the user application to compute the
    310            *         baud-rate for the communication peripherals or configure other parameters.
    311            * @{
    312            */
    313          
    314          /**
    315            * @brief  Return the frequencies of different on chip clocks;  System, AHB, APB1 and APB2 buses clocks
    316            * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
    317            *         must be called to update structure fields. Otherwise, any
    318            *         configuration based on this function will be incorrect.
    319            * @param  RCC_Clocks pointer to a @ref LL_RCC_ClocksTypeDef structure which will hold the clocks frequencies
    320            * @retval None
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          void LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
    323          {
   \                     LL_RCC_GetSystemClocksFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    324            /* Get SYSCLK frequency */
    325            RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
   \        0x4   0x....'....        BL       RCC_GetSystemClockFreq
    326          
    327            /* HCLK clock frequency */
    328            RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
   \        0x8   0x6020             STR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       RCC_GetHCLKClockFreq
    329          
    330            /* PCLK1 clock frequency */
    331            RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
   \        0xE   0x6060             STR      R0,[R4, #+4]
   \       0x10   0x....'....        BL       RCC_GetPCLK1ClockFreq
   \       0x14   0x60A0             STR      R0,[R4, #+8]
    332          
    333            /* PCLK2 clock frequency */
    334            RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
   \       0x16   0x6860             LDR      R0,[R4, #+4]
   \       0x18   0x....'....        BL       RCC_GetPCLK2ClockFreq
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
    335          }
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    336          
    337          /**
    338            * @brief  Return USARTx clock frequency
    339            * @param  USARTxSource This parameter can be one of the following values:
    340            *         @arg @ref LL_RCC_USART1_CLKSOURCE
    341            *         @arg @ref LL_RCC_USART2_CLKSOURCE (*)
    342            *         @arg @ref LL_RCC_USART3_CLKSOURCE (*)
    343            *
    344            *         (*) value not defined in all devices.
    345            * @retval USART clock frequency (in Hz)
    346            *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          uint32_t LL_RCC_GetUSARTClockFreq(uint32_t USARTxSource)
    349          {
   \                     LL_RCC_GetUSARTClockFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    350            uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
   \        0x2   0x2100             MOVS     R1,#+0
    351          
    352            /* Check parameter */
    353            assert_param(IS_LL_RCC_USART_CLKSOURCE(USARTxSource));
    354          #if defined(RCC_CFGR3_USART1SW)
    355            if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
   \        0x4   0xB9F8             CBNZ.N   R0,??LL_RCC_GetUSARTClockFreq_0
    356            {
    357              /* USART1CLK clock frequency */
    358              switch (LL_RCC_GetUSARTClockSource(USARTxSource))
   \        0x6   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40021000
   \        0x8   0x6B02             LDR      R2,[R0, #+48]
   \        0xA   0xF002 0x0203      AND      R2,R2,#0x3
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD004             BEQ.N    ??LL_RCC_GetUSARTClockFreq_1
   \       0x12   0xD311             BCC.N    ??LL_RCC_GetUSARTClockFreq_2
   \       0x14   0x2A03             CMP      R2,#+3
   \       0x16   0xD004             BEQ.N    ??LL_RCC_GetUSARTClockFreq_3
   \       0x18   0xD308             BCC.N    ??LL_RCC_GetUSARTClockFreq_4
   \       0x1A   0xE00D             B.N      ??LL_RCC_GetUSARTClockFreq_2
    359              {
    360                case LL_RCC_USART1_CLKSOURCE_SYSCLK: /* USART1 Clock is System Clock */
    361                  usart_frequency = RCC_GetSystemClockFreq();
   \                     ??LL_RCC_GetUSARTClockFreq_1: (+1)
   \       0x1C   0x....'....        BL       RCC_GetSystemClockFreq
   \       0x20   0xE010             B.N      ??LL_RCC_GetUSARTClockFreq_5
    362                  break;
    363          
    364                case LL_RCC_USART1_CLKSOURCE_HSI:    /* USART1 Clock is HSI Osc. */
    365                  if (LL_RCC_HSI_IsReady())
   \                     ??LL_RCC_GetUSARTClockFreq_3: (+1)
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x0780             LSLS     R0,R0,#+30
   \       0x26   0xD50E             BPL.N    ??LL_RCC_GetUSARTClockFreq_0
    366                  {
    367                    usart_frequency = HSI_VALUE;
   \       0x28   0x....             LDR.N    R1,??DataTable12_4  ;; 0x7a1200
   \       0x2A   0xE00C             B.N      ??LL_RCC_GetUSARTClockFreq_0
    368                  }
    369                  break;
    370          
    371                case LL_RCC_USART1_CLKSOURCE_LSE:    /* USART1 Clock is LSE Osc. */
    372                  if (LL_RCC_LSE_IsReady())
   \                     ??LL_RCC_GetUSARTClockFreq_4: (+1)
   \       0x2C   0x6A00             LDR      R0,[R0, #+32]
   \       0x2E   0x0780             LSLS     R0,R0,#+30
   \       0x30   0xD509             BPL.N    ??LL_RCC_GetUSARTClockFreq_0
    373                  {
    374                    usart_frequency = LSE_VALUE;
   \       0x32   0xF44F 0x4100      MOV      R1,#+32768
   \       0x36   0xE006             B.N      ??LL_RCC_GetUSARTClockFreq_0
    375                  }
    376                  break;
    377          
    378          #if defined(RCC_CFGR3_USART1SW_PCLK1)
    379                case LL_RCC_USART1_CLKSOURCE_PCLK1:  /* USART1 Clock is PCLK1 */
    380                default:
    381                  usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
   \                     ??LL_RCC_GetUSARTClockFreq_2: (+1)
   \       0x38   0x....'....        BL       RCC_GetSystemClockFreq
   \       0x3C   0x....'....        BL       RCC_GetHCLKClockFreq
   \       0x40   0x....'....        BL       RCC_GetPCLK1ClockFreq
   \                     ??LL_RCC_GetUSARTClockFreq_5: (+1)
   \       0x44   0x4601             MOV      R1,R0
    382          #else
    383                case LL_RCC_USART1_CLKSOURCE_PCLK2:  /* USART1 Clock is PCLK2 */
    384                default:
    385                  usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    386          #endif /* RCC_CFGR3_USART1SW_PCLK1 */
    387                  break;
    388              }
    389            }
    390          #endif /* RCC_CFGR3_USART1SW  */
    391          
    392          #if defined(RCC_CFGR3_USART2SW)
    393            if (USARTxSource == LL_RCC_USART2_CLKSOURCE)
    394            {
    395              /* USART2CLK clock frequency */
    396              switch (LL_RCC_GetUSARTClockSource(USARTxSource))
    397              {
    398                case LL_RCC_USART2_CLKSOURCE_SYSCLK: /* USART2 Clock is System Clock */
    399                  usart_frequency = RCC_GetSystemClockFreq();
    400                  break;
    401          
    402                case LL_RCC_USART2_CLKSOURCE_HSI:    /* USART2 Clock is HSI Osc. */
    403                  if (LL_RCC_HSI_IsReady())
    404                  {
    405                    usart_frequency = HSI_VALUE;
    406                  }
    407                  break;
    408          
    409                case LL_RCC_USART2_CLKSOURCE_LSE:    /* USART2 Clock is LSE Osc. */
    410                  if (LL_RCC_LSE_IsReady())
    411                  {
    412                    usart_frequency = LSE_VALUE;
    413                  }
    414                  break;
    415          
    416                case LL_RCC_USART2_CLKSOURCE_PCLK1:  /* USART2 Clock is PCLK1 */
    417                default:
    418                  usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    419                  break;
    420              }
    421            }
    422          #endif /* RCC_CFGR3_USART2SW */
    423          
    424          #if defined(RCC_CFGR3_USART3SW)
    425            if (USARTxSource == LL_RCC_USART3_CLKSOURCE)
    426            {
    427              /* USART3CLK clock frequency */
    428              switch (LL_RCC_GetUSARTClockSource(USARTxSource))
    429              {
    430                case LL_RCC_USART3_CLKSOURCE_SYSCLK: /* USART3 Clock is System Clock */
    431                  usart_frequency = RCC_GetSystemClockFreq();
    432                  break;
    433          
    434                case LL_RCC_USART3_CLKSOURCE_HSI:    /* USART3 Clock is HSI Osc. */
    435                  if (LL_RCC_HSI_IsReady())
    436                  {
    437                    usart_frequency = HSI_VALUE;
    438                  }
    439                  break;
    440          
    441                case LL_RCC_USART3_CLKSOURCE_LSE:    /* USART3 Clock is LSE Osc. */
    442                  if (LL_RCC_LSE_IsReady())
    443                  {
    444                    usart_frequency = LSE_VALUE;
    445                  }
    446                  break;
    447          
    448                case LL_RCC_USART3_CLKSOURCE_PCLK1:  /* USART3 Clock is PCLK1 */
    449                default:
    450                  usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    451                  break;
    452              }
    453            }
    454          
    455          #endif /* RCC_CFGR3_USART3SW */
    456            return usart_frequency;
   \                     ??LL_RCC_GetUSARTClockFreq_0: (+1)
   \       0x46   0x4608             MOV      R0,R1
   \       0x48   0xBD02             POP      {R1,PC}          ;; return
    457          }
    458          
    459          #if defined(UART4) || defined(UART5)
    460          /**
    461            * @brief  Return UARTx clock frequency
    462            * @param  UARTxSource This parameter can be one of the following values:
    463            *         @arg @ref LL_RCC_UART4_CLKSOURCE
    464            *         @arg @ref LL_RCC_UART5_CLKSOURCE
    465            * @retval UART clock frequency (in Hz)
    466            *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI or LSE) is not ready
    467            */
    468          uint32_t LL_RCC_GetUARTClockFreq(uint32_t UARTxSource)
    469          {
    470            uint32_t uart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    471          
    472            /* Check parameter */
    473            assert_param(IS_LL_RCC_UART_CLKSOURCE(UARTxSource));
    474          
    475          #if defined(UART4)
    476            if (UARTxSource == LL_RCC_UART4_CLKSOURCE)
    477            {
    478              /* UART4CLK clock frequency */
    479              switch (LL_RCC_GetUARTClockSource(UARTxSource))
    480              {
    481                case LL_RCC_UART4_CLKSOURCE_SYSCLK: /* UART4 Clock is System Clock */
    482                  uart_frequency = RCC_GetSystemClockFreq();
    483                  break;
    484          
    485                case LL_RCC_UART4_CLKSOURCE_HSI:    /* UART4 Clock is HSI Osc. */
    486                  if (LL_RCC_HSI_IsReady())
    487                  {
    488                    uart_frequency = HSI_VALUE;
    489                  }
    490                  break;
    491          
    492                case LL_RCC_UART4_CLKSOURCE_LSE:    /* UART4 Clock is LSE Osc. */
    493                  if (LL_RCC_LSE_IsReady())
    494                  {
    495                    uart_frequency = LSE_VALUE;
    496                  }
    497                  break;
    498          
    499                case LL_RCC_UART4_CLKSOURCE_PCLK1:  /* UART4 Clock is PCLK1 */
    500                default:
    501                  uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    502                  break;
    503              }
    504            }
    505          #endif /* UART4 */
    506          
    507          #if defined(UART5)
    508            if (UARTxSource == LL_RCC_UART5_CLKSOURCE)
    509            {
    510              /* UART5CLK clock frequency */
    511              switch (LL_RCC_GetUARTClockSource(UARTxSource))
    512              {
    513                case LL_RCC_UART5_CLKSOURCE_SYSCLK: /* UART5 Clock is System Clock */
    514                  uart_frequency = RCC_GetSystemClockFreq();
    515                  break;
    516          
    517                case LL_RCC_UART5_CLKSOURCE_HSI:    /* UART5 Clock is HSI Osc. */
    518                  if (LL_RCC_HSI_IsReady())
    519                  {
    520                    uart_frequency = HSI_VALUE;
    521                  }
    522                  break;
    523          
    524                case LL_RCC_UART5_CLKSOURCE_LSE:    /* UART5 Clock is LSE Osc. */
    525                  if (LL_RCC_LSE_IsReady())
    526                  {
    527                    uart_frequency = LSE_VALUE;
    528                  }
    529                  break;
    530          
    531                case LL_RCC_UART5_CLKSOURCE_PCLK1:  /* UART5 Clock is PCLK1 */
    532                default:
    533                  uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    534                  break;
    535              }
    536            }
    537          #endif /* UART5 */
    538          
    539            return uart_frequency;
    540          }
    541          #endif /* UART4 || UART5 */
    542          
    543          /**
    544            * @brief  Return I2Cx clock frequency
    545            * @param  I2CxSource This parameter can be one of the following values:
    546            *         @arg @ref LL_RCC_I2C1_CLKSOURCE
    547            *         @arg @ref LL_RCC_I2C2_CLKSOURCE (*)
    548            *         @arg @ref LL_RCC_I2C3_CLKSOURCE (*)
    549            *
    550            *         (*) value not defined in all devices
    551            * @retval I2C clock frequency (in Hz)
    552            *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NO indicates that HSI oscillator is not ready
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          uint32_t LL_RCC_GetI2CClockFreq(uint32_t I2CxSource)
    555          {
   \                     LL_RCC_GetI2CClockFreq: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xB510             PUSH     {R4,LR}
    556            uint32_t i2c_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
   \        0x4   0x2000             MOVS     R0,#+0
    557          
    558            /* Check parameter */
    559            assert_param(IS_LL_RCC_I2C_CLKSOURCE(I2CxSource));
    560          
    561            /* I2C1 CLK clock frequency */
    562            if (I2CxSource == LL_RCC_I2C1_CLKSOURCE)
   \        0x6   0x2910             CMP      R1,#+16
   \        0x8   0x....             LDR.N    R2,??DataTable12_4  ;; 0x7a1200
   \        0xA   0x....             LDR.N    R3,??DataTable12_1  ;; 0x40021000
   \        0xC   0xD106             BNE.N    ??LL_RCC_GetI2CClockFreq_0
    563            {
    564              switch (LL_RCC_GetI2CClockSource(I2CxSource))
   \        0xE   0x6B19             LDR      R1,[R3, #+48]
    565              {
    566                case LL_RCC_I2C1_CLKSOURCE_SYSCLK: /* I2C1 Clock is System Clock */
    567                  i2c_frequency = RCC_GetSystemClockFreq();
    568                  break;
    569          
    570                case LL_RCC_I2C1_CLKSOURCE_HSI:    /* I2C1 Clock is HSI Osc. */
    571                default:
    572                  if (LL_RCC_HSI_IsReady())
    573                  {
    574                    i2c_frequency = HSI_VALUE;
    575                  }
    576                  break;
    577              }
    578            }
   \       0x10   0x....             LDR.N    R4,??DataTable12_5  ;; 0x10000010
   \       0x12   0xF001 0x0110      AND      R1,R1,#0x10
   \       0x16   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \       0x1A   0xE007             B.N      ??LL_RCC_GetI2CClockFreq_1
    579          
    580          #if defined(RCC_CFGR3_I2C2SW)
    581            /* I2C2 CLK clock frequency */
    582            if (I2CxSource == LL_RCC_I2C2_CLKSOURCE)
   \                     ??LL_RCC_GetI2CClockFreq_0: (+1)
   \       0x1C   0x2920             CMP      R1,#+32
   \       0x1E   0xD108             BNE.N    ??LL_RCC_GetI2CClockFreq_2
    583            {
    584              switch (LL_RCC_GetI2CClockSource(I2CxSource))
   \       0x20   0x6B19             LDR      R1,[R3, #+48]
   \       0x22   0x....             LDR.N    R4,??DataTable12_6  ;; 0x20000020
   \       0x24   0xF001 0x0120      AND      R1,R1,#0x20
   \       0x28   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \                     ??LL_RCC_GetI2CClockFreq_1: (+1)
   \       0x2C   0x42A1             CMP      R1,R4
   \       0x2E   0xD00A             BEQ.N    ??LL_RCC_GetI2CClockFreq_3
    585              {
    586                case LL_RCC_I2C2_CLKSOURCE_SYSCLK: /* I2C2 Clock is System Clock */
    587                  i2c_frequency = RCC_GetSystemClockFreq();
    588                  break;
    589          	
    590                case LL_RCC_I2C2_CLKSOURCE_HSI:    /* I2C2 Clock is HSI Osc. */
    591                default:
    592                  if (LL_RCC_HSI_IsReady())
   \       0x30   0xE00C             B.N      ??LL_RCC_GetI2CClockFreq_4
    593                  {
    594                    i2c_frequency = HSI_VALUE;
    595                  }
    596                  break;
    597              }
    598            }
    599          #endif /*RCC_CFGR3_I2C2SW*/
    600          
    601          #if defined(RCC_CFGR3_I2C3SW)
    602            /* I2C3 CLK clock frequency */
    603            if (I2CxSource == LL_RCC_I2C3_CLKSOURCE)
   \                     ??LL_RCC_GetI2CClockFreq_2: (+1)
   \       0x32   0x2940             CMP      R1,#+64
   \       0x34   0xD10E             BNE.N    ??LL_RCC_GetI2CClockFreq_5
    604            {
    605              switch (LL_RCC_GetI2CClockSource(I2CxSource))
   \       0x36   0x6B19             LDR      R1,[R3, #+48]
   \       0x38   0x....             LDR.N    R4,??DataTable12_7  ;; 0x40000040
   \       0x3A   0xF001 0x0140      AND      R1,R1,#0x40
   \       0x3E   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \       0x42   0x42A1             CMP      R1,R4
   \       0x44   0xD102             BNE.N    ??LL_RCC_GetI2CClockFreq_4
    606              {
    607                case LL_RCC_I2C3_CLKSOURCE_SYSCLK: /* I2C3 Clock is System Clock */
    608                  i2c_frequency = RCC_GetSystemClockFreq();
   \                     ??LL_RCC_GetI2CClockFreq_3: (+1)
   \       0x46   0xE8BD 0x4010      POP      {R4,LR}
   \       0x4A   0x....             B.N      RCC_GetSystemClockFreq
    609                  break;
    610          
    611                case LL_RCC_I2C3_CLKSOURCE_HSI:    /* I2C3 Clock is HSI Osc. */
    612                default:
    613                  if (LL_RCC_HSI_IsReady())
   \                     ??LL_RCC_GetI2CClockFreq_4: (+1)
   \       0x4C   0x6819             LDR      R1,[R3, #+0]
   \       0x4E   0x0789             LSLS     R1,R1,#+30
   \       0x50   0xBF48             IT       MI
   \       0x52   0x4610             MOVMI    R0,R2
    614                  {
    615                    i2c_frequency = HSI_VALUE;
    616                  }
    617                  break;
    618              }
    619            }
    620          #endif /*RCC_CFGR3_I2C3SW*/
    621          
    622            return i2c_frequency;
   \                     ??LL_RCC_GetI2CClockFreq_5: (+1)
   \       0x54   0xBD10             POP      {R4,PC}          ;; return
    623          }
    624          
    625          #if  defined(RCC_CFGR_I2SSRC)
    626          /**
    627            * @brief  Return I2Sx clock frequency
    628            * @param  I2SxSource This parameter can be one of the following values:
    629            *         @arg @ref LL_RCC_I2S_CLKSOURCE
    630            * @retval I2S clock frequency (in Hz)
    631            *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NA indicates that external clock is used */

   \                                 In section .text, align 2, keep-with-next
    632          uint32_t LL_RCC_GetI2SClockFreq(uint32_t I2SxSource)
    633          {
    634            uint32_t i2s_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    635          
    636            /* Check parameter */
    637            assert_param(IS_LL_RCC_I2S_CLKSOURCE(I2SxSource));
    638          
    639            /* I2S1CLK clock frequency */
    640            switch (LL_RCC_GetI2SClockSource(I2SxSource))
   \                     LL_RCC_GetI2SClockFreq: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_8  ;; 0x40021004
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0x4201             TST      R1,R0
   \        0x6   0xBF08             IT       EQ
    641            {
    642              case LL_RCC_I2S_CLKSOURCE_SYSCLK: /*!< System clock selected as I2S clock source */
    643                i2s_frequency = RCC_GetSystemClockFreq();
   \        0x8   0x....'....        BEQ.W    RCC_GetSystemClockFreq
    644                break;
    645          
    646              case LL_RCC_I2S_CLKSOURCE_PIN:    /*!< External clock selected as I2S clock source */
    647              default:
    648                i2s_frequency = LL_RCC_PERIPH_FREQUENCY_NA;
   \        0xC   0xF04F 0x30FF      MOV      R0,#-1
    649                break;
    650            }
    651          
    652            return i2s_frequency;
   \       0x10   0x4770             BX       LR               ;; return
    653          }
    654          #endif /* RCC_CFGR_I2SSRC */
    655          #if defined(USB)
    656          /**
    657            * @brief  Return USBx clock frequency
    658            * @param  USBxSource This parameter can be one of the following values:
    659            *         @arg @ref LL_RCC_USB_CLKSOURCE
    660            * @retval USB clock frequency (in Hz)
    661            *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillator (HSI48) or PLL is not ready
    662            *         @arg @ref LL_RCC_PERIPH_FREQUENCY_NA indicates that no clock source selected
    663            */

   \                                 In section .text, align 2, keep-with-next
    664          uint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)
    665          {
   \                     LL_RCC_GetUSBClockFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    666            uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    667          
    668            /* Check parameter */
    669            assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));
    670          
    671            /* USBCLK clock frequency */
    672            switch (LL_RCC_GetUSBClockSource(USBxSource))
   \        0x2   0x....             LDR.N    R2,??DataTable12_1  ;; 0x40021000
   \        0x4   0x6853             LDR      R3,[R2, #+4]
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x4018             ANDS     R0,R0,R3
   \        0xA   0xF5B0 0x0F80      CMP      R0,#+4194304
   \        0xE   0x6810             LDR      R0,[R2, #+0]
   \       0x10   0xD105             BNE.N    ??LL_RCC_GetUSBClockFreq_0
    673            {
    674              case LL_RCC_USB_CLKSOURCE_PLL:        /* PLL clock used as USB clock source */
    675                if (LL_RCC_PLL_IsReady())
   \       0x12   0x0180             LSLS     R0,R0,#+6
   \       0x14   0xD50A             BPL.N    ??LL_RCC_GetUSBClockFreq_1
    676                {
    677                  usb_frequency = RCC_PLL_GetFreqDomain_SYS();
   \       0x16   0x....'....        BL       RCC_PLL_GetFreqDomain_SYS
   \       0x1A   0x4601             MOV      R1,R0
   \       0x1C   0xE006             B.N      ??LL_RCC_GetUSBClockFreq_1
    678                }
    679                break;
    680          
    681              case LL_RCC_USB_CLKSOURCE_PLL_DIV_1_5:        /* PLL clock used as USB clock source */
    682              default:
    683                if (LL_RCC_PLL_IsReady())
   \                     ??LL_RCC_GetUSBClockFreq_0: (+1)
   \       0x1E   0x0180             LSLS     R0,R0,#+6
   \       0x20   0xD504             BPL.N    ??LL_RCC_GetUSBClockFreq_1
    684                {
    685                  usb_frequency = (RCC_PLL_GetFreqDomain_SYS() * 3U) / 2U;
   \       0x22   0x....'....        BL       RCC_PLL_GetFreqDomain_SYS
   \       0x26   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \       0x2A   0x0849             LSRS     R1,R1,#+1
    686                }
    687                break;
    688            }
    689          
    690            return usb_frequency;
   \                     ??LL_RCC_GetUSBClockFreq_1: (+1)
   \       0x2C   0x4608             MOV      R0,R1
   \       0x2E   0xBD02             POP      {R1,PC}          ;; return
    691          }
    692          #endif /* USB */
    693          
    694          #if defined(RCC_CFGR_ADCPRE) || defined(RCC_CFGR2_ADC1PRES) || defined(RCC_CFGR2_ADCPRE12) || defined(RCC_CFGR2_ADCPRE34)
    695          /**
    696            * @brief  Return ADCx clock frequency
    697            * @param  ADCxSource This parameter can be one of the following values:
    698            *         @arg @ref LL_RCC_ADC_CLKSOURCE   (*)
    699            *         @arg @ref LL_RCC_ADC1_CLKSOURCE  (*)
    700            *         @arg @ref LL_RCC_ADC12_CLKSOURCE (*)
    701            *         @arg @ref LL_RCC_ADC34_CLKSOURCE (*)
    702            *
    703            *         (*) value not defined in all devices
    704            * @retval ADC clock frequency (in Hz)
    705            */

   \                                 In section .text, align 4, keep-with-next
    706          uint32_t LL_RCC_GetADCClockFreq(uint32_t ADCxSource)
    707          {
   \                     LL_RCC_GetADCClockFreq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
    708            uint32_t adc_prescaler = 0U;
    709            uint32_t adc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    710          
    711            /* Check parameter */
    712            assert_param(IS_LL_RCC_ADC_CLKSOURCE(ADCxSource));
    713          
    714            /* Get ADC prescaler */
    715            adc_prescaler = LL_RCC_GetADCClockSource(ADCxSource);
   \        0x4   0x....             LDR.N    R0,??DataTable12_9  ;; 0x4002102c
   \        0x6   0x6804             LDR      R4,[R0, #+0]
   \        0x8   0x402C             ANDS     R4,R5,R4
    716          
    717          #if defined(RCC_CFGR_ADCPRE)
    718            /* ADC frequency = PCLK2 frequency / ADC prescaler (2, 4, 6 or 8) */
    719            adc_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()))
    720                            / (((adc_prescaler >> POSITION_VAL(ADCxSource)) + 1U) * 2U);
    721          #else
    722            if ((adc_prescaler & 0x0000FFFFU) == ((uint32_t)0x00000000U))
   \        0xA   0x0421             LSLS     R1,R4,#+16
   \        0xC   0xD104             BNE.N    ??LL_RCC_GetADCClockFreq_0
    723            {
    724              /* ADC frequency = HCLK frequency */
    725              adc_frequency = RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq());
   \        0xE   0x....'....        BL       RCC_GetSystemClockFreq
   \       0x12   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x16   0x....             B.N      RCC_GetHCLKClockFreq
    726            }
    727            else
    728            {
    729              /* ADC frequency = PCLK2 frequency / ADC prescaler (from 1 to 256) */
    730              adc_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()))
    731                              / (aADCPrescTable[((adc_prescaler & 0x0000FFFFU) >> POSITION_VAL(ADCxSource)) & 0xFU]);
   \                     ??LL_RCC_GetADCClockFreq_0: (+1)
   \       0x18   0x....'....        BL       RCC_GetSystemClockFreq
   \       0x1C   0x....'....        BL       RCC_GetHCLKClockFreq
   \       0x20   0x....'....        BL       RCC_GetPCLK2ClockFreq
   \       0x24   0xFA95 0xF2A5      RBIT     R2,R5
   \       0x28   0xB2A4             UXTH     R4,R4
   \       0x2A   0xFAB2 0xF282      CLZ      R2,R2
   \       0x2E   0xBF00             Nop
   \       0x30   0x....             ADR.N    R1,aADCPrescTable
   \       0x32   0x40D4             LSRS     R4,R4,R2
   \       0x34   0xF004 0x040F      AND      R4,R4,#0xF
   \       0x38   0xF831 0x1014      LDRH     R1,[R1, R4, LSL #+1]
   \       0x3C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    732            }
    733          #endif /* RCC_CFGR_ADCPRE */
    734          
    735            return adc_frequency;
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    736          }
    737          #endif /*RCC_CFGR_ADCPRE || RCC_CFGR2_ADC1PRES || RCC_CFGR2_ADCPRE12 || RCC_CFGR2_ADCPRE34 */
    738          
    739          #if defined(RCC_CFGR_SDPRE)
    740          /**
    741            * @brief  Return SDADCx clock frequency
    742            * @param  SDADCxSource This parameter can be one of the following values:
    743            *         @arg @ref LL_RCC_SDADC_CLKSOURCE
    744            * @retval SDADC clock frequency (in Hz)
    745            */
    746          uint32_t LL_RCC_GetSDADCClockFreq(uint32_t SDADCxSource)
    747          {
    748            uint32_t sdadc_prescaler = 0U;
    749            uint32_t sdadc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    750          
    751            /* Check parameter */
    752            assert_param(IS_LL_RCC_SDADC_CLKSOURCE(SDADCxSource));
    753          
    754            /* Get SDADC prescaler */
    755            sdadc_prescaler = LL_RCC_GetSDADCClockSource(SDADCxSource);
    756          
    757            /* SDADC frequency = SYSTEM frequency / SDADC prescaler (from 2 to 48) */
    758            sdadc_frequency = RCC_GetSystemClockFreq()
    759                              / (aSDADCPrescTable[(sdadc_prescaler >> POSITION_VAL(SDADCxSource)) & 0xFU]);
    760          
    761            return sdadc_frequency;
    762          }
    763          #endif /*RCC_CFGR_SDPRE */
    764          
    765          #if defined(CEC)
    766          /**
    767            * @brief  Return CECx clock frequency
    768            * @param  CECxSource This parameter can be one of the following values:
    769            *         @arg @ref LL_RCC_CEC_CLKSOURCE
    770            * @retval CEC clock frequency (in Hz)
    771            *        @arg @ref LL_RCC_PERIPH_FREQUENCY_NO indicates that oscillators (HSI or LSE) are not ready
    772            */
    773          uint32_t LL_RCC_GetCECClockFreq(uint32_t CECxSource)
    774          {
    775            uint32_t cec_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    776          
    777            /* Check parameter */
    778            assert_param(IS_LL_RCC_CEC_CLKSOURCE(CECxSource));
    779          
    780            /* CECCLK clock frequency */
    781            switch (LL_RCC_GetCECClockSource(CECxSource))
    782            {
    783              case LL_RCC_CEC_CLKSOURCE_HSI_DIV244:   /* HSI / 244 clock used as CEC clock source */
    784                if (LL_RCC_HSI_IsReady())
    785                {
    786                  cec_frequency = HSI_VALUE / 244U;
    787                }
    788                break;
    789          
    790              case LL_RCC_CEC_CLKSOURCE_LSE:          /* LSE clock used as CEC clock source */
    791              default:
    792                if (LL_RCC_LSE_IsReady())
    793                {
    794                  cec_frequency = LSE_VALUE;
    795                }
    796                break;
    797            }
    798          
    799            return cec_frequency;
    800          }
    801          #endif /* CEC */
    802          
    803          #if defined(RCC_CFGR3_TIMSW)
    804          /**
    805            * @brief  Return TIMx clock frequency
    806            * @param  TIMxSource This parameter can be one of the following values:
    807            *         @arg @ref LL_RCC_TIM1_CLKSOURCE
    808            *         @arg @ref LL_RCC_TIM8_CLKSOURCE (*)
    809            *         @arg @ref LL_RCC_TIM15_CLKSOURCE (*)
    810            *         @arg @ref LL_RCC_TIM16_CLKSOURCE (*)
    811            *         @arg @ref LL_RCC_TIM17_CLKSOURCE (*)
    812            *         @arg @ref LL_RCC_TIM20_CLKSOURCE (*)
    813            *         @arg @ref LL_RCC_TIM2_CLKSOURCE (*)
    814            *         @arg @ref LL_RCC_TIM34_CLKSOURCE (*)
    815            *
    816            *         (*) value not defined in all devices
    817            * @retval TIM clock frequency (in Hz)
    818            */

   \                                 In section .text, align 2, keep-with-next
    819          uint32_t LL_RCC_GetTIMClockFreq(uint32_t TIMxSource)
    820          {
   \                     LL_RCC_GetTIMClockFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    821            uint32_t tim_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
   \        0x2   0x2100             MOVS     R1,#+0
    822          
    823            /* Check parameter */
    824            assert_param(IS_LL_RCC_TIM_CLKSOURCE(TIMxSource));
    825          
    826            if (TIMxSource == LL_RCC_TIM1_CLKSOURCE)
   \        0x4   0xB918             CBNZ.N   R0,??LL_RCC_GetTIMClockFreq_0
    827            {
    828              /* TIM1CLK clock frequency */
    829              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM1_CLKSOURCE) == LL_RCC_TIM1_CLKSOURCE_PCLK2)
   \        0x6   0x....'....        BL       LL_RCC_GetTIMClockSource
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xE013             B.N      ??LL_RCC_GetTIMClockFreq_1
    830              {
    831                /* PCLK2 used as TIM1 clock source */
    832                tim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    833              }
    834              else /* LL_RCC_TIM1_CLKSOURCE_PLL */
    835              {
    836                /* PLL clock used as TIM1 clock source */
    837                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    838              }
    839            }
    840          
    841          #if defined(RCC_CFGR3_TIM8SW)
    842            if (TIMxSource == LL_RCC_TIM8_CLKSOURCE)
    843            {
    844              /* TIM8CLK clock frequency */
    845              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM8_CLKSOURCE) == LL_RCC_TIM8_CLKSOURCE_PCLK2)
    846              {
    847                /* PCLK2 used as TIM8 clock source */
    848                tim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    849              }
    850              else /* LL_RCC_TIM8_CLKSOURCE_PLL */
    851              {
    852                /* PLL clock used as TIM8 clock source */
    853                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    854              }
    855            }
    856          #endif /*RCC_CFGR3_TIM8SW*/
    857          
    858          #if defined(RCC_CFGR3_TIM15SW)
    859            if (TIMxSource == LL_RCC_TIM15_CLKSOURCE)
   \                     ??LL_RCC_GetTIMClockFreq_0: (+1)
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD104             BNE.N    ??LL_RCC_GetTIMClockFreq_2
    860            {
    861              /* TIM15CLK clock frequency */
    862              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM15_CLKSOURCE) == LL_RCC_TIM15_CLKSOURCE_PCLK2)
   \       0x12   0x....'....        BL       LL_RCC_GetTIMClockSource
   \       0x16   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0x1A   0xE00C             B.N      ??LL_RCC_GetTIMClockFreq_1
    863              {
    864                /* PCLK2 used as TIM15 clock source */
    865                tim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    866              }
    867              else /* LL_RCC_TIM15_CLKSOURCE_PLL */
    868              {
    869                /* PLL clock used as TIM15 clock source */
    870                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    871              }
    872            }
    873          #endif /*RCC_CFGR3_TIM15SW*/
    874          
    875          #if defined(RCC_CFGR3_TIM16SW)
    876            if (TIMxSource == LL_RCC_TIM16_CLKSOURCE)
   \                     ??LL_RCC_GetTIMClockFreq_2: (+1)
   \       0x1C   0x2803             CMP      R0,#+3
   \       0x1E   0xD104             BNE.N    ??LL_RCC_GetTIMClockFreq_3
    877            {
    878              /* TIM16CLK clock frequency */
    879              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM16_CLKSOURCE) == LL_RCC_TIM16_CLKSOURCE_PCLK2)
   \       0x20   0x....'....        BL       LL_RCC_GetTIMClockSource
   \       0x24   0xF1B0 0x5FC0      CMP      R0,#+402653184
   \       0x28   0xE005             B.N      ??LL_RCC_GetTIMClockFreq_1
    880              {
    881                /* PCLK2 used as TIM16 clock source */
    882                tim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    883              }
    884              else /* LL_RCC_TIM16_CLKSOURCE_PLL */
    885              {
    886                /* PLL clock used as TIM16 clock source */
    887                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    888              }
    889            }
    890          #endif /*RCC_CFGR3_TIM16SW*/
    891          
    892          #if defined(RCC_CFGR3_TIM17SW)
    893            if (TIMxSource == LL_RCC_TIM17_CLKSOURCE)
   \                     ??LL_RCC_GetTIMClockFreq_3: (+1)
   \       0x2A   0x2805             CMP      R0,#+5
   \       0x2C   0xD10E             BNE.N    ??LL_RCC_GetTIMClockFreq_4
    894            {
    895              /* TIM17CLK clock frequency */
    896              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM17_CLKSOURCE) == LL_RCC_TIM17_CLKSOURCE_PCLK2)
   \       0x2E   0x....'....        BL       LL_RCC_GetTIMClockSource
   \       0x32   0xF1B0 0x5F20      CMP      R0,#+671088640
   \                     ??LL_RCC_GetTIMClockFreq_1: (+1)
   \       0x36   0xD106             BNE.N    ??LL_RCC_GetTIMClockFreq_5
    897              {
    898                /* PCLK2 used as TIM17 clock source */
    899                tim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
   \       0x38   0x....'....        BL       RCC_GetSystemClockFreq
   \       0x3C   0x....'....        BL       RCC_GetHCLKClockFreq
   \       0x40   0x....'....        BL       RCC_GetPCLK2ClockFreq
   \       0x44   0xE001             B.N      ??LL_RCC_GetTIMClockFreq_6
    900              }
    901              else /* LL_RCC_TIM17_CLKSOURCE_PLL */
    902              {
    903                /* PLL clock used as TIM17 clock source */
    904                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
   \                     ??LL_RCC_GetTIMClockFreq_5: (+1)
   \       0x46   0x....'....        BL       RCC_PLL_GetFreqDomain_SYS
   \                     ??LL_RCC_GetTIMClockFreq_6: (+1)
   \       0x4A   0x4601             MOV      R1,R0
    905              }
    906            }
    907          #endif /*RCC_CFGR3_TIM17SW*/
    908          
    909          #if defined(RCC_CFGR3_TIM20SW)
    910            if (TIMxSource == LL_RCC_TIM20_CLKSOURCE)
    911            {
    912              /* TIM20CLK clock frequency */
    913              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM20_CLKSOURCE) == LL_RCC_TIM20_CLKSOURCE_PCLK2)
    914              {
    915                /* PCLK2 used as TIM20 clock source */
    916                tim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    917              }
    918              else /* LL_RCC_TIM20_CLKSOURCE_PLL */
    919              {
    920                /* PLL clock used as TIM20 clock source */
    921                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    922              }
    923            }
    924          #endif /*RCC_CFGR3_TIM20SW*/
    925          
    926          #if defined(RCC_CFGR3_TIM2SW)
    927            if (TIMxSource == LL_RCC_TIM2_CLKSOURCE)
    928            {
    929              /* TIM2CLK clock frequency */
    930              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM2_CLKSOURCE) == LL_RCC_TIM2_CLKSOURCE_PCLK1)
    931              {
    932                /* PCLK1 used as TIM2 clock source */
    933                tim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    934              }
    935              else /* LL_RCC_TIM2_CLKSOURCE_PLL */
    936              {
    937                /* PLL clock used as TIM2 clock source */
    938                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    939              }
    940            }
    941          #endif /*RCC_CFGR3_TIM2SW*/
    942          
    943          #if defined(RCC_CFGR3_TIM34SW)
    944            if (TIMxSource == LL_RCC_TIM34_CLKSOURCE)
    945            {
    946              /* TIM3/4 CLK clock frequency */
    947              if (LL_RCC_GetTIMClockSource(LL_RCC_TIM34_CLKSOURCE) == LL_RCC_TIM34_CLKSOURCE_PCLK1)
    948              {
    949                /* PCLK1 used as TIM3/4 clock source */
    950                tim_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    951              }
    952              else /* LL_RCC_TIM34_CLKSOURCE_PLL */
    953              {
    954                /* PLL clock used as TIM3/4 clock source */
    955                tim_frequency = RCC_PLL_GetFreqDomain_SYS();
    956              }
    957            }
    958          #endif /*RCC_CFGR3_TIM34SW*/
    959          
    960            return tim_frequency;
   \                     ??LL_RCC_GetTIMClockFreq_4: (+1)
   \       0x4C   0x4608             MOV      R0,R1
   \       0x4E   0xBD02             POP      {R1,PC}          ;; return
    961          }
    962          #endif /*RCC_CFGR3_TIMSW*/
    963          
    964          #if defined(HRTIM1)
    965          /**
    966            * @brief  Return HRTIMx clock frequency
    967            * @param  HRTIMxSource This parameter can be one of the following values:
    968            *         @arg @ref LL_RCC_HRTIM1_CLKSOURCE
    969            * @retval HRTIM clock frequency (in Hz)
    970            */
    971          uint32_t LL_RCC_GetHRTIMClockFreq(uint32_t HRTIMxSource)
    972          {
    973            uint32_t hrtim_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
    974          
    975            /* Check parameter */
    976            assert_param(IS_LL_RCC_HRTIM_CLKSOURCE(HRTIMxSource));
    977          
    978            /* HRTIM1CLK clock frequency */
    979            if (LL_RCC_GetHRTIMClockSource(LL_RCC_HRTIM1_CLKSOURCE) == LL_RCC_HRTIM1_CLKSOURCE_PCLK2)
    980            {
    981              /* PCLK2 used as HRTIM1 clock source */
    982              hrtim_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
    983            }
    984            else /* LL_RCC_HRTIM1_CLKSOURCE_PLL */
    985            {
    986              /* PLL clock used as HRTIM1 clock source */
    987              hrtim_frequency = RCC_PLL_GetFreqDomain_SYS();
    988            }
    989          
    990            return hrtim_frequency;
    991          }
    992          #endif /* HRTIM1 */
    993          
    994          /**
    995            * @}
    996            */
    997          
    998          /**
    999            * @}
   1000            */
   1001          
   1002          /** @addtogroup RCC_LL_Private_Functions
   1003            * @{
   1004            */
   1005          
   1006          /**
   1007            * @brief  Return SYSTEM clock frequency
   1008            * @retval SYSTEM clock frequency (in Hz)
   1009            */

   \                                 In section .text, align 2, keep-with-next
   1010          uint32_t RCC_GetSystemClockFreq(void)
   1011          {
   1012            uint32_t frequency = 0U;
   1013          
   1014            /* Get SYSCLK source -------------------------------------------------------*/
   1015            switch (LL_RCC_GetSysClkSource())
   \                     RCC_GetSystemClockFreq: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40021004
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF000 0x000C      AND      R0,R0,#0xC
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xBF08             IT       EQ
   1016            {
   1017              case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
   1018                frequency = HSI_VALUE;
   1019                break;
   1020          
   1021              case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
   1022                frequency = HSE_VALUE;
   1023                break;
   1024          
   1025              case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
   1026                frequency = RCC_PLL_GetFreqDomain_SYS();
   \        0xC   0x....'....        BEQ.W    RCC_PLL_GetFreqDomain_SYS
   1027                break;
   1028          
   1029              default:
   1030                frequency = HSI_VALUE;
   \       0x10   0x....             LDR.N    R0,??DataTable12_4  ;; 0x7a1200
   1031                break;
   1032            }
   1033          
   1034            return frequency;
   \       0x12   0x4770             BX       LR               ;; return
   1035          }
   1036          
   1037          /**
   1038            * @brief  Return HCLK clock frequency
   1039            * @param  SYSCLK_Frequency SYSCLK clock frequency
   1040            * @retval HCLK clock frequency (in Hz)
   1041            */

   \                                 In section .text, align 2, keep-with-next
   1042          uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
   1043          {
   1044            /* HCLK clock frequency */
   1045            return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
   \                     RCC_GetHCLKClockFreq: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_8  ;; 0x40021004
   \        0x2   0x....             LDR.N    R2,??DataTable12_10
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xF3C1 0x1103      UBFX     R1,R1,#+4,#+4
   \        0xA   0x....             B.N      ?Subroutine0
   1046          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x5C51             LDRB     R1,[R2, R1]
   \        0x2   0x40C8             LSRS     R0,R0,R1
   \        0x4   0x4770             BX       LR               ;; return
   1047          
   1048          /**
   1049            * @brief  Return PCLK1 clock frequency
   1050            * @param  HCLK_Frequency HCLK clock frequency
   1051            * @retval PCLK1 clock frequency (in Hz)
   1052            */

   \                                 In section .text, align 2, keep-with-next
   1053          uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
   1054          {
   1055            /* PCLK1 clock frequency */
   1056            return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
   \                     RCC_GetPCLK1ClockFreq: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_8  ;; 0x40021004
   \        0x2   0x....             LDR.N    R2,??DataTable12_11
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xF3C1 0x2102      UBFX     R1,R1,#+8,#+3
   \        0xA                      REQUIRE ?Subroutine0
   \        0xA                      ;; // Fall through to label ?Subroutine0
   1057          }
   1058          
   1059          /**
   1060            * @brief  Return PCLK2 clock frequency
   1061            * @param  HCLK_Frequency HCLK clock frequency
   1062            * @retval PCLK2 clock frequency (in Hz)
   1063            */

   \                                 In section .text, align 2, keep-with-next
   1064          uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
   1065          {
   1066            /* PCLK2 clock frequency */
   1067            return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
   \                     RCC_GetPCLK2ClockFreq: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable12_8  ;; 0x40021004
   \        0x2   0x....             LDR.N    R2,??DataTable12_11
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0xF3C1 0x21C2      UBFX     R1,R1,#+11,#+3
   \        0xA   0x....             B.N      ?Subroutine0
   1068          }
   1069          
   1070          /**
   1071            * @brief  Return PLL clock frequency used for system domain
   1072            * @retval PLL clock frequency (in Hz)
   1073            */

   \                                 In section .text, align 2, keep-with-next
   1074          uint32_t RCC_PLL_GetFreqDomain_SYS(void)
   1075          {
   1076            uint32_t pllinputfreq = 0U, pllsource = 0U;
   1077          
   1078            /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL divider) * PLL Multiplicator */
   1079          
   1080            /* Get PLL source */
   1081            pllsource = LL_RCC_PLL_GetMainSource();
   \                     RCC_PLL_GetFreqDomain_SYS: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40021004
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   1082          
   1083            switch (pllsource)
   1084            {
   1085          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
   1086              case LL_RCC_PLLSOURCE_HSI:       /* HSI used as PLL clock source */
   1087                pllinputfreq = HSI_VALUE;
   1088          #else
   1089              case LL_RCC_PLLSOURCE_HSI_DIV_2: /* HSI used as PLL clock source */
   1090                pllinputfreq = HSI_VALUE / 2U;
   1091          #endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
   1092                break;
   1093          
   1094              case LL_RCC_PLLSOURCE_HSE:       /* HSE used as PLL clock source */
   1095                pllinputfreq = HSE_VALUE;
   1096                break;
   1097          
   1098              default:
   1099          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
   1100                pllinputfreq = HSI_VALUE;
   1101          #else
   1102                pllinputfreq = HSI_VALUE / 2U;
   1103          #endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
   1104                break;
   1105            }
   1106          #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
   1107            return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetMultiplicator(), LL_RCC_PLL_GetPrediv());
   1108          #else
   1109            return __LL_RCC_CALC_PLLCLK_FREQ((pllinputfreq / (LL_RCC_PLL_GetPrediv() + 1U)), LL_RCC_PLL_GetMultiplicator());
   \        0x4   0x6A82             LDR      R2,[R0, #+40]
   \        0x6   0x6803             LDR      R3,[R0, #+0]
   \        0x8   0xF401 0x3180      AND      R1,R1,#0x10000
   \        0xC   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0x10   0xBF0C             ITE      EQ
   \       0x12   0x....             LDREQ.N  R1,??DataTable12_4  ;; 0x7a1200
   \       0x14   0x....             LDRNE.N  R1,??DataTable12_12  ;; 0x3d0900
   \       0x16   0xF002 0x020F      AND      R2,R2,#0xF
   \       0x1A   0x1C52             ADDS     R2,R2,#+1
   \       0x1C   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \       0x20   0xF3C3 0x4183      UBFX     R1,R3,#+18,#+4
   \       0x24   0x1C89             ADDS     R1,R1,#+2
   \       0x26   0x4348             MULS     R0,R1,R0
   \       0x28   0x4770             BX       LR               ;; return
   1110          #endif /* RCC_PLLSRC_PREDIV1_SUPPORT */
   1111          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x4002'1030        DC32     0x40021030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0xF8FF'C00C        DC32     0xf8ffc00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0xFEF6'FFFF        DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x007A'1200        DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x1000'0010        DC32     0x10000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x2000'0020        DC32     0x20000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x4000'0040        DC32     0x40000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x4002'1004        DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x4002'102C        DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x....'....        DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x....'....        DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x003D'0900        DC32     0x3d0900
   1112          /**
   1113            * @}
   1114            */
   1115          
   1116          /**
   1117            * @}
   1118            */
   1119          
   1120          #endif /* defined(RCC) */
   1121          
   1122          /**
   1123            * @}
   1124            */
   1125          
   1126          #endif /* USE_FULL_LL_DRIVER */
   1127          
   1128          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   LL_RCC_DeInit
      16   LL_RCC_GetADCClockFreq
         0   -> RCC_GetHCLKClockFreq
        16   -> RCC_GetHCLKClockFreq
        16   -> RCC_GetPCLK2ClockFreq
        16   -> RCC_GetSystemClockFreq
       8   LL_RCC_GetI2CClockFreq
         0   -> RCC_GetSystemClockFreq
       0   LL_RCC_GetI2SClockFreq
         0   -> RCC_GetSystemClockFreq
       8   LL_RCC_GetSystemClocksFreq
         8   -> RCC_GetHCLKClockFreq
         8   -> RCC_GetPCLK1ClockFreq
         8   -> RCC_GetPCLK2ClockFreq
         8   -> RCC_GetSystemClockFreq
       8   LL_RCC_GetTIMClockFreq
         8   -> LL_RCC_GetTIMClockSource
         8   -> RCC_GetHCLKClockFreq
         8   -> RCC_GetPCLK2ClockFreq
         8   -> RCC_GetSystemClockFreq
         8   -> RCC_PLL_GetFreqDomain_SYS
       0   LL_RCC_GetTIMClockSource
       8   LL_RCC_GetUSARTClockFreq
         8   -> RCC_GetHCLKClockFreq
         8   -> RCC_GetPCLK1ClockFreq
         8   -> RCC_GetSystemClockFreq
       8   LL_RCC_GetUSBClockFreq
         8   -> RCC_PLL_GetFreqDomain_SYS
       0   RCC_GetHCLKClockFreq
       0   RCC_GetPCLK1ClockFreq
       0   RCC_GetPCLK2ClockFreq
       0   RCC_GetSystemClockFreq
         0   -> RCC_PLL_GetFreqDomain_SYS
       0   RCC_PLL_GetFreqDomain_SYS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       6  ?Subroutine0
     124  LL_RCC_DeInit
      66  LL_RCC_GetADCClockFreq
      86  LL_RCC_GetI2CClockFreq
      18  LL_RCC_GetI2SClockFreq
      32  LL_RCC_GetSystemClocksFreq
      80  LL_RCC_GetTIMClockFreq
      20  LL_RCC_GetTIMClockSource
      74  LL_RCC_GetUSARTClockFreq
      48  LL_RCC_GetUSBClockFreq
      12  RCC_GetHCLKClockFreq
      10  RCC_GetPCLK1ClockFreq
      12  RCC_GetPCLK2ClockFreq
      20  RCC_GetSystemClockFreq
      42  RCC_PLL_GetFreqDomain_SYS
      32  aADCPrescTable

 
 734 bytes in section .text
 
 734 bytes of CODE memory

Errors: none
Warnings: none
