###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:52
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_ReplyCmd.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW3DE.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_ReplyCmd.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\module_ReplyCmd.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\module_ReplyCmd.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\UniversalProtocol\module_ReplyCmd.c
      1          /**
      2            ***************************************************************************************************
      3            * @file    module_ReplyCmd.c 
      4            * @author  Regal Pamela Lee
      5            * @version V1.0
      6            * @date    19-OCT-2020
      7            * @brief   Decode and perform group 3 CMD
      8            * @note    This App decode Group3 CMD in Universal protocol
      9            ***************************************************************************************************
     10            */
     11          #include "pmsm_motor_parameters.h"
     12          #include "module_ReplyCmd.h"

   \                                 In section .data, align 8
   \   static __absolute uint8_t reallocError
   \                     reallocError:
   \        0x0   0x00               DC8 0
   \        0x1   0x00 0x00          DC8 0, 0, 0

   \              0x00
     13          #include "mc_api.h"
     14          #include "driver_usart2.h"
     15          #include "mc_config.h"
     16          
     17          extern ProcessInfo processInfoTable[];
     18          extern MCT_Handle_t MCT[NBR_OF_MOTORS];
     19          static MCT_Handle_t *pMCT = &MCT[M1]; 
     20          
     21          Usart2_Control* usart2Control_ReplyCmd;
     22          
     23          /************** this enum and array made for the periodic resent of motor data back to comBoard ***************************/
     24          typedef enum                                                            //data request cmd list
     25          {                                                                       //please assign according to the universal protocol document
     26            BusVolt = 0x40,               //item0
     27            MotFault,                     //item1
     28            MeaSpeed = 0x60,               //item2
     29            MotDir = 0x42,               //item3
     30            MotEE = 0x4F,                 //item4
     31            MotThermMech = 0x6F,           //item5
     32            MotTorque = 0x61,                     //item6
     33            HeartBeat = 0x4E,                    //item7
     34          }ReplyCMD;
     35                   //         item       0  1  2    3    4    5   6   7         -- as the valuable will match in the same way for the enum command list above
     36          uint64_t tt_PerioidTime[]   = {0, 0, 0,   0,   0,   0,  0,  0};                                //please declare total numbers of items in enum, for example three zero with 3 command in enum
     37          uint16_t PerioidTimeValue[] = {0, 0, 0,   0, 1000, 0,   0,  2000};      ///please declare total numbers of items in enum, for example three zero with 3 
   \                     PerioidTimeValue:
   \        0x4   0x0000 0x0000      DC16 0, 0, 0, 0, 1'000, 0, 0, 2'000

   \               0x0000 0x000

   \              0 0x03E8 0x00

   \              00 0x0000 0x0

   \              7D0
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0

   \              0x00 0x00
   \                     tt_PerioidTime:
   \       0x18   0x0000'0000'0      DC64 0, 0, 0, 0, 0, 0, 0, 0

   \              000'0000 0x00

   \              00'0000'0000'

   \              0000 0x0000'0

   \              000'0000'0000

   \               0x0000'0000'

   \              0000'0000 0x0

   \              000'0000'0000

   \              '0000 0x0000'

   \              0000'0000'000

   \              0 0x0000'0000

   \              '0000'0000 0x

   \              0000'0000'000

   \              0'0000
   \                     usart2Control_ReplyCmd:
   \       0x58                      DS8 4
     38                                                           ///command in enum,you can put the default reply period in the relative item, then it will report data automatically.
     39                                                           /// for example item2 is Measured-speed will send back every 1000mS
     40          /**************************************************************************************************************************/
     41          
     42          enum AppStates {
     43              INIT_APP,
     44              RUN_APP,
     45              CMDreply,
     46              // additional states to be added here as necessary.
     47              IRQ_APP = DEFAULT_IRQ_STATE,
     48              STOP_APP = KILL_APP
     49          };
     50          
     51          //uint16_t adcFilterVal = 0;
     52          unsigned char* protocolBuf_ReplyCmd ;
   \                     protocolBuf_ReplyCmd:
   \       0x5C                      DS8 4

   \                                 In section .data, align 4
   \        0x0   0x....'....        DC32 MCT
     53          //^**Tips: APPs/Drivers adding process example step7 (Add the Additional funtion itself)

   \                                 In section .text, align 4, keep-with-next
     54          uint8_t moduleReplyCmd_u32(uint8_t module_id_u8, uint8_t prev_state_u8, uint8_t next_State_u8,
     55                                  uint8_t irq_id_u8)                
     56          { 
   \                     moduleReplyCmd_u32: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
     57            uint8_t     returnStage = 0;  
   \        0x6   0x2000             MOVS     R0,#+0
     58            switch (next_State_u8)
   \        0x8   0x....'....        LDR.W    R4,??DataTable8
   \        0xC   0xB152             CBZ.N    R2,??moduleReplyCmd_u32_1
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD014             BEQ.N    ??moduleReplyCmd_u32_2
   \       0x12   0x2A02             CMP      R2,#+2
   \       0x14   0xF000 0x80DD      BEQ.W    ??moduleReplyCmd_u32_3
   \       0x18   0x2AC8             CMP      R2,#+200
   \       0x1A   0xD00E             BEQ.N    ??moduleReplyCmd_u32_4
   \       0x1C   0x2AFF             CMP      R2,#+255
   \       0x1E   0xF000 0x81BB      BEQ.W    ??moduleReplyCmd_u32_5
   \       0x22   0xE1B8             B.N      ??moduleReplyCmd_u32_6
     59              {
     60                case INIT_APP:                                                              //initial stage
     61                  {     
     62                    /*Attach Uart2 shared memory into this App*/
     63                    uint8_t Usart2index  = getProcessInfoIndex(MODULE_USART1);              //return Process index from processInfo array with the Uart2 driver
   \                     ??moduleReplyCmd_u32_1: (+1)
   \       0x24   0x....'....        BL       getProcessInfoIndex
     64                    usart2Control_ReplyCmd = (Usart2_Control*) ((*(processInfoTable[Usart2index].Sched_ModuleData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x28   0x2116             MOVS     R1,#+22
   \       0x2A   0x....'....        LDR.W    R2,??DataTable8_1
   \       0x2E   0x4348             MULS     R0,R1,R0
   \       0x30   0x1811             ADDS     R1,R2,R0
   \       0x32   0xF8D1 0x000B      LDR      R0,[R1, #+11]
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x65A0             STR      R0,[R4, #+88]
   \                     ??moduleReplyCmd_u32_4: (+1)
   \       0x3A   0xE1AA             B.N      ??moduleReplyCmd_u32_7
     65          
     66                    returnStage = RUN_APP ;
     67                    break;
     68                  }       
     69                case RUN_APP:
     70                  { 
     71                    unsigned int DataLen2 = (unsigned int)UniHeaderlen;
     72                    if(RingBuf_GetUsedNumOfElements((*usart2Control_ReplyCmd).seqMemRXG3_u32) >= DataLen2 )
   \                     ??moduleReplyCmd_u32_2: (+1)
   \       0x3C   0x6DA0             LDR      R0,[R4, #+88]
   \       0x3E   0x2107             MOVS     R1,#+7
   \       0x40   0x9100             STR      R1,[SP, #+0]
   \       0x42   0x6840             LDR      R0,[R0, #+4]
   \       0x44   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x48   0x9900             LDR      R1,[SP, #+0]
   \       0x4A   0x4288             CMP      R0,R1
   \       0x4C   0xD331             BCC.N    ??moduleReplyCmd_u32_8
     73                    {        
     74                      if((protocolBuf_ReplyCmd = (unsigned char*) realloc(protocolBuf_ReplyCmd,DataLen2)) == NULL) reallocError++;     
   \       0x4E   0x6DE0             LDR      R0,[R4, #+92]
   \       0x50   0x....'....        BL       realloc
   \       0x54   0x0001             MOVS     R1,R0
   \       0x56   0xD102             BNE.N    ??moduleReplyCmd_u32_9
   \       0x58   0x7820             LDRB     R0,[R4, #+0]
   \       0x5A   0x1C40             ADDS     R0,R0,#+1
   \       0x5C   0x7020             STRB     R0,[R4, #+0]
     75                      RingBuf_Observe((*usart2Control_ReplyCmd).seqMemRXG3_u32, protocolBuf_ReplyCmd, 0, &DataLen2);  
   \                     ??moduleReplyCmd_u32_9: (+1)
   \       0x5E   0x65E1             STR      R1,[R4, #+92]
   \       0x60   0x466B             MOV      R3,SP
   \       0x62   0x6DA0             LDR      R0,[R4, #+88]
   \       0x64   0x6840             LDR      R0,[R0, #+4]
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x....'....        BL       RingBuf_Observe
     76                      //calculate the total number of frame
     77                      DataLen2 = ((unsigned int)protocolBuf_ReplyCmd[1] & 0x3F) + (unsigned int)UniHeaderlen;
   \       0x6C   0x6DE0             LDR      R0,[R4, #+92]
   \       0x6E   0x7841             LDRB     R1,[R0, #+1]
   \       0x70   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x74   0x1DC9             ADDS     R1,R1,#+7
   \       0x76   0x9100             STR      R1,[SP, #+0]
     78                      if((protocolBuf_ReplyCmd = (unsigned char*) realloc(protocolBuf_ReplyCmd,DataLen2)) == NULL) reallocError++;     //allocate the right frame size of memory for buffer
   \       0x78   0x....'....        BL       realloc
   \       0x7C   0x....'....        BL       ?Subroutine0
     79                      RingBuf_ReadBlock((*usart2Control_ReplyCmd).seqMemRXG3_u32, protocolBuf_ReplyCmd, &DataLen2); //extract the whole frame
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x80   0x4601             MOV      R1,R0
   \       0x82   0x6DA0             LDR      R0,[R4, #+88]
   \       0x84   0x6840             LDR      R0,[R0, #+4]
   \       0x86   0x466A             MOV      R2,SP
   \       0x88   0x....'....        BL       RingBuf_ReadBlock
     80                      //decode and perform the CMD function
     81                      switch((ReplyCMD)protocolBuf_ReplyCmd[2])
   \       0x8C   0x6DE0             LDR      R0,[R4, #+92]
   \       0x8E   0x7881             LDRB     R1,[R0, #+2]
   \       0x90   0x2940             CMP      R1,#+64
   \       0x92   0xD00F             BEQ.N    ??moduleReplyCmd_u32_10
   \       0x94   0x2941             CMP      R1,#+65
   \       0x96   0xD01E             BEQ.N    ??moduleReplyCmd_u32_11
   \       0x98   0x2942             CMP      R1,#+66
   \       0x9A   0xD03E             BEQ.N    ??moduleReplyCmd_u32_12
   \       0x9C   0x294E             CMP      R1,#+78
   \       0x9E   0xF000 0x8080      BEQ.W    ??moduleReplyCmd_u32_13
   \       0xA2   0x294F             CMP      R1,#+79
   \       0xA4   0xD04A             BEQ.N    ??moduleReplyCmd_u32_14
   \       0xA6   0x2960             CMP      R1,#+96
   \       0xA8   0xD026             BEQ.N    ??moduleReplyCmd_u32_15
   \       0xAA   0x2961             CMP      R1,#+97
   \       0xAC   0xD068             BEQ.N    ??moduleReplyCmd_u32_16
   \       0xAE   0x296F             CMP      R1,#+111
   \       0xB0   0xD055             BEQ.N    ??moduleReplyCmd_u32_17
   \                     ??moduleReplyCmd_u32_8: (+1)
   \       0xB2   0xE086             B.N      ??moduleReplyCmd_u32_18
     82                      {
     83                        case BusVolt: // point to tt_PerioidTime[0] and PerioidTimeValue[0]
     84                          { //Bus voltage request
     85                            PerioidTimeValue[0] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_10: (+1)
   \       0xB4   0x7941             LDRB     R1,[R0, #+5]
   \       0xB6   0x0209             LSLS     R1,R1,#+8
   \       0xB8   0x80A1             STRH     R1,[R4, #+4]
     86                            PerioidTimeValue[0] += protocolBuf_ReplyCmd[6];
   \       0xBA   0x7980             LDRB     R0,[R0, #+6]
   \       0xBC   0x1808             ADDS     R0,R1,R0
   \       0xBE   0x80A0             STRH     R0,[R4, #+4]
     87                            if(PerioidTimeValue[0] > 1)
   \       0xC0   0xB280             UXTH     R0,R0
   \       0xC2   0x2801             CMP      R0,#+1
   \       0xC4   0xDD7D             BLE.N    ??moduleReplyCmd_u32_18
     88                            {     // if not one off cmd will start to remember the next wakeup time
     89                              tt_PerioidTime[0] = getSysCount() + PerioidTimeValue[0];                          //store time tick value
   \       0xC6   0x....'....        BL       getSysCount
   \       0xCA   0x88A2             LDRH     R2,[R4, #+4]
   \       0xCC   0x....'....        BL       ?Subroutine1
     90                            }   
     91                            break;
     92                          }
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0xD0   0xE9C4 0x0106      STRD     R0,R1,[R4, #+24]
   \       0xD4   0xE075             B.N      ??moduleReplyCmd_u32_18
     93                        case MotFault: // point to tt_PerioidTime[1] and PerioidTimeValue[1]
     94                          { //fault status request
     95                            PerioidTimeValue[1] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_11: (+1)
   \       0xD6   0x7941             LDRB     R1,[R0, #+5]
   \       0xD8   0x0209             LSLS     R1,R1,#+8
   \       0xDA   0x80E1             STRH     R1,[R4, #+6]
     96                            PerioidTimeValue[1] += protocolBuf_ReplyCmd[6];
   \       0xDC   0x7980             LDRB     R0,[R0, #+6]
   \       0xDE   0x1808             ADDS     R0,R1,R0
   \       0xE0   0x80E0             STRH     R0,[R4, #+6]
     97                            if(PerioidTimeValue[1] > 1)
   \       0xE2   0xB280             UXTH     R0,R0
   \       0xE4   0x2801             CMP      R0,#+1
   \       0xE6   0xDD6C             BLE.N    ??moduleReplyCmd_u32_18
     98                            {     // if not one off cmd will start to remember the next wakeup time
     99                              tt_PerioidTime[1] = getSysCount() + PerioidTimeValue[1];                          //store time tick value
   \       0xE8   0x....'....        BL       getSysCount
   \       0xEC   0x88E2             LDRH     R2,[R4, #+6]
   \       0xEE   0x....'....        BL       ?Subroutine1
    100                            }                
    101                            break;
    102                          }
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xF2   0xE9C4 0x0108      STRD     R0,R1,[R4, #+32]
   \       0xF6   0xE064             B.N      ??moduleReplyCmd_u32_18
    103                        case MeaSpeed: // point to tt_PerioidTime[2] and PerioidTimeValue[2]
    104                          { //measured speed request
    105                            PerioidTimeValue[2] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_15: (+1)
   \       0xF8   0x7941             LDRB     R1,[R0, #+5]
   \       0xFA   0x0209             LSLS     R1,R1,#+8
   \       0xFC   0x8121             STRH     R1,[R4, #+8]
    106                            PerioidTimeValue[2] += protocolBuf_ReplyCmd[6];
   \       0xFE   0x7980             LDRB     R0,[R0, #+6]
   \      0x100   0x1808             ADDS     R0,R1,R0
   \      0x102   0x8120             STRH     R0,[R4, #+8]
    107                            if(PerioidTimeValue[2] > 1)
   \      0x104   0xB280             UXTH     R0,R0
   \      0x106   0x2801             CMP      R0,#+1
   \      0x108   0xDD5B             BLE.N    ??moduleReplyCmd_u32_18
    108                            {     // if not one off cmd will start to remember the next wakeup time
    109                              tt_PerioidTime[2] = getSysCount() + PerioidTimeValue[2];                          //store time tick value
   \      0x10A   0x....'....        BL       getSysCount
   \      0x10E   0x8922             LDRH     R2,[R4, #+8]
   \      0x110   0x....'....        BL       ?Subroutine1
    110                            }
    111                            break;
    112                          }
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x114   0xE9C4 0x010A      STRD     R0,R1,[R4, #+40]
   \      0x118   0xE053             B.N      ??moduleReplyCmd_u32_18
    113                       case MotDir: // point to tt_PerioidTime[3] and PerioidTimeValue[3]
    114                          { //actual direction request
    115                            PerioidTimeValue[3] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_12: (+1)
   \      0x11A   0x7941             LDRB     R1,[R0, #+5]
   \      0x11C   0x0209             LSLS     R1,R1,#+8
   \      0x11E   0x8161             STRH     R1,[R4, #+10]
    116                            PerioidTimeValue[3] += protocolBuf_ReplyCmd[6];
   \      0x120   0x7980             LDRB     R0,[R0, #+6]
   \      0x122   0x1808             ADDS     R0,R1,R0
   \      0x124   0x8160             STRH     R0,[R4, #+10]
    117                            if(PerioidTimeValue[3] > 1)
   \      0x126   0xB280             UXTH     R0,R0
   \      0x128   0x2801             CMP      R0,#+1
   \      0x12A   0xDD4A             BLE.N    ??moduleReplyCmd_u32_18
    118                            {     // if not one off cmd will start to remember the next wakeup time
    119                              tt_PerioidTime[3] = getSysCount() + PerioidTimeValue[3];                          //store time tick value
   \      0x12C   0x....'....        BL       getSysCount
   \      0x130   0x8962             LDRH     R2,[R4, #+10]
   \      0x132   0x....'....        BL       ?Subroutine1
    120                            }
    121                            break;                  
    122                          }                  
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x136   0xE9C4 0x010C      STRD     R0,R1,[R4, #+48]
   \      0x13A   0xE042             B.N      ??moduleReplyCmd_u32_18
    123                       case MotEE: // point to tt_PerioidTime[4] and PerioidTimeValue[4]
    124                          { //measured power request
    125                            PerioidTimeValue[4] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_14: (+1)
   \      0x13C   0x7941             LDRB     R1,[R0, #+5]
   \      0x13E   0x0209             LSLS     R1,R1,#+8
   \      0x140   0x81A1             STRH     R1,[R4, #+12]
    126                            PerioidTimeValue[4] += protocolBuf_ReplyCmd[6];
   \      0x142   0x7980             LDRB     R0,[R0, #+6]
   \      0x144   0x1808             ADDS     R0,R1,R0
   \      0x146   0x81A0             STRH     R0,[R4, #+12]
    127                            if(PerioidTimeValue[4] > 1)
   \      0x148   0xB280             UXTH     R0,R0
   \      0x14A   0x2801             CMP      R0,#+1
   \      0x14C   0xDD39             BLE.N    ??moduleReplyCmd_u32_18
    128                            {     // if not one off cmd will start to remember the next wakeup time
    129                              tt_PerioidTime[4] = getSysCount() + PerioidTimeValue[4];                          //store time tick value
   \      0x14E   0x....'....        BL       getSysCount
   \      0x152   0x89A2             LDRH     R2,[R4, #+12]
   \      0x154   0x....'....        BL       ?Subroutine1
    130                            }
    131                            break;
    132                          }
   \                     ??CrossCallReturnLabel_6: (+1)
   \      0x158   0xE9C4 0x010E      STRD     R0,R1,[R4, #+56]
   \      0x15C   0xE031             B.N      ??moduleReplyCmd_u32_18
    133                       case MotThermMech: // point to tt_PerioidTime[5] and PerioidTimeValue[5]
    134                          { //estimated temperature request
    135                            PerioidTimeValue[5] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_17: (+1)
   \      0x15E   0x7941             LDRB     R1,[R0, #+5]
   \      0x160   0x0209             LSLS     R1,R1,#+8
   \      0x162   0x81E1             STRH     R1,[R4, #+14]
    136                            PerioidTimeValue[5] += protocolBuf_ReplyCmd[6];
   \      0x164   0x7980             LDRB     R0,[R0, #+6]
   \      0x166   0x1808             ADDS     R0,R1,R0
   \      0x168   0x81E0             STRH     R0,[R4, #+14]
    137                            if(PerioidTimeValue[5] > 1)
   \      0x16A   0xB280             UXTH     R0,R0
   \      0x16C   0x2801             CMP      R0,#+1
   \      0x16E   0xDD28             BLE.N    ??moduleReplyCmd_u32_18
    138                            {     // if not one off cmd will start to remember the next wakeup time
    139                              tt_PerioidTime[5] = getSysCount() + PerioidTimeValue[5];                          //store time tick value
   \      0x170   0x....'....        BL       getSysCount
   \      0x174   0x89E2             LDRH     R2,[R4, #+14]
   \      0x176   0x....'....        BL       ?Subroutine1
    140                            }
    141                            break;  
    142                          }  
   \                     ??CrossCallReturnLabel_7: (+1)
   \      0x17A   0xE9C4 0x0110      STRD     R0,R1,[R4, #+64]
   \      0x17E   0xE020             B.N      ??moduleReplyCmd_u32_18
    143                       case MotTorque: // point to tt_PerioidTime[6] and PerioidTimeValue[6]
    144                          { //estimated temperature request
    145                            PerioidTimeValue[6] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_16: (+1)
   \      0x180   0x7941             LDRB     R1,[R0, #+5]
   \      0x182   0x0209             LSLS     R1,R1,#+8
   \      0x184   0x8221             STRH     R1,[R4, #+16]
    146                            PerioidTimeValue[6] += protocolBuf_ReplyCmd[6];
   \      0x186   0x7980             LDRB     R0,[R0, #+6]
   \      0x188   0x1808             ADDS     R0,R1,R0
   \      0x18A   0x8220             STRH     R0,[R4, #+16]
    147                            if(PerioidTimeValue[6] > 1)
   \      0x18C   0xB280             UXTH     R0,R0
   \      0x18E   0x2801             CMP      R0,#+1
   \      0x190   0xDD17             BLE.N    ??moduleReplyCmd_u32_18
    148                            {     // if not one off cmd will start to remember the next wakeup time
    149                              tt_PerioidTime[6] = getSysCount() + PerioidTimeValue[6];                          //store time tick value
   \      0x192   0x....'....        BL       getSysCount
   \      0x196   0x8A22             LDRH     R2,[R4, #+16]
   \      0x198   0x....'....        BL       ?Subroutine1
    150                            }
    151                            break;   
    152                          }
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x19C   0xE9C4 0x0112      STRD     R0,R1,[R4, #+72]
   \      0x1A0   0xE00F             B.N      ??moduleReplyCmd_u32_18
    153                       case HeartBeat: // point to tt_PerioidTime[6] and PerioidTimeValue[6]
    154                          { //estimated temperature request
    155                            PerioidTimeValue[7] = (uint16_t)protocolBuf_ReplyCmd[5] << 8;
   \                     ??moduleReplyCmd_u32_13: (+1)
   \      0x1A2   0x7941             LDRB     R1,[R0, #+5]
   \      0x1A4   0x0209             LSLS     R1,R1,#+8
   \      0x1A6   0x8261             STRH     R1,[R4, #+18]
    156                            PerioidTimeValue[7] += protocolBuf_ReplyCmd[6];
   \      0x1A8   0x7980             LDRB     R0,[R0, #+6]
   \      0x1AA   0x1808             ADDS     R0,R1,R0
   \      0x1AC   0x8260             STRH     R0,[R4, #+18]
    157                            if(PerioidTimeValue[7] > 1)
   \      0x1AE   0xB280             UXTH     R0,R0
   \      0x1B0   0x2801             CMP      R0,#+1
   \      0x1B2   0xDD06             BLE.N    ??moduleReplyCmd_u32_18
    158                            {     // if not one off cmd will start to remember the next wakeup time
    159                              tt_PerioidTime[7] = getSysCount() + PerioidTimeValue[7];                          //store time tick value
   \      0x1B4   0x....'....        BL       getSysCount
   \      0x1B8   0x8A62             LDRH     R2,[R4, #+18]
   \      0x1BA   0x....'....        BL       ?Subroutine1
    160                            }
    161                            break;   
    162                          }                
    163                        default:
    164                          break;
    165                      }
    166                    }
   \                     ??CrossCallReturnLabel_9: (+1)
   \      0x1BE   0xE9C4 0x0114      STRD     R0,R1,[R4, #+80]
    167                    if((protocolBuf_ReplyCmd = (unsigned char*) realloc(protocolBuf_ReplyCmd,1)) == NULL) reallocError++;  
   \                     ??moduleReplyCmd_u32_18: (+1)
   \      0x1C2   0x6DE0             LDR      R0,[R4, #+92]
   \      0x1C4   0x2101             MOVS     R1,#+1
   \      0x1C6   0x....'....        BL       realloc
   \      0x1CA   0x....'....        BL       ?Subroutine0
    168                    returnStage = CMDreply;
   \                     ??CrossCallReturnLabel_1: (+1)
   \      0x1CE   0x2002             MOVS     R0,#+2
    169                    break;
   \      0x1D0   0xE0E2             B.N      ??moduleReplyCmd_u32_5
    170                  }
    171                case CMDreply:
    172                  {
    173                    uint8_t CMDindex;
    174                    for(CMDindex = 0; CMDindex < (sizeof(PerioidTimeValue)/sizeof(PerioidTimeValue[0])); CMDindex++)
   \                     ??moduleReplyCmd_u32_3: (+1)
   \      0x1D2   0x....             LDR.N    R0,??DataTable8_2
   \      0x1D4   0x9001             STR      R0,[SP, #+4]
   \      0x1D6   0x2500             MOVS     R5,#+0
   \      0x1D8   0xF10D 0x0808      ADD      R8,SP,#+8
    175                    {
    176                      if((PerioidTimeValue[CMDindex] == 1) || ((getSysCount() >= tt_PerioidTime[CMDindex]) && ( PerioidTimeValue[CMDindex] != 0)))
   \                     ??moduleReplyCmd_u32_19: (+1)
   \      0x1DC   0xEB04 0x0745      ADD      R7,R4,R5, LSL #+1
   \      0x1E0   0xEB04 0x06C5      ADD      R6,R4,R5, LSL #+3
   \      0x1E4   0x88B8             LDRH     R0,[R7, #+4]
   \      0x1E6   0x2801             CMP      R0,#+1
   \      0x1E8   0xD00D             BEQ.N    ??moduleReplyCmd_u32_20
   \      0x1EA   0x....'....        BL       getSysCount
   \      0x1EE   0xE9D6 0x2306      LDRD     R2,R3,[R6, #+24]
   \      0x1F2   0x4299             CMP      R1,R3
   \      0x1F4   0xD301             BCC.N    ??moduleReplyCmd_u32_21
   \      0x1F6   0xD802             BHI.N    ??moduleReplyCmd_u32_22
   \      0x1F8   0x4290             CMP      R0,R2
   \                     ??moduleReplyCmd_u32_21: (+1)
   \      0x1FA   0xF0C0 0x80C6      BCC.W    ??moduleReplyCmd_u32_23
   \                     ??moduleReplyCmd_u32_22: (+1)
   \      0x1FE   0x88B8             LDRH     R0,[R7, #+4]
   \      0x200   0x2800             CMP      R0,#+0
   \      0x202   0xF000 0x80C2      BEQ.W    ??moduleReplyCmd_u32_23
    177                      {
    178                        unsigned int TxLen;
    179                        switch(CMDindex)
   \                     ??moduleReplyCmd_u32_20: (+1)
   \      0x206   0x2D07             CMP      R5,#+7
   \      0x208   0x....'....        LDR.W    R11,??DataTable8_3
   \      0x20C   0xF200 0x80B0      BHI.W    ??moduleReplyCmd_u32_24
   \      0x210   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??moduleReplyCmd_u32_0:
   \      0x214   0x04 0x16          DC8      0x4,0x16,0x27,0x3A

   \              0x27 0x3A
   \      0x218   0x4A 0x6F          DC8      0x4A,0x6F,0x8D,0x9F

   \              0x8D 0x9F
    180                        {
    181                          case 0:
    182                            { //Bus voltage request
    183                              uint16_t busVoltage = VBS_GetAvBusVoltage_V(PQD_MotorPowMeasM1.pVBS);
   \                     ??moduleReplyCmd_u32_25: (+1)
   \      0x21C   0x9A01             LDR      R2,[SP, #+4]
   \      0x21E   0x6850             LDR      R0,[R2, #+4]
   \      0x220   0x....'....        BL       VBS_GetAvBusVoltage_V
    184                              unsigned char busVoltageTx[] = {0x55, 0x02, 0x40, 0x00, 0x00, 0xff, 0xff, 0xCC, 0xCC};
   \      0x224   0x....             ADR.N    R2,?_0
   \      0x226   0xE892 0x4208      LDM      R2,{R3,R9,LR}
   \      0x22A   0xA902             ADD      R1,SP,#+8
    185                              TxLen = sizeof(busVoltageTx);
   \      0x22C   0x2209             MOVS     R2,#+9
   \      0x22E   0xE881 0x4208      STM      R1,{R3,R9,LR}
   \      0x232   0x9200             STR      R2,[SP, #+0]
    186                              busVoltageTx[5] = (unsigned char) ((busVoltage & 0xff00) >> 8);
    187                              busVoltageTx[6] = (unsigned char) busVoltage & 0xff;
   \      0x234   0xF88D 0x000E      STRB     R0,[SP, #+14]
   \      0x238   0x0A02             LSRS     R2,R0,#+8
   \      0x23A   0xF88D 0x200D      STRB     R2,[SP, #+13]
    188                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, busVoltageTx, &TxLen); 
   \      0x23E   0xE074             B.N      ??moduleReplyCmd_u32_26
    189                              break;
    190                            }
    191                          case 1:
    192                            { //fault status request
    193                              int16_t faultStatus = MC_GetOccurredFaultsMotor1();
   \                     ??moduleReplyCmd_u32_27: (+1)
   \      0x240   0x....'....        BL       MC_GetOccurredFaultsMotor1
    194                              unsigned char faultStatusTx[] = {0x55, 0x02, 0x41, 0x00, 0x00, 0xff, 0xff, 0xCC, 0xCC};
   \      0x244   0x....             ADR.N    R2,?_1
   \      0x246   0xE892 0x4208      LDM      R2,{R3,R9,LR}
   \      0x24A   0xA902             ADD      R1,SP,#+8
    195                              TxLen = sizeof(faultStatusTx);
   \      0x24C   0x2209             MOVS     R2,#+9
   \      0x24E   0xE881 0x4208      STM      R1,{R3,R9,LR}
   \      0x252   0x9200             STR      R2,[SP, #+0]
    196                              faultStatusTx[5] = (unsigned char) ((faultStatus & 0xff00) >> 8);
    197                              faultStatusTx[6] = (unsigned char) faultStatus & 0xff;
   \      0x254   0xF88D 0x000E      STRB     R0,[SP, #+14]
   \      0x258   0x0402             LSLS     R2,R0,#+16
   \      0x25A   0x1612             ASRS     R2,R2,#+24
   \      0x25C   0xF88D 0x200D      STRB     R2,[SP, #+13]
    198                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, faultStatusTx, &TxLen); 
   \      0x260   0xE063             B.N      ??moduleReplyCmd_u32_26
    199                              break;
    200                            }
    201                          case 2:
    202                            { //measured speed request
    203                              int16_t Speed = MC_GetMecSpeedAverageMotor1() * 6;
   \                     ??moduleReplyCmd_u32_28: (+1)
   \      0x262   0x....'....        BL       MC_GetMecSpeedAverageMotor1
    204                              unsigned char speedTx[] = {0x55, 0x02, 0x60, 0x00, 0x00, 0xff, 0xff, 0xCC, 0xCC};
   \      0x266   0xBF00             Nop
   \      0x268   0x....             ADR.N    R2,?_2
   \      0x26A   0x2106             MOVS     R1,#+6
   \      0x26C   0xE892 0x4208      LDM      R2,{R3,R9,LR}
   \      0x270   0xFB10 0xF101      SMULBB   R1,R0,R1
   \      0x274   0xA802             ADD      R0,SP,#+8
   \      0x276   0xE880 0x4208      STM      R0,{R3,R9,LR}
    205                              TxLen = sizeof(speedTx);
   \      0x27A   0x2009             MOVS     R0,#+9
   \      0x27C   0x9000             STR      R0,[SP, #+0]
    206                              speedTx[5] = (unsigned char) ((Speed & 0xff00) >> 8);
    207                              speedTx[6] = (unsigned char) Speed & 0xff;   
   \      0x27E   0xF88D 0x100E      STRB     R1,[SP, #+14]
   \      0x282   0x0408             LSLS     R0,R1,#+16
   \      0x284   0x1600             ASRS     R0,R0,#+24
   \      0x286   0xE061             B.N      ??moduleReplyCmd_u32_29
    208                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, speedTx, &TxLen); 
    209                              break;
    210                            }
    211                          case 3:
    212                            { //actual direction request
    213                              int16_t Direction = MC_GetImposedDirectionMotor1();
   \                     ??moduleReplyCmd_u32_30: (+1)
   \      0x288   0x....'....        BL       MC_GetImposedDirectionMotor1
    214                              unsigned char directionTx[] = {0x55, 0x02, 0x42, 0x00, 0x00, 0xff, 0xff, 0xCC, 0xCC};
   \      0x28C   0x....             ADR.N    R2,?_3
   \      0x28E   0xE892 0x4208      LDM      R2,{R3,R9,LR}
   \      0x292   0xA902             ADD      R1,SP,#+8
    215                              TxLen = sizeof(directionTx);
   \      0x294   0x2209             MOVS     R2,#+9
   \      0x296   0xE881 0x4208      STM      R1,{R3,R9,LR}
   \      0x29A   0x9200             STR      R2,[SP, #+0]
    216                              directionTx[5] = (unsigned char) ((Direction & 0xff00) >> 8);
    217                              directionTx[6] = (unsigned char) Direction & 0xff;   
   \      0x29C   0xF88D 0x000E      STRB     R0,[SP, #+14]
   \      0x2A0   0x1202             ASRS     R2,R0,#+8
   \      0x2A2   0xF88D 0x200D      STRB     R2,[SP, #+13]
    218                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, directionTx, &TxLen); 
   \      0x2A6   0xE040             B.N      ??moduleReplyCmd_u32_26
    219                              break;
    220                            }                  
    221                          case 4:
    222                            { //EE information request                   
    223                              int16_t Voltage = MC_GetPhaseVoltageAmplitudeMotor1();//RPa: do the necessary conversion either on the motor-side or the app-side
   \                     ??moduleReplyCmd_u32_31: (+1)
   \      0x2A8   0x....'....        BL       MC_GetPhaseVoltageAmplitudeMotor1
   \      0x2AC   0x4681             MOV      R9,R0
    224                              int16_t Current = MC_GetPhaseCurrentAmplitudeMotor1();//RPa: do the necessary conversion either on the motor-side or the app-side
   \      0x2AE   0x....'....        BL       MC_GetPhaseCurrentAmplitudeMotor1
   \      0x2B2   0x4682             MOV      R10,R0
    225                              int16_t Power = MPM_GetAvrgElMotorPowerW(&PQD_MotorPowMeasM1._super);
   \      0x2B4   0x4658             MOV      R0,R11
   \      0x2B6   0x....'....        BL       MPM_GetAvrgElMotorPowerW
   \      0x2BA   0x4683             MOV      R11,R0
    226                              unsigned char EETx[] = {0x55, 0x06, 0x4F, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xCC, 0xCC};
   \      0x2BC   0xF10D 0x0008      ADD.W    R0,SP,#+8
   \      0x2C0   0x....             ADR.N    R1,?_4
   \      0x2C2   0x2210             MOVS     R2,#+16
   \      0x2C4   0x....'....        BL       __aeabi_memcpy4
    227                              TxLen = sizeof(EETx);
   \      0x2C8   0x200D             MOVS     R0,#+13
    228                              EETx[5] = (unsigned char) ((Voltage & 0xff00) >> 8);
   \      0x2CA   0xEA4F 0x2129      ASR      R1,R9,#+8
   \      0x2CE   0x9000             STR      R0,[SP, #+0]
   \      0x2D0   0xF888 0x1005      STRB     R1,[R8, #+5]
    229                              EETx[6] = (unsigned char) Voltage & 0xff;  
    230                              EETx[7] = (unsigned char) ((Current & 0xff00) >> 8);
   \      0x2D4   0xEA4F 0x202A      ASR      R0,R10,#+8
    231                              EETx[8] = (unsigned char) Current & 0xff;
    232                              EETx[9] = (unsigned char) ((Power & 0xff00) >> 8);
   \      0x2D8   0xEA4F 0x212B      ASR      R1,R11,#+8
   \      0x2DC   0xF888 0x9006      STRB     R9,[R8, #+6]
   \      0x2E0   0xF888 0x0007      STRB     R0,[R8, #+7]
   \      0x2E4   0xF888 0xA008      STRB     R10,[R8, #+8]
   \      0x2E8   0xF888 0x1009      STRB     R1,[R8, #+9]
    233                              EETx[10] = (unsigned char) Power & 0xff;
   \      0x2EC   0xF888 0xB00A      STRB     R11,[R8, #+10]
    234                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, EETx, &TxLen); 
   \      0x2F0   0xE038             B.N      ??moduleReplyCmd_u32_32
    235                              break;
    236                            } 
    237                           case 5:
    238                            { //Thermo-mechanical information request
    239                              int16_t Torque = PQD_MotorPowMeasM1.pFOCVars->Iqd.q;
   \                     ??moduleReplyCmd_u32_33: (+1)
   \      0x2F2   0x9801             LDR      R0,[SP, #+4]
   \      0x2F4   0x6801             LDR      R1,[R0, #+0]
    240                              int16_t Temperature = NTC_GetAvTemp_C(pMCT->pTemperatureSensor);// RPa: update this call                  
   \      0x2F6   0x....             LDR.N    R0,??DataTable8_4
   \      0x2F8   0xF9B1 0x900C      LDRSH    R9,[R1, #+12]
   \      0x2FC   0x6AC0             LDR      R0,[R0, #+44]
   \      0x2FE   0x....'....        BL       NTC_GetAvTemp_C
    241                              unsigned char ThMETx[] = {0x55, 0x04, 0x6F, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xCC, 0xCC};
   \      0x302   0xBF00             Nop
   \      0x304   0x....             ADR.N    R2,?_5
   \      0x306   0xE892 0x4408      LDM      R2,{R3,R10,LR}
   \      0x30A   0xA902             ADD      R1,SP,#+8
    242                              TxLen = sizeof(ThMETx);
   \      0x30C   0x220B             MOVS     R2,#+11
   \      0x30E   0xE881 0x4408      STM      R1,{R3,R10,LR}
   \      0x312   0x9200             STR      R2,[SP, #+0]
    243                              ThMETx[5] = (unsigned char) ((Torque & 0xff00) >> 8);
    244                              ThMETx[6] = (unsigned char) Torque & 0xff;   
   \      0x314   0xF88D 0x900E      STRB     R9,[SP, #+14]
   \      0x318   0xEA4F 0x2229      ASR      R2,R9,#+8
   \      0x31C   0xF88D 0x200D      STRB     R2,[SP, #+13]
    245                              ThMETx[7] = (unsigned char) ((Temperature & 0xff00) >> 8);
    246                              ThMETx[8] = (unsigned char) Temperature & 0xff;  
   \      0x320   0xF88D 0x0010      STRB     R0,[SP, #+16]
   \      0x324   0x1202             ASRS     R2,R0,#+8
   \      0x326   0xF88D 0x200F      STRB     R2,[SP, #+15]
    247                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, ThMETx, &TxLen); 
   \                     ??moduleReplyCmd_u32_26: (+1)
   \      0x32A   0x466A             MOV      R2,SP
   \      0x32C   0xE01C             B.N      ??moduleReplyCmd_u32_34
    248                              break;
    249                            }  
    250                           case 6:
    251                            { //Motor Torque request
    252                              int16_t Torque = PQD_MotorPowMeasM1.pFOCVars->Iqd.q;         
   \                     ??moduleReplyCmd_u32_35: (+1)
   \      0x32E   0x9801             LDR      R0,[SP, #+4]
    253                              unsigned char TorqueTx[] = {0x55, 0x04, 0x61, 0x00, 0x00, 0xff, 0xff, 0xCC, 0xCC};
   \      0x330   0x....             ADR.N    R2,?_6
   \      0x332   0x6801             LDR      R1,[R0, #+0]
   \      0x334   0xF9B1 0x100C      LDRSH    R1,[R1, #+12]
   \      0x338   0xE892 0x4208      LDM      R2,{R3,R9,LR}
   \      0x33C   0xA802             ADD      R0,SP,#+8
   \      0x33E   0xE880 0x4208      STM      R0,{R3,R9,LR}
    254                              TxLen = sizeof(TorqueTx);
   \      0x342   0x2009             MOVS     R0,#+9
   \      0x344   0x9000             STR      R0,[SP, #+0]
    255                              TorqueTx[5] = (unsigned char) ((Torque & 0xff00) >> 8);
    256                              TorqueTx[6] = (unsigned char) Torque & 0xff;  
   \      0x346   0xF88D 0x100E      STRB     R1,[SP, #+14]
   \      0x34A   0x1208             ASRS     R0,R1,#+8
   \                     ??moduleReplyCmd_u32_29: (+1)
   \      0x34C   0xF88D 0x000D      STRB     R0,[SP, #+13]
    257                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, TorqueTx, &TxLen); 
   \      0x350   0xE008             B.N      ??moduleReplyCmd_u32_32
    258                              break;
    259                            } 
    260                           case 7:
    261                            { //HeartBeat Request     
    262                              unsigned char HeartBeatTx[] = {0x55, 0x04, 0x4E, 0x5A, 0xA5, 0xff, 0xff, 0xCC, 0xCC};// Just send 0x5AA5 to App-side and get a response
   \                     ??moduleReplyCmd_u32_36: (+1)
   \      0x352   0xBF00             Nop
   \      0x354   0x....             ADR.N    R1,?_7
   \      0x356   0xE891 0x400C      LDM      R1,{R2,R3,LR}
   \      0x35A   0xA802             ADD      R0,SP,#+8
   \      0x35C   0xE880 0x400C      STM      R0,{R2,R3,LR}
    263                              TxLen = sizeof(HeartBeatTx);
   \      0x360   0x2009             MOVS     R0,#+9
   \      0x362   0x9000             STR      R0,[SP, #+0]
    264                              RingBuf_WriteBlock((*usart2Control_ReplyCmd).seqMemTX_u32, HeartBeatTx, &TxLen); 
   \                     ??moduleReplyCmd_u32_32: (+1)
   \      0x364   0x466A             MOV      R2,SP
   \      0x366   0xA902             ADD      R1,SP,#+8
   \                     ??moduleReplyCmd_u32_34: (+1)
   \      0x368   0x6DA0             LDR      R0,[R4, #+88]
   \      0x36A   0x6900             LDR      R0,[R0, #+16]
   \      0x36C   0x....'....        BL       RingBuf_WriteBlock
    265                              break;
    266                            }                   
    267                          default:
    268                              break;
    269                        }  
    270                        if(PerioidTimeValue[CMDindex] == 1) 
   \                     ??moduleReplyCmd_u32_24: (+1)
   \      0x370   0x88B8             LDRH     R0,[R7, #+4]
   \      0x372   0x2801             CMP      R0,#+1
   \      0x374   0xD102             BNE.N    ??moduleReplyCmd_u32_37
    271                        {
    272                          PerioidTimeValue[CMDindex] = 0;
   \      0x376   0x2100             MOVS     R1,#+0
   \      0x378   0x80B9             STRH     R1,[R7, #+4]
   \      0x37A   0xE006             B.N      ??moduleReplyCmd_u32_23
    273                        }
    274                        else
    275                        {
    276                          tt_PerioidTime[CMDindex] = getSysCount() + PerioidTimeValue[CMDindex];                          //store  next time tick compare value
   \                     ??moduleReplyCmd_u32_37: (+1)
   \      0x37C   0x....'....        BL       getSysCount
   \      0x380   0x88BA             LDRH     R2,[R7, #+4]
   \      0x382   0x....'....        BL       ?Subroutine1
    277                        }
    278                      }
    279                    }
   \                     ??CrossCallReturnLabel_10: (+1)
   \      0x386   0xE9C6 0x0106      STRD     R0,R1,[R6, #+24]
   \                     ??moduleReplyCmd_u32_23: (+1)
   \      0x38A   0x1C6D             ADDS     R5,R5,#+1
   \      0x38C   0x2D08             CMP      R5,#+8
   \      0x38E   0xF4FF 0xAF25      BCC.W    ??moduleReplyCmd_u32_19
    280                    returnStage = RUN_APP ;
    281                    break;
    282                  }
    283                case IRQ_APP:
    284                  {
    285                    //if more than 1 driver interrupt attached to this APP
    286          //           uint8_t index = getProcessInfoIndex(interruptIdentfer);         //return Process index from processInfo array of the driver interrupt call, APP can response respectively
    287                    returnStage = RUN_APP;
   \                     ??moduleReplyCmd_u32_7: (+1)
   \      0x392   0x2001             MOVS     R0,#+1
    288                    break;
   \      0x394   0xE000             B.N      ??moduleReplyCmd_u32_5
    289                  }               
    290                case STOP_APP:
    291                  {
    292                    returnStage = INIT_APP;
    293                    break;
    294                  }
    295                default:
    296                  returnStage = STOP_APP;   
   \                     ??moduleReplyCmd_u32_6: (+1)
   \      0x396   0x20FF             MOVS     R0,#+255
    297              }
    298            return returnStage;
   \                     ??moduleReplyCmd_u32_5: (+1)
   \      0x398   0xB007             ADD      SP,SP,#+28
   \      0x39A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    299          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x1880             ADDS     R0,R0,R2
   \        0x4   0x4159             ADCS     R1,R1,R3
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB910             CBNZ.N   R0,??Subroutine0_0
   \        0x2   0x7821             LDRB     R1,[R4, #+0]
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   \                     ??Subroutine0_0: (+1)
   \        0x8   0x65E0             STR      R0,[R4, #+92]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     reallocError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     PQD_MotorPowMeasM1+0x10C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     PQD_MotorPowMeasM1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     MCT

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x55 0x02          DC8 85, 2, 64, 0, 0, 255, 255, 204, 204

   \              0x40 0x00    

   \              0x00 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x55 0x02          DC8 85, 2, 65, 0, 0, 255, 255, 204, 204

   \              0x41 0x00    

   \              0x00 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x55 0x02          DC8 85, 2, 96, 0, 0, 255, 255, 204, 204

   \              0x60 0x00    

   \              0x00 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x55 0x02          DC8 85, 2, 66, 0, 0, 255, 255, 204, 204

   \              0x42 0x00    

   \              0x00 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x55 0x06          DC8 85, 6, 79, 0, 0, 255, 255, 255, 255, 255, 255, 204, 204

   \              0x4F 0x00    

   \              0x00 0xFF    

   \              0xFF 0xFF    

   \              0xFF 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0xD                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x55 0x04          DC8 85, 4, 111, 0, 0, 255, 255, 255, 255, 204, 204

   \              0x6F 0x00    

   \              0x00 0xFF    

   \              0xFF 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0xB                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x55 0x04          DC8 85, 4, 97, 0, 0, 255, 255, 204, 204

   \              0x61 0x00    

   \              0x00 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0x9                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x55 0x04          DC8 85, 4, 78, 90, 165, 255, 255, 204, 204

   \              0x4E 0x5A    

   \              0xA5 0xFF    

   \              0xFF 0xCC    

   \              0xCC
   \        0x9                      DS8 3
    300          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   moduleReplyCmd_u32
        64   -> MC_GetImposedDirectionMotor1
        64   -> MC_GetMecSpeedAverageMotor1
        64   -> MC_GetOccurredFaultsMotor1
        64   -> MC_GetPhaseCurrentAmplitudeMotor1
        64   -> MC_GetPhaseVoltageAmplitudeMotor1
        64   -> MPM_GetAvrgElMotorPowerW
        64   -> NTC_GetAvTemp_C
        64   -> RingBuf_GetUsedNumOfElements
        64   -> RingBuf_Observe
        64   -> RingBuf_ReadBlock
        64   -> RingBuf_WriteBlock
        64   -> VBS_GetAvBusVoltage_V
        64   -> __aeabi_memcpy4
        64   -> getProcessInfoIndex
        64   -> getSysCount
        64   -> realloc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
      12  ?Subroutine0
       8  ?Subroutine1
      12  ?_0
      12  ?_1
      12  ?_2
      12  ?_3
      16  ?_4
      12  ?_5
      12  ?_6
      12  ?_7
     926  moduleReplyCmd_u32
       4  pMCT
      96  reallocError
          PerioidTimeValue
          tt_PerioidTime
          usart2Control_ReplyCmd
          protocolBuf_ReplyCmd

 
   100 bytes in section .data
 1'066 bytes in section .text
 
 1'066 bytes of CODE memory
   100 bytes of DATA memory

Errors: none
Warnings: none
