###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:44
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\regular_conversion_manager.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW75A3.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\regular_conversion_manager.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\regular_conversion_manager.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\regular_conversion_manager.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Src\regular_conversion_manager.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    regular_conversion_manager.c
      5            * @author  Motor Control SDK Team, ST Microelectronics
      6            * @brief   This file provides firmware functions that implement the following features
      7            *          of the regular_conversion_manager component of the Motor Control SDK:
      8            *           Register conversion with or without callback
      9            *           Execute regular conv directly from Temperature and VBus sensors
     10            *           Execute user regular conversion scheduled by medium frequency task
     11            *           Manage user conversion state machine
     12            *           +
     13            *           +
     14            *
     15            ******************************************************************************
     16            * @attention
     17            *
     18            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     19            * All rights reserved.</center></h2>
     20            *
     21            * This software component is licensed by ST under Ultimate Liberty license
     22            * SLA0044, the "License"; You may not use this file except in compliance with
     23            * the License. You may obtain a copy of the License at:
     24            *                             www.st.com/SLA0044
     25            *
     26            ******************************************************************************
     27            */
     28          
     29          /* Includes ------------------------------------------------------------------*/
     30          #include "regular_conversion_manager.h"
     31          #include "mc_config.h"
     32          
     33          /** @addtogroup MCSDK
     34            * @{
     35            */
     36          
     37          /** @defgroup RCM Regular Conversion Manager 
     38            * @brief Regular Conversion Manager component of the Motor Control SDK
     39            *
     40            * MotorControl SDK makes an extensive usage of ADCs. Some conversions are timing critical
     41            * like current reading, and some have less constraints. If an ADC offers both Injected and Regular,
     42            * channels, critical conversions will be systematically done on Injected channels, because they 
     43            * interrupt any ongoing regular conversion so as to be executed without delay.
     44            * Others conversions, mainly Bus voltage, and Temperature sensing are performed with regular channels.
     45            * If users wants to perform ADC conversions with an ADC already used by MC SDK, they must use regular
     46            * conversions. It is forbidden to use Injected channel on an ADC that is already in use for current reading.
     47            * As usera and MC-SDK may share ADC regular scheduler, this component intents to manage all the 
     48            * regular conversions.
     49            * 
     50            * If users wants to execute their own conversion, they first have to register it through the 
     51            * RCM_RegisterRegConv_WithCB() or RCM_RegisterRegConv() APIs. Multiple conversions can be registered, 
     52            * but only one can be scheduled at a time .
     53            *
     54            * A requested user regular conversion will be executed by the medium frequency task after the 
     55            * MC-SDK regular safety conversions: Bus voltage and Temperature.
     56            *
     57            * If a callback is registered, particular care must be taken with the code executed inside the CB.
     58            * The callback code is executed under Medium frequency task IRQ context (Systick).
     59            *
     60            * If the Users do not register a callback, they must poll the RCM state machine to know if
     61            * a conversion is ready to be read, scheduled, or free to be scheduled. This is performed through 
     62            * the RCM_GetUserConvState() API.
     63            *
     64            * If the state is RCM_USERCONV_IDLE, a conversion is ready to be scheduled.
     65            * if a conversion is already scheduled, the returned value is RCM_USERCONV_REQUESTED.
     66            * if a conversion is ready to be read, the returned value is RCM_USERCONV_EOC.
     67            * In RCM_USERCONV_EOC state, a call to RCM_GetUserConv will consume the value, and set the state machine back
     68            * to RCM_USERCONV_IDLE state. It implies that a second call without new conversion performed,
     69            * will send back 0xffff which is an error value meaning that the data is not available.
     70            * If a conversion request is executed, but the previous conversion has not been completed, nor consumed, 
     71            * the request is discarded and the RCM_RequestUserConv return false.
     72            * 
     73            * If a callback is registered, the data read is sent back to the callback parameters, and therefor consumed.
     74            * @{
     75            */
     76          
     77          /* Private typedef -----------------------------------------------------------*/
     78          
     79          typedef struct 
     80          {
     81            RCM_exec_cb_t cb;
     82            void * data;
     83          } RCM_callback_t;
     84          
     85          /* Private defines -----------------------------------------------------------*/
     86          /**
     87            * @brief Number of regular conversion allowed By default.
     88            *  
     89            * In single drive configuration, it is defined to 4. 2 of them are consumed by 
     90            * Bus voltage and temperature reading. This leaves 2 handles available for 
     91            * user conversions
     92            *
     93            * In dual drives configuration, it is defined to 6. 2 of them are consumed by 
     94            * Bus voltage and temperature reading for each motor. This leaves 2 handles 
     95            * available for user conversion.
     96            *
     97            * Defined to 4 here. 
     98            */
     99          #define RCM_MAX_CONV  4 
    100          
    101          /* Global variables ----------------------------------------------------------*/
    102          

   \                                 In section .bss, align 4
    103          RegConv_t * RCM_handle_array [RCM_MAX_CONV];
    104          RCM_callback_t RCM_CB_array [RCM_MAX_CONV];
    105          
    106          uint8_t RCM_UserConvHandle;
   \                     RCM_UserConvHandle:
   \        0x0                      DS8 1
    107          uint16_t RCM_UserConvValue;
    108          RCM_UserConvState_t RCM_UserConvState;
   \                     RCM_UserConvState:
   \        0x1                      DS8 1
   \                     RCM_UserConvValue:
   \        0x2                      DS8 2
   \                     RCM_CB_array:
   \        0x4                      DS8 32
   \                     RCM_handle_array:
   \       0x24                      DS8 16
    109          
    110          /* Private function prototypes -----------------------------------------------*/
    111          
    112          /* Private functions ---------------------------------------------------------*/
    113          
    114          /**
    115            * @brief  Registers a regular conversion, and attaches a callback.
    116            * 
    117            * This function registers a regular ADC conversion that can be later scheduled for execution. It
    118            * returns a handle that uniquely identifies the conversion. This handle is used in the other API
    119            * of the Regular Converion Manager to reference the registered conversion.
    120            * 
    121            * A regular conversion is defined by an ADC + ADC channel pair. If a registration already exists 
    122            * for the requested ADC + ADC channel pair, the same handle will be reused.
    123            *
    124            * The regular conversion is registered along with a callback that is executed each time the
    125            * conversion has completed. The callback is invoked with two parameters:
    126            *
    127            * - the handle of the regular conversion
    128            * - a data pointer, supplied by uthe users at registration time.
    129            * 
    130            * The registration may fail if there is no space left for additional conversions. The 
    131            * maximum number of regular conversion that can be registered is defined by #RCM_MAX_CONV.
    132            *  
    133            * @note   Users who do not want a callback to be executed at the end of the conversion, 
    134            *         should use RCM_RegisterRegConv() instead.
    135            *
    136            * @param  regConv Pointer to the regular conversion parameters. 
    137            *         Contains ADC, Channel and sampling time to be used.
    138            *
    139            * @param  fctCB Function called once the regular conversion is executed.
    140            *
    141            * @param  data Used to save a user context. this parameter will be send back by 
    142            *               the fctCB function. @b Note: This parameter can be NULL if not used.
    143            *
    144            *  @retval the handle of the registered conversion or 255 if the registration failed
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          uint8_t RCM_RegisterRegConv_WithCB (RegConv_t * regConv, RCM_exec_cb_t fctCB, void *data)
    147          {
   \                     RCM_RegisterRegConv_WithCB: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
    148            uint8_t handle;
    149            handle = RCM_RegisterRegConv(regConv);
   \        0x6   0x....'....        BL       RCM_RegisterRegConv
    150            if (handle < RCM_MAX_CONV) 
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xDA04             BGE.N    ??RCM_RegisterRegConv_WithCB_0
    151            {
    152              RCM_CB_array [handle].cb = fctCB;
   \        0xE   0x....             LDR.N    R1,??DataTable6
   \       0x10   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   \       0x14   0x604C             STR      R4,[R1, #+4]
    153              RCM_CB_array [handle].data = data;
   \       0x16   0x608D             STR      R5,[R1, #+8]
    154            }
    155            return handle;
   \                     ??RCM_RegisterRegConv_WithCB_0: (+1)
   \       0x18   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    156          }  
    157            
    158          /**
    159            * @brief  Registers a regular conversion.
    160            * 
    161            * This function registers a regular ADC conversion that can be later scheduled for execution. It
    162            * returns a handle that uniquely identifies the conversion. This handle is used in the other API
    163            * of the Regular Converion Manager to reference the registered conversion.
    164            * 
    165            * A regular conversion is defined by an ADC + ADC channel pair. If a registration already exists 
    166            * for the requested ADC + ADC channel pair, the same handle will be reused.
    167            *
    168            * The registration may fail if there is no space left for additional conversions. The 
    169            * maximum number of regular conversion that can be registered is defined by #RCM_MAX_CONV.
    170            *  
    171            * @note   Users who do not want a callback to be executed at the end of the conversion, 
    172            *         should use RCM_RegisterRegConv() instead.
    173            *
    174            * @param  regConv Pointer to the regular conversion parameters. 
    175            *         Contains ADC, Channel and sampling time to be used.
    176            *
    177            *  @retval the handle of the registered conversion or 255 if the registration failed
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          uint8_t RCM_RegisterRegConv(RegConv_t * regConv)
    180          {
   \                     RCM_RegisterRegConv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4601             MOV      R1,R0
    181            uint8_t handle=255;
   \        0x4   0x22FF             MOVS     R2,#+255
    182            uint8_t i=0;
   \        0x6   0x790E             LDRB     R6,[R1, #+4]
   \        0x8   0x....             LDR.N    R4,??DataTable6
   \        0xA   0x2300             MOVS     R3,#+0
    183            
    184              /* Parse the array to be sure that same 
    185               * conversion does not already exist*/
    186              while (i < RCM_MAX_CONV)
    187              { 
    188                if (  RCM_handle_array [i] == 0 && handle > RCM_MAX_CONV)  
   \                     ??RCM_RegisterRegConv_0: (+1)
   \        0xC   0xEB04 0x0083      ADD      R0,R4,R3, LSL #+2
   \       0x10   0x6A40             LDR      R0,[R0, #+36]
   \       0x12   0xB918             CBNZ.N   R0,??RCM_RegisterRegConv_1
   \       0x14   0x2A04             CMP      R2,#+4
   \       0x16   0xDD0A             BLE.N    ??RCM_RegisterRegConv_2
   \       0x18   0x461A             MOV      R2,R3
   \       0x1A   0xE008             B.N      ??RCM_RegisterRegConv_2
    189                {
    190                  handle = i; /* First location available, but still looping to check that this config does not already exist*/ 
    191                }
    192                /* Ticket 64042 : If RCM_handle_array [i] is null access to data member will cause Memory Fault. */
    193                if (  RCM_handle_array [i] != 0 )
    194                {
    195                  if ((RCM_handle_array [i]->channel == regConv->channel) && 
    196                      (RCM_handle_array [i]->regADC == regConv->regADC))
   \                     ??RCM_RegisterRegConv_1: (+1)
   \       0x1C   0x7905             LDRB     R5,[R0, #+4]
   \       0x1E   0x42B5             CMP      R5,R6
   \       0x20   0xBF02             ITTT     EQ
   \       0x22   0x6800             LDREQ    R0,[R0, #+0]
   \       0x24   0x680D             LDREQ    R5,[R1, #+0]
   \       0x26   0x42A8             CMPEQ    R0,R5
   \       0x28   0xBF04             ITT      EQ
   \       0x2A   0x461A             MOVEQ    R2,R3
   \       0x2C   0x2304             MOVEQ    R3,#+4
    197                    {
    198                     handle =i; /* Reuse the same handle */
    199                     i = RCM_MAX_CONV; /* we can skip the rest of the loop*/
    200                    }
    201                }
    202                i++;
   \                     ??RCM_RegisterRegConv_2: (+1)
   \       0x2E   0x1C5B             ADDS     R3,R3,#+1
   \       0x30   0xB2DB             UXTB     R3,R3
    203              }    
   \       0x32   0x2B04             CMP      R3,#+4
   \       0x34   0xDBEA             BLT.N    ??RCM_RegisterRegConv_0
    204              if (handle < RCM_MAX_CONV )
   \       0x36   0x4610             MOV      R0,R2
   \       0x38   0x2804             CMP      R0,#+4
   \       0x3A   0xDA4E             BGE.N    ??RCM_RegisterRegConv_3
    205              {    
    206                RCM_handle_array [handle] = regConv;
   \       0x3C   0xF104 0x0324      ADD      R3,R4,#+36
    207                RCM_CB_array [handle].cb = NULL; /* if a previous callback was attached, it is cleared*/
   \       0x40   0x1D24             ADDS     R4,R4,#+4
   \       0x42   0xF843 0x1020      STR      R1,[R3, R0, LSL #+2]
   \       0x46   0x2500             MOVS     R5,#+0
   \       0x48   0xF844 0x5030      STR      R5,[R4, R0, LSL #+3]
    208                if (LL_ADC_IsEnabled(regConv->regADC) == 0 )
   \       0x4C   0x680B             LDR      R3,[R1, #+0]
   \       0x4E   0x6898             LDR      R0,[R3, #+8]
   \       0x50   0x07C0             LSLS     R0,R0,#+31
   \       0x52   0xD41A             BMI.N    ??RCM_RegisterRegConv_4
    209                {
    210                 LL_ADC_DisableIT_EOC(regConv->regADC);
   \       0x54   0x685C             LDR      R4,[R3, #+4]
   \       0x56   0xF024 0x0404      BIC      R4,R4,#0x4
   \       0x5A   0x605C             STR      R4,[R3, #+4]
    211                 LL_ADC_ClearFlag_EOC(regConv->regADC);
   \       0x5C   0x2004             MOVS     R0,#+4
   \       0x5E   0x6018             STR      R0,[R3, #+0]
    212                 LL_ADC_DisableIT_JEOC(regConv->regADC);
    213                 LL_ADC_ClearFlag_JEOC(regConv->regADC);
   \       0x60   0x2520             MOVS     R5,#+32
   \       0x62   0x685C             LDR      R4,[R3, #+4]
    214          
    215                  LL_ADC_StartCalibration( regConv->regADC, LL_ADC_SINGLE_ENDED );
   \       0x64   0x....             LDR.N    R0,??DataTable6_1  ;; 0x3fffffc0
   \       0x66   0xF024 0x0420      BIC      R4,R4,#0x20
   \       0x6A   0x605C             STR      R4,[R3, #+4]
   \       0x6C   0x601D             STR      R5,[R3, #+0]
   \       0x6E   0x689C             LDR      R4,[R3, #+8]
   \       0x70   0x4004             ANDS     R4,R0,R4
   \       0x72   0xF044 0x4400      ORR      R4,R4,#0x80000000
   \       0x76   0x609C             STR      R4,[R3, #+8]
    216                  while ( LL_ADC_IsCalibrationOnGoing( regConv->regADC ) )  
   \                     ??RCM_RegisterRegConv_5: (+1)
   \       0x78   0x6898             LDR      R0,[R3, #+8]
   \       0x7A   0x0FC0             LSRS     R0,R0,#+31
   \       0x7C   0xD1FC             BNE.N    ??RCM_RegisterRegConv_5
    217                  { }
    218                  LL_ADC_Enable( regConv->regADC );
   \       0x7E   0x689C             LDR      R4,[R3, #+8]
   \       0x80   0x....             LDR.N    R0,??DataTable6_2  ;; 0x7fffffc0
   \       0x82   0x4004             ANDS     R4,R0,R4
   \       0x84   0xF044 0x0401      ORR      R4,R4,#0x1
   \       0x88   0x609C             STR      R4,[R3, #+8]
    219                  
    220                }
    221                else 
    222                {
    223                }
    224                /* reset regular conversion sequencer length set by cubeMX */
    225                LL_ADC_REG_SetSequencerLength( regConv->regADC, LL_ADC_REG_SEQ_SCAN_DISABLE );
   \                     ??RCM_RegisterRegConv_4: (+1)
   \       0x8A   0x6B18             LDR      R0,[R3, #+48]
   \       0x8C   0x0900             LSRS     R0,R0,#+4
   \       0x8E   0x0100             LSLS     R0,R0,#+4
   \       0x90   0x6318             STR      R0,[R3, #+48]
    226                /* configure the sampling time (should already be configured by for non user conversions)*/
    227                LL_ADC_SetChannelSamplingTime ( regConv->regADC, __LL_ADC_DECIMAL_NB_TO_CHANNEL(regConv->channel) ,regConv->samplingTime);
   \       0x92   0x7908             LDRB     R0,[R1, #+4]
   \       0x94   0x4604             MOV      R4,R0
   \       0x96   0x2C0A             CMP      R4,#+10
   \       0x98   0x4605             MOV      R5,R0
   \       0x9A   0xD205             BCS.N    ??RCM_RegisterRegConv_6
   \       0x9C   0x2602             MOVS     R6,#+2
   \       0x9E   0xFA06 0xF000      LSL      R0,R6,R0
   \       0xA2   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xA6   0xE007             B.N      ??RCM_RegisterRegConv_7
   \                     ??RCM_RegisterRegConv_6: (+1)
   \       0xA8   0x2602             MOVS     R6,#+2
   \       0xAA   0xFA06 0xF000      LSL      R0,R6,R0
   \       0xAE   0x3C0A             SUBS     R4,R4,#+10
   \       0xB0   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xB4   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \                     ??RCM_RegisterRegConv_7: (+1)
   \       0xB8   0x0DC4             LSRS     R4,R0,#+23
   \       0xBA   0x3314             ADDS     R3,R3,#+20
   \       0xBC   0xF004 0x0404      AND      R4,R4,#0x4
   \       0xC0   0x6889             LDR      R1,[R1, #+8]
   \       0xC2   0x18E3             ADDS     R3,R4,R3
   \       0xC4   0x0D00             LSRS     R0,R0,#+20
   \       0xC6   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0xCA   0x681C             LDR      R4,[R3, #+0]
   \       0xCC   0x2507             MOVS     R5,#+7
   \       0xCE   0x4085             LSLS     R5,R5,R0
   \       0xD0   0x43AC             BICS     R4,R4,R5
   \       0xD2   0xFA01 0xF000      LSL      R0,R1,R0
   \       0xD6   0x4320             ORRS     R0,R0,R4
   \       0xD8   0x6018             STR      R0,[R3, #+0]
    228              }
    229              else
    230              {
    231                /* Nothing to do handle is already set to error value : 255 */
    232              }
    233            return handle;
   \                     ??RCM_RegisterRegConv_3: (+1)
   \       0xDA   0x4610             MOV      R0,R2
   \       0xDC   0xBD70             POP      {R4-R6,PC}       ;; return
    234          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xEA40 0x6085      ORR      R0,R0,R5, LSL #+26
   \        0x4   0xEB04 0x0444      ADD      R4,R4,R4, LSL #+1
   \        0x8   0xEA40 0x5004      ORR      R0,R0,R4, LSL #+20
   \        0xC   0x4770             BX       LR
    235          
    236          /*
    237           * This function is used to read the result of a regular conversion.
    238           * This function polls on the ADC end of conversion.
    239           * As ADC have injected channels for currents sensing, 
    240           * There is no issue to execute regular conversion asynchronously.
    241           *
    242           * NOTE: This function is not part of the public API and users should not call it. 
    243           */

   \                                 In section .text, align 2, keep-with-next
    244          uint16_t RCM_ExecRegularConv (uint8_t handle)
    245          {
   \                     RCM_ExecRegularConv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    246            uint16_t retVal;
    247           
    248            LL_ADC_REG_SetSequencerRanks( RCM_handle_array[handle]->regADC,
    249                                          LL_ADC_REG_RANK_1,
    250                                          __LL_ADC_DECIMAL_NB_TO_CHANNEL( RCM_handle_array[handle]->channel ) );
   \        0x2   0x....             LDR.N    R1,??DataTable6
   \        0x4   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0x8   0x2202             MOVS     R2,#+2
   \        0xA   0x6A41             LDR      R1,[R0, #+36]
   \        0xC   0x7908             LDRB     R0,[R1, #+4]
   \        0xE   0x4082             LSLS     R2,R2,R0
   \       0x10   0x280A             CMP      R0,#+10
   \       0x12   0xEA42 0x6280      ORR      R2,R2,R0, LSL #+26
   \       0x16   0xD204             BCS.N    ??RCM_ExecRegularConv_0
   \       0x18   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \       0x1C   0xEA42 0x5200      ORR      R2,R2,R0, LSL #+20
   \       0x20   0xE006             B.N      ??RCM_ExecRegularConv_1
   \                     ??RCM_ExecRegularConv_0: (+1)
   \       0x22   0x380A             SUBS     R0,R0,#+10
   \       0x24   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \       0x28   0xEA42 0x5200      ORR      R2,R2,R0, LSL #+20
   \       0x2C   0xF042 0x7200      ORR      R2,R2,#0x2000000
   \                     ??RCM_ExecRegularConv_1: (+1)
   \       0x30   0x6808             LDR      R0,[R1, #+0]
   \       0x32   0xF850 0x3F30      LDR      R3,[R0, #+48]!
   \       0x36   0x0D12             LSRS     R2,R2,#+20
   \       0x38   0xF423 0x63F8      BIC      R3,R3,#0x7C0
   \       0x3C   0xF402 0x62F8      AND      R2,R2,#0x7C0
   \       0x40   0x431A             ORRS     R2,R2,R3
   \       0x42   0x6002             STR      R2,[R0, #+0]
    251          
    252            LL_ADC_REG_ReadConversionData12( RCM_handle_array[handle]->regADC );
    253          
    254              LL_ADC_REG_StartConversion( RCM_handle_array[handle]->regADC );
   \       0x44   0x....             LDR.N    R0,??DataTable6_2  ;; 0x7fffffc0
   \       0x46   0x680A             LDR      R2,[R1, #+0]
   \       0x48   0x6C13             LDR      R3,[R2, #+64]
   \       0x4A   0x6894             LDR      R4,[R2, #+8]
   \       0x4C   0x4004             ANDS     R4,R0,R4
   \       0x4E   0xF044 0x0404      ORR      R4,R4,#0x4
   \       0x52   0x6094             STR      R4,[R2, #+8]
   \       0x54   0x6808             LDR      R0,[R1, #+0]
    255            /* Wait until end of regular conversion */
    256            while ( LL_ADC_IsActiveFlag_EOC( RCM_handle_array[handle]->regADC ) == 0u ) {}
   \                     ??RCM_ExecRegularConv_2: (+1)
   \       0x56   0x6802             LDR      R2,[R0, #+0]
   \       0x58   0x0752             LSLS     R2,R2,#+29
   \       0x5A   0xD5FC             BPL.N    ??RCM_ExecRegularConv_2
    257            retVal = LL_ADC_REG_ReadConversionData12( RCM_handle_array[handle]->regADC );   
   \       0x5C   0x6C00             LDR      R0,[R0, #+64]
    258          return retVal;
   \       0x5E   0xB280             UXTH     R0,R0
   \       0x60   0xBD10             POP      {R4,PC}          ;; return
    259          }
    260          
    261          /**
    262           * @brief Schedules a regular conversion for execution.
    263           *  
    264           * This function requests the execution of the user-defined regular conversion identified
    265           * by @p handle. All user defined conversion requests must be performed inside routines with the
    266           * same priority level. If a previous regular conversion request is pending this function has no 
    267           * effect, for this reason is better to call RCM_GetUserConvState() and check if the state is 
    268           * #RCM_USERCONV_IDLE before calling RCM_RequestUserConv().
    269           *
    270           * @param  handle used for the user conversion.
    271           *
    272           * @return true if the regular conversion could be scheduled and false otherwise.
    273           */

   \                                 In section .text, align 2, keep-with-next
    274          bool RCM_RequestUserConv(uint8_t handle)
    275          {
    276            bool retVal = false;
    277            if (RCM_UserConvState == RCM_USERCONV_IDLE)
   \                     RCM_RequestUserConv: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable6
   \        0x2   0x7859             LDRB     R1,[R3, #+1]
   \        0x4   0x4602             MOV      R2,R0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xB911             CBNZ.N   R1,??RCM_RequestUserConv_0
    278            {
    279              RCM_UserConvHandle = handle;
    280              /* must be done last so that RCM_UserConvHandle already has the right value */
    281              RCM_UserConvState = RCM_USERCONV_REQUESTED;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x701A             STRB     R2,[R3, #+0]
   \        0xE   0x7058             STRB     R0,[R3, #+1]
    282              retVal = true;
    283            }
    284            return retVal;
   \                     ??RCM_RequestUserConv_0: (+1)
   \       0x10   0x4770             BX       LR               ;; return
    285          }
    286          
    287          /**
    288           * @brief  Returns the last user-defined regular conversion that was executed.
    289           *
    290           * This function returns a valid result if the state returned by
    291           * RCM_GetUserConvState is #RCM_USERCONV_EOC.
    292           *
    293           * @retval uint16_t The converted value or 0xFFFF in case of conversion error.
    294           */

   \                                 In section .text, align 2, keep-with-next
    295          uint16_t RCM_GetUserConv(void)
    296          {
    297            uint16_t hRetVal = 0xFFFFu;
    298            if (RCM_UserConvState == RCM_USERCONV_EOC)
   \                     RCM_GetUserConv: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable6
   \        0x2   0x784A             LDRB     R2,[R1, #+1]
   \        0x4   0x2A02             CMP      R2,#+2
   \        0x6   0xF64F 0x70FF      MOVW     R0,#+65535
   \        0xA   0xD102             BNE.N    ??RCM_GetUserConv_0
    299            {
    300              hRetVal = RCM_UserConvValue;
   \        0xC   0x8848             LDRH     R0,[R1, #+2]
    301              RCM_UserConvState = RCM_USERCONV_IDLE;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x704A             STRB     R2,[R1, #+1]
    302            }
    303            return hRetVal;
   \                     ??RCM_GetUserConv_0: (+1)
   \       0x12   0x4770             BX       LR               ;; return
    304          }
    305          
    306          /*
    307           *  This function must be scheduled by mc_task.
    308           *  It executes the current user conversion that has been selected by the 
    309           *  latest call to RCM_RequestUserConv
    310           *
    311           * NOTE: This function is not part of the public API and users should not call it. 
    312           */

   \                                 In section .text, align 2, keep-with-next
    313          void RCM_ExecUserConv ()
    314          {
   \                     RCM_ExecUserConv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    315            if (RCM_UserConvState == RCM_USERCONV_REQUESTED)
   \        0x2   0x....             LDR.N    R4,??DataTable6
   \        0x4   0x7861             LDRB     R1,[R4, #+1]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD114             BNE.N    ??RCM_ExecUserConv_0
    316            {
    317              RCM_UserConvValue = RCM_ExecRegularConv (RCM_UserConvHandle);
   \        0xA   0x7820             LDRB     R0,[R4, #+0]
   \        0xC   0x....'....        BL       RCM_ExecRegularConv
    318              RCM_UserConvState = RCM_USERCONV_EOC;
    319              if (RCM_CB_array [RCM_UserConvHandle].cb != NULL)
   \       0x10   0x7823             LDRB     R3,[R4, #+0]
   \       0x12   0x8060             STRH     R0,[R4, #+2]
   \       0x14   0x2102             MOVS     R1,#+2
   \       0x16   0x7061             STRB     R1,[R4, #+1]
   \       0x18   0xEB04 0x05C3      ADD      R5,R4,R3, LSL #+3
   \       0x1C   0x6869             LDR      R1,[R5, #+4]
   \       0x1E   0xB149             CBZ.N    R1,??RCM_ExecUserConv_0
    320              {
    321                RCM_UserConvState = RCM_USERCONV_IDLE;
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x7062             STRB     R2,[R4, #+1]
    322                RCM_CB_array [RCM_UserConvHandle].cb (RCM_UserConvHandle, RCM_UserConvValue ,RCM_CB_array [RCM_UserConvHandle].data);
   \       0x24   0x4601             MOV      R1,R0
   \       0x26   0x4618             MOV      R0,R3
   \       0x28   0x68AA             LDR      R2,[R5, #+8]
   \       0x2A   0x686B             LDR      R3,[R5, #+4]
   \       0x2C   0xB001             ADD      SP,SP,#+4
   \       0x2E   0xE8BD 0x4030      POP      {R4,R5,LR}
   \       0x32   0x4718             BX       R3
    323              }
    324            }
    325          }
   \                     ??RCM_ExecUserConv_0: (+1)
   \       0x34   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    326          
    327          /**
    328           * @brief  Returns the status of the last requested regular conversion.
    329           *
    330           * It can be one of the following values:
    331           
    332           * - UDRC_STATE_IDLE no regular conversion request pending.
    333           * - UDRC_STATE_REQUESTED regular conversion has been requested and not completed.
    334           * - UDRC_STATE_EOC regular conversion has been completed but not readed from the user.
    335           *
    336           * @retval The state of the last user-defined regular conversion.
    337           */

   \                                 In section .text, align 2, keep-with-next
    338          RCM_UserConvState_t RCM_GetUserConvState(void)
    339          {
    340            return RCM_UserConvState;
   \                     RCM_GetUserConvState: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable6
   \        0x2   0x7840             LDRB     R0,[R0, #+1]
   \        0x4   0x4770             BX       LR               ;; return
    341          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     RCM_UserConvHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x3FFF'FFC0        DC32     0x3fffffc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x7FFF'FFC0        DC32     0x7fffffc0
    342          
    343          /**
    344            * @}
    345            */
    346          
    347          /**
    348            * @}
    349            */
    350          
    351          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
    352          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RCM_ExecRegularConv
      16   RCM_ExecUserConv
         0   -- Indirect call
        16   -> RCM_ExecRegularConv
       0   RCM_GetUserConv
       0   RCM_GetUserConvState
      16   RCM_RegisterRegConv
      16   RCM_RegisterRegConv_WithCB
        16   -> RCM_RegisterRegConv
       0   RCM_RequestUserConv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
      14  ?Subroutine0
      98  RCM_ExecRegularConv
      54  RCM_ExecUserConv
      20  RCM_GetUserConv
       6  RCM_GetUserConvState
     222  RCM_RegisterRegConv
      26  RCM_RegisterRegConv_WithCB
      18  RCM_RequestUserConv
      52  RCM_UserConvHandle
          RCM_UserConvState
          RCM_UserConvValue
          RCM_CB_array
          RCM_handle_array

 
  52 bytes in section .bss
 470 bytes in section .text
 
 470 bytes of CODE memory
  52 bytes of DATA memory

Errors: none
Warnings: none
