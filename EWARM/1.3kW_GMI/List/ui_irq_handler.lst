###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:15
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\ui_irq_handler.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW611A.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\ui_irq_handler.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\ui_irq_handler.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\ui_irq_handler.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\UILibrary\Src\ui_irq_handler.c
      1          /**
      2            ******************************************************************************
      3            * @file    ui_irq_handler.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides firmware functions that implement the UI IRQ Handler
      6            *          component of the Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "ui_irq_handler.h"
     24          #include "mc_type.h"
     25          
     26          
     27          /** @addtogroup MCSDK
     28            * @{
     29            */
     30          
     31          /**
     32           * @addtogroup MCUI
     33           * @{
     34           */
     35          
     36          /** @defgroup UI_IRQ_HANDLER MC IRQ Handler Component
     37            * @brief Performs registration and execution of Interrupts handlers for the UI
     38            *
     39            *  This component is a temporary work around allowing to use the former IRQ Handler
     40            * registration mechanism with both the old Classes and the new Components.
     41            *
     42            *  The former mechanism is defined in the UIIRQHandlerClass and is basically playing
     43            * two roles.
     44            *
     45            *  The first one is to register an Object and a method of that object to be executed
     46            * when an given interrupt occurs. Interrupt sources are identified by a number; 1
     47            * such sources are defined:
     48            *
     49            * - #UI_IRQ_USART
     50            *
     51            *  The second is to provide a function that executes the Interrupt handler
     52            * registered for a given interrupt source.
     53            *
     54            *  The implementation of the UIIRQHandlerClass mandated that the first field of the
     55            * structure of the registered Object be a pointer on the interrupt handling function to
     56            * execute.
     57            *
     58            *  This constraint is unacceptable for Components and this is the reason why
     59            * this work-around is proposed.
     60            *
     61            *  It is only a work around as the actual interrupt handling method to be used
     62            * on the 5.0.0 onwards will rely on Cube FW mechanisms and is still TBD in details.
     63            *
     64            *  This work around is designed to work both with remanants of the former 4.3 architecture and
     65            * with the new components from the 5.0 architecture. It minimizes the changes to be made in the
     66            * legacy 4.3 code by providing two macros named after the UIIRQHandlerClass methods:
     67            *
     68            * - #Set_UI_IRQ_Handler
     69            * - #Exec_UI_IRQ_Handler
     70            *
     71            *  And it provides two functions, similar to the former UIIRQHandlerClass's methods, but designed
     72            * to work with the new components.
     73            * @{
     74            */
     75          
     76          
     77          /* Private typedef -----------------------------------------------------------*/
     78          /**
     79            * @brief Interrupt handling configuration structure
     80            *
     81            *  The #Handler field is a pointer on the Interrupt handling function, while the
     82            * #Handle field is a pointer that is passed as the first parameter to the interrupt
     83            * handling function when it is executed.
     84            */
     85          typedef struct
     86          {
     87              UIIRQ_Handler_t Handler;
     88              void *          Handle;
     89          } UIIRQ_HandlerConfigItem_t;
     90          
     91          
     92          /* Private defines -----------------------------------------------------------*/
     93          /** @brief Number of Interrupt handlers managed by the UI IRQ component */
     94          #define MAX_UI_IRQ_NUM 1
     95          
     96          
     97          /* Static variables ----------------------------------------------------------*/
     98          /** @brief Table containing the Interrupt handling configurations */

   \                                 In section .bss, align 4
     99          static UIIRQ_HandlerConfigItem_t oUI_IRQTable[MAX_UI_IRQ_NUM];
   \                     oUI_IRQTable:
   \        0x0                      DS8 8
    100          
    101          
    102          /* Functions ---------------------------------------------------- */
    103          /**
    104            * @brief Sets the function to invoque when the interrupt identified by bIRQAddr occurs.
    105            * @p Handler as the handler for the interrupt identified by @p bIRQAddr.
    106            * @p Handle is also registered and passed as first argument to the @p Handler function when it
    107            * is executed.
    108            */
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void UIIRQ_SetIrqHandler(uint8_t bIRQAddr, UIIRQ_Handler_t Handler, void * Handle)
    111          {
    112              if ( bIRQAddr < MAX_UI_IRQ_NUM )
   \                     UIIRQ_SetIrqHandler: (+1)
   \        0x0   0xB910             CBNZ.N   R0,??UIIRQ_SetIrqHandler_0
    113              {
    114                  oUI_IRQTable[ bIRQAddr ].Handler = Handler;
   \        0x2   0x....             LDR.N    R0,??DataTable1
   \        0x4   0x6001             STR      R1,[R0, #+0]
    115                  oUI_IRQTable[ bIRQAddr ].Handle  = Handle;
   \        0x6   0x6042             STR      R2,[R0, #+4]
    116              }
    117          }
   \                     ??UIIRQ_SetIrqHandler_0: (+1)
   \        0x8   0x4770             BX       LR               ;; return
    118          
    119          
    120          /** @brief Executes the function registered for the interrupt identified by
    121            * @p bIRQAddr and returns its return value.
    122            * @p flag is passed as second argument to the handler function, the first being the pointer
    123            * that was registered with it.
    124            * @p rx_data is passed as third argument to the handler function.
    125            */

   \                                 In section .text, align 2, keep-with-next
    126          void* UIIRQ_ExecIrqHandler(uint8_t bIRQAddr, uint8_t flag, uint16_t rx_data)
    127          {  
   \                     UIIRQ_ExecIrqHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    128            void * ret_val = MC_NULL;
   \        0x2   0x2300             MOVS     R3,#+0
    129          
    130            if ( bIRQAddr < MAX_UI_IRQ_NUM )
   \        0x4   0xB920             CBNZ.N   R0,??UIIRQ_ExecIrqHandler_0
    131            {
    132                ret_val = oUI_IRQTable[ bIRQAddr ].Handler( oUI_IRQTable[ bIRQAddr ].Handle, flag, rx_data );
   \        0x6   0x....             LDR.N    R3,??DataTable1
   \        0x8   0x6858             LDR      R0,[R3, #+4]
   \        0xA   0x681B             LDR      R3,[R3, #+0]
   \        0xC   0x4798             BLX      R3
   \        0xE   0x4603             MOV      R3,R0
    133            }
    134          
    135            return ret_val;
   \                     ??UIIRQ_ExecIrqHandler_0: (+1)
   \       0x10   0x4618             MOV      R0,R3
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    136          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     oUI_IRQTable
    137          
    138          /**
    139            * @}
    140            */
    141          
    142          /**
    143            * @}
    144            */
    145          
    146          /**
    147           * @}
    148           */
    149          
    150          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UIIRQ_ExecIrqHandler
         8   -- Indirect call
       0   UIIRQ_SetIrqHandler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      20  UIIRQ_ExecIrqHandler
      10  UIIRQ_SetIrqHandler
       8  oUI_IRQTable

 
  8 bytes in section .bss
 34 bytes in section .text
 
 34 bytes of CODE memory
  8 bytes of DATA memory

Errors: none
Warnings: none
