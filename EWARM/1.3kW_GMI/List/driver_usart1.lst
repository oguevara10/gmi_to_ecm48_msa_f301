###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:12:42
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\driver_usart1.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EWD9FF.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\driver_usart1.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\driver_usart1.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\driver_usart1.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Drivers\driver_usart1.c
      1          /**
      2            ********************************************************************************************************************************
      3            * @file    drv_usart1.c 
      4            * @author  Pamela Lee
      5            * @brief   Main Driver function/s for serial protocol with usart1 hardware
      6            * @details Protocol usart1, after decode a whole valid frame from serial port2,
      7            *          trigger the system control to execute the relative APP in the int stage
      8            *          the Rx data is in usart1SeqMemRX_u32.
      9            *          To Transmitt data : put data into usart1SeqMemTX_u32, and call this function
     10            *                              USART_ITConfig(usart1, USART_IT_TXE, ENABLE);
     11            ********************************************************************************************************************************
     12            */
     13          
     14          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     15          #include "driver_usart1.h"
     16          #include "module_AutoAck.h"
     17          
     18          #include "main.h"
     19          #include "ui_task.h" // !error TODO: Remove, only for Regal_SendDebugMessage testing
     20          
     21          /* Private variables ---------------------------------------------------------*/
     22          //UART_HandleTypeDef huart2; //SPA
     23          
     24          Usart1_Control *usart1Control;
     25          
     26          AutoAck_Control *autoAckControl_u32;             
     27          
     28          __IO ITStatus UartReady = RESET;
     29          uint8_t usart1CaptureLen;                     //default Universal Protocol header length
     30          //uint8_t counter = 0;
     31          uint16_t uwCRCValue = 0;
     32          
     33          /**
     34            * @brief USART1 Initialization Function
     35            * @param None
     36            * @retval None
     37            */

   \                                 In section .text, align 2, keep-with-next
     38          void MX_USART1_UART_Init(void)
     39          {
   \                     MX_USART1_UART_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB08E             SUB      SP,SP,#+56
   \        0x4   0x221C             MOVS     R2,#+28
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xA807             ADD      R0,SP,#+28
   \        0xA   0x....'....        BL       memset
   \        0xE   0x2218             MOVS     R2,#+24
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x....'....        BL       memset
     40          
     41             /* USER CODE BEGIN USART1_Init 0 */
     42          
     43            /* USER CODE END USART1_Init 0 */
     44          
     45            LL_USART_InitTypeDef USART_InitStruct = {0};
     46          
     47            LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
     48          
     49            /* Peripheral clock enable */
     50            LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_USART1);
   \       0x18   0x....'....        LDR.W    R0,??DataTable7  ;; 0x40021014
     51            LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOB);
     52            
     53          //  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART1);
     54          //  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
     55            /**USART1 GPIO Configuration  
     56            PB6   ------> USART1_TX
     57            PB7   ------> USART1_RX 
     58            */
     59            GPIO_InitStruct.Pin = LL_GPIO_PIN_6|LL_GPIO_PIN_7;
     60            GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
     61            GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_HIGH;
     62            GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
     63            GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
     64            GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
     65            LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \       0x1C   0x....'....        LDR.W    R4,??DataTable7_1  ;; 0x40013800
   \       0x20   0x6841             LDR      R1,[R0, #+4]
   \       0x22   0xF441 0x4180      ORR      R1,R1,#0x4000
   \       0x26   0x6041             STR      R1,[R0, #+4]
   \       0x28   0x2302             MOVS     R3,#+2
   \       0x2A   0x6841             LDR      R1,[R0, #+4]
   \       0x2C   0xF401 0x4180      AND      R1,R1,#0x4000
   \       0x30   0x9100             STR      R1,[SP, #+0]
   \       0x32   0x9900             LDR      R1,[SP, #+0]
   \       0x34   0x6802             LDR      R2,[R0, #+0]
   \       0x36   0xF442 0x2280      ORR      R2,R2,#0x40000
   \       0x3A   0x6002             STR      R2,[R0, #+0]
   \       0x3C   0x22C0             MOVS     R2,#+192
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0xF400 0x2080      AND      R0,R0,#0x40000
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0x9900             LDR      R1,[SP, #+0]
   \       0x48   0x....'....        LDR.W    R0,??DataTable7_2  ;; 0x48000400
   \       0x4C   0x9201             STR      R2,[SP, #+4]
   \       0x4E   0x2103             MOVS     R1,#+3
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x9204             STR      R2,[SP, #+16]
   \       0x54   0x9205             STR      R2,[SP, #+20]
   \       0x56   0x9103             STR      R1,[SP, #+12]
   \       0x58   0x2207             MOVS     R2,#+7
   \       0x5A   0x9302             STR      R3,[SP, #+8]
   \       0x5C   0x9206             STR      R2,[SP, #+24]
   \       0x5E   0xA901             ADD      R1,SP,#+4
   \       0x60   0x....'....        BL       LL_GPIO_Init
     66          
     67          
     68          
     69            /* USER CODE BEGIN USART1_Init 1 */
     70          
     71            /* USER CODE END USART1_Init 1 */
     72            USART_InitStruct.BaudRate = 115200;
   \       0x64   0xF44F 0x30E1      MOV      R0,#+115200
     73            USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x9007             STR      R0,[SP, #+28]
   \       0x6C   0x9108             STR      R1,[SP, #+32]
     74            USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
   \       0x6E   0x9109             STR      R1,[SP, #+36]
     75            USART_InitStruct.Parity = LL_USART_PARITY_NONE;
   \       0x70   0x910A             STR      R1,[SP, #+40]
     76            USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
   \       0x72   0x220C             MOVS     R2,#+12
     77            USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
   \       0x74   0x910C             STR      R1,[SP, #+48]
     78            USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
   \       0x76   0x910D             STR      R1,[SP, #+52]
   \       0x78   0x920B             STR      R2,[SP, #+44]
     79            LL_USART_Init(USART1, &USART_InitStruct);
   \       0x7A   0xA907             ADD      R1,SP,#+28
   \       0x7C   0x4620             MOV      R0,R4
   \       0x7E   0x....'....        BL       LL_USART_Init
     80            LL_USART_DisableIT_CTS(USART1);
   \       0x82   0x68A0             LDR      R0,[R4, #+8]
   \       0x84   0xF420 0x6080      BIC      R0,R0,#0x400
   \       0x88   0x60A0             STR      R0,[R4, #+8]
     81            LL_USART_ConfigAsyncMode(USART1);
   \       0x8A   0x6860             LDR      R0,[R4, #+4]
   \       0x8C   0xF420 0x4090      BIC      R0,R0,#0x4800
   \       0x90   0x6060             STR      R0,[R4, #+4]
   \       0x92   0x68A0             LDR      R0,[R4, #+8]
   \       0x94   0xF020 0x002A      BIC      R0,R0,#0x2A
   \       0x98   0x60A0             STR      R0,[R4, #+8]
     82            LL_USART_Enable(USART1);
     83          
     84            /* USER CODE BEGIN WKUPType USART1 */
     85          
     86            /* USER CODE END WKUPType USART1 */
     87            LL_USART_ClearFlag_ORE(USART1);               //reset all usart error bit
   \       0x9A   0x2008             MOVS     R0,#+8
   \       0x9C   0x6821             LDR      R1,[R4, #+0]
   \       0x9E   0xF041 0x0101      ORR      R1,R1,#0x1
   \       0xA2   0x6021             STR      R1,[R4, #+0]
   \       0xA4   0x6220             STR      R0,[R4, #+32]
     88            /* Polling USART1 initialisation */
     89           while((!(LL_USART_IsActiveFlag_TEACK(USART1))) || (!(LL_USART_IsActiveFlag_REACK(USART1))))
   \                     ??MX_USART1_UART_Init_0: (+1)
   \       0xA6   0x69E0             LDR      R0,[R4, #+28]
   \       0xA8   0x0280             LSLS     R0,R0,#+10
   \       0xAA   0xD5FC             BPL.N    ??MX_USART1_UART_Init_0
   \       0xAC   0x69E0             LDR      R0,[R4, #+28]
   \       0xAE   0x0240             LSLS     R0,R0,#+9
   \       0xB0   0xD5F9             BPL.N    ??MX_USART1_UART_Init_0
     90           {
     91           }
     92            LL_USART_EnableIT_RXNE(USART1);
   \       0xB2   0x6821             LDR      R1,[R4, #+0]
   \       0xB4   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0xB8   0x6021             STR      R1,[R4, #+0]
     93            /* USER CODE BEGIN USART1_Init 2 */
     94          
     95          
     96            /* USER CODE END USART1_Init 2 */
     97          
     98          }
   \       0xBA   0xB00E             ADD      SP,SP,#+56
   \       0xBC   0xBD10             POP      {R4,PC}          ;; return
     99          
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void usart1_Init(){
    102            MX_USART1_UART_Init();
   \                     usart1_Init: (+1)
   \        0x0   0x....             B.N      MX_USART1_UART_Init
    103          }
    104          
    105          
    106          /**
    107            * @brief  Function called from USART IRQ Handler when RXNE flag is set
    108            *         Function is in charge of reading character received on USART RX line.
    109            * @param  None
    110            * @retval None
    111            */

   \                                 In section .text, align 2, keep-with-next
    112          void USART1_CharReception_Callback(void)
    113          {
   \                     USART1_CharReception_Callback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    114            /*
    115            __IO uint32_t received_char;
    116          
    117            // Read Received character. RXNE flag is cleared by reading of RDR register //
    118            received_char = LL_USART_ReceiveData8(USART1);
    119            */
    120           
    121            unsigned char rxDat2;
    122            rxDat2 = LL_USART_ReceiveData8(USART1);
   \        0x2   0x....'....        LDR.W    R0,??DataTable7_3  ;; 0x40013824
   \        0x6   0x8800             LDRH     R0,[R0, #+0]
   \        0x8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    123          
    124            RingBuf_WriteCharacter((*usart1Control).seqMem_InternalPipe_u32,&rxDat2);
   \        0xC   0x4669             MOV      R1,SP
   \        0xE   0x....'....        LDR.W    R0,??DataTable7_4
   \       0x12   0x6882             LDR      R2,[R0, #+8]
   \       0x14   0x6950             LDR      R0,[R2, #+20]
   \       0x16   0x....'....        BL       RingBuf_WriteCharacter
    125            //RBWrite(usart1InternalSeqMem_u32->systemInstanceIndex_u8,&rxDat2); 
    126            
    127            /* Echo received character on TX */
    128           // LL_USART_TransmitData8(USART1, received_char);
    129          }
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    130          
    131          /******************* variable for usart1 TX interrupt **************************/
    132          __IO uint8_t indexTx = 0;
    133          uint8_t ubSizeToSend = 0;
    134          unsigned char* wholeFramebuf;
    135          /*******************************************************************************/
    136          /**
    137            * @brief  Function called for achieving next TX Byte sending
    138            * @param  None
    139            * @retval None
    140            */

   \                                 In section .text, align 2, keep-with-next
    141          void USART1_TXEmpty_Callback(void)
    142          {
    143            /* Fill TDR with a new char */
    144            LL_USART_TransmitData8(USART1, wholeFramebuf[indexTx++]);
   \                     USART1_TXEmpty_Callback: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable7_4
   \        0x4   0x7882             LDRB     R2,[R0, #+2]
   \        0x6   0x1C51             ADDS     R1,R2,#+1
   \        0x8   0x7081             STRB     R1,[R0, #+2]
   \        0xA   0x68C3             LDR      R3,[R0, #+12]
   \        0xC   0x....'....        LDR.W    R1,??DataTable7_1  ;; 0x40013800
   \       0x10   0x5C9A             LDRB     R2,[R3, R2]
   \       0x12   0x850A             STRH     R2,[R1, #+40]
    145            
    146            if (indexTx == (ubSizeToSend ))
   \       0x14   0x7883             LDRB     R3,[R0, #+2]
   \       0x16   0x78C2             LDRB     R2,[R0, #+3]
   \       0x18   0x4293             CMP      R3,R2
   \       0x1A   0xD105             BNE.N    ??USART1_TXEmpty_Callback_0
    147            {
    148              /* Disable TXE interrupt */
    149              LL_USART_DisableIT_TXE(USART1);
   \       0x1C   0x680B             LDR      R3,[R1, #+0]
   \       0x1E   0xF023 0x0380      BIC      R3,R3,#0x80
   \       0x22   0x600B             STR      R3,[R1, #+0]
    150              indexTx = 0;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x7081             STRB     R1,[R0, #+2]
    151            } 
    152          }
   \                     ??USART1_TXEmpty_Callback_0: (+1)
   \       0x28   0x4770             BX       LR               ;; return
    153          
    154          /**
    155            * @brief  Function called at completion of last byte transmission
    156            * @param  None
    157            * @retval None
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          void USART1_CharTransmitComplete_Callback(void)
    160          {
    161          //  if (indexTx == sizeof(ubSizeToSend))
    162          //  {
    163          //    indexTx = 0;
    164          
    165              /* Disable TC interrupt */
    166          //    LL_USART_DisableIT_TC(USART1);
    167          //  }
    168          }
   \                     USART1_CharTransmitComplete_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    169          
    170          
    171          static uint8_t dataLen = 0;                                         //length of data byte/s plus CRC expected
    172          uint8_t UniProtocolState = protocolstart;
    173          unsigned char* protocolBuf ;
    174          
    175          
    176          /**
    177            *@brief   Function for decode a valid frame of universal protocol
    178            *         the Rx data will put into an internal pipe and process after 
    179            *         the first 5 byte contain sync byte and then wait for the whole header 
    180            *         bytes in side the internal pipe, then perform the header veification.
    181            *         If the the header bytes are valid, then prepare for getting the whole data fields 
    182            *         and perform CRC check.
    183            * @param  None
    184            * @retval None
    185            */

   \                                 In section .text, align 4, keep-with-next
    186          void protocolHeaderfetch(void)
    187          {
   \                     protocolHeaderfetch: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    188          //  usart1SeqMemRX_u32 = (*usart1Control).seqMemRX_u32;   //pam bug without
    189            switch(UniProtocolState)
   \        0x2   0x....'....        LDR.W    R4,??DataTable7_4
   \        0x6   0x7960             LDRB     R0,[R4, #+5]
   \        0x8   0xB086             SUB      SP,SP,#+24
   \        0xA   0xB118             CBZ.N    R0,??protocolHeaderfetch_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD058             BEQ.N    ??protocolHeaderfetch_1
   \       0x10   0xD31B             BCC.N    ??protocolHeaderfetch_2
   \       0x12   0xE0CA             B.N      ??protocolHeaderfetch_3
    190            {
    191              case  protocolstart:
    192               Reentryprotocalstart: 
    193                { // assume this is very beginning of universal-frame, check and clear any garble before sync byte
    194                  usart1CaptureLen = UniHeaderlen; 
    195                  dataLen = 0;
   \                     ??protocolHeaderfetch_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
    196                  unsigned int SyncPosition = RingBuf_Search((*usart1Control).seqMem_InternalPipe_u32, RxSyncChr, 0);              //search sync byte within internal pipe,[return position or 0xf000 == not found 0xffff == error]
   \       0x16   0x68A3             LDR      R3,[R4, #+8]
   \       0x18   0x7120             STRB     R0,[R4, #+4]
   \       0x1A   0x2107             MOVS     R1,#+7
   \       0x1C   0x7061             STRB     R1,[R4, #+1]
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x6958             LDR      R0,[R3, #+20]
   \       0x22   0x2155             MOVS     R1,#+85
   \       0x24   0x....'....        BL       RingBuf_Search
   \       0x28   0x9000             STR      R0,[SP, #+0]
    197                  if (SyncPosition != 0) 
   \       0x2A   0xB168             CBZ.N    R0,??protocolHeaderfetch_4
    198                  {
    199                    if(SyncPosition & 0xf000)                                                            
   \       0x2C   0xF410 0x4F70      TST      R0,#0xF000
   \       0x30   0xBF1C             ITT      NE
   \       0x32   0x2007             MOVNE    R0,#+7
   \       0x34   0x9000             STRNE    R0,[SP, #+0]
    200                    { //sync byte not found or error, then clear the first 5 bytes
    201                      SyncPosition = UniHeaderlen;                                                                // this will clear all 5 byte                                       
    202                    }
    203                    if((protocolBuf = (unsigned char*) realloc(protocolBuf,SyncPosition)) == NULL) reallocError++;
   \       0x36   0x9900             LDR      R1,[SP, #+0]
   \       0x38   0x6920             LDR      R0,[R4, #+16]
   \       0x3A   0x....'....        BL       realloc
   \       0x3E   0x....'....        BL       ?Subroutine0
    204                    RingBuf_ReadBlock((*usart1Control).seqMem_InternalPipe_u32, protocolBuf, &SyncPosition);                          //truncate any char before SYNC char 
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x42   0x6121             STR      R1,[R4, #+16]
   \       0x44   0x466A             MOV      R2,SP
   \       0x46   0xE0A3             B.N      ??protocolHeaderfetch_5
    205                    if((protocolBuf = (unsigned char*)realloc(protocolBuf,1)) == NULL) reallocError++;
    206                    usart1CaptureLen = UniHeaderlen; 
    207                    UniProtocolState = protocolstart;                                                             // still to back here next stage for complete header frame 
    208                    break;
    209                  }
    210                  // otherwise mean the the first byte in buffer is sync byte, then can directly process to header Validate state !!!!!!!!!
    211                  UniProtocolState = protocolstart;
   \                     ??protocolHeaderfetch_4: (+1)
   \       0x48   0x7160             STRB     R0,[R4, #+5]
   \                     ??protocolHeaderfetch_2: (+1)
   \       0x4A   0x2209             MOVS     R2,#+9
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0xA803             ADD      R0,SP,#+12
   \       0x50   0x....'....        BL       memset
    212                }
    213              case headerValidate:
    214                { //check this is a valid header frame in internal pipe
    215                  unsigned char headerBuf[]={ 0, 0, 0, 0, 0, 0, 0, 0, 0};                 //9 byte array  for header including advanced CMD 
    216                  unsigned int headerLen = 9;     
   \       0x54   0x2009             MOVS     R0,#+9
   \       0x56   0x9002             STR      R0,[SP, #+8]
    217                  RingBuf_Observe((*usart1Control).seqMem_InternalPipe_u32, headerBuf, 0, &headerLen);      //get the pipe data without clear internal pipe, headerLen will return number of bytes in pipe if less than 9 byte
   \       0x58   0xAB02             ADD      R3,SP,#+8
   \       0x5A   0x68A0             LDR      R0,[R4, #+8]
   \       0x5C   0x6940             LDR      R0,[R0, #+20]
   \       0x5E   0x2200             MOVS     R2,#+0
   \       0x60   0xA903             ADD      R1,SP,#+12
   \       0x62   0x....'....        BL       RingBuf_Observe
    218          
    219                  uint8_t dataA ;
    220                  uint8_t headerCRCLen = 7;                                               //default normal frame header + CRC bytes = 7 byte
    221                  uint8_t dataC = (uint8_t) headerBuf[1] & 0xC0;
   \       0x66   0xAA03             ADD      R2,SP,#+12
   \       0x68   0x2107             MOVS     R1,#+7
   \       0x6A   0x7853             LDRB     R3,[R2, #+1]
   \       0x6C   0xF013 0x00C0      ANDS     R0,R3,#0xC0
    222                  if (dataC == 0)                                                         //check this is advanced frame [00]+[data length]
   \       0x70   0xD10B             BNE.N    ??protocolHeaderfetch_6
    223                  {
    224                    dataA = (uint8_t)headerBuf[4] & 0xf0 ;                                //this is normal frame, store dataA as the expected Header-end in byte 5
   \       0x72   0x7910             LDRB     R0,[R2, #+4]
   \       0x74   0xF000 0x00F0      AND      R0,R0,#0xF0
    225                  }
    226                  else
    227                  {  //this is advanced frame [11]+[data length]   or  garbage 
    228                    if (dataC == 0xC0)
    229                    { //this is advanced frame 
    230                      dataA = (uint8_t)headerBuf[6] & 0xf0 ;                              //this is Advanced frame,  store dataA as the expected Header-end in byte 7 
    231                      headerCRCLen = 9;                                                   //header + CRC bytes = 9 byte
    232                    }
    233                    else
    234                    { //this is garbage, because the frame type pointer not valid
    235                      unsigned char tmpbuf3;
    236                      unsigned int truncateLen = 1;   
    237                      RingBuf_ReadBlock((*usart1Control).seqMem_InternalPipe_u32, &tmpbuf3, &truncateLen);                             //truncate the first byte incase the garbage is the same of sync byte
    238                      usart1CaptureLen = UniHeaderlen; 
    239                      UniProtocolState = protocolstart;    
    240                      if( *RingBuf_GetPointerToRingBuf((*usart1Control).seqMem_InternalPipe_u32) >= usart1CaptureLen)                     //after truncase the carbage byte still contain more then header length then goto back to do again
    241                      {
    242                        goto Reentryprotocalstart;                                                                 //this line needed to use goto for finish the frame check in one go
    243                      }
    244                      break;   
    245                    }
    246                  }
    247                  if(dataA == (~((uint8_t)RxSyncChr) & 0xf0))                                  //check header-end byte is valid
   \                     ??protocolHeaderfetch_7: (+1)
   \       0x78   0x28A0             CMP      R0,#+160
   \       0x7A   0xD10D             BNE.N    ??protocolHeaderfetch_8
    248                  {// this is a valid header        
    249                    dataLen = (uint8_t) headerBuf[1] & 0x3F;     
    250                    usart1CaptureLen = (uint8_t)(dataLen + headerCRCLen) ; // header+ CRC +data length = number of bytes for next capture
   \       0x7C   0xF003 0x033F      AND      R3,R3,#0x3F
   \       0x80   0x18C9             ADDS     R1,R1,R3
    251                    UniProtocolState = frameCRC;
   \       0x82   0x2002             MOVS     R0,#+2
   \       0x84   0x7061             STRB     R1,[R4, #+1]
   \       0x86   0x7160             STRB     R0,[R4, #+5]
    252                    break;
   \       0x88   0xE094             B.N      ??protocolHeaderfetch_9
    253                  }
   \                     ??protocolHeaderfetch_6: (+1)
   \       0x8A   0x28C0             CMP      R0,#+192
   \       0x8C   0xD104             BNE.N    ??protocolHeaderfetch_8
   \       0x8E   0x7990             LDRB     R0,[R2, #+6]
   \       0x90   0xF000 0x00F0      AND      R0,R0,#0xF0
   \       0x94   0x2109             MOVS     R1,#+9
   \       0x96   0xE7EF             B.N      ??protocolHeaderfetch_7
   \                     ??protocolHeaderfetch_8: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0x9001             STR      R0,[SP, #+4]
   \       0x9C   0xAA01             ADD      R2,SP,#+4
   \       0x9E   0x68A0             LDR      R0,[R4, #+8]
   \       0xA0   0x6940             LDR      R0,[R0, #+20]
   \       0xA2   0x4669             MOV      R1,SP
   \       0xA4   0x....'....        BL       RingBuf_ReadBlock
   \       0xA8   0x2007             MOVS     R0,#+7
   \       0xAA   0x7060             STRB     R0,[R4, #+1]
   \       0xAC   0x2100             MOVS     R1,#+0
   \       0xAE   0x68A0             LDR      R0,[R4, #+8]
   \       0xB0   0x7161             STRB     R1,[R4, #+5]
   \       0xB2   0x6940             LDR      R0,[R0, #+20]
   \       0xB4   0x....'....        BL       RingBuf_GetPointerToRingBuf
   \       0xB8   0x7861             LDRB     R1,[R4, #+1]
   \       0xBA   0x7800             LDRB     R0,[R0, #+0]
   \       0xBC   0x4288             CMP      R0,R1
   \       0xBE   0xD379             BCC.N    ??protocolHeaderfetch_9
   \       0xC0   0xE7A8             B.N      ??protocolHeaderfetch_0
    254                  else
    255                  {
    256                   // if the header frame is not valid, then delete the first byte only
    257                    unsigned char tmpbuf3;
    258                    unsigned int truncateLen = 1;   
    259                    RingBuf_ReadBlock((*usart1Control).seqMem_InternalPipe_u32, &tmpbuf3, &truncateLen);                             //truncate the first byte incase the garbage is the same of sync byte
    260                    usart1CaptureLen = UniHeaderlen; 
    261                    UniProtocolState = protocolstart;    
    262                    if( *RingBuf_GetPointerToRingBuf((*usart1Control).seqMem_InternalPipe_u32) >= usart1CaptureLen)                     //after truncase the carbage byte still contain more then header length then goto back to do again
    263                    {
    264                      goto Reentryprotocalstart;                  //this line needed to use goto for finish the frame check in one go
    265                    }
    266                    break;
    267                  }
    268                }
    269              case frameCRC:
    270                {
    271                  if((protocolBuf = (unsigned char*) realloc(protocolBuf,usart1CaptureLen)) == NULL) reallocError++;        
   \                     ??protocolHeaderfetch_1: (+1)
   \       0xC2   0x7861             LDRB     R1,[R4, #+1]
   \       0xC4   0x6920             LDR      R0,[R4, #+16]
   \       0xC6   0x....'....        BL       realloc
   \       0xCA   0x....'....        BL       ?Subroutine1
    272                  unsigned int DataLen2 = (unsigned int)usart1CaptureLen;
    273                  RingBuf_Observe((*usart1Control).seqMem_InternalPipe_u32, protocolBuf, 0, &DataLen2);                             //copy the whole frame into buffer
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0xCE   0x466B             MOV      R3,SP
   \       0xD0   0x7861             LDRB     R1,[R4, #+1]
   \       0xD2   0x9100             STR      R1,[SP, #+0]
   \       0xD4   0x2200             MOVS     R2,#+0
   \       0xD6   0x4601             MOV      R1,R0
   \       0xD8   0x68A0             LDR      R0,[R4, #+8]
   \       0xDA   0x6940             LDR      R0,[R0, #+20]
   \       0xDC   0x....'....        BL       RingBuf_Observe
    274                  uint16_t frameCRC = (((uint16_t)protocolBuf[DataLen2 - 2]) << 8) + ((uint16_t)protocolBuf[DataLen2 - 1]) ;
   \       0xE0   0x6921             LDR      R1,[R4, #+16]
   \       0xE2   0x9800             LDR      R0,[SP, #+0]
   \       0xE4   0x4408             ADD      R0,R1,R0
   \       0xE6   0xF810 0x2D02      LDRB     R2,[R0, #-2]!
   \       0xEA   0x7840             LDRB     R0,[R0, #+1]
   \       0xEC   0xEB00 0x2502      ADD      R5,R0,R2, LSL #+8
    275                  
    276                  uwCRCValue = Calculate_CRC((DataLen2 - 2) , protocolBuf);                                       //Get calculated CRC of this frame
   \       0xF0   0x9A00             LDR      R2,[SP, #+0]
   \       0xF2   0x1E90             SUBS     R0,R2,#+2
   \       0xF4   0xB280             UXTH     R0,R0
   \       0xF6   0x....'....        BL       Calculate_CRC
    277                  if(uwCRCValue == frameCRC)
   \       0xFA   0xB2AD             UXTH     R5,R5
   \       0xFC   0x42A8             CMP      R0,R5
   \       0xFE   0x80E0             STRH     R0,[R4, #+6]
   \      0x100   0xD142             BNE.N    ??protocolHeaderfetch_10
    278                  { //CRC match put whole frame into RX pipe      
    279                    //decode from the CMD of group(1-2, 3 or 4 )
    280                   // RingBuf_WriteBlock((*usart1Control).seqMemRX_u32, protocolBuf, &DataLen2);                                //put fully checked (Valid) Rx frame into Rx Pipe
    281                    if((protocolBuf[3]) && (protocolBuf[2] != 0x3f))                                              //if auto ACK
   \      0x102   0x6921             LDR      R1,[R4, #+16]
   \      0x104   0x78C8             LDRB     R0,[R1, #+3]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xBF1C             ITT      NE
   \      0x10A   0x7888             LDRBNE   R0,[R1, #+2]
   \      0x10C   0x283F             CMPNE    R0,#+63
   \      0x10E   0xD010             BEQ.N    ??protocolHeaderfetch_11
    282                    {
    283                      unsigned char ackTx[] = {0x55, 0x00, 0x3F, protocolBuf[3], 0x00, 0xCC, 0xCC};
   \      0x110   0x....             ADR.N    R0,?_0
   \      0x112   0xAA02             ADD      R2,SP,#+8
   \      0x114   0xE9D0 0x3500      LDRD     R3,R5,[R0, #+0]
   \      0x118   0xE9C2 0x3500      STRD     R3,R5,[R2, #+0]
   \      0x11C   0x78C9             LDRB     R1,[R1, #+3]
    284                      unsigned int TxLen = sizeof(ackTx);
    285                      RingBuf_WriteBlock((*usart1Control).seqMemTX_u32, ackTx, &TxLen); 
   \      0x11E   0x68A0             LDR      R0,[R4, #+8]
   \      0x120   0xF88D 0x100B      STRB     R1,[SP, #+11]
   \      0x124   0x2207             MOVS     R2,#+7
   \      0x126   0x9201             STR      R2,[SP, #+4]
   \      0x128   0xAA01             ADD      R2,SP,#+4
   \      0x12A   0x6900             LDR      R0,[R0, #+16]
   \      0x12C   0xA902             ADD      R1,SP,#+8
   \      0x12E   0x....'....        BL       RingBuf_WriteBlock
    286                    }          
    287                    // RPa: to signal that there is valid packet
    288                    Set_ValidRx();
   \                     ??protocolHeaderfetch_11: (+1)
   \      0x132   0x....'....        BL       Set_ValidRx
    289                    
    290                    switch(protocolBuf[2] & 0xf0)
   \      0x136   0x6921             LDR      R1,[R4, #+16]
   \      0x138   0x7888             LDRB     R0,[R1, #+2]
   \      0x13A   0xF010 0x02F0      ANDS     R2,R0,#0xF0
   \      0x13E   0xBF18             IT       NE
   \      0x140   0x2A10             CMPNE    R2,#+16
   \      0x142   0xD00B             BEQ.N    ??protocolHeaderfetch_12
   \      0x144   0x2A20             CMP      R2,#+32
   \      0x146   0xBF18             IT       NE
   \      0x148   0x2A30             CMPNE    R2,#+48
   \      0x14A   0xD007             BEQ.N    ??protocolHeaderfetch_12
   \      0x14C   0x2A40             CMP      R2,#+64
   \      0x14E   0xBF1C             ITT      NE
   \      0x150   0x2A50             CMPNE    R2,#+80
   \      0x152   0x2A60             CMPNE    R2,#+96
   \      0x154   0xD00B             BEQ.N    ??protocolHeaderfetch_13
   \      0x156   0x2A70             CMP      R2,#+112
   \      0x158   0xD00D             BEQ.N    ??protocolHeaderfetch_14
   \      0x15A   0xE017             B.N      ??protocolHeaderfetch_15
    291                    {     //groups decoding  please refer to the document of Universal protocol 
    292                      case 0x00:          //group 1
    293                      case 0x10:          //group 1
    294                      case 0x20:          //group 2
    295                      case 0x30:          //group 2
    296                        {    
    297                          if(protocolBuf[2] == 0x3f)
   \                     ??protocolHeaderfetch_12: (+1)
   \      0x15C   0x283F             CMP      R0,#+63
   \      0x15E   0xD103             BNE.N    ??protocolHeaderfetch_16
    298                          {
    299                            //Auto-Ack feedback from receiver
    300                            AckDeRegistered((uint8_t)protocolBuf[3]);  /** Pam!!!! this is the only function linking from outside driver_USART1.c can be replace by using structured-memory for loose coupling **/ 
   \      0x160   0x78C8             LDRB     R0,[R1, #+3]
   \      0x162   0x....'....        BL       AckDeRegistered
   \      0x166   0xE011             B.N      ??protocolHeaderfetch_15
    301           //                 (*autoAckControl_u32).RxAckFrameID = (uint8_t)protocolBuf[3];
    302                          }
    303                          else
    304                          {       //group1_2 as module_ShortCmd
    305                            RingBuf_WriteBlock((*usart1Control).seqMemRXG1_2_u32, protocolBuf, &DataLen2);                                //put fully checked (Valid) Rx frame into Rx Pipe
   \                     ??protocolHeaderfetch_16: (+1)
   \      0x168   0x68A0             LDR      R0,[R4, #+8]
   \      0x16A   0x6800             LDR      R0,[R0, #+0]
   \      0x16C   0xE001             B.N      ??protocolHeaderfetch_17
    306                          }
    307                          break;
    308                        }
    309                      case 0x40:          //group 3
    310                      case 0x50:          //group 3
    311                      case 0x60:            //group 3
    312                        {         //group3 module_ReplyCMD
    313                          RingBuf_WriteBlock((*usart1Control).seqMemRXG3_u32, protocolBuf, &DataLen2);                                //put fully checked (Valid) Rx frame into Rx Pipe
   \                     ??protocolHeaderfetch_13: (+1)
   \      0x16E   0x68A0             LDR      R0,[R4, #+8]
   \      0x170   0x6840             LDR      R0,[R0, #+4]
   \                     ??protocolHeaderfetch_17: (+1)
   \      0x172   0x466A             MOV      R2,SP
   \      0x174   0xE005             B.N      ??protocolHeaderfetch_18
    314                          break;
    315                        }
    316                    
    317                      case 0x70:            //group 4
    318                        {        //group 4 module_FlashCMD 
    319                          if(protocolBuf[2] & 0x08)
   \                     ??protocolHeaderfetch_14: (+1)
   \      0x176   0x68A3             LDR      R3,[R4, #+8]
   \      0x178   0x0700             LSLS     R0,R0,#+28
   \      0x17A   0x466A             MOV      R2,SP
   \      0x17C   0xBF4C             ITE      MI
   \      0x17E   0x68D8             LDRMI    R0,[R3, #+12]
   \      0x180   0x6898             LDRPL    R0,[R3, #+8]
    320                          {
    321                             RingBuf_WriteBlock((*usart1Control).seqMemRXG4H_u32, protocolBuf, &DataLen2);                                //put fully checked (Valid) Rx frame into Rx Pipe
    322                          }
    323                          else
    324                          {
    325                            RingBuf_WriteBlock((*usart1Control).seqMemRXG4L_u32, protocolBuf, &DataLen2);                                //put fully checked (Valid) Rx frame into Rx Pipe
   \                     ??protocolHeaderfetch_18: (+1)
   \      0x182   0x....'....        BL       RingBuf_WriteBlock
   \      0x186   0xE001             B.N      ??protocolHeaderfetch_15
    326                          }
    327                          break;
    328                        }
    329                      default:              // the rest will be truncase
    330                        {   
    331                          break;
    332                        }
    333                    }
    334                    
    335                    /*********** this part only for testing the Tx message *************/
    336                    /*
    337                    //Echo back the full valid frame to sender
    338                    protocolBuf[DataLen2 - 2] = 0xCC;                                                             //Tx frame always use 0xCC as CRC byte, the Tx sending routine should process it with the final CRC value
    339                    protocolBuf[DataLen2 - 1] = 0xCC;                                                             //Tx frame always use 0xCC as CRC byte, the Tx sending routine should process it with the final CRC value
    340                    protocolBuf[0] = 0x55;                                                                           //Tx frame always use 0x55 as Sync, the Tx sending routine should process it for Master or Slave
    341                    if(protocolBuf[1] & 0xC0)
    342                    {//Advanced frame
    343                      protocolBuf[5] = 0x00;                                                                         //Tx frame always use 0xFF as Source Frame ID for ACK require, and 0x00 as non-ACK frame, the Tx sending routine should process with the value for ACK frame        
    344                      protocolBuf[6] = 0x01;                                                                         //Tx frame slways put motor address to lower nibble, and leave upper nibble as 0 for Tx routine to put the Header-end value to this field
    345                    }
    346                    else
    347                    {//Normal frame
    348                      protocolBuf[3] = 0x00;                                                                         //Tx frame always use 0xFF as Source Frame ID for ACK require, and 0x00 as non-ACK frame, the Tx sending routine should process with the value for ACK frame        
    349                      protocolBuf[4] = 0x01;                                                                         //Tx frame slways put motor address to lower nibble, and leave upper nibble as 0 for Tx routine to put the Header-end value to this field
    350                    }
    351                    RingBuf_WriteBlock(usart1SeqMemTX_u32->systemInstanceIndex_u8, protocolBuf, &DataLen2);        
    352          */
    353                    /*********** this part only for testing the Tx message End End End *************/
    354                  }                                
    355                  else
    356                  { 
    357                    DataLen2 = UniHeaderlen;                                                                   //only truncase the header         
   \                     ??protocolHeaderfetch_10: (+1)
   \      0x188   0x2007             MOVS     R0,#+7
   \      0x18A   0x9000             STR      R0,[SP, #+0]
    358                  }                                                                  
    359          
    360                  RingBuf_ReadBlock((*usart1Control).seqMem_InternalPipe_u32, protocolBuf, &DataLen2);                              //extract the whole frame  
   \                     ??protocolHeaderfetch_15: (+1)
   \      0x18C   0x466A             MOV      R2,SP
   \      0x18E   0x6921             LDR      R1,[R4, #+16]
   \                     ??protocolHeaderfetch_5: (+1)
   \      0x190   0x68A0             LDR      R0,[R4, #+8]
   \      0x192   0x6940             LDR      R0,[R0, #+20]
   \      0x194   0x....'....        BL       RingBuf_ReadBlock
    361          #if ENABLE_DEBUG_OUTPUT_VIA_STMC_PORT >= 1
    362                  Regal_SendDebugMessage(protocolBuf, DataLen2); // !error
    363          #endif
    364                  if((protocolBuf = (unsigned char*) realloc(protocolBuf,1)) == NULL) reallocError++;                                          //free heap only leave 1 byte 
   \      0x198   0x6920             LDR      R0,[R4, #+16]
   \      0x19A   0x....'....        BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x19E   0x....'....        BL       ?Subroutine1
    365                          
    366                  usart1CaptureLen = UniHeaderlen; 
    367                  UniProtocolState = protocolstart;    
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x1A2   0x2100             MOVS     R1,#+0
   \      0x1A4   0x2007             MOVS     R0,#+7
   \      0x1A6   0x7060             STRB     R0,[R4, #+1]
   \      0x1A8   0xE003             B.N      ??protocolHeaderfetch_19
    368                  break;
    369                }
    370          
    371              default:
    372                {
    373                  usart1CaptureLen = UniHeaderlen; 
   \                     ??protocolHeaderfetch_3: (+1)
   \      0x1AA   0x2007             MOVS     R0,#+7
    374                  dataLen = 0;
   \      0x1AC   0x2100             MOVS     R1,#+0
   \      0x1AE   0x7060             STRB     R0,[R4, #+1]
   \      0x1B0   0x7121             STRB     R1,[R4, #+4]
    375                  UniProtocolState = protocolstart;
   \                     ??protocolHeaderfetch_19: (+1)
   \      0x1B2   0x7161             STRB     R1,[R4, #+5]
    376                  break;
    377                } 
    378              
    379            }
    380          
    381          }
   \                     ??protocolHeaderfetch_9: (+1)
   \      0x1B4   0xB007             ADD      SP,SP,#+28
   \      0x1B6   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB910             CBNZ.N   R0,??Subroutine1_0
   \        0x2   0x7821             LDRB     R1,[R4, #+0]
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   \                     ??Subroutine1_0: (+1)
   \        0x8   0x6120             STR      R0,[R4, #+16]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6960             LDR      R0,[R4, #+20]
   \                     ??Subroutine2_0: (+1)
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x....'....        B.W      realloc

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD102             BNE.N    ??Subroutine0_0
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0x7020             STRB     R0,[R4, #+0]
   \                     ??Subroutine0_0: (+1)
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x55 0x00          DC8 85, 0, 63, 0, 0, 204, 204

   \              0x3F 0x00    

   \              0x00 0xCC    

   \              0xCC
   \        0x7                      DS8 1

   \                                 In section .bss, align 4
   \   static __absolute uint8_t reallocError
   \                     reallocError:
   \        0x0                      DS8 1
   \                     usart1CaptureLen:
   \        0x1                      DS8 1
   \                     indexTx:
   \        0x2                      DS8 1
   \                     ubSizeToSend:
   \        0x3                      DS8 1
   \        0x4                      DS8 1
   \                     UniProtocolState:
   \        0x5                      DS8 1
   \                     uwCRCValue:
   \        0x6                      DS8 2
   \                     usart1Control:
   \        0x8                      DS8 4
   \                     wholeFramebuf:
   \        0xC                      DS8 4
   \                     protocolBuf:
   \       0x10                      DS8 4
    382          
    383          
    384          /**
    385            *@brief   Universal protocol transmit
    386            * @ usage  To send a frame out user should setup a frame buffer
    387            *          always start with a 0x55 (no matter Master or slave) 
    388            *            |    count how many data length
    389            *            |     |   Command of this frame                 
    390            *            |     |     |   FrameID as 0x00 = non-ack frame or 0xff = auto ack frame
    391            *            |     |     |     |    put the motor addres for the low 4bits and always 0x0 for the upper 4 bits 
    392            *            |     |     |     |     |   data for this frame or omit these two byte if no data
    393            *            |     |     |     |     |     |     |   if this is Auto ack frame put the module ID here, otherwise always leave it as 0xCC
    394            *            |     |     |     |     |     |     |     |    Always leave as 0xCC
    395            *            |     |     |     |     |     |     |     |     |
    396            *          0x55, 0x02, 0x40, 0x00, 0x00, 0xff, 0xff, 0xCC, 0xCC
    397            *          Then put them into Tx sequential-memory of usart1, the system will add all the correct sync byte and CRC.
    398            *          User can put as many frame as the Tx sequential-memory is not full, so please check the Tx sequential-memory status before append new frame.
    399            * @param  None
    400            * @retval None
    401            */
    402          unsigned char* headerFramebuf;
   \                     headerFramebuf:
   \       0x14                      DS8 4

   \                                 In section .bss, align 4
   \                     autoAckControl_u32:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
   \                     UartReady:
   \        0x0                      DS8 1
    403          

   \                                 In section .text, align 2, keep-with-next
    404          uint8_t TxProcess(void)
    405          { //process Tx frame in Tx pipe
   \                     TxProcess: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    406            int txHeaderSize = UniHeaderlen;
    407            uint8_t currentFrameID = 0;
    408            if((headerFramebuf = (unsigned char*) realloc(headerFramebuf, txHeaderSize)) == NULL) reallocError++;
   \        0x2   0x....             LDR.N    R4,??DataTable7_4
   \        0x4   0x6960             LDR      R0,[R4, #+20]
   \        0x6   0x2107             MOVS     R1,#+7
   \        0x8   0x....'....        BL       realloc
   \        0xC   0x2500             MOVS     R5,#+0
   \        0xE   0x....'....        BL       ?Subroutine3
    409            unsigned int DataLenTx = (unsigned int)txHeaderSize;
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x12   0x2107             MOVS     R1,#+7
   \       0x14   0x9100             STR      R1,[SP, #+0]
    410            if(indexTx == 0)
   \       0x16   0x78A0             LDRB     R0,[R4, #+2]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD16F             BNE.N    ??TxProcess_0
    411            {
    412              unsigned int HeaderSize = 0;
    413              if(RingBuf_GetUsedNumOfElements((*usart1Control).seqMemTX_u32) >= txHeaderSize)
   \       0x1C   0x68A0             LDR      R0,[R4, #+8]
   \       0x1E   0x6900             LDR      R0,[R0, #+16]
   \       0x20   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x24   0x2807             CMP      R0,#+7
   \       0x26   0xDB53             BLT.N    ??TxProcess_1
    414              {
    415                RingBuf_Observe((*usart1Control).seqMemTX_u32, headerFramebuf, 0, &DataLenTx);                //copy the whole header frame into buffer
   \       0x28   0x68A0             LDR      R0,[R4, #+8]
   \       0x2A   0x6961             LDR      R1,[R4, #+20]
   \       0x2C   0x6900             LDR      R0,[R0, #+16]
   \       0x2E   0x466B             MOV      R3,SP
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x....'....        BL       RingBuf_Observe
    416                if(headerFramebuf[1] & 0xc0) 
   \       0x36   0x6960             LDR      R0,[R4, #+20]
   \       0x38   0x7841             LDRB     R1,[R0, #+1]
   \       0x3A   0xF011 0x0FC0      TST      R1,#0xC0
   \       0x3E   0xBF14             ITE      NE
   \       0x40   0x2609             MOVNE    R6,#+9
   \       0x42   0x2607             MOVEQ    R6,#+7
    417                {
    418                  HeaderSize = 9; //Advanced frame +CRC
    419                }
    420                else
    421                {
    422                  HeaderSize = 7; //normal frame +CRC                                                 //put back the lastest frameID into the Tx frame 
    423                }
    424                DataLenTx = HeaderSize + ((unsigned int)(headerFramebuf[1] & 0x3F)); 
   \       0x44   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x48   0x1989             ADDS     R1,R1,R6
   \       0x4A   0x9100             STR      R1,[SP, #+0]
    425                if(headerFramebuf[HeaderSize - 4]) 
   \       0x4C   0x1981             ADDS     R1,R0,R6
   \       0x4E   0xF811 0x0C04      LDRB     R0,[R1, #-4]
   \       0x52   0xB1D0             CBZ.N    R0,??TxProcess_2
    426                { /**check this is auto-ack frame  **/
    427                  if(!IsAckBufFull())
   \       0x54   0x....'....        BL       IsAckBufFull
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD163             BNE.N    ??TxProcess_3
    428                  {
    429                    if((headerFramebuf = (unsigned char*) realloc(headerFramebuf, DataLenTx)) == NULL) reallocError++;       
   \       0x5C   0x9900             LDR      R1,[SP, #+0]
   \       0x5E   0x6960             LDR      R0,[R4, #+20]
   \       0x60   0x....'....        BL       realloc
   \       0x64   0x....'....        BL       ?Subroutine0
    430                    RingBuf_Observe((*usart1Control).seqMemTX_u32, headerFramebuf, 0, &DataLenTx);                      //get the whole frame to capture the second last byte of module ID data in the frame
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x68   0x6161             STR      R1,[R4, #+20]
   \       0x6A   0x466B             MOV      R3,SP
   \       0x6C   0x68A0             LDR      R0,[R4, #+8]
   \       0x6E   0x6900             LDR      R0,[R0, #+16]
   \       0x70   0x2200             MOVS     R2,#+0
   \       0x72   0x....'....        BL       RingBuf_Observe
    431                    currentFrameID = AckDatSet((uint8_t)headerFramebuf[2], 0, (uint8_t)headerFramebuf[DataLenTx - 2]);  //put the current Auto Ack frame data to UniversalAckInfo for timout or auto dismiss  
   \       0x76   0x6960             LDR      R0,[R4, #+20]
   \       0x78   0x9900             LDR      R1,[SP, #+0]
   \       0x7A   0x4401             ADD      R1,R0,R1
   \       0x7C   0xF811 0x2C02      LDRB     R2,[R1, #-2]
   \       0x80   0x7880             LDRB     R0,[R0, #+2]
   \       0x82   0x2100             MOVS     R1,#+0
   \       0x84   0x....'....        BL       AckDatSet
   \       0x88   0x4605             MOV      R5,R0
    432                  }
    433                  else
    434                  { //if this is auto ack frame but autoACk UniversalAckInfo is full
    435                    //then wait until the buffer clear 
    436                    /**!!!!!!!!!!!!!!!!!! The communication may slow down alot if completely no reply by the other end, need to be carefull !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!**/
    437                    if((headerFramebuf = (unsigned char*) realloc(headerFramebuf, 1)) == NULL) reallocError++;                            //free heap only leave 1 byte 
    438                    return 1;               //Tx buffer full can't accept anymore frame
    439                  }
    440                }
    441                if((headerFramebuf = (unsigned char*) realloc(headerFramebuf, 1)) == NULL) reallocError++;                            //free heap only leave 1 byte 
   \                     ??TxProcess_2: (+1)
   \       0x8A   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x8E   0xB910             CBNZ.N   R0,??TxProcess_4
   \       0x90   0x7821             LDRB     R1,[R4, #+0]
   \       0x92   0x1C49             ADDS     R1,R1,#+1
   \       0x94   0x7021             STRB     R1,[R4, #+0]
    442                if((wholeFramebuf = (unsigned char*) realloc(wholeFramebuf, DataLenTx)) == NULL) reallocError++;       
   \                     ??TxProcess_4: (+1)
   \       0x96   0x6160             STR      R0,[R4, #+20]
   \       0x98   0x9900             LDR      R1,[SP, #+0]
   \       0x9A   0x68E0             LDR      R0,[R4, #+12]
   \       0x9C   0x....'....        BL       realloc
   \       0xA0   0xB910             CBNZ.N   R0,??TxProcess_5
   \       0xA2   0x7821             LDRB     R1,[R4, #+0]
   \       0xA4   0x1C49             ADDS     R1,R1,#+1
   \       0xA6   0x7021             STRB     R1,[R4, #+0]
    443                RingBuf_ReadBlock((*usart1Control).seqMemTX_u32, wholeFramebuf, &DataLenTx);             //copy the complete frame into buffer
   \                     ??TxProcess_5: (+1)
   \       0xA8   0x60E0             STR      R0,[R4, #+12]
   \       0xAA   0x4601             MOV      R1,R0
   \       0xAC   0x68A0             LDR      R0,[R4, #+8]
   \       0xAE   0x6900             LDR      R0,[R0, #+16]
   \       0xB0   0x466A             MOV      R2,SP
   \       0xB2   0x....'....        BL       RingBuf_ReadBlock
    444                wholeFramebuf[HeaderSize - 3] = (~TxSyncChr & 0xf0) + (wholeFramebuf[HeaderSize - 3] & 0xf); 
   \       0xB6   0x68E0             LDR      R0,[R4, #+12]
   \       0xB8   0x4430             ADD      R0,R0,R6
   \       0xBA   0xF810 0x1C03      LDRB     R1,[R0, #-3]
   \       0xBE   0xF001 0x010F      AND      R1,R1,#0xF
   \       0xC2   0x3150             ADDS     R1,R1,#+80
   \       0xC4   0xF800 0x1C03      STRB     R1,[R0, #-3]
    445                wholeFramebuf[HeaderSize - 4] = currentFrameID; 
   \       0xC8   0x68E0             LDR      R0,[R4, #+12]
   \       0xCA   0x4430             ADD      R0,R0,R6
   \       0xCC   0xF800 0x5C04      STRB     R5,[R0, #-4]
    446              }   
    447              wholeFramebuf[0] = TxSyncChr;
   \                     ??TxProcess_1: (+1)
   \       0xD0   0x21AA             MOVS     R1,#+170
   \       0xD2   0x68E0             LDR      R0,[R4, #+12]
   \       0xD4   0x7001             STRB     R1,[R0, #+0]
    448              uwCRCValue = Calculate_CRC((DataLenTx - 2) , wholeFramebuf);    
   \       0xD6   0x9800             LDR      R0,[SP, #+0]
   \       0xD8   0x68E1             LDR      R1,[R4, #+12]
   \       0xDA   0x1E80             SUBS     R0,R0,#+2
   \       0xDC   0xB280             UXTH     R0,R0
   \       0xDE   0x....'....        BL       Calculate_CRC
    449              wholeFramebuf[DataLenTx - 2] = (unsigned char)((uwCRCValue & 0xff00) >> 8);                  //put calculated CRC back into Tx frame
   \       0xE2   0x68E1             LDR      R1,[R4, #+12]
   \       0xE4   0x9A00             LDR      R2,[SP, #+0]
   \       0xE6   0x80E0             STRH     R0,[R4, #+6]
   \       0xE8   0x440A             ADD      R2,R1,R2
   \       0xEA   0x0A00             LSRS     R0,R0,#+8
   \       0xEC   0xF802 0x0C02      STRB     R0,[R2, #-2]
    450              wholeFramebuf[DataLenTx - 1] = (unsigned char)(uwCRCValue & 0xff) ;                          //put calculated CRC back into Tx frame  
   \       0xF0   0x68E1             LDR      R1,[R4, #+12]
   \       0xF2   0x9A00             LDR      R2,[SP, #+0]
   \       0xF4   0x88E0             LDRH     R0,[R4, #+6]
   \       0xF6   0x440A             ADD      R2,R1,R2
   \       0xF8   0xF802 0x0C01      STRB     R0,[R2, #-1]
    451            }    
    452            
    453            if((!indexTx) && (LL_USART_IsActiveFlag_TXE(USART1)))
   \                     ??TxProcess_0: (+1)
   \       0xFC   0x78A0             LDRB     R0,[R4, #+2]
   \       0xFE   0xB978             CBNZ.N   R0,??TxProcess_6
   \      0x100   0x....             LDR.N    R0,??DataTable7_1  ;; 0x40013800
   \      0x102   0x69C1             LDR      R1,[R0, #+28]
   \      0x104   0x0609             LSLS     R1,R1,#+24
   \      0x106   0xD50B             BPL.N    ??TxProcess_6
    454            {
    455              ubSizeToSend = DataLenTx;      //set TX length                                                      
   \      0x108   0x9A00             LDR      R2,[SP, #+0]
   \      0x10A   0x70E2             STRB     R2,[R4, #+3]
    456              /* Start USART transmission : Will initiate TXE interrupt after TDR register is empty */
    457              LL_USART_TransmitData8(USART1, wholeFramebuf[indexTx++]);                                       //put buffer in
   \      0x10C   0x78A1             LDRB     R1,[R4, #+2]
   \      0x10E   0x1C4A             ADDS     R2,R1,#+1
   \      0x110   0x70A2             STRB     R2,[R4, #+2]
   \      0x112   0x68E3             LDR      R3,[R4, #+12]
   \      0x114   0x5C59             LDRB     R1,[R3, R1]
   \      0x116   0x8501             STRH     R1,[R0, #+40]
    458              /* Enable TXE interrupt */
    459              LL_USART_EnableIT_TXE(USART1);
   \      0x118   0x6802             LDR      R2,[R0, #+0]
   \      0x11A   0xF042 0x0280      ORR      R2,R2,#0x80
   \      0x11E   0x6002             STR      R2,[R0, #+0]
    460            }
    461            /**********************for TX interrupt still using this variable , so don't free it!!!!!!!*******/
    462            //wholeFramebuf = (unsigned char*) malloc(1);   //for 
    463            return 0;
   \                     ??TxProcess_6: (+1)
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??TxProcess_3: (+1)
   \      0x124   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x128   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x12C   0x2001             MOVS     R0,#+1
   \      0x12E   0xBD76             POP      {R1,R2,R4-R6,PC}
    464          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6160             STR      R0,[R4, #+20]
   \        0x2   0xB910             CBNZ.N   R0,??Subroutine3_0
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0x7020             STRB     R0,[R4, #+0]
   \                     ??Subroutine3_0: (+1)
   \        0xA   0x4770             BX       LR
    465          
    466          
    467          
    468          
    469          /**
    470            * @brief  Function called in case of error detected in USART IT Handler
    471            * @param  None
    472            * @retval None
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          void Error_Callback(void)
    475          {
    476            __IO uint32_t isr_reg;
    477          
    478            /* Disable USARTx_IRQn */
    479            NVIC_DisableIRQ(USART1_IRQn);
   \                     Error_Callback: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000e184
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x2020             MOVS     R0,#+32
   \        0x6   0x6008             STR      R0,[R1, #+0]
   \        0x8   0xF3BF 0x8F4F      DSB      SY
   \        0xC   0xF3BF 0x8F6F      ISB      SY
    480          
    481            /* Error handling example :
    482              - Read USART ISR register to identify flag that leads to IT raising
    483              - Perform corresponding error handling treatment according to flag
    484            */
    485            isr_reg = LL_USART_ReadReg(USART1, ISR);
   \       0x10   0x....             LDR.N    R2,??DataTable7_6  ;; 0x4001381c
   \       0x12   0x6810             LDR      R0,[R2, #+0]
   \       0x14   0x9000             STR      R0,[SP, #+0]
    486            if (isr_reg & LL_USART_ISR_NE)
   \       0x16   0x9900             LDR      R1,[SP, #+0]
    487            {
    488              /* case Noise Error flag is raised : ... */
    489          //    LED_Blinking(LED_BLINK_FAST);
    490            }
    491            else
    492            {
    493              /* Unexpected IT source : Set LED to Blinking mode to indicate error occurs */
    494          //    LED_Blinking(LED_BLINK_ERROR);
    495            }
    496          }
   \       0x18   0xB001             ADD      SP,SP,#+4
   \       0x1A   0x4770             BX       LR               ;; return
    497          
    498          /**
    499            * @brief This function handles USART1 global interrupt / usart1 wake-up interrupt through EXTI line 26.
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void USART1_IRQHandler(void)
    502          {
   \                     USART1_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    503            /* USER CODE BEGIN USART1_IRQn 0 */
    504            /* Check RXNE flag value in ISR register */
    505            if (LL_USART_IsActiveFlag_RXNE(USART1) && LL_USART_IsEnabledIT_RXNE(USART1))
   \        0x2   0x....             LDR.N    R4,??DataTable7_1  ;; 0x40013800
   \        0x4   0x69E0             LDR      R0,[R4, #+28]
   \        0x6   0x0680             LSLS     R0,R0,#+26
   \        0x8   0xD504             BPL.N    ??USART1_IRQHandler_0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x0680             LSLS     R0,R0,#+26
   \        0xE   0xBF48             IT       MI
    506            {
    507              /* RXNE flag will be cleared by reading of RDR register (done in call) */
    508              /* Call function in charge of handling Character reception */
    509              USART1_CharReception_Callback();
   \       0x10   0x....'....        BLMI     USART1_CharReception_Callback
    510            }
    511            
    512            if (LL_USART_IsEnabledIT_TXE(USART1) && LL_USART_IsActiveFlag_TXE(USART1))
   \                     ??USART1_IRQHandler_0: (+1)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x0600             LSLS     R0,R0,#+24
   \       0x18   0xD504             BPL.N    ??USART1_IRQHandler_1
   \       0x1A   0x69E0             LDR      R0,[R4, #+28]
   \       0x1C   0x0600             LSLS     R0,R0,#+24
   \       0x1E   0xBF48             IT       MI
    513            {
    514              /* TXE flag will be automatically cleared when writing new data in TDR register */
    515          
    516              /* Call function in charge of handling empty DR => will lead to transmission of next character */
    517              USART1_TXEmpty_Callback();
   \       0x20   0x....'....        BLMI     USART1_TXEmpty_Callback
    518            }
    519          
    520            if (LL_USART_IsEnabledIT_TC(USART1) && LL_USART_IsActiveFlag_TC(USART1))
   \                     ??USART1_IRQHandler_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x0640             LSLS     R0,R0,#+25
   \       0x28   0xD504             BPL.N    ??USART1_IRQHandler_2
   \       0x2A   0x69E0             LDR      R0,[R4, #+28]
   \       0x2C   0x0640             LSLS     R0,R0,#+25
   \       0x2E   0xBF44             ITT      MI
   \       0x30   0x2140             MOVMI    R1,#+64
   \       0x32   0x6221             STRMI    R1,[R4, #+32]
    521            {
    522              /* Clear TC flag */
    523              LL_USART_ClearFlag_TC(USART1);
    524              /* Call function in charge of handling end of transmission of sent character
    525                 and prepare next charcater transmission */
    526              USART1_CharTransmitComplete_Callback();
    527            }
    528            
    529            if (LL_USART_IsEnabledIT_ERROR(USART1) && LL_USART_IsActiveFlag_NE(USART1))
   \                     ??USART1_IRQHandler_2: (+1)
   \       0x34   0x68A0             LDR      R0,[R4, #+8]
   \       0x36   0x07C0             LSLS     R0,R0,#+31
   \       0x38   0xD505             BPL.N    ??USART1_IRQHandler_3
   \       0x3A   0x69E0             LDR      R0,[R4, #+28]
   \       0x3C   0x0740             LSLS     R0,R0,#+29
   \       0x3E   0xD502             BPL.N    ??USART1_IRQHandler_3
    530            {
    531              /* Call Error function */
    532              Error_Callback();
   \       0x40   0xE8BD 0x4010      POP      {R4,LR}
   \       0x44   0x....             B.N      Error_Callback
    533            }
    534            /* USER CODE END usart1_IRQn 0 */
    535            /* USER CODE BEGIN usart1_IRQn 1 */
    536          
    537            /* USER CODE END usart1_IRQn 1 */
    538          }
   \                     ??USART1_IRQHandler_3: (+1)
   \       0x46   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x4002'1014        DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x4001'3800        DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x4800'0400        DC32     0x48000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x4001'3824        DC32     0x40013824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     reallocError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0xE000'E184        DC32     0xe000e184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x4001'381C        DC32     0x4001381c
    539          
    540          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   Error_Callback
      64   MX_USART1_UART_Init
        64   -> LL_GPIO_Init
        64   -> LL_USART_Init
        64   -> memset
      24   TxProcess
        24   -> AckDatSet
        24   -> Calculate_CRC
        24   -> IsAckBufFull
        24   -> RingBuf_GetUsedNumOfElements
        24   -> RingBuf_Observe
        24   -> RingBuf_ReadBlock
        24   -> realloc
       8   USART1_CharReception_Callback
         8   -> RingBuf_WriteCharacter
       0   USART1_CharTransmitComplete_Callback
       8   USART1_IRQHandler
         0   -> Error_Callback
         8   -> USART1_CharReception_Callback
         8   -> USART1_TXEmpty_Callback
       0   USART1_TXEmpty_Callback
      40   protocolHeaderfetch
        40   -> AckDeRegistered
        40   -> Calculate_CRC
        40   -> RingBuf_GetPointerToRingBuf
        40   -> RingBuf_Observe
        40   -> RingBuf_ReadBlock
        40   -> RingBuf_Search
        40   -> RingBuf_WriteBlock
        40   -> Set_ValidRx
        40   -> memset
        40   -> realloc
       0   usart1_Init
         0   -> MX_USART1_UART_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
      12  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
      12  ?Subroutine3
       8  ?_0
      28  Error_Callback
     190  MX_USART1_UART_Init
     304  TxProcess
      28  USART1_CharReception_Callback
       2  USART1_CharTransmitComplete_Callback
      72  USART1_IRQHandler
      42  USART1_TXEmpty_Callback
       1  UartReady
       4  autoAckControl_u32
     440  protocolHeaderfetch
      24  reallocError
          usart1CaptureLen
          indexTx
          ubSizeToSend
          dataLen
          UniProtocolState
          uwCRCValue
          usart1Control
          wholeFramebuf
          protocolBuf
          headerFramebuf
       2  usart1_Init

 
    29 bytes in section .bss
 1'188 bytes in section .text
 
 1'188 bytes of CODE memory
    29 bytes of DATA memory

Errors: none
Warnings: none
