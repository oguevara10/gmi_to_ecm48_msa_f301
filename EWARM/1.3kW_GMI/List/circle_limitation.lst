###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:25
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\circle_limitation.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW2C4E.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\circle_limitation.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\circle_limitation.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\circle_limitation.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\MCSDK_v5.4.4-Full\MotorControl\MCSDK\MCLib\Any\Src\circle_limitation.c
      1          /**
      2            ******************************************************************************
      3            * @file    circle_limitation.c
      4            * @author  Motor Control SDK Team, ST Microelectronics
      5            * @brief   This file provides the functions that implement the circle
      6            *          limitation feature of the STM32 Motor Control SDK.
      7            *
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                             www.st.com/SLA0044
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "circle_limitation.h"
     24          #include "mc_math.h"
     25          #include "mc_type.h"
     26          
     27          /** @addtogroup MCSDK
     28            * @{
     29            */
     30          
     31          /** @defgroup CircleLimitation Circle Limitation
     32            * @brief Circle Limitation component of the Motor Control SDK
     33            *
     34            * @todo Document the Circle Limitation "module".
     35            *
     36            * @{
     37            */
     38          
     39          #if defined (CIRCLE_LIMITATION_VD)
     40          __weak qd_t Circle_Limitation(CircleLimitation_Handle_t * pHandle, qd_t Vqd)
     41          {
     42            int32_t MaxModule;
     43            int32_t square_q;
     44            int32_t square_temp;
     45            int32_t square_d;
     46            int32_t square_sum;
     47            int32_t square_limit;
     48            int32_t vd_square_limit;
     49            int32_t new_q;
     50            int32_t new_d;
     51            qd_t Local_Vqd=Vqd;
     52          
     53            MaxModule = pHandle->MaxModule;
     54          
     55            square_q = (int32_t)(Vqd.q) * Vqd.q;
     56            square_d = (int32_t)(Vqd.d) * Vqd.d;
     57            square_limit = MaxModule * MaxModule;
     58            vd_square_limit = pHandle->MaxVd * pHandle->MaxVd;
     59            square_sum = square_q + square_d;
     60          
     61            if (square_sum > square_limit)
     62            {
     63              if(square_d <= vd_square_limit)
     64              {
     65                square_temp = square_limit - square_d;
     66                new_q = MCM_Sqrt(square_temp);
     67                if(Vqd.q < 0)
     68                {
     69                  new_q = -new_q;
     70                }
     71                new_d = Vqd.d;
     72              }
     73              else
     74              {
     75                new_d = pHandle->MaxVd;
     76                if(Vqd.d < 0)
     77                {
     78                  new_d = -new_d;
     79                }
     80          
     81                square_temp = square_limit - vd_square_limit;
     82                new_q = MCM_Sqrt(square_temp);
     83                if(Vqd.q < 0)
     84                {
     85                  new_q = - new_q;
     86                }
     87              }
     88              Local_Vqd.q = new_q;
     89              Local_Vqd.d = new_d;
     90            }
     91            return(Local_Vqd);
     92          }
     93          #else
     94          /**
     95            * @brief Check whether Vqd.q^2 + Vqd.d^2 <= 32767^2
     96            *        and if not it applies a limitation keeping constant ratio
     97            *        Vqd.q / Vqd.d
     98            * @param  pHandle pointer on the related component instance
     99            * @param  Vqd Voltage in qd reference frame
    100            * @retval qd_t Limited Vqd vector
    101            */

   \                                 In section .text, align 2
    102          __weak qd_t Circle_Limitation( CircleLimitation_Handle_t * pHandle, qd_t Vqd )
    103          {
   \                     Circle_Limitation: (+1)
   \        0x0   0xB513             PUSH     {R0,R1,R4,LR}
    104            uint16_t table_element;
    105            uint32_t uw_temp;
    106            int32_t  sw_temp;
    107            qd_t local_vqd = Vqd;
   \        0x2   0x9100             STR      R1,[SP, #+0]
    108          
    109            sw_temp = ( int32_t )( Vqd.q ) * Vqd.q +
    110                      ( int32_t )( Vqd.d ) * Vqd.d;
    111          
    112            uw_temp = ( uint32_t ) sw_temp;
   \        0x4   0xF9BD 0x3004      LDRSH    R3,[SP, #+4]
   \        0x8   0xF9BD 0x2006      LDRSH    R2,[SP, #+6]
   \        0xC   0xFB13 0xF103      SMULBB   R1,R3,R3
   \       0x10   0xFB12 0x1402      SMLABB   R4,R2,R2,R1
    113          
    114            /* uw_temp min value 0, max value 32767*32767 */
    115            if ( uw_temp > ( uint32_t )( pHandle->MaxModule ) * pHandle->MaxModule )
   \       0x14   0x8801             LDRH     R1,[R0, #+0]
   \       0x16   0x4349             MULS     R1,R1,R1
   \       0x18   0x42A1             CMP      R1,R4
   \       0x1A   0xD215             BCS.N    ??Circle_Limitation_0
    116            {
    117          
    118              uw_temp /= ( uint32_t )( 16777216 );
    119          
    120              /* wtemp min value pHandle->Start_index, max value 127 */
    121              uw_temp -= pHandle->Start_index;
    122          
    123              /* uw_temp min value 0, max value 127 - pHandle->Start_index */
    124              table_element = pHandle->Circle_limit_table[( uint8_t )uw_temp];
   \       0x1C   0xF890 0x10B2      LDRB     R1,[R0, #+178]
   \       0x20   0x0E24             LSRS     R4,R4,#+24
   \       0x22   0x1A64             SUBS     R4,R4,R1
   \       0x24   0xB2E4             UXTB     R4,R4
   \       0x26   0xEB00 0x0044      ADD      R0,R0,R4, LSL #+1
   \       0x2A   0x8880             LDRH     R0,[R0, #+4]
    125          
    126              sw_temp = Vqd.q * ( int32_t )table_element;
    127              local_vqd.q = ( int16_t )( sw_temp / 32768 );
   \       0x2C   0x4343             MULS     R3,R0,R3
    128          
    129              sw_temp = Vqd.d * ( int32_t )( table_element );
    130              local_vqd.d = ( int16_t )( sw_temp / 32768 );
   \       0x2E   0x4342             MULS     R2,R0,R2
   \       0x30   0x1399             ASRS     R1,R3,#+14
   \       0x32   0x1390             ASRS     R0,R2,#+14
   \       0x34   0xEB03 0x4351      ADD      R3,R3,R1, LSR #+17
   \       0x38   0xEB02 0x4250      ADD      R2,R2,R0, LSR #+17
   \       0x3C   0x13DB             ASRS     R3,R3,#+15
   \       0x3E   0x13D2             ASRS     R2,R2,#+15
   \       0x40   0xF8AD 0x3000      STRH     R3,[SP, #+0]
   \       0x44   0xF8AD 0x2002      STRH     R2,[SP, #+2]
    131            }
    132          
    133            return ( local_vqd );
   \                     ??Circle_Limitation_0: (+1)
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    134          }
    135          #endif
    136          
    137          /**
    138            * @}
    139            */
    140          
    141          /**
    142            * @}
    143            */
    144          
    145          /************************ (C) COPYRIGHT 2019 STMicroelectronics *****END OF FILE****/
    146          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Circle_Limitation


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      76  Circle_Limitation

 
 76 bytes in section .text
 
 0 bytes of CODE memory (+ 76 bytes shared)

Errors: none
Warnings: none
