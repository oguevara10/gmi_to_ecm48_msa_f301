###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  11:13:05
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_flash_ex.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW35AC.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_flash_ex.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\stm32f3xx_hal_flash_ex.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\stm32f3xx_hal_flash_ex.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\Drivers\STM32F3xx_HAL_Driver\Src\stm32f3xx_hal_flash_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f3xx_hal_flash_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended FLASH HAL module driver.
      6            *    
      7            *          This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *           + Extended Initialization/de-initialization functions
     10            *           + Extended I/O operation functions
     11            *           + Extended Peripheral Control functions 
     12            *         
     13            @verbatim
     14            ==============================================================================
     15                         ##### Flash peripheral extended features  #####
     16            ==============================================================================
     17                     
     18                                ##### How to use this driver #####
     19            ==============================================================================
     20            [..] This driver provides functions to configure and program the FLASH memory 
     21                 of all STM32F3xxx devices. It includes
     22                 
     23                  (++) Set/Reset the write protection
     24                  (++) Program the user Option Bytes
     25                  (++) Get the Read protection Level
     26            
     27            @endverbatim
     28            ******************************************************************************
     29            * @attention
     30            *
     31            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     32            * All rights reserved.</center></h2>
     33            *
     34            * This software component is licensed by ST under BSD 3-Clause license,
     35            * the "License"; You may not use this file except in compliance with the
     36            * License. You may obtain a copy of the License at:
     37            *                        opensource.org/licenses/BSD-3-Clause
     38            *
     39            ******************************************************************************
     40            */
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32f3xx_hal.h"
     44          
     45          /** @addtogroup STM32F3xx_HAL_Driver
     46            * @{
     47            */
     48          #ifdef HAL_FLASH_MODULE_ENABLED
     49          
     50          /** @addtogroup FLASH
     51            * @{
     52            */
     53          /** @addtogroup FLASH_Private_Variables
     54           * @{
     55           */
     56          /* Variables used for Erase pages under interruption*/
     57          extern FLASH_ProcessTypeDef pFlash;
     58          /**
     59            * @}
     60            */
     61          
     62          /**
     63            * @}
     64            */
     65            
     66          /** @defgroup FLASHEx FLASHEx
     67            * @brief FLASH HAL Extension module driver
     68            * @{
     69            */
     70          
     71          /* Private typedef -----------------------------------------------------------*/
     72          /* Private define ------------------------------------------------------------*/
     73          /** @defgroup FLASHEx_Private_Constants FLASHEx Private Constants
     74           * @{
     75           */
     76          #define FLASH_POSITION_IWDGSW_BIT        (uint32_t)POSITION_VAL(FLASH_OBR_IWDG_SW)
     77          #define FLASH_POSITION_OB_USERDATA0_BIT  (uint32_t)POSITION_VAL(FLASH_OBR_DATA0)
     78          #define FLASH_POSITION_OB_USERDATA1_BIT  (uint32_t)POSITION_VAL(FLASH_OBR_DATA1)
     79          /**
     80            * @}
     81            */
     82          
     83          /* Private macro -------------------------------------------------------------*/
     84          /** @defgroup FLASHEx_Private_Macros FLASHEx Private Macros
     85            * @{
     86            */
     87          /**
     88            * @}
     89            */ 
     90          
     91          /* Private variables ---------------------------------------------------------*/
     92          /* Private function prototypes -----------------------------------------------*/
     93          /** @defgroup FLASHEx_Private_Functions FLASHEx Private Functions
     94           * @{
     95           */
     96          /* Erase operations */
     97          static void              FLASH_MassErase(void);
     98          void    FLASH_PageErase(uint32_t PageAddress);
     99          
    100          /* Option bytes control */
    101          static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WriteProtectPage);
    102          static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WriteProtectPage);
    103          static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel);
    104          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t UserConfig);
    105          static HAL_StatusTypeDef FLASH_OB_ProgramData(uint32_t Address, uint8_t Data);
    106          static uint32_t          FLASH_OB_GetWRP(void);
    107          static uint32_t          FLASH_OB_GetRDP(void);
    108          static uint8_t           FLASH_OB_GetUser(void);
    109          
    110          /**
    111            * @}
    112            */
    113          
    114          /* Exported functions ---------------------------------------------------------*/
    115          /** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
    116            * @{
    117            */
    118            
    119          /** @defgroup FLASHEx_Exported_Functions_Group1 FLASHEx Memory Erasing functions
    120           *  @brief   FLASH Memory Erasing functions
    121            *
    122          @verbatim   
    123            ==============================================================================
    124                          ##### FLASH Erasing Programming functions ##### 
    125            ==============================================================================
    126          
    127              [..] The FLASH Memory Erasing functions, includes the following functions:
    128              (+) @ref HAL_FLASHEx_Erase: return only when erase has been done
    129              (+) @ref HAL_FLASHEx_Erase_IT: end of erase is done when @ref HAL_FLASH_EndOfOperationCallback 
    130                  is called with parameter 0xFFFFFFFF
    131          
    132              [..] Any operation of erase should follow these steps:
    133              (#) Call the @ref HAL_FLASH_Unlock() function to enable the flash control register and 
    134                  program memory access.
    135              (#) Call the desired function to erase page.
    136              (#) Call the @ref HAL_FLASH_Lock() to disable the flash program memory access 
    137                 (recommended to protect the FLASH memory against possible unwanted operation).
    138          
    139          @endverbatim
    140            * @{
    141            */
    142            
    143          
    144          /**
    145            * @brief  Perform a mass erase or erase the specified FLASH memory pages
    146            * @note   To correctly run this function, the @ref HAL_FLASH_Unlock() function
    147            *         must be called before.
    148            *         Call the @ref HAL_FLASH_Lock() to disable the flash memory access 
    149            *         (recommended to protect the FLASH memory against possible unwanted operation)
    150            * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    151            *         contains the configuration information for the erasing.
    152            *
    153            * @param[out]  PageError pointer to variable  that
    154            *         contains the configuration information on faulty page in case of error
    155            *         (0xFFFFFFFF means that all the pages have been correctly erased)
    156            *
    157            * @retval HAL_StatusTypeDef HAL Status
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
    160          {
   \                     HAL_FLASHEx_Erase: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    161            HAL_StatusTypeDef status = HAL_ERROR;
    162            uint32_t address = 0U;
    163          
    164            /* Process Locked */
    165            __HAL_LOCK(&pFlash);
   \        0x4   0x....'....        LDR.W    R6,??DataTable9
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x7E30             LDRB     R0,[R6, #+24]
   \        0xC   0x2501             MOVS     R5,#+1
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0x4688             MOV      R8,R1
   \       0x12   0xBF08             IT       EQ
   \       0x14   0x2002             MOVEQ    R0,#+2
   \       0x16   0xD039             BEQ.N    ??HAL_FLASHEx_Erase_0
   \       0x18   0x7635             STRB     R5,[R6, #+24]
    166          
    167            /* Check the parameters */
    168            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    169          
    170            if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
   \       0x1A   0xF24C 0x3950      MOVW     R9,#+50000
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x....             LDR.N    R4,??DataTable9_1  ;; 0x40022010
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0x4648             MOV      R0,R9
   \       0x26   0xD10D             BNE.N    ??HAL_FLASHEx_Erase_1
    171            {
    172                /* Mass Erase requested for Bank1 */
    173                /* Wait for last operation to be completed */
    174                if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
   \       0x28   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x2C   0xBB58             CBNZ.N   R0,??HAL_FLASHEx_Erase_2
    175                {
    176                  /*Mass erase to be done*/
    177                  FLASH_MassErase();
   \       0x2E   0x....'....        BL       FLASH_MassErase
    178                  
    179                  /* Wait for last operation to be completed */
    180                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \       0x32   0x4648             MOV      R0,R9
   \       0x34   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x38   0x4605             MOV      R5,R0
    181                  
    182                  /* If the erase operation is completed, disable the MER Bit */
    183                  CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0xF020 0x0004      BIC      R0,R0,#0x4
   \       0x40   0x6020             STR      R0,[R4, #+0]
   \       0x42   0xE020             B.N      ??HAL_FLASHEx_Erase_2
    184                }
    185            }
    186            else
    187            {
    188              /* Page Erase is requested */
    189              /* Check the parameters */
    190              assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    191              assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
    192              
    193                /* Page Erase requested on address located on bank1 */
    194                /* Wait for last operation to be completed */
    195                if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
   \                     ??HAL_FLASHEx_Erase_1: (+1)
   \       0x44   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x48   0xB9E8             CBNZ.N   R0,??HAL_FLASHEx_Erase_2
    196                {
    197                  /*Initialization of PageError variable*/
    198                  *PageError = 0xFFFFFFFFU;
   \       0x4A   0xF04F 0x30FF      MOV      R0,#-1
   \       0x4E   0xF8C8 0x0000      STR      R0,[R8, #+0]
    199                  
    200                  /* Erase page by page to be done*/
    201                  for(address = pEraseInit->PageAddress;
   \       0x52   0xF8D7 0xA004      LDR      R10,[R7, #+4]
   \       0x56   0xE001             B.N      ??HAL_FLASHEx_Erase_3
    202                      address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
    203                      address += FLASH_PAGE_SIZE)
   \                     ??HAL_FLASHEx_Erase_4: (+1)
   \       0x58   0xF50A 0x6A00      ADD      R10,R10,#+2048
   \                     ??HAL_FLASHEx_Erase_3: (+1)
   \       0x5C   0x68B8             LDR      R0,[R7, #+8]
   \       0x5E   0x6879             LDR      R1,[R7, #+4]
   \       0x60   0xEB01 0x21C0      ADD      R1,R1,R0, LSL #+11
   \       0x64   0x458A             CMP      R10,R1
   \       0x66   0xD20E             BCS.N    ??HAL_FLASHEx_Erase_2
    204                  {
    205                    FLASH_PageErase(address);
   \       0x68   0x4650             MOV      R0,R10
   \       0x6A   0x....'....        BL       FLASH_PageErase
    206                    
    207                    /* Wait for last operation to be completed */
    208                    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \       0x6E   0x4648             MOV      R0,R9
   \       0x70   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x74   0x4605             MOV      R5,R0
    209                    
    210                    /* If the erase operation is completed, disable the PER Bit */
    211                    CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0xF020 0x0002      BIC      R0,R0,#0x2
    212                    
    213                    if (status != HAL_OK)
   \       0x7C   0x0029             MOVS     R1,R5
   \       0x7E   0x6020             STR      R0,[R4, #+0]
   \       0x80   0xD0EA             BEQ.N    ??HAL_FLASHEx_Erase_4
    214                    {
    215                      /* In case of error, stop erase procedure and return the faulty address */
    216                      *PageError = address;
   \       0x82   0xF8C8 0xA000      STR      R10,[R8, #+0]
    217                      break;
    218                    }
    219                  }
    220                }
    221            }
    222          
    223            /* Process Unlocked */
    224            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_Erase_2: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x7630             STRB     R0,[R6, #+24]
    225          
    226            return status;
   \       0x8A   0x4628             MOV      R0,R5
   \                     ??HAL_FLASHEx_Erase_0: (+1)
   \       0x8C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    227          }
    228          
    229          /**
    230            * @brief  Perform a mass erase or erase the specified FLASH memory pages with interrupt enabled
    231            * @note   To correctly run this function, the @ref HAL_FLASH_Unlock() function
    232            *         must be called before.
    233            *         Call the @ref HAL_FLASH_Lock() to disable the flash memory access 
    234            *         (recommended to protect the FLASH memory against possible unwanted operation)
    235            * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    236            *         contains the configuration information for the erasing.
    237            *
    238            * @retval HAL_StatusTypeDef HAL Status
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
    241          {
   \                     HAL_FLASHEx_Erase_IT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    242            HAL_StatusTypeDef status = HAL_OK;
    243          
    244            /* Process Locked */
    245            __HAL_LOCK(&pFlash);
   \        0x2   0x....             LDR.N    R2,??DataTable9
   \        0x4   0x7E11             LDRB     R1,[R2, #+24]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE.N    ??HAL_FLASHEx_Erase_IT_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xBD02             POP      {R1,PC}
   \                     ??HAL_FLASHEx_Erase_IT_0: (+1)
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0x7613             STRB     R3,[R2, #+24]
    246          
    247            /* If procedure already ongoing, reject the next one */
    248            if (pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \       0x12   0x7811             LDRB     R1,[R2, #+0]
   \       0x14   0xB109             CBZ.N    R1,??HAL_FLASHEx_Erase_IT_1
    249            {
    250              return HAL_ERROR;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD02             POP      {R1,PC}
    251            }
    252            
    253            /* Check the parameters */
    254            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    255          
    256            /* Enable End of FLASH Operation and Error source interrupts */
    257            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \                     ??HAL_FLASHEx_Erase_IT_1: (+1)
   \       0x1A   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40022010
   \       0x1C   0x680B             LDR      R3,[R1, #+0]
   \       0x1E   0xF443 0x53A0      ORR      R3,R3,#0x1400
   \       0x22   0x600B             STR      R3,[R1, #+0]
    258          
    259            if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x2901             CMP      R1,#+1
   \       0x28   0xD104             BNE.N    ??HAL_FLASHEx_Erase_IT_2
    260            {
    261              /*Mass erase to be done*/
    262              pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x7010             STRB     R0,[R2, #+0]
    263                  FLASH_MassErase();
   \       0x2E   0x....'....        BL       FLASH_MassErase
   \       0x32   0xE008             B.N      ??HAL_FLASHEx_Erase_IT_3
    264            }
    265            else
    266            {
    267              /* Erase by page to be done*/
    268          
    269              /* Check the parameters */
    270              assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    271              assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
    272          
    273              pFlash.ProcedureOnGoing = FLASH_PROC_PAGEERASE;
   \                     ??HAL_FLASHEx_Erase_IT_2: (+1)
   \       0x34   0x2101             MOVS     R1,#+1
   \       0x36   0x7011             STRB     R1,[R2, #+0]
    274              pFlash.DataRemaining = pEraseInit->NbPages;
   \       0x38   0x6883             LDR      R3,[R0, #+8]
   \       0x3A   0x6053             STR      R3,[R2, #+4]
    275              pFlash.Address = pEraseInit->PageAddress;
   \       0x3C   0x6841             LDR      R1,[R0, #+4]
   \       0x3E   0x6091             STR      R1,[R2, #+8]
    276          
    277              /*Erase 1st page and wait for IT*/
    278              FLASH_PageErase(pEraseInit->PageAddress);
   \       0x40   0x6840             LDR      R0,[R0, #+4]
   \       0x42   0x....'....        BL       FLASH_PageErase
    279            }
    280          
    281            return status;
   \                     ??HAL_FLASHEx_Erase_IT_3: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xBD02             POP      {R1,PC}          ;; return
    282          }
    283          
    284          /**
    285            * @}
    286            */
    287          
    288          /** @defgroup FLASHEx_Exported_Functions_Group2 Option Bytes Programming functions
    289           *  @brief   Option Bytes Programming functions
    290            *
    291          @verbatim   
    292            ==============================================================================
    293                          ##### Option Bytes Programming functions ##### 
    294            ==============================================================================  
    295              [..]
    296              This subsection provides a set of functions allowing to control the FLASH 
    297              option bytes operations.
    298          
    299          @endverbatim
    300            * @{
    301            */
    302          
    303          /**
    304            * @brief  Erases the FLASH option bytes.
    305            * @note   This functions erases all option bytes except the Read protection (RDP).
    306            *         The function @ref HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    307            *         The function @ref HAL_FLASH_OB_Unlock() should be called before to unlock the options bytes
    308            *         The function @ref HAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes
    309            *         (system reset will occur)
    310            * @retval HAL status
    311            */
    312          

   \                                 In section .text, align 2, keep-with-next
    313          HAL_StatusTypeDef HAL_FLASHEx_OBErase(void)
    314          {
   \                     HAL_FLASHEx_OBErase: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    315            uint8_t rdptmp = OB_RDP_LEVEL_0;
    316            HAL_StatusTypeDef status = HAL_ERROR;
    317          
    318            /* Get the actual read protection Option Byte value */
    319            rdptmp = FLASH_OB_GetRDP();
   \        0x2   0x....'....        BL       FLASH_OB_GetRDP
   \        0x6   0x....'....        BL       ?Subroutine1
    320          
    321            /* Wait for last operation to be completed */
    322            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    323          
    324            if(status == HAL_OK)
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xA   0x0001             MOVS     R1,R0
   \        0xC   0xD108             BNE.N    ??HAL_FLASHEx_OBErase_0
    325            {
    326              /* Clean the error context */
    327              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \        0xE   0x....'....        BL       ?Subroutine0
    328          
    329              /* If the previous operation is completed, proceed to erase the option bytes */
    330              SET_BIT(FLASH->CR, FLASH_CR_OPTER);
    331              SET_BIT(FLASH->CR, FLASH_CR_STRT);
    332          
    333              /* Wait for last operation to be completed */
    334              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    335          
    336              /* If the erase operation is completed, disable the OPTER Bit */
    337              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTER);
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x12   0x....'....        BL       ?Subroutine5
    338          
    339              if(status == HAL_OK)
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x16   0xD103             BNE.N    ??HAL_FLASHEx_OBErase_0
    340              {
    341                /* Restore the last read protection Option Byte value */
    342                status = FLASH_OB_RDP_LevelConfig(rdptmp);
   \       0x18   0xB2E0             UXTB     R0,R4
   \       0x1A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x1E   0x....             B.N      FLASH_OB_RDP_LevelConfig
    343              }
    344            }
    345          
    346            /* Return the erase status */
    347            return status;
   \                     ??HAL_FLASHEx_OBErase_0: (+1)
   \       0x20   0xBD70             POP      {R4-R6,PC}       ;; return
    348          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x6831             LDR      R1,[R6, #+0]
   \        0x2   0xF021 0x0120      BIC      R1,R1,#0x20
   \        0x6   0x0002             MOVS     R2,R0
   \        0x8   0x6031             STR      R1,[R6, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0xF24C 0x3550      MOVW     R5,#+50000
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....'....        B.W      FLASH_WaitForLastOperation

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable9
   \        0x2   0x....             LDR.N    R6,??DataTable9_1  ;; 0x40022010
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x61C8             STR      R0,[R1, #+28]
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0xF040 0x0020      ORR      R0,R0,#0x20
   \        0xE   0x6030             STR      R0,[R6, #+0]
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x6831             LDR      R1,[R6, #+0]
   \       0x14   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x18   0x6031             STR      R1,[R6, #+0]
   \       0x1A   0x....'....        B.W      FLASH_WaitForLastOperation
    349          
    350          /**
    351            * @brief  Program option bytes
    352            * @note   The function @ref HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    353            *         The function @ref HAL_FLASH_OB_Unlock() should be called before to unlock the options bytes
    354            *         The function @ref HAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes
    355            *         (system reset will occur)
    356            *
    357            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    358            *         contains the configuration information for the programming.
    359            *
    360            * @retval HAL_StatusTypeDef HAL Status
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
    363          {
   \                     HAL_FLASHEx_OBProgram: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    364            HAL_StatusTypeDef status = HAL_ERROR;
    365          
    366            /* Process Locked */
    367            __HAL_LOCK(&pFlash);
   \        0x4   0x....'....        LDR.W    R9,??DataTable9
   \        0x8   0xF899 0x2018      LDRB     R2,[R9, #+24]
   \        0xC   0x4604             MOV      R4,R0
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x2A01             CMP      R2,#+1
   \       0x12   0xBF08             IT       EQ
   \       0x14   0x2002             MOVEQ    R0,#+2
   \       0x16   0xF000 0x8082      BEQ.W    ??HAL_FLASHEx_OBProgram_0
   \       0x1A   0xF889 0x0018      STRB     R0,[R9, #+24]
    368          
    369            /* Check the parameters */
    370            assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
    371          
    372            /* Write protection configuration */
    373            if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
   \       0x1E   0xF24C 0x3850      MOVW     R8,#+50000
   \       0x22   0x7821             LDRB     R1,[R4, #+0]
   \       0x24   0x....             LDR.N    R6,??DataTable9_2  ;; 0x1ffff802
   \       0x26   0x....             LDR.N    R7,??DataTable9_1  ;; 0x40022010
   \       0x28   0x07CA             LSLS     R2,R1,#+31
   \       0x2A   0xD53F             BPL.N    ??HAL_FLASHEx_OBProgram_1
    374            {
    375              assert_param(IS_WRPSTATE(pOBInit->WRPState));
    376              if (pOBInit->WRPState == OB_WRPSTATE_ENABLE)
   \       0x2C   0x6861             LDR      R1,[R4, #+4]
   \       0x2E   0x68A0             LDR      R0,[R4, #+8]
   \       0x30   0x2901             CMP      R1,#+1
   \       0x32   0x6939             LDR      R1,[R7, #+16]
   \       0x34   0xD11A             BNE.N    ??HAL_FLASHEx_OBProgram_2
    377              {
    378                /* Enable of Write protection on the selected page */
    379                status = FLASH_OB_EnableWRP(pOBInit->WRPPage);
   \       0x36   0xEA21 0x0000      BIC      R0,R1,R0
   \       0x3A   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x3E   0x0001             MOVS     R1,R0
   \       0x40   0xD132             BNE.N    ??CrossCallReturnLabel_6
   \       0x42   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x46   0x0001             MOVS     R1,R0
   \       0x48   0xD12E             BNE.N    ??CrossCallReturnLabel_6
   \       0x4A   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x4E   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_3
   \       0x50   0x88F0             LDRH     R0,[R6, #+6]
   \       0x52   0x4005             ANDS     R5,R5,R0
   \       0x54   0x80F5             STRH     R5,[R6, #+6]
   \       0x56   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x5A   0x0001             MOVS     R1,R0
   \       0x5C   0xD122             BNE.N    ??CrossCallReturnLabel_16
   \                     ??HAL_FLASHEx_OBProgram_3: (+1)
   \       0x5E   0xF1BA 0x0FFF      CMP      R10,#+255
   \       0x62   0xD01F             BEQ.N    ??CrossCallReturnLabel_16
   \       0x64   0x8930             LDRH     R0,[R6, #+8]
   \       0x66   0xEA0A 0x0000      AND      R0,R10,R0
   \       0x6A   0xE018             B.N      ??HAL_FLASHEx_OBProgram_4
    380              }
    381              else
    382              {
    383                /* Disable of Write protection on the selected page */
    384                status = FLASH_OB_DisableWRP(pOBInit->WRPPage);
   \                     ??HAL_FLASHEx_OBProgram_2: (+1)
   \       0x6C   0x4308             ORRS     R0,R0,R1
   \       0x6E   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x72   0x0001             MOVS     R1,R0
   \       0x74   0xD118             BNE.N    ??CrossCallReturnLabel_6
   \       0x76   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x7A   0x0001             MOVS     R1,R0
   \       0x7C   0xD114             BNE.N    ??CrossCallReturnLabel_6
   \       0x7E   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x82   0xD006             BEQ.N    ??HAL_FLASHEx_OBProgram_5
   \       0x84   0x88F0             LDRH     R0,[R6, #+6]
   \       0x86   0x4305             ORRS     R5,R5,R0
   \       0x88   0x80F5             STRH     R5,[R6, #+6]
   \       0x8A   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x8E   0x0001             MOVS     R1,R0
   \       0x90   0xD108             BNE.N    ??CrossCallReturnLabel_16
   \                     ??HAL_FLASHEx_OBProgram_5: (+1)
   \       0x92   0xF1BA 0x0FFF      CMP      R10,#+255
   \       0x96   0xD005             BEQ.N    ??CrossCallReturnLabel_16
   \       0x98   0x8930             LDRH     R0,[R6, #+8]
   \       0x9A   0xEA4A 0x0000      ORR      R0,R10,R0
   \                     ??HAL_FLASHEx_OBProgram_4: (+1)
   \       0x9E   0x8130             STRH     R0,[R6, #+8]
   \       0xA0   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0xA4   0x....'....        BL       ?Subroutine4
    385              }
    386              if (status != HAL_OK)
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0xA8   0x0001             MOVS     R1,R0
   \       0xAA   0xD135             BNE.N    ??CrossCallReturnLabel_8
    387              {
    388                /* Process Unlocked */
    389                __HAL_UNLOCK(&pFlash);
    390                return status;
    391              }
    392            }
    393          
    394            /* Read protection configuration */
    395            if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
   \                     ??HAL_FLASHEx_OBProgram_1: (+1)
   \       0xAC   0x7821             LDRB     R1,[R4, #+0]
   \       0xAE   0x078A             LSLS     R2,R1,#+30
   \       0xB0   0xD504             BPL.N    ??HAL_FLASHEx_OBProgram_6
    396            {
    397              status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
   \       0xB2   0x7B20             LDRB     R0,[R4, #+12]
   \       0xB4   0x....'....        BL       FLASH_OB_RDP_LevelConfig
    398              if (status != HAL_OK)
   \       0xB8   0x0001             MOVS     R1,R0
   \       0xBA   0xD12D             BNE.N    ??CrossCallReturnLabel_8
    399              {
    400                /* Process Unlocked */
    401                __HAL_UNLOCK(&pFlash);
    402                return status;
    403              }
    404            }
    405          
    406            /* USER configuration */
    407            if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
   \                     ??HAL_FLASHEx_OBProgram_6: (+1)
   \       0xBC   0x7821             LDRB     R1,[R4, #+0]
   \       0xBE   0x074A             LSLS     R2,R1,#+29
   \       0xC0   0xD514             BPL.N    ??HAL_FLASHEx_OBProgram_7
    408            {
    409              status = FLASH_OB_UserConfig(pOBInit->USERConfig);
   \       0xC2   0x7B65             LDRB     R5,[R4, #+13]
   \       0xC4   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xC8   0x0001             MOVS     R1,R0
   \       0xCA   0xD10D             BNE.N    ??CrossCallReturnLabel_7
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xF8C9 0x001C      STR      R0,[R9, #+28]
   \       0xD2   0xF045 0x0588      ORR      R5,R5,#0x88
   \       0xD6   0x6839             LDR      R1,[R7, #+0]
   \       0xD8   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0xDC   0x6039             STR      R1,[R7, #+0]
   \       0xDE   0x8035             STRH     R5,[R6, #+0]
   \       0xE0   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0xE4   0x....'....        BL       ?Subroutine4
    410              if (status != HAL_OK)
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0xE8   0x0001             MOVS     R1,R0
   \       0xEA   0xD115             BNE.N    ??CrossCallReturnLabel_8
    411              {
    412                /* Process Unlocked */
    413                __HAL_UNLOCK(&pFlash);
    414                return status;
    415              }
    416            }
    417          
    418            /* DATA configuration*/
    419            if((pOBInit->OptionType & OPTIONBYTE_DATA) == OPTIONBYTE_DATA)
   \                     ??HAL_FLASHEx_OBProgram_7: (+1)
   \       0xEC   0x7821             LDRB     R1,[R4, #+0]
   \       0xEE   0x070A             LSLS     R2,R1,#+28
   \       0xF0   0xD512             BPL.N    ??CrossCallReturnLabel_8
    420            {
    421              status = FLASH_OB_ProgramData(pOBInit->DATAAddress, pOBInit->DATAData);
   \       0xF2   0x7D26             LDRB     R6,[R4, #+20]
   \       0xF4   0x6924             LDR      R4,[R4, #+16]
   \       0xF6   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0xFA   0x0001             MOVS     R1,R0
   \       0xFC   0xD10C             BNE.N    ??CrossCallReturnLabel_8
   \       0xFE   0x2000             MOVS     R0,#+0
   \      0x100   0xF8C9 0x001C      STR      R0,[R9, #+28]
   \      0x104   0x4640             MOV      R0,R8
   \      0x106   0x6839             LDR      R1,[R7, #+0]
   \      0x108   0xF041 0x0110      ORR      R1,R1,#0x10
   \      0x10C   0x6039             STR      R1,[R7, #+0]
   \      0x10E   0x8026             STRH     R6,[R4, #+0]
   \      0x110   0x....'....        BL       FLASH_WaitForLastOperation
   \      0x114   0x....'....        BL       ?Subroutine4
    422              if (status != HAL_OK)
    423              {
    424                /* Process Unlocked */
    425                __HAL_UNLOCK(&pFlash);
    426                return status;
    427              }
    428            }
    429          
    430            /* Process Unlocked */
    431            __HAL_UNLOCK(&pFlash);
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x118   0x2200             MOVS     R2,#+0
   \      0x11A   0xF889 0x2018      STRB     R2,[R9, #+24]
    432          
    433            return status;
   \                     ??HAL_FLASHEx_OBProgram_0: (+1)
   \      0x11E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    434          }
    435          
    436          /**
    437            * @brief  Get the Option byte configuration
    438            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    439            *         contains the configuration information for the programming.
    440            *
    441            * @retval None
    442            */

   \                                 In section .text, align 2, keep-with-next
    443          void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
    444          {
   \                     HAL_FLASHEx_OBGetConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    445            pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER;
   \        0x4   0x2007             MOVS     R0,#+7
   \        0x6   0x6020             STR      R0,[R4, #+0]
    446          
    447            /*Get WRP*/
    448            pOBInit->WRPPage = FLASH_OB_GetWRP();
   \        0x8   0x....             LDR.N    R5,??DataTable9_3  ;; 0x4002201c
   \        0xA   0x6868             LDR      R0,[R5, #+4]
   \        0xC   0x60A0             STR      R0,[R4, #+8]
    449          
    450            /*Get RDP Level*/
    451            pOBInit->RDPLevel = FLASH_OB_GetRDP();
   \        0xE   0x....'....        BL       FLASH_OB_GetRDP
   \       0x12   0x7320             STRB     R0,[R4, #+12]
    452          
    453            /*Get USER*/
    454            pOBInit->USERConfig = FLASH_OB_GetUser();
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x0A00             LSRS     R0,R0,#+8
   \       0x18   0xF000 0x0077      AND      R0,R0,#0x77
   \       0x1C   0x7360             STRB     R0,[R4, #+13]
    455          }
   \       0x1E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    456          
    457          /**
    458            * @brief  Get the Option byte user data
    459            * @param  DATAAdress Address of the option byte DATA
    460            *          This parameter can be one of the following values:
    461            *            @arg @ref OB_DATA_ADDRESS_DATA0
    462            *            @arg @ref OB_DATA_ADDRESS_DATA1
    463            * @retval Value programmed in USER data
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          uint32_t HAL_FLASHEx_OBGetUserData(uint32_t DATAAdress)
    466          {
    467            uint32_t value = 0U;
    468            
    469            if (DATAAdress == OB_DATA_ADDRESS_DATA0)
   \                     HAL_FLASHEx_OBGetUserData: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable9_3  ;; 0x4002201c
   \        0x2   0x....             LDR.N    R2,??DataTable9_4  ;; 0x1ffff804
   \        0x4   0x4290             CMP      R0,R2
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0xD102             BNE.N    ??HAL_FLASHEx_OBGetUserData_0
    470            {
    471              /* Get value programmed in OB USER Data0 */
    472              value = READ_BIT(FLASH->OBR, FLASH_OBR_DATA0) >> FLASH_POSITION_OB_USERDATA0_BIT;
   \        0xA   0xF3C0 0x4007      UBFX     R0,R0,#+16,#+8
   \        0xE   0x4770             BX       LR
    473            }
    474            else
    475            {
    476              /* Get value programmed in OB USER Data1 */
    477              value = READ_BIT(FLASH->OBR, FLASH_OBR_DATA1) >> FLASH_POSITION_OB_USERDATA1_BIT;
   \                     ??HAL_FLASHEx_OBGetUserData_0: (+1)
   \       0x10   0x0E00             LSRS     R0,R0,#+24
    478            }
    479            
    480            return value;
   \       0x12   0x4770             BX       LR               ;; return
    481          }
    482          
    483          /**
    484            * @}
    485            */
    486          
    487          /**
    488            * @}
    489            */
    490          
    491          /** @addtogroup FLASHEx_Private_Functions
    492           * @{
    493           */
    494          
    495          /**
    496            * @brief  Full erase of FLASH memory Bank 
    497            *
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          static void FLASH_MassErase(void)
    501          {
    502            /* Clean the error context */
    503            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_MassErase: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable9
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x61C8             STR      R0,[R1, #+28]
    504          
    505              /* Only bank1 will be erased*/
    506              SET_BIT(FLASH->CR, FLASH_CR_MER);
   \        0x6   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40022010
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0xF042 0x0204      ORR      R2,R2,#0x4
   \        0xE   0x6002             STR      R2,[R0, #+0]
    507              SET_BIT(FLASH->CR, FLASH_CR_STRT);
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x16   0x6001             STR      R1,[R0, #+0]
    508          }
   \       0x18   0x4770             BX       LR               ;; return
    509          
    510          /**
    511            * @brief  Enable the write protection of the desired pages
    512            * @note   An option byte erase is done automatically in this function. 
    513            * @note   When the memory read protection level is selected (RDP level = 1), 
    514            *         it is not possible to program or erase the flash page i if
    515            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    516            * 
    517            * @param  WriteProtectPage specifies the page(s) to be write protected.
    518            *         The value of this parameter depend on device used within the same series 
    519            * @retval HAL status 
    520            */
    521          static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WriteProtectPage)
    522          {
    523            HAL_StatusTypeDef status = HAL_OK;
    524            uint16_t WRP0_Data = 0xFFFFU;
    525          #if defined(OB_WRP1_WRP1)
    526            uint16_t WRP1_Data = 0xFFFFU;
    527          #endif /* OB_WRP1_WRP1 */
    528          #if defined(OB_WRP2_WRP2)
    529            uint16_t WRP2_Data = 0xFFFFU;
    530          #endif /* OB_WRP2_WRP2 */
    531          #if defined(OB_WRP3_WRP3)
    532            uint16_t WRP3_Data = 0xFFFFU;
    533          #endif /* OB_WRP3_WRP3 */
    534            
    535            /* Check the parameters */
    536            assert_param(IS_OB_WRP(WriteProtectPage));
    537              
    538            /* Get current write protected pages and the new pages to be protected ******/
    539            WriteProtectPage = (uint32_t)(~((~FLASH_OB_GetWRP()) | WriteProtectPage));
    540            
    541          #if defined(OB_WRP_PAGES0TO15MASK)
    542            WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO15MASK);
    543          #endif /* OB_WRP_PAGES0TO31MASK */
    544            
    545          #if defined(OB_WRP_PAGES16TO31MASK)
    546            WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES16TO31MASK) >> 8U);
    547          #endif /* OB_WRP_PAGES32TO63MASK */
    548           
    549          #if defined(OB_WRP_PAGES32TO47MASK)
    550            WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO47MASK) >> 16U);
    551          #endif /* OB_WRP_PAGES32TO47MASK */
    552          
    553          #if defined(OB_WRP_PAGES48TO127MASK)
    554            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO127MASK) >> 24U); 
    555          #elif defined(OB_WRP_PAGES48TO255MASK)
    556            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO255MASK) >> 24U); 
    557          #endif /* OB_WRP_PAGES48TO63MASK */
    558            
    559            /* Wait for last operation to be completed */
    560            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    561          
    562            if(status == HAL_OK)
    563            { 
    564              /* Clean the error context */
    565              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    566          
    567              /* To be able to write again option byte, need to perform a option byte erase */
    568              status = HAL_FLASHEx_OBErase();
    569              if (status == HAL_OK)  
    570              {
    571                /* Enable write protection */
    572                SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
    573          
    574          #if defined(OB_WRP0_WRP0)
    575                if(WRP0_Data != 0xFFU)
    576                {
    577                  OB->WRP0 &= WRP0_Data;
    578                  
    579                  /* Wait for last operation to be completed */
    580                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    581                }
    582          #endif /* OB_WRP0_WRP0 */
    583          
    584          #if defined(OB_WRP1_WRP1)
    585                if((status == HAL_OK) && (WRP1_Data != 0xFFU))
    586                {
    587                  OB->WRP1 &= WRP1_Data;
    588                  
    589                  /* Wait for last operation to be completed */
    590                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    591                }
    592          #endif /* OB_WRP1_WRP1 */
    593          
    594          #if defined(OB_WRP2_WRP2)
    595                if((status == HAL_OK) && (WRP2_Data != 0xFFU))
    596                {
    597                  OB->WRP2 &= WRP2_Data;
    598                  
    599                  /* Wait for last operation to be completed */
    600                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    601                }
    602          #endif /* OB_WRP2_WRP2 */
    603          
    604          #if defined(OB_WRP3_WRP3)
    605                if((status == HAL_OK) && (WRP3_Data != 0xFFU))
    606                {
    607                  OB->WRP3 &= WRP3_Data;
    608                  
    609                  /* Wait for last operation to be completed */
    610                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    611                }
    612          #endif /* OB_WRP3_WRP3 */
    613          
    614                /* if the program operation is completed, disable the OPTPG Bit */
    615                CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
    616              }
    617            }
    618            
    619            return status;
    620          }
    621          
    622          /**
    623            * @brief  Disable the write protection of the desired pages
    624            * @note   An option byte erase is done automatically in this function. 
    625            * @note   When the memory read protection level is selected (RDP level = 1), 
    626            *         it is not possible to program or erase the flash page i if   
    627            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    628            * 
    629            * @param  WriteProtectPage specifies the page(s) to be write unprotected.
    630            *         The value of this parameter depend on device used within the same series 
    631            * @retval HAL status 
    632            */
    633          static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WriteProtectPage)
    634          {
    635            HAL_StatusTypeDef status = HAL_OK;
    636            uint16_t WRP0_Data = 0xFFFFU;
    637          #if defined(OB_WRP1_WRP1)
    638            uint16_t WRP1_Data = 0xFFFFU;
    639          #endif /* OB_WRP1_WRP1 */
    640          #if defined(OB_WRP2_WRP2)
    641            uint16_t WRP2_Data = 0xFFFFU;
    642          #endif /* OB_WRP2_WRP2 */
    643          #if defined(OB_WRP3_WRP3)
    644            uint16_t WRP3_Data = 0xFFFFU;
    645          #endif /* OB_WRP3_WRP3 */
    646            
    647            /* Check the parameters */
    648            assert_param(IS_OB_WRP(WriteProtectPage));
    649          
    650            /* Get current write protected pages and the new pages to be unprotected ******/
    651            WriteProtectPage = (FLASH_OB_GetWRP() | WriteProtectPage);
    652          
    653          #if defined(OB_WRP_PAGES0TO15MASK)
    654            WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO15MASK);
    655          #endif /* OB_WRP_PAGES0TO31MASK */
    656            
    657          #if defined(OB_WRP_PAGES16TO31MASK)
    658            WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES16TO31MASK) >> 8U);
    659          #endif /* OB_WRP_PAGES32TO63MASK */
    660           
    661          #if defined(OB_WRP_PAGES32TO47MASK)
    662            WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO47MASK) >> 16U);
    663          #endif /* OB_WRP_PAGES32TO47MASK */
    664          
    665          #if defined(OB_WRP_PAGES48TO127MASK)
    666            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO127MASK) >> 24U); 
    667          #elif defined(OB_WRP_PAGES48TO255MASK)
    668            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO255MASK) >> 24U); 
    669          #endif /* OB_WRP_PAGES48TO63MASK */
    670          
    671              
    672            /* Wait for last operation to be completed */
    673            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    674          
    675            if(status == HAL_OK)
    676            { 
    677              /* Clean the error context */
    678              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    679          
    680              /* To be able to write again option byte, need to perform a option byte erase */
    681              status = HAL_FLASHEx_OBErase();
    682              if (status == HAL_OK)  
    683              {
    684                SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
    685          
    686          #if defined(OB_WRP0_WRP0)
    687                if(WRP0_Data != 0xFFU)
    688                {
    689                  OB->WRP0 |= WRP0_Data;
    690                  
    691                  /* Wait for last operation to be completed */
    692                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    693                }
    694          #endif /* OB_WRP0_WRP0 */
    695          
    696          #if defined(OB_WRP1_WRP1)
    697                if((status == HAL_OK) && (WRP1_Data != 0xFFU))
    698                {
    699                  OB->WRP1 |= WRP1_Data;
    700                  
    701                  /* Wait for last operation to be completed */
    702                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    703                }
    704          #endif /* OB_WRP1_WRP1 */
    705          
    706          #if defined(OB_WRP2_WRP2)
    707                if((status == HAL_OK) && (WRP2_Data != 0xFFU))
    708                {
    709                  OB->WRP2 |= WRP2_Data;
    710                  
    711                  /* Wait for last operation to be completed */
    712                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    713                }
    714          #endif /* OB_WRP2_WRP2 */
    715          
    716          #if defined(OB_WRP3_WRP3)
    717                if((status == HAL_OK) && (WRP3_Data != 0xFFU))
    718                {
    719                  OB->WRP3 |= WRP3_Data;
    720                  
    721                  /* Wait for last operation to be completed */
    722                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    723                }
    724          #endif /* OB_WRP3_WRP3 */
    725          
    726                /* if the program operation is completed, disable the OPTPG Bit */
    727                CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
    728              }
    729            }
    730            return status;
    731          }
    732          
    733          /**
    734            * @brief  Set the read protection level.
    735            * @param  ReadProtectLevel specifies the read protection level.
    736            *         This parameter can be one of the following values:
    737            *            @arg @ref OB_RDP_LEVEL_0 No protection
    738            *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
    739            *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
    740            * @note   Warning: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
    741            * @retval HAL status
    742            */

   \                                 In section .text, align 2, keep-with-next
    743          static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel)
    744          {
   \                     FLASH_OB_RDP_LevelConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine1
    745            HAL_StatusTypeDef status = HAL_OK;
    746            
    747            /* Check the parameters */
    748            assert_param(IS_OB_RDP_LEVEL(ReadProtectLevel));
    749            
    750            /* Wait for last operation to be completed */
    751            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    752            
    753            if(status == HAL_OK)
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0xD111             BNE.N    ??FLASH_OB_RDP_LevelConfig_0
    754            { 
    755              /* Clean the error context */
    756              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \        0xA   0x....'....        BL       ?Subroutine0
    757              
    758              /* If the previous operation is completed, proceed to erase the option bytes */
    759              SET_BIT(FLASH->CR, FLASH_CR_OPTER);
    760              SET_BIT(FLASH->CR, FLASH_CR_STRT);
    761          
    762              /* Wait for last operation to be completed */
    763              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    764          
    765              /* If the erase operation is completed, disable the OPTER Bit */
    766              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTER);
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xE   0x....'....        BL       ?Subroutine5
    767          
    768              if(status == HAL_OK)
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x12   0xD10C             BNE.N    ??FLASH_OB_RDP_LevelConfig_0
    769              {
    770                /* Enable the Option Bytes Programming operation */
    771                SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \       0x14   0x6830             LDR      R0,[R6, #+0]
    772                
    773                WRITE_REG(OB->RDP, ReadProtectLevel);
   \       0x16   0x....             LDR.N    R1,??DataTable9_5  ;; 0x1ffff800
   \       0x18   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x1C   0x6030             STR      R0,[R6, #+0]
   \       0x1E   0x800C             STRH     R4,[R1, #+0]
    774                
    775                /* Wait for last operation to be completed */
    776                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); 
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x....'....        BL       FLASH_WaitForLastOperation
    777                
    778                /* if the program operation is completed, disable the OPTPG Bit */
    779                CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \       0x26   0x6832             LDR      R2,[R6, #+0]
   \       0x28   0xF022 0x0210      BIC      R2,R2,#0x10
   \       0x2C   0x6032             STR      R2,[R6, #+0]
    780              }
    781            }
    782            
    783            return status;
   \                     ??FLASH_OB_RDP_LevelConfig_0: (+1)
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    784          }
    785          
    786          /**
    787            * @brief  Program the FLASH User Option Byte.    
    788            * @note   Programming of the OB should be performed only after an erase (otherwise PGERR occurs)
    789            * @param  UserConfig The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1), RST_STDBY(Bit2), nBOOT1(Bit4),
    790            *         VDDA_Analog_Monitoring(Bit5) and SRAM_Parity_Enable(Bit6). 
    791            *         And SDADC12_VDD_MONITOR(Bit7) for STM32F373 or STM32F378 . 
    792            * @retval HAL status
    793            */
    794          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t UserConfig)
    795          {
    796            HAL_StatusTypeDef status = HAL_OK;
    797          
    798            /* Check the parameters */
    799            assert_param(IS_OB_IWDG_SOURCE((UserConfig&OB_IWDG_SW)));
    800            assert_param(IS_OB_STOP_SOURCE((UserConfig&OB_STOP_NO_RST)));
    801            assert_param(IS_OB_STDBY_SOURCE((UserConfig&OB_STDBY_NO_RST)));
    802            assert_param(IS_OB_BOOT1((UserConfig&OB_BOOT1_SET)));
    803            assert_param(IS_OB_VDDA_ANALOG((UserConfig&OB_VDDA_ANALOG_ON)));
    804            assert_param(IS_OB_SRAM_PARITY((UserConfig&OB_SRAM_PARITY_RESET)));
    805          #if defined(FLASH_OBR_SDADC12_VDD_MONITOR)
    806            assert_param(IS_OB_SDACD_VDD_MONITOR((UserConfig&OB_SDACD_VDD_MONITOR_SET)));
    807          #endif /* FLASH_OBR_SDADC12_VDD_MONITOR */
    808          
    809            /* Wait for last operation to be completed */
    810            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    811            
    812            if(status == HAL_OK)
    813            {     
    814              /* Clean the error context */
    815              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    816          
    817              /* Enable the Option Bytes Programming operation */
    818              SET_BIT(FLASH->CR, FLASH_CR_OPTPG); 
    819           
    820          #if   defined(FLASH_OBR_SDADC12_VDD_MONITOR)
    821              OB->USER = (UserConfig | 0x08U);
    822          #else
    823              OB->USER = (UserConfig | 0x88U);
    824          #endif
    825          
    826              /* Wait for last operation to be completed */
    827              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    828          
    829              /* if the program operation is completed, disable the OPTPG Bit */
    830              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
    831            }
    832            
    833            return status; 
    834          }
    835          
    836          /**
    837            * @brief  Programs a half word at a specified Option Byte Data address.
    838            * @note   The function @ref HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    839            *         The function @ref HAL_FLASH_OB_Unlock() should be called before to unlock the options bytes
    840            *         The function @ref HAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes 
    841            *         (system reset will occur)
    842            *         Programming of the OB should be performed only after an erase (otherwise PGERR occurs)
    843            * @param  Address specifies the address to be programmed.
    844            *         This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    845            * @param  Data specifies the data to be programmed.
    846            * @retval HAL status
    847            */
    848          static HAL_StatusTypeDef FLASH_OB_ProgramData(uint32_t Address, uint8_t Data)
    849          {
    850            HAL_StatusTypeDef status = HAL_ERROR;
    851            
    852            /* Check the parameters */
    853            assert_param(IS_OB_DATA_ADDRESS(Address));
    854            
    855            /* Wait for last operation to be completed */
    856            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    857            
    858            if(status == HAL_OK)
    859            {
    860              /* Clean the error context */
    861              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    862          
    863              /* Enables the Option Bytes Programming operation */
    864              SET_BIT(FLASH->CR, FLASH_CR_OPTPG); 
    865              *(__IO uint16_t*)Address = Data;
    866              
    867              /* Wait for last operation to be completed */
    868              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
    869              
    870              /* If the program operation is completed, disable the OPTPG Bit */
    871              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
    872            }
    873            /* Return the Option Byte Data Program Status */
    874            return status;
    875          }
    876          
    877          /**
    878            * @brief  Return the FLASH Write Protection Option Bytes value.
    879            * @retval The FLASH Write Protection Option Bytes value
    880            */
    881          static uint32_t FLASH_OB_GetWRP(void)
    882          {
    883            /* Return the FLASH write protection Register value */
    884            return (uint32_t)(READ_REG(FLASH->WRPR));
    885          }
    886          
    887          /**
    888            * @brief  Returns the FLASH Read Protection level.
    889            * @retval FLASH RDP level
    890            *         This parameter can be one of the following values:
    891            *            @arg @ref OB_RDP_LEVEL_0 No protection
    892            *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
    893            *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
    894            */

   \                                 In section .text, align 2, keep-with-next
    895          static uint32_t FLASH_OB_GetRDP(void)
    896          {
    897            uint32_t tmp_reg = 0U;
    898            
    899            /* Read RDP level bits */
    900          #if defined(FLASH_OBR_RDPRT)
    901            tmp_reg = READ_BIT(FLASH->OBR, FLASH_OBR_RDPRT);
   \                     FLASH_OB_GetRDP: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable9_3  ;; 0x4002201c
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF000 0x0006      AND      R0,R0,#0x6
    902          #elif defined(FLASH_OBR_LEVEL1_PROT)
    903            tmp_reg = READ_BIT(FLASH->OBR, (FLASH_OBR_LEVEL1_PROT | FLASH_OBR_LEVEL2_PROT));
    904          #endif /* FLASH_OBR_RDPRT */
    905          
    906          #if defined(FLASH_OBR_RDPRT)
    907            if (tmp_reg == FLASH_OBR_RDPRT_2)
   \        0x8   0x2806             CMP      R0,#+6
   \        0xA   0xD101             BNE.N    ??FLASH_OB_GetRDP_0
    908          #elif defined(FLASH_OBR_LEVEL1_PROT)
    909            if (tmp_reg == FLASH_OBR_LEVEL2_PROT)
    910          #endif /* FLASH_OBR_RDPRT */
    911            {
    912              return OB_RDP_LEVEL_2;
   \        0xC   0x20CC             MOVS     R0,#+204
   \        0xE   0x4770             BX       LR
    913            }
    914            else if (tmp_reg == 0U)
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \       0x10   0xB908             CBNZ.N   R0,??FLASH_OB_GetRDP_1
    915            {
    916              return OB_RDP_LEVEL_0;
   \       0x12   0x20AA             MOVS     R0,#+170
   \       0x14   0x4770             BX       LR
    917            }
    918            else 
    919            {
    920              return OB_RDP_LEVEL_1;
   \                     ??FLASH_OB_GetRDP_1: (+1)
   \       0x16   0x20BB             MOVS     R0,#+187
   \       0x18   0x4770             BX       LR               ;; return
    921            }
    922          }
    923          
    924          /**
    925            * @brief  Return the FLASH User Option Byte value.
    926            * @retval  The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1), RST_STDBY(Bit2), nBOOT1(Bit4),
    927            *         VDDA_Analog_Monitoring(Bit5) and SRAM_Parity_Enable(Bit6). 
    928            *         And SDADC12_VDD_MONITOR(Bit7) for STM32F373 or STM32F378 . 
    929            */
    930          static uint8_t FLASH_OB_GetUser(void)
    931          {
    932            /* Return the User Option Byte */
    933            return (uint8_t)((READ_REG(FLASH->OBR) & FLASH_OBR_USER) >> FLASH_POSITION_IWDGSW_BIT);
    934          }
    935          
    936          /**
    937            * @}
    938            */
    939          
    940          /**
    941            * @}
    942            */
    943          
    944          /** @addtogroup FLASH
    945            * @{
    946            */
    947          
    948          /** @addtogroup FLASH_Private_Functions
    949           * @{
    950           */
    951          
    952          /**
    953            * @brief  Erase the specified FLASH memory page
    954            * @param  PageAddress FLASH page to erase
    955            *         The value of this parameter depend on device used within the same series      
    956            * 
    957            * @retval None
    958            */

   \                                 In section .text, align 2, keep-with-next
    959          void FLASH_PageErase(uint32_t PageAddress)
    960          {
    961            /* Clean the error context */
    962            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_PageErase: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable9
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x61D1             STR      R1,[R2, #+28]
    963          
    964              /* Proceed to erase the page */
    965              SET_BIT(FLASH->CR, FLASH_CR_PER);
   \        0x6   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40022010
   \        0x8   0x680B             LDR      R3,[R1, #+0]
   \        0xA   0xF043 0x0302      ORR      R3,R3,#0x2
   \        0xE   0x600B             STR      R3,[R1, #+0]
    966              WRITE_REG(FLASH->AR, PageAddress);
   \       0x10   0x6048             STR      R0,[R1, #+4]
    967              SET_BIT(FLASH->CR, FLASH_CR_STRT);
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x18   0x6008             STR      R0,[R1, #+0]
    968          }
   \       0x1A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x6839             LDR      R1,[R7, #+0]
   \        0x2   0xF041 0x0110      ORR      R1,R1,#0x10
   \        0x6   0x2DFF             CMP      R5,#+255
   \        0x8   0x6039             STR      R1,[R7, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x6839             LDR      R1,[R7, #+0]
   \        0x2   0xF021 0x0110      BIC      R1,R1,#0x10
   \        0x6   0x6039             STR      R1,[R7, #+0]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF000 0x05FF      AND      R5,R0,#0xFF
   \        0x4   0xF3C0 0x2A07      UBFX     R10,R0,#+8,#+8
   \        0x8                      REQUIRE ??Subroutine7_0
   \        0x8                      ;; // Fall through to label ??Subroutine7_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine7_0: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x....'....        B.W      FLASH_WaitForLastOperation

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xF8C9 0x001C      STR      R0,[R9, #+28]
   \        0x6   0x....             B.N      HAL_FLASHEx_OBErase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x4002'2010        DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x1FFF'F802        DC32     0x1ffff802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x4002'201C        DC32     0x4002201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x1FFF'F804        DC32     0x1ffff804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x1FFF'F800        DC32     0x1ffff800
    969          
    970          /**
    971            * @}
    972            */
    973          
    974          /**
    975            * @}
    976            */
    977          
    978          #endif /* HAL_FLASH_MODULE_ENABLED */
    979          /**
    980            * @}
    981            */
    982          
    983          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_MassErase
       0   FLASH_OB_GetRDP
      16   FLASH_OB_RDP_LevelConfig
        16   -> FLASH_WaitForLastOperation
       0   FLASH_PageErase
      32   HAL_FLASHEx_Erase
        32   -> FLASH_MassErase
        32   -> FLASH_PageErase
        32   -> FLASH_WaitForLastOperation
       8   HAL_FLASHEx_Erase_IT
         8   -> FLASH_MassErase
         8   -> FLASH_PageErase
      16   HAL_FLASHEx_OBErase
        16   -> FLASH_OB_GetRDP
         0   -> FLASH_OB_RDP_LevelConfig
        16   -> FLASH_WaitForLastOperation
      16   HAL_FLASHEx_OBGetConfig
        16   -> FLASH_OB_GetRDP
       0   HAL_FLASHEx_OBGetUserData
      32   HAL_FLASHEx_OBProgram
        32   -> FLASH_OB_RDP_LevelConfig
        32   -> FLASH_WaitForLastOperation
        32   -> HAL_FLASHEx_OBErase


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       6  ??Subroutine7_0
      30  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
      10  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
      26  FLASH_MassErase
      26  FLASH_OB_GetRDP
      48  FLASH_OB_RDP_LevelConfig
      28  FLASH_PageErase
     144  HAL_FLASHEx_Erase
      74  HAL_FLASHEx_Erase_IT
      34  HAL_FLASHEx_OBErase
      32  HAL_FLASHEx_OBGetConfig
      20  HAL_FLASHEx_OBGetUserData
     290  HAL_FLASHEx_OBProgram

 
 844 bytes in section .text
 
 844 bytes of CODE memory

Errors: none
Warnings: none
