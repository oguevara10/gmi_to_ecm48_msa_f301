###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  14:03:43
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Motor\regal_mc_lib.c
#    Command line      =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW73DD.tmp
#        (C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Motor\regal_mc_lib.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale            =  C
#    List file         =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\List\regal_mc_lib.lst
#    Object file       =
#        C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\EWARM\1.3kW_GMI\Obj\regal_mc_lib.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\gmi_to_ecm48_msa_f301\FlexMouse\Motor\regal_mc_lib.c
      1          /**
      2            ********************************************************************************************************************************
      3            * @file    regal_mc_lib.c
      4            * @author  Roel Pantonial
      5            * @brief   This source file contains the regal motor control library
      6            * @details This file has declarations for motor control algorithms such as on-the-fly and non-regenerative braking
      7            ********************************************************************************************************************************
      8            */
      9          
     10          #include "drive_parameters.h"
     11          #include "regal_mc_lib.h"
     12          #include "bus_voltage_sensor.h"
     13          #include "mc_math.h"
     14          #include "mc_api.h"
     15          #include "mc_config.h"
     16          
     17          /*Private Variables */

   \                                 In section .bss, align 2
     18          static uint8_t Imax_count = 0;
   \                     Imax_count:
   \        0x0                      DS8 1
   \        0x1                      DS8 1
   \        0x2                      DS8 2
     19          static uint16_t LowSide_count = 0;
     20          /**
     21            * @brief  PI / PID Bus Voltage parameters Motor 1
     22            */
     23          //RPa

   \                                 In section .data, align 4
     24          PID_Handle_t PIDBkHandle_M1 =
   \                     PIDBkHandle_M1:
   \        0x0   0x002D 0x000A      DC16 45, 10, 0, 0

   \               0x0000 0x000

   \              0
   \        0x8   0x0000'0000        DC32 0, 25'600, -25'600

   \              0x0000'6400  

   \              0xFFFF'9C00
   \       0x14   0x0000 0xF830      DC16 0, -2'000, 16, 256, 4, 8, 0, 0, 0, 0

   \               0x0010 0x010

   \              0 0x0004 0x00

   \              08 0x0000 0x0

   \              000 0x0000 0x

   \              0000
   \       0x28                      DS8 4
     25          {
     26            .hDefKpGain          = (int16_t)PID_BRAKE_KP_DEFAULT,
     27            .hDefKiGain          = (int16_t)PID_BRAKE_KI_DEFAULT,
     28            .wUpperIntegralLimit = (int32_t)100 * (int32_t)BK_KIDIV, //GMI 200
     29            .wLowerIntegralLimit = -(int32_t)100 * (int32_t)BK_KIDIV, //GMI: -200
     30            .hUpperOutputLimit       = 0, //Rpa: a factor of the OVP, temp is for 60V
     31            .hLowerOutputLimit       = -2000,//RPa: a factor of the UVP, temp is for 60V, GMI -3000
     32            .hKpDivisor          = (uint16_t)BK_KPDIV,
     33            .hKiDivisor          = (uint16_t)BK_KIDIV,
     34            .hKpDivisorPOW2      = (uint16_t)BK_KPDIV_LOG,
     35            .hKiDivisorPOW2      = (uint16_t)BK_KIDIV_LOG,
     36            .hDefKdGain           = 0x0000U,
     37            .hKdDivisor           = 0x0000U,
     38            .hKdDivisorPOW2       = 0x0000U,
     39          };
     40          
     41          /**
     42            * @brief  PI / PID Imax Controller parameters Motor 1
     43            */
     44          //RPa 

   \                                 In section .data, align 4
     45          PID_Handle_t PIDImHandle_M1 =
   \                     PIDImHandle_M1:
   \        0x0   0x0037 0x000A      DC16 55, 10, 0, 0

   \               0x0000 0x000

   \              0
   \        0x8   0x0000'0000        DC32 0, 512'000, -512'000

   \              0x0007'D000  

   \              0xFFF8'3000
   \       0x14   0x01F4 0xFE0C      DC16 500, -500, 16, 256, 4, 8, 0, 0, 0, 0

   \               0x0010 0x010

   \              0 0x0004 0x00

   \              08 0x0000 0x0

   \              000 0x0000 0x

   \              0000
   \       0x28                      DS8 4
     46          {
     47            .hDefKpGain          = (int16_t)PID_IMAX_KP_DEFAULT,
     48            .hDefKiGain          = (int16_t)PID_IMAX_KI_DEFAULT,
     49            .wUpperIntegralLimit = (int32_t)2000 * (int32_t)IMAX_KIDIV,
     50            .wLowerIntegralLimit = -(int32_t)2000 * (int32_t)IMAX_KIDIV,
     51            .hUpperOutputLimit       = 500,//INT16_MAX,
     52            .hLowerOutputLimit       = -500,//RPa: make sure that this is more than -Flux/Ld,
     53            .hKpDivisor          = (uint16_t)IMAX_KPDIV,
     54            .hKiDivisor          = (uint16_t)IMAX_KIDIV,
     55            .hKpDivisorPOW2      = (uint16_t)IMAX_KPDIV_LOG,
     56            .hKiDivisorPOW2      = (uint16_t)IMAX_KIDIV_LOG,
     57            .hDefKdGain           = 0x0000U,
     58            .hKdDivisor           = 0x0000U,
     59            .hKdDivisorPOW2       = 0x0000U,
     60          };
     61          
     62          /**
     63            * @brief  Brake parametrs Motor 1
     64            */

   \                                 In section .data, align 4
     65          Braking_Handle_t BrakeHandle_M1 =
   \                     BrakeHandle_M1:
   \        0x0   0x00               DC8 0
   \        0x1                      DS8 1
   \        0x2   0x0000 0x0000      DC16 0, 0
   \        0x6                      DS8 2
   \        0x8   0x0000'01F4        DC32 500
   \        0xC   0x00CD             DC16 205
   \        0xE                      DS8 2
   \       0x10   0x0000'0000        DC32 0, 0

   \              0x0000'0000
   \       0x18   0x0000 0x0014      DC16 0, 20
     66          {
     67            .Nbar = 205,
     68            .BrakingPhase = STARTRAMP,
     69            .IMax_Ref = 500,// GMI: 2000
     70            .FeedForward_term = 0,
     71            .Vbus_Add = 20, //GMI: 60, Blender: 40.
     72          };
     73          
     74          
     75          /**
     76            * @brief Execution of DC Bus Voltage Control
     77          */

   \                                 In section .text, align 2, keep-with-next
     78          int32_t FOC_BusVoltageControlM1(Braking_Handle_t * pHandle, PID_Handle_t * pPIDHandle, RDivider_Handle_t * pBSHandle)
     79          {
   \                     FOC_BusVoltageControlM1: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x460D             MOV      R5,R1
     80            int32_t hVBusError;
     81            uint16_t BusVoltCheck_16bit;
     82            int32_t BrakeTorque_q;
     83            
     84            // Compute Error given BusVoltageRef and measured bus voltage in 16bit representation
     85            BusVoltCheck_16bit = VBS_GetAvBusVoltage_d(&(pBSHandle->_Super));
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x....'....        BL       VBS_GetAvBusVoltage_d
   \        0xE   0x4607             MOV      R7,R0
     86            hVBusError = (int32_t) BusVoltCheck_16bit - (int32_t) (((uint32_t)pHandle->Adapt_BusVoltageRef*FP16)/((uint32_t)(pBSHandle->_Super.ConversionFactor)));
   \       0x10   0x8B21             LDRH     R1,[R4, #+24]
   \       0x12   0x8870             LDRH     R0,[R6, #+2]
   \       0x14   0x0409             LSLS     R1,R1,#+16
   \       0x16   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x1A   0x1A3F             SUBS     R7,R7,R0
     87            
     88            // Check Direction
     89              int16_t dir = MC_GetImposedDirectionMotor1();
   \       0x1C   0x....'....        BL       MC_GetImposedDirectionMotor1
   \       0x20   0x4604             MOV      R4,R0
     90            // PI Control
     91            BrakeTorque_q = (int32_t)PI_Controller(pPIDHandle, hVBusError) * dir;
     92              
     93            return(BrakeTorque_q);
   \       0x22   0x4639             MOV      R1,R7
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       PI_Controller
   \       0x2A   0xFB10 0xF004      SMULBB   R0,R0,R4
   \       0x2E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     94          }
     95          
     96          /**
     97            * @brief Execution of maximum current control
     98          */

   \                                 In section .text, align 2, keep-with-next
     99          int32_t FOC_ImaxCurrentControllerM1(Braking_Handle_t * pHandle, PID_Handle_t * pPIDHandle, FOCVars_t * pFOCHandle_t)
    100          {
   \                     FOC_ImaxCurrentControllerM1: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
    101            int32_t CurrentLoss;
    102            int32_t hCurrentError;
    103            uint32_t current_meas;
    104            
    105            // Compute Error given with current reference and the magnitude of the current vector
    106            current_meas = (uint32_t)(pFOCHandle_t->Iqd.d * pFOCHandle_t->Iqd.d) + (uint32_t) (pFOCHandle_t->Iqd.q * pFOCHandle_t->Iqd.q);
    107            current_meas = MCM_Sqrt( (int32_t) current_meas);
   \        0x6   0xF9B2 0x100E      LDRSH    R1,[R2, #+14]
   \        0xA   0xF9B2 0x000C      LDRSH    R0,[R2, #+12]
   \        0xE   0xFB11 0xF101      SMULBB   R1,R1,R1
   \       0x12   0xFB10 0x1000      SMLABB   R0,R0,R0,R1
   \       0x16   0x....'....        BL       MCM_Sqrt
    108            hCurrentError =   (int32_t) current_meas - (int32_t) pHandle->IMax_Ref;
    109            // PI Control
    110            CurrentLoss = PI_Controller(pPIDHandle, hCurrentError);
   \       0x1A   0x68A1             LDR      R1,[R4, #+8]
   \       0x1C   0x1A41             SUBS     R1,R0,R1
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       PI_Controller
    111            
    112            //Feedforward term
    113            pHandle->FeedForward_term = ((int32_t)pHandle->Nbar * (int32_t) pHandle->IMax_Ref)>>BYTE_SHIFT;
   \       0x24   0xF9B4 0x200C      LDRSH    R2,[R4, #+12]
   \       0x28   0x68A1             LDR      R1,[R4, #+8]
   \       0x2A   0x434A             MULS     R2,R1,R2
   \       0x2C   0x1212             ASRS     R2,R2,#+8
    114            
    115            //Output_calculation
    116            CurrentLoss = CurrentLoss - pHandle->FeedForward_term;
   \       0x2E   0x1A80             SUBS     R0,R0,R2
    117            
    118            //RPa: an insurance that d-current will never get to the IV quadrant
    119            if (CurrentLoss > 0)
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xBFC8             IT       GT
   \       0x34   0x2000             MOVGT    R0,#+0
    120              CurrentLoss = 0;
    121            
    122            return(CurrentLoss);
   \       0x36   0x6122             STR      R2,[R4, #+16]
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    123          }
    124          
    125          /**
    126            * @brief Initialisation of Braking structure
    127          */

   \                                 In section .text, align 2, keep-with-next
    128          void BrakingStruct_Init(Braking_Handle_t * pHandle, SpeednTorqCtrl_Handle_t * pSTCHandle)
    129          {
   \                     BrakingStruct_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    130            pHandle->rMeasuredSpeed = SPD_GetAvrgMecSpeedUnit( pSTCHandle->SPD );
   \        0x4   0x6948             LDR      R0,[R1, #+20]
   \        0x6   0x....'....        BL       SPD_GetAvrgMecSpeedUnit
    131            //RPa: take the absolute value of speed measure
    132            pHandle->Adapt_IMax = (int32_t)((RAMP_a * (int32_t) pHandle->rMeasuredSpeed * (int32_t) pHandle->rMeasuredSpeed)>>BYTE_SHIFT) + \
    133              (int32_t)(RAMP_b * (int32_t)pHandle->rMeasuredSpeed) + RAMP_c;
   \        0xA   0xFB10 0xF200      SMULBB   R2,R0,R0
   \        0xE   0x210D             MOVS     R1,#+13
   \       0x10   0x80A0             STRH     R0,[R4, #+4]
   \       0x12   0x434A             MULS     R2,R1,R2
   \       0x14   0x1212             ASRS     R2,R2,#+8
   \       0x16   0xF06F 0x0305      MVN      R3,#+5
   \       0x1A   0xFB10 0x2003      SMLABB   R0,R0,R3,R2
   \       0x1E   0xF200 0x40C4      ADDW     R0,R0,#+1220
   \       0x22   0x6160             STR      R0,[R4, #+20]
    134          }
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    135          
    136          /**
    137            * @brief Motor Braking State Machine
    138          */

   \                                 In section .text, align 4, keep-with-next
    139          void MotorBraking_StateMachine(Braking_Handle_t * pBkHandle, PID_Handle_t * pPIDBusHandle, PID_Handle_t * pPIDImHandle, SpeednTorqCtrl_Handle_t * pSTCHandle, FOCVars_t * pFOCHandle, RDivider_Handle_t * pBSHandle)
    140          {
   \                     MotorBraking_StateMachine: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    141               //RPa controlled way to set the next Iq and Id
    142              pBkHandle->rMeasuredSpeed = SPD_GetAvrgMecSpeedUnit( pSTCHandle->SPD );
   \        0x4   0x6958             LDR      R0,[R3, #+20]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x....'....        BL       SPD_GetAvrgMecSpeedUnit
    143              //RPa: take the absolute value of speed measure  
    144              int16_t MeasuredSpeedAbsValue = (pBkHandle->rMeasuredSpeed < 0 ? (-pBkHandle->rMeasuredSpeed): (pBkHandle->rMeasuredSpeed));
   \        0xE   0x....             LDR.N    R7,??DataTable1
   \       0x10   0x80A0             STRH     R0,[R4, #+4]
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0x7839             LDRB     R1,[R7, #+0]
   \       0x16   0xBF44             ITT      MI
   \       0x18   0x4240             RSBMI    R0,R0,#+0
   \       0x1A   0xB200             SXTHMI   R0,R0
    145           ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    146            //RPa: IMax trajectory is controlled to always be within the motor loss ellipse (copper+iron losses)
    147            if (Imax_count >= 2) //RPa: does an IMax trajectory sampling every 2msec but sampling can be increased
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xDB0C             BLT.N    ??MotorBraking_StateMachine_1
    148            {
    149              pBkHandle->Adapt_IMax = (int32_t)((RAMP_a * (int32_t) MeasuredSpeedAbsValue * (int32_t) MeasuredSpeedAbsValue)>>BYTE_SHIFT) + \
    150                (int32_t)(RAMP_b * (int32_t)MeasuredSpeedAbsValue) + RAMP_c;
   \       0x20   0xFB10 0xF300      SMULBB   R3,R0,R0
   \       0x24   0x220D             MOVS     R2,#+13
   \       0x26   0x4353             MULS     R3,R2,R3
   \       0x28   0x121B             ASRS     R3,R3,#+8
   \       0x2A   0xF06F 0x0105      MVN      R1,#+5
   \       0x2E   0xFB11 0x3300      SMLABB   R3,R1,R0,R3
   \       0x32   0xF203 0x43C4      ADDW     R3,R3,#+1220
   \       0x36   0x6163             STR      R3,[R4, #+20]
    151              Imax_count = 0;
   \       0x38   0x2100             MOVS     R1,#+0
    152            }
    153            Imax_count++;
   \                     ??MotorBraking_StateMachine_1: (+1)
   \       0x3A   0x1C49             ADDS     R1,R1,#+1
   \       0x3C   0x7039             STRB     R1,[R7, #+0]
    154            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    155            // RPa: State Machine for the d current injection
    156            switch(pBkHandle->BrakingPhase)
   \       0x3E   0x7821             LDRB     R1,[R4, #+0]
   \       0x40   0x9B06             LDR      R3,[SP, #+24]
   \       0x42   0x9A07             LDR      R2,[SP, #+28]
   \       0x44   0x2905             CMP      R1,#+5
   \       0x46   0xD858             BHI.N    ??MotorBraking_StateMachine_2
   \       0x48   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??MotorBraking_StateMachine_0:
   \       0x4C   0x03 0x0B          DC8      0x3,0xB,0x17,0x23

   \              0x17 0x23
   \       0x50   0x30 0x4E          DC8      0x30,0x4E
    157            {
    158            case STARTRAMP:   
    159              if (MeasuredSpeedAbsValue >= SPEED_TRANSITION)
   \                     ??MotorBraking_StateMachine_3: (+1)
   \       0x52   0x2841             CMP      R0,#+65
   \       0x54   0xBFAC             ITE      GE
   \       0x56   0x2001             MOVGE    R0,#+1
   \       0x58   0x2003             MOVLT    R0,#+3
    160                pBkHandle->BrakingPhase = RAMPUP;
    161              else
    162                pBkHandle->BrakingPhase = RAMPDOWN;
   \       0x5A   0x7020             STRB     R0,[R4, #+0]
    163               Imax_count = 0;   
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x7038             STRB     R0,[R7, #+0]
   \       0x60   0xE021             B.N      ??MotorBraking_StateMachine_4
    164              FOCStop_CalcCurrRef( pBkHandle, pPIDBusHandle, pPIDImHandle, pFOCHandle, pBSHandle); 
    165              break;
    166              
    167            case RAMPUP:   
    168              if (pBkHandle->IMax_Ref >=  pBkHandle->Adapt_IMax)
   \                     ??MotorBraking_StateMachine_5: (+1)
   \       0x62   0x6961             LDR      R1,[R4, #+20]
   \       0x64   0x68A7             LDR      R7,[R4, #+8]
   \       0x66   0x428F             CMP      R7,R1
   \       0x68   0xBFA6             ITTE     GE
   \       0x6A   0x2702             MOVGE    R7,#+2
   \       0x6C   0x7027             STRBGE   R7,[R4, #+0]
   \       0x6E   0xF107 0x010A      ADDLT    R1,R7,#+10
    169              {
    170                // Always compute the I-maximum reference to be within the copper loss ellipse
    171                pBkHandle->IMax_Ref =  pBkHandle->Adapt_IMax;
    172                pBkHandle->BrakingPhase = STEADYSTATE;
    173              }
    174              else
    175              {
    176                pBkHandle->IMax_Ref += RAMP_STEP;
    177              }
    178              //RPa: can be placed the next lines into a function as this is common with steadystate
    179              if (MeasuredSpeedAbsValue < SPEED_TRANSITION)
   \       0x72   0x2841             CMP      R0,#+65
   \       0x74   0x60A1             STR      R1,[R4, #+8]
   \       0x76   0xDA16             BGE.N    ??MotorBraking_StateMachine_4
   \       0x78   0xE003             B.N      ??MotorBraking_StateMachine_6
    180              {
    181                pBkHandle->BrakingPhase = RAMPDOWN;
    182                pPIDImHandle->hLowerOutputLimit = -5;
    183                pPIDImHandle->hUpperOutputLimit = 5;
    184              }   
    185              //Calling the Iq and Id injection for controlled braking
    186              FOCStop_CalcCurrRef( pBkHandle, pPIDBusHandle, pPIDImHandle, pFOCHandle, pBSHandle); 
    187              break;
    188              
    189            case STEADYSTATE:
    190              pBkHandle->IMax_Ref =  pBkHandle->Adapt_IMax;
   \                     ??MotorBraking_StateMachine_7: (+1)
   \       0x7A   0x6961             LDR      R1,[R4, #+20]
   \       0x7C   0x60A1             STR      R1,[R4, #+8]
    191              
    192              //RPa: can be placed the next lines into a function as this is common with rampup
    193              if (MeasuredSpeedAbsValue < SPEED_TRANSITION)
   \       0x7E   0x2841             CMP      R0,#+65
   \       0x80   0xDA11             BGE.N    ??MotorBraking_StateMachine_4
    194              {
    195                pBkHandle->BrakingPhase = RAMPDOWN;
   \                     ??MotorBraking_StateMachine_6: (+1)
   \       0x82   0x2003             MOVS     R0,#+3
   \       0x84   0x7020             STRB     R0,[R4, #+0]
    196                // Limit the boundaries of the Id injection when ramping down
    197                pPIDImHandle->hLowerOutputLimit = -5;
   \       0x86   0xF06F 0x0104      MVN      R1,#+4
    198                pPIDImHandle->hUpperOutputLimit = 5;
   \       0x8A   0x2705             MOVS     R7,#+5
   \       0x8C   0x82F1             STRH     R1,[R6, #+22]
   \       0x8E   0x82B7             STRH     R7,[R6, #+20]
   \       0x90   0xE009             B.N      ??MotorBraking_StateMachine_4
    199              } 
    200              //Calling the Iq and Id injection for controlled braking
    201              FOCStop_CalcCurrRef( pBkHandle, pPIDBusHandle, pPIDImHandle, pFOCHandle, pBSHandle);  
    202              break;
    203              
    204            case RAMPDOWN:
    205                if (pBkHandle->IMax_Ref <=  RAMPEND_CURRENT) // go to Iq Hold state when Id injection is at the end of a specified minimum
   \                     ??MotorBraking_StateMachine_8: (+1)
   \       0x92   0x68A1             LDR      R1,[R4, #+8]
   \       0x94   0x290A             CMP      R1,#+10
   \       0x96   0xDC04             BGT.N    ??MotorBraking_StateMachine_9
    206                {
    207                  pBkHandle->FilteredSpeed = MeasuredSpeedAbsValue;   
   \       0x98   0x8060             STRH     R0,[R4, #+2]
    208                  pBkHandle->IMax_Ref =  RAMPEND_CURRENT;
   \       0x9A   0x210A             MOVS     R1,#+10
    209                  pBkHandle->BrakingPhase = LOWSPEED_IQHOLD;
   \       0x9C   0x2004             MOVS     R0,#+4
   \       0x9E   0x7020             STRB     R0,[R4, #+0]
   \       0xA0   0xE000             B.N      ??MotorBraking_StateMachine_10
    210                }
    211                else
    212                {
    213                  pBkHandle->IMax_Ref -= RAMP_STEP ;
   \                     ??MotorBraking_StateMachine_9: (+1)
   \       0xA2   0x390A             SUBS     R1,R1,#+10
   \                     ??MotorBraking_StateMachine_10: (+1)
   \       0xA4   0x60A1             STR      R1,[R4, #+8]
    214                }
    215                //Calling the Iq and Id injection for controlled braking
    216                FOCStop_CalcCurrRef( pBkHandle, pPIDBusHandle, pPIDImHandle, pFOCHandle, pBSHandle); 
   \                     ??MotorBraking_StateMachine_4: (+1)
   \       0xA6   0x....'....        BL       ?Subroutine0
    217              break;
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xAA   0xBDF1             POP      {R0,R4-R7,PC}
    218              
    219            case LOWSPEED_IQHOLD:
    220              //RPa: Low-Pass Filtering of Speed measurement
    221              pBkHandle->FilteredSpeed = (int16_t)((((256 - (int32_t)alpha_br)*(int32_t)MeasuredSpeedAbsValue) + ((int32_t)alpha_br*(int32_t)pBkHandle->FilteredSpeed) + 128)>>BYTE_SHIFT) ;
   \                     ??MotorBraking_StateMachine_11: (+1)
   \       0xAC   0xF9B4 0xE002      LDRSH    LR,[R4, #+2]
   \       0xB0   0x21B3             MOVS     R1,#+179
   \       0xB2   0xF04F 0x0C4D      MOV      R12,#+77
   \       0xB6   0xFB1E 0xF101      SMULBB   R1,LR,R1
   \       0xBA   0xFB1C 0x1000      SMLABB   R0,R12,R0,R1
   \       0xBE   0x3080             ADDS     R0,R0,#+128
   \       0xC0   0x1200             ASRS     R0,R0,#+8
   \       0xC2   0x8060             STRH     R0,[R4, #+2]
    222              //Calling the Iq and Id injection for controlled braking
    223              FOCStop_CalcCurrRef( pBkHandle, pPIDBusHandle, pPIDImHandle, pFOCHandle, pBSHandle); 
   \       0xC4   0x....'....        BL       ?Subroutine0
    224              
    225              if (pBkHandle->FilteredSpeed < BRAKING_ENDSPEED)//RPa: (MeasuredSpeedAbsValue < BRAKING_ENDSPEED)
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xC8   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \       0xCC   0x280A             CMP      R0,#+10
   \       0xCE   0xDA14             BGE.N    ??MotorBraking_StateMachine_2
    226              {
    227                LowSide_count = 0;
   \       0xD0   0x2100             MOVS     R1,#+0
   \       0xD2   0x8079             STRH     R1,[R7, #+2]
    228                R3_1_SwitchOffPWM( &PWM_Handle_M1._Super );
   \       0xD4   0x....             LDR.N    R5,??DataTable1_1
   \       0xD6   0x4628             MOV      R0,R5
   \       0xD8   0x....'....        BL       R3_1_SwitchOffPWM
    229                R3_1_TurnOnLowSides( &PWM_Handle_M1._Super );// Turning the low-side on when speed is lower than a specified threshold
   \       0xDC   0x4628             MOV      R0,R5
   \       0xDE   0x....'....        BL       R3_1_TurnOnLowSides
    230                pBkHandle->BrakingPhase=TURNONLOWSIDE;
   \       0xE2   0x2005             MOVS     R0,#+5
   \       0xE4   0x7020             STRB     R0,[R4, #+0]
   \       0xE6   0xBDF1             POP      {R0,R4-R7,PC}
    231              }   
    232              break;   
    233          
    234            case TURNONLOWSIDE:
    235              
    236              if (LowSide_count>1000)//RPa: Low-side turned on for a specified amount of time; this can be tuned later on for the application (or not even turned off at all)
   \                     ??MotorBraking_StateMachine_12: (+1)
   \       0xE8   0x8878             LDRH     R0,[R7, #+2]
   \       0xEA   0xF240 0x32E9      MOVW     R2,#+1001
   \       0xEE   0x4290             CMP      R0,R2
   \       0xF0   0xBFA4             ITT      GE
   \       0xF2   0x2300             MOVGE    R3,#+0
   \       0xF4   0x7023             STRBGE   R3,[R4, #+0]
    237              {
    238                pBkHandle->BrakingPhase=STARTRAMP;
    239              }
    240              LowSide_count++;
   \       0xF6   0x1C40             ADDS     R0,R0,#+1
   \       0xF8   0x8078             STRH     R0,[R7, #+2]
    241              break;
    242              
    243            default:
    244              
    245              break;
    246            }
    247          }
   \                     ??MotorBraking_StateMachine_2: (+1)
   \       0xFA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x9200             STR      R2,[SP, #+0]
   \        0x2   0x4629             MOV      R1,R5
   \        0x4   0x4632             MOV      R2,R6
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....             B.N      FOCStop_CalcCurrRef
    248          
    249          /**
    250            * @brief Current Reference calculation for non-regenerative braking
    251          */

   \                                 In section .text, align 2, keep-with-next
    252          void FOCStop_CalcCurrRef(Braking_Handle_t * pBrakeHandle, PID_Handle_t * pPIDBusHandle, PID_Handle_t * pPIDImHandle, FOCVars_t * pFOCHandle_t, RDivider_Handle_t * pBSHandle)
    253          {
   \                     FOCStop_CalcCurrRef: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x461E             MOV      R6,R3
   \        0x4   0x4604             MOV      R4,R0
    254            if(pFOCHandle_t->bDriveInput == INTERNAL)
   \        0x6   0xF896 0x0024      LDRB     R0,[R6, #+36]
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0xB950             CBNZ.N   R0,??FOCStop_CalcCurrRef_0
   \        0xE   0x9A04             LDR      R2,[SP, #+16]
    255            {
    256              pFOCHandle_t->Iqdref.q = FOC_BusVoltageControlM1(pBrakeHandle, pPIDBusHandle, pBSHandle); 
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       FOC_BusVoltageControlM1
   \       0x16   0x8230             STRH     R0,[R6, #+16]
    257              pFOCHandle_t->Iqdref.d = FOC_ImaxCurrentControllerM1(pBrakeHandle, pPIDImHandle, pFOCHandle_t );
   \       0x18   0x4632             MOV      R2,R6
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       FOC_ImaxCurrentControllerM1
   \       0x22   0x8270             STRH     R0,[R6, #+18]
    258            }
    259          }
   \                     ??FOCStop_CalcCurrRef_0: (+1)
   \       0x24   0xBD70             POP      {R4-R6,PC}       ;; return
    260          
    261          /**
    262            * @brief non-regenerative braking when motor is at running state
    263          */

   \                                 In section .text, align 2, keep-with-next
    264          void RegenControlM1(Braking_Handle_t * pBkHandle, PID_Handle_t * pPIDBusHandle, PID_Handle_t * pPIDSpeedHandle, SpeednTorqCtrl_Handle_t * pSTCHandle, RDivider_Handle_t * pBSHandle)
    265          {
   \                     RegenControlM1: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x9F06             LDR      R7,[SP, #+24]
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x461D             MOV      R5,R3
    266              if ((MC_GetImposedDirectionMotor1()==1)&&((pSTCHandle->SPD->hAvrMecSpeedUnit - pSTCHandle->TargetFinal) > 5))
   \        0xE   0x....'....        BL       MC_GetImposedDirectionMotor1
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD10B             BNE.N    ??RegenControlM1_0
   \       0x16   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x1A   0x2906             CMP      R1,#+6
   \       0x1C   0xDB07             BLT.N    ??RegenControlM1_0
    267              {//FWD direction
    268                pPIDSpeedHandle->hLowerOutputLimit = FOC_BusVoltageControlM1(pBkHandle, pPIDBusHandle, pBSHandle); 
   \       0x1E   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x22   0x82F0             STRH     R0,[R6, #+22]
    269                pPIDSpeedHandle->wLowerIntegralLimit = (int32_t) pPIDSpeedHandle->hLowerOutputLimit * (int32_t)SP_KIDIV;
   \       0x24   0xF9B6 0x0016      LDRSH    R0,[R6, #+22]
   \       0x28   0x0380             LSLS     R0,R0,#+14
   \       0x2A   0x6130             STR      R0,[R6, #+16]
   \       0x2C   0xE010             B.N      ??RegenControlM1_1
    270              }
    271              else if ((MC_GetImposedDirectionMotor1()==-1)&&((pSTCHandle->SPD->hAvrMecSpeedUnit - pSTCHandle->TargetFinal) < -5))
   \                     ??RegenControlM1_0: (+1)
   \       0x2E   0x....'....        BL       MC_GetImposedDirectionMotor1
   \       0x32   0xF110 0x0F01      CMN      R0,#+1
   \       0x36   0xD10B             BNE.N    ??RegenControlM1_1
   \       0x38   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x3C   0xF111 0x0F05      CMN      R1,#+5
   \       0x40   0xDA06             BGE.N    ??RegenControlM1_1
    272              {//REV direction
    273                pPIDSpeedHandle->hUpperOutputLimit = FOC_BusVoltageControlM1(pBkHandle, pPIDBusHandle, pBSHandle);
   \       0x42   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x46   0x82B0             STRH     R0,[R6, #+20]
    274                pPIDSpeedHandle->wUpperIntegralLimit = (int32_t) pPIDSpeedHandle->hUpperOutputLimit * (int32_t)SP_KIDIV;
   \       0x48   0xF9B6 0x0014      LDRSH    R0,[R6, #+20]
   \       0x4C   0x0380             LSLS     R0,R0,#+14
   \       0x4E   0x60F0             STR      R0,[R6, #+12]
    275              }  
    276          }
   \                     ??RegenControlM1_1: (+1)
   \       0x50   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x463A             MOV      R2,R7
   \        0x2   0x4641             MOV      R1,R8
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....             B.N      FOC_BusVoltageControlM1

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6968             LDR      R0,[R5, #+20]
   \        0x2   0xF9B0 0x100C      LDRSH    R1,[R0, #+12]
   \        0x6   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \        0xA   0x1A09             SUBS     R1,R1,R0
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     Imax_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     PWM_Handle_M1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BrakingStruct_Init
         8   -> SPD_GetAvrgMecSpeedUnit
      16   FOCStop_CalcCurrRef
        16   -> FOC_BusVoltageControlM1
        16   -> FOC_ImaxCurrentControllerM1
      24   FOC_BusVoltageControlM1
        24   -> MC_GetImposedDirectionMotor1
        24   -> PI_Controller
        24   -> VBS_GetAvBusVoltage_d
      16   FOC_ImaxCurrentControllerM1
        16   -> MCM_Sqrt
        16   -> PI_Controller
      24   MotorBraking_StateMachine
        24   -> FOCStop_CalcCurrRef
        24   -> R3_1_SwitchOffPWM
        24   -> R3_1_TurnOnLowSides
        24   -> SPD_GetAvrgMecSpeedUnit
      24   RegenControlM1
        24   -> FOC_BusVoltageControlM1
        24   -> MC_GetImposedDirectionMotor1


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      10  ?Subroutine0
      14  ?Subroutine1
       8  ?Subroutine2
      28  BrakeHandle_M1
      38  BrakingStruct_Init
      38  FOCStop_CalcCurrRef
      48  FOC_BusVoltageControlM1
      58  FOC_ImaxCurrentControllerM1
       4  Imax_count
          LowSide_count
     252  MotorBraking_StateMachine
      44  PIDBkHandle_M1
      44  PIDImHandle_M1
      84  RegenControlM1

 
   4 bytes in section .bss
 116 bytes in section .data
 558 bytes in section .text
 
 558 bytes of CODE memory
 120 bytes of DATA memory

Errors: none
Warnings: none
