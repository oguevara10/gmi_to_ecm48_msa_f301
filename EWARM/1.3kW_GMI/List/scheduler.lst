###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Feb/2021  10:14:05
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Kernel\scheduler.c
#    Command line                 =
#        -f C:\Users\100001~1\AppData\Local\Temp\EW2FE7.tmp
#        (C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Kernel\scheduler.c
#        -D ARM_MATH_CM4 -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F302x8
#        -lCN
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List
#        -o
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/STM32F3xx_HAL_Driver/Inc/Legacy\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/Any/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/MCLib/F3xx/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/UILibrary/Inc\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../MCSDK_v5.4.4-Full/MotorControl/MCSDK/SystemDriveParams\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Device/ST/STM32F3xx/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM/../Drivers/CMSIS/DSP/Include\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Drivers\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Features\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Kernel\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Memory\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Regal\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\UniversalProtocol\\
#        -I
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\..\FlexMouse\Motor\\
#        -Ohz)
#    Locale                       =  C
#    List file                    =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\List\scheduler.lst
#    Object file                  =
#        C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\EWARM\1.3kW_GMI\Obj\scheduler.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Users\100001305\Documents\GitHub\ecm48_motor_drive_us\FlexMouse\Kernel\scheduler.c
      1          /**
      2            ********************************************************************************************************************************
      3            * @file    scheduler.c
      4            * @author  Pamela Lee
      5            * @brief   Implementation of c++ function/s for the kernel scheduler. 
      6            * @details Modules and drivers are collectively known as processes. This file contains the implementation of function related to
      7            *             scheduling processes and handling their respective driver interrupts, if any. The function scheduler_run is the
      8            *             'main loop' of the FlexMouse architecture.
      9            ********************************************************************************************************************************
     10            */
     11          
     12          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     13          #include "scheduler.h"
     14          
     15          #include "main.h"
     16          //#include "stm32f3xx_ll_iwdg.h"
     17          //volatile uint64_t tickCounter = 0;

   \                                 In section app_crc32_rom, align 4, root
     18          __root const uint32_t App_CRC @ "app_crc32_rom" = 0x00000000; // This is a placeholder for App Firmware Checksum (CRC32)
   \                     App_CRC:
   \        0x0   0x0000'0000        DC32 0
     19          
     20          /*Software interrupt variable in bit oriented
     21            * SoftwareIrqBitPt[0] of binary IRQ process (from 0 to 63), 
     22            * SoftwareIrqBitPt[1] of binary IRQ process (from 64 to 127)
     23            * SoftwareIrqBitPt[2] of binary IRQ process (from 128 to 191)
     24            * SoftwareIrqBitPt[3] of binary IRQ process (from 192 to 254)
     25          */
     26          uint64_t SoftwareIrqBitPt[] = { 0,0,0,0 };        
     27          uint8_t  IrqTrigProcessID = 255;        //current module/process (ID) trigged IRQ 
     28          
     29          uint64_t tickCounter; 
     30          
     31          /* house keeping variable ------------------------------------------------------------------------------------------------------*/
     32          uint64_t moduleStartTime;       //keep the the start time of systick for measure the run period of this module
     33          uint64_t moduleRunTime;
     34          #define maxModuleRunTimeLimit   200     // maxmium execution time for a module 200ms 
     35          uint64_t IrqModuleStartTime;    //keep the the start time of systick for measure the run period of the IRQ response module
     36          uint64_t IrqModuleRunTime;
     37          
     38          uint8_t  maxTimeModuleId = 255;
     39          uint64_t maxModuleTimeUsage = 0;
     40          uint8_t  maxTimeIRQ_ModuleId = 255;
     41          uint64_t maxIRQTimeUsage = 0;
     42          
     43          
     44          // REVIEW: Placement
     45          
     46          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     47              /** pam procedure #9 of Module insertion  :  add the module/s into the kernal list **/
     48              /** @caution: please put the modules-parameters in the same sequence as the enum defined in the header file for consistance ID number reflect in processInfoTable[MODULE_ID] below**/
     49          ProcessInfo processInfoTable[TOTAL_NUM_OF_PROCESSES] = {
     50              // Driver Modules
     51              {MODULE_USART1_ID, MODULE_USART1_FUNCTION_POINTER, MODULE_USART1_TOTAL_SEQ, MODULE_USART1_TOTAL_STRUCT, MODULE_USART1_PREV_STATE,
     52               MODULE_USART1_NEXT_STATE, MODULE_USART1_IRQ_STATUS, MODULE_USART1_PROCESS_STATUS, MODULE_USART1_MASTER_SHARED_MEM},
     53          
     54          	 /** removing USART2 for ECM
     55          	 {MODULE_USART2_ID, MODULE_USART2_FUNCTION_POINTER, MODULE_USART2_TOTAL_SEQ, MODULE_USART2_TOTAL_STRUCT, MODULE_USART2_PREV_STATE,
     56               MODULE_USART2_NEXT_STATE, MODULE_USART2_IRQ_STATUS, MODULE_USART2_PROCESS_STATUS, MODULE_USART2_MASTER_SHARED_MEM},
     57               **/
     58          	 
     59               {MODULE_FLASH_ID, MODULE_FLASH_FUNCTION_POINTER, MODULE_FLASH_TOTAL_SEQ, MODULE_FLASH_TOTAL_STRUCT, MODULE_FLASH_PREV_STATE,
     60               MODULE_FLASH_NEXT_STATE, MODULE_FLASH_IRQ_STATUS, MODULE_FLASH_PROCESS_STATUS, MODULE_FLASH_MASTER_SHARED_MEM},
     61               
     62               // Application Modules
     63              {MODULE_MC_STATEMACHINE_ID , MODULE_MC_STATEMACHINE_FUNCTION_POINTER, MODULE_MC_STATEMACHINE_TOTAL_SEQ, MODULE_MC_STATEMACHINE_TOTAL_STRUCT, MODULE_MC_STATEMACHINE_PREV_STATE,
     64               MODULE_MC_STATEMACHINE_NEXT_STATE, MODULE_MC_STATEMACHINE_IRQ_STATUS, MODULE_MC_STATEMACHINE_PROCESS_STATUS, MODULE_MC_STATEMACHINE_MASTER_SHARED_MEM},
     65               
     66              {MODULE_APP_ID, MODULE_APP_FUNCTION_POINTER, MODULE_APP_TOTAL_SEQ, MODULE_APP_TOTAL_STRUCT, MODULE_APP_PREV_STATE,
     67               MODULE_APP_NEXT_STATE, MODULE_APP_IRQ_STATUS, MODULE_APP_PROCESS_STATUS, MODULE_APP_MASTER_SHARED_MEM},
     68               
     69              {MODULE_SHORT_CMD_ID, MODULE_SHORT_CMD_FUNCTION_POINTER, MODULE_SHORT_CMD_TOTAL_SEQ, MODULE_SHORT_CMD_TOTAL_STRUCT, MODULE_SHORT_CMD_PREV_STATE,
     70               MODULE_SHORT_CMD_NEXT_STATE, MODULE_SHORT_CMD_IRQ_STATUS, MODULE_SHORT_CMD_PROCESS_STATUS, MODULE_SHORT_CMD_MASTER_SHARED_MEM},
     71               
     72              {MODULE_REPLY_CMD_ID, MODULE_REPLY_CMD_FUNCTION_POINTER, MODULE_REPLY_CMD_TOTAL_SEQ, MODULE_REPLY_CMD_TOTAL_STRUCT, MODULE_REPLY_CMD_PREV_STATE,
     73               MODULE_REPLY_CMD_NEXT_STATE, MODULE_REPLY_CMD_IRQ_STATUS, MODULE_REPLY_CMD_PROCESS_STATUS, MODULE_REPLY_CMD_MASTER_SHARED_MEM},
     74               
     75              {MODULE_FLASH_UPDATE_CMD_ID, MODULE_FLASH_UPDATE_CMD_FUNCTION_POINTER, MODULE_FLASH_UPDATE_CMD_TOTAL_SEQ, MODULE_FLASH_UPDATE_CMD_TOTAL_STRUCT, MODULE_FLASH_UPDATE_CMD_PREV_STATE,
     76               MODULE_FLASH_UPDATE_CMD_NEXT_STATE, MODULE_FLASH_UPDATE_CMD_IRQ_STATUS, MODULE_FLASH_UPDATE_CMD_PROCESS_STATUS, MODULE_FLASH_UPDATE_CMD_MASTER_SHARED_MEM},
     77               
     78              {MODULE_FLASH_REGISTER_CMD_ID, MODULE_FLASH_REGISTER_CMD_FUNCTION_POINTER, MODULE_FLASH_REGISTER_CMD_TOTAL_SEQ, MODULE_FLASH_REGISTER_CMD_TOTAL_STRUCT, MODULE_FLASH_REGISTER_CMD_PREV_STATE,
     79               MODULE_FLASH_REGISTER_CMD_NEXT_STATE, MODULE_FLASH_REGISTER_CMD_IRQ_STATUS, MODULE_FLASH_REGISTER_CMD_PROCESS_STATUS, MODULE_FLASH_REGISTER_CMD_MASTER_SHARED_MEM},
     80               
     81              {MODULE_AUTOACK_ID, MODULE_AUTOACK_FUNCTION_POINTER, MODULE_AUTOACK_TOTAL_SEQ, MODULE_AUTOACK_TOTAL_STRUCT, MODULE_AUTOACK_PREV_STATE,
     82               MODULE_AUTOACK_NEXT_STATE, MODULE_AUTOACK_IRQ_STATUS, MODULE_AUTOACK_PROCESS_STATUS, MODULE_AUTOACK_MASTER_SHARED_MEM},
     83          
     84              {MODULE_ERR_LOGHANDLE_ID, MODULE_ERR_LOGHANDLE_FUNCTION_POINTER, MODULE_ERR_LOGHANDLE_TOTAL_SEQ, MODULE_ERR_LOGHANDLE_TOTAL_STRUCT, MODULE_ERR_LOGHANDLE_PREV_STATE,
     85               MODULE_ERR_LOGHANDLE_NEXT_STATE, MODULE_ERR_LOGHANDLE_IRQ_STATUS, MODULE_ERR_LOGHANDLE_PROCESS_STATUS, MODULE_ERR_LOGHANDLE_MASTER_SHARED_MEM},     
     86          
     87          };
     88          /** pam procedure #9 of Module insertion  :  add the module/s into the kernal list end **/

   \                                 In section .text, align 2, keep-with-next
     89          uint8_t Sched_Initialize()  {
   \                     Sched_Initialize: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     90              StructMem_InitBufs();
   \        0x2   0x....'....        BL       StructMem_InitBufs
     91              SeqMem_InitBufs();
   \        0x6   0x....'....        BL       SeqMem_InitBufs
     92          
     93          
     94              // Watchdog_Initialize(NUM_OF_625_MS_INC);
     95          
     96              return TRUE;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
     97          }

   \                                 In section .data, align 8
   \                     IrqTrigProcessID:
   \        0x0   0xFF               DC8 255
   \                     maxTimeModuleId:
   \        0x1   0xFF               DC8 255
   \                     maxTimeIRQ_ModuleId:
   \        0x2   0xFF               DC8 255
     98          uint64_t shifter_u8;
     99          uint8_t IRQgroupItem;
   \                     IRQgroupItem:
   \        0x3                      DS8 1
    100          uint8_t IrqGroupIndx_u8;
   \                     IrqGroupIndx_u8:
   \        0x4                      DS8 1
   \        0x5   0x00 0x00          DC8 0, 0, 0

   \              0x00
   \                     SoftwareIrqBitPt:
   \        0x8   0x0000'0000'0      DC64 0, 0, 0, 0

   \              000'0000 0x00

   \              00'0000'0000'

   \              0000 0x0000'0

   \              000'0000'0000

   \               0x0000'0000'

   \              0000'0000
   \                     tickCounter:
   \       0x28                      DS8 8
   \                     moduleStartTime:
   \       0x30                      DS8 8
   \                     moduleRunTime:
   \       0x38                      DS8 8
   \                     IrqModuleStartTime:
   \       0x40                      DS8 8
   \                     IrqModuleRunTime:
   \       0x48                      DS8 8
   \                     maxModuleTimeUsage:
   \       0x50   0x0000'0000'0      DC64 0

   \              000'0000
   \                     maxIRQTimeUsage:
   \       0x58   0x0000'0000'0      DC64 0

   \              000'0000
   \                     shifter_u8:
   \       0x60                      DS8 8

   \                                 In section .data, align 4
   \                     processInfoTable:
   \        0x0   0x00               DC8 0
   \        0x1   0x....'....        DC32 moduleUsart1_u32
   \        0x5   0x06 0x01          DC8 6, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \        0xB   0x0000'0000        DC32 0x0
   \        0xF                      DS8 7
   \       0x16   0x01               DC8 1
   \       0x17   0x....'....        DC32 moduleFlash_u32
   \       0x1B   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0x21   0x0000'0000        DC32 0x0
   \       0x25                      DS8 7
   \       0x2C   0x02               DC8 2
   \       0x2D   0x....'....        DC32 module_Mc_StateMachine_u32
   \       0x31   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0x37   0x0000'0000        DC32 0x0
   \       0x3B                      DS8 7
   \       0x42   0x03               DC8 3
   \       0x43   0x....'....        DC32 p_moduleApp_u32
   \       0x47   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0x4D   0x0000'0000        DC32 0x0
   \       0x51                      DS8 7
   \       0x58   0x04               DC8 4
   \       0x59   0x....'....        DC32 moduleShortCmd_u32
   \       0x5D   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0x63   0x0000'0000        DC32 0x0
   \       0x67                      DS8 7
   \       0x6E   0x05               DC8 5
   \       0x6F   0x....'....        DC32 moduleReplyCmd_u32
   \       0x73   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0x79   0x0000'0000        DC32 0x0
   \       0x7D                      DS8 7
   \       0x84   0x06               DC8 6
   \       0x85   0x....'....        DC32 moduleFlashUpdateCmd_u32
   \       0x89   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0x8F   0x0000'0000        DC32 0x0
   \       0x93                      DS8 7
   \       0x9A   0x07               DC8 7
   \       0x9B   0x....'....        DC32 moduleFlashRegisterCmd_u32
   \       0x9F   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0xA5   0x0000'0000        DC32 0x0
   \       0xA9                      DS8 7
   \       0xB0   0x08               DC8 8
   \       0xB1   0x....'....        DC32 moduleAutoAck_u32
   \       0xB5   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0xBB   0x0000'0000        DC32 0x0
   \       0xBF                      DS8 7
   \       0xC6   0x09               DC8 9
   \       0xC7   0x....'....        DC32 module_err_log_u32
   \       0xCB   0x00 0x01          DC8 0, 1, 0, 0, 200, 0

   \              0x00 0x00    

   \              0xC8 0x00
   \       0xD1   0x0000'0000        DC32 0x0
   \       0xD5                      DS8 7

   \                                 In section .text, align 2, keep-with-next
    101          void Sched_Run()  {
   \                     Sched_Run: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x....             LDR.N    R4,??DataTable6
   \        0x6   0x....             LDR.N    R5,??DataTable6_1
   \        0x8   0xF04F 0x0A16      MOV      R10,#+22
    102              while (TRUE) {
    103                  // Run each process with nextState_u8, save nextState_u8 as prevState_u8, and update nextState_u8 using return value.
    104                  for (uint8_t table_index_u8 = 0; table_index_u8 < TOTAL_NUM_OF_PROCESSES; table_index_u8++) 
   \                     ??Sched_Run_0: (+1)
   \        0xC   0x2600             MOVS     R6,#+0
    105                  {
    106                      if (processInfoTable[table_index_u8].Sched_ModuleData.processStatus_u8 == PROCESS_STATUS_RUNNING) 
   \                     ??Sched_Run_1: (+1)
   \        0xE   0xFB0A 0xF006      MUL      R0,R10,R6
   \       0x12   0x182F             ADDS     R7,R5,R0
   \       0x14   0x7AB8             LDRB     R0,[R7, #+10]
   \       0x16   0xBB00             CBNZ.N   R0,??Sched_Run_2
    107                      {
    108                          uint8_t current_state_u8 = processInfoTable[table_index_u8].Sched_ModuleData.nextState_u8;
    109                          moduleStartTime = getSysCount();        //acquire time before execute the module//house keeping code                            //house keeping code 
   \       0x18   0xE9D4 0x010A      LDRD     R0,R1,[R4, #+40]
   \       0x1C   0xF897 0x8008      LDRB     R8,[R7, #+8]
   \       0x20   0xE9C4 0x010C      STRD     R0,R1,[R4, #+48]
    110                          processInfoTable[table_index_u8].Sched_ModuleData.nextState_u8 =
    111                              (*processInfoTable[table_index_u8].Sched_ModuleData.p_module_u32)(
    112                                  processInfoTable[table_index_u8].Sched_ModuleData.moduleId_u8,
    113                                  processInfoTable[table_index_u8].Sched_ModuleData.prevState_u8,
    114                                  processInfoTable[table_index_u8].Sched_ModuleData.nextState_u8,
    115                                  processInfoTable[table_index_u8].Sched_ModuleData.irqState_u8);
   \       0x24   0xF8D7 0xC001      LDR      R12,[R7, #+1]
   \       0x28   0x7A7B             LDRB     R3,[R7, #+9]
   \       0x2A   0x7A3A             LDRB     R2,[R7, #+8]
   \       0x2C   0x79F9             LDRB     R1,[R7, #+7]
   \       0x2E   0x7838             LDRB     R0,[R7, #+0]
   \       0x30   0x47E0             BLX      R12
   \       0x32   0x7238             STRB     R0,[R7, #+8]
    116                         processInfoTable[table_index_u8].Sched_ModuleData.prevState_u8 = current_state_u8;     
   \       0x34   0xF887 0x8007      STRB     R8,[R7, #+7]
    117                         moduleRunTime = getSysCount() - moduleStartTime;                                             //get this module run time          //house keeping code      
   \       0x38   0xE9D4 0x010A      LDRD     R0,R1,[R4, #+40]
   \       0x3C   0xE9D4 0x230C      LDRD     R2,R3,[R4, #+48]
    118                         if( moduleRunTime > maxModuleTimeUsage) {                                                    //store the max run time module ID  //house keeping code  
   \       0x40   0xE9D4 0x8914      LDRD     R8,R9,[R4, #+80]
   \       0x44   0x1A80             SUBS     R0,R0,R2
   \       0x46   0x4199             SBCS     R1,R1,R3
   \       0x48   0x4589             CMP      R9,R1
   \       0x4A   0xD804             BHI.N    ??Sched_Run_3
   \       0x4C   0xBF2E             ITEE     CS
   \       0x4E   0x4580             CMPCS    R8,R0
   \       0x50   0xE9C4 0x0114      STRDCC   R0,R1,[R4, #+80]
   \       0x54   0x7066             STRBCC   R6,[R4, #+1]
    119                            maxModuleTimeUsage = moduleRunTime;                                                                                           //house keeping code  
    120                            maxTimeModuleId = table_index_u8;                                                                                             //house keeping code  
   \                     ??Sched_Run_3: (+1)
   \       0x56   0xE9C4 0x010E      STRD     R0,R1,[R4, #+56]
    121                         }
    122                      }
    123                      // Iterate through the interrupt register when an interrupt is present.
    124                      // Handle each event sequentially by calling the interrupt handler of the driver's respective associated module.
    125                      // Clear each event from the register after being handled.
    126                      // After the event is handled, the module's previousStage_u8 remains unchanged, so normal operation can resume.
    127                      for(IrqGroupIndx_u8 = 0; IrqGroupIndx_u8 < 4 ; IrqGroupIndx_u8++)
   \                     ??Sched_Run_2: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x7120             STRB     R0,[R4, #+4]
    128                      {
    129                        if( SoftwareIrqBitPt[IrqGroupIndx_u8] != 0)
   \                     ??Sched_Run_4: (+1)
   \       0x5E   0x7920             LDRB     R0,[R4, #+4]
   \       0x60   0xF104 0x0108      ADD      R1,R4,#+8
   \       0x64   0xEB01 0x02C0      ADD      R2,R1,R0, LSL #+3
   \       0x68   0xE9D2 0x8900      LDRD     R8,R9,[R2, #+0]
   \       0x6C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x70   0xBF08             IT       EQ
   \       0x72   0xF1B8 0x0F00      CMPEQ    R8,#+0
   \       0x76   0xD062             BEQ.N    ??Sched_Run_5
    130                        {
    131                          shifter_u8 = SHIFTER;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0xE9C4 0x0118      STRD     R0,R1,[R4, #+96]
    132                          for(IRQgroupItem = 0; IRQgroupItem < 64 ; IRQgroupItem++)
   \       0x80   0x70E1             STRB     R1,[R4, #+3]
    133                          {
    134                            if (SoftwareIrqBitPt[IrqGroupIndx_u8] & shifter_u8) 
   \                     ??Sched_Run_6: (+1)
   \       0x82   0xF894 0xC004      LDRB     R12,[R4, #+4]
   \       0x86   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x8A   0xEB00 0x07CC      ADD      R7,R0,R12, LSL #+3
   \       0x8E   0xE9D4 0x0118      LDRD     R0,R1,[R4, #+96]
   \       0x92   0xE9D7 0x2300      LDRD     R2,R3,[R7, #+0]
   \       0x96   0x4010             ANDS     R0,R2,R0
   \       0x98   0x4019             ANDS     R1,R3,R1
   \       0x9A   0xBF08             IT       EQ
   \       0x9C   0x2800             CMPEQ    R0,#+0
   \       0x9E   0xD03C             BEQ.N    ??Sched_Run_7
    135                              {
    136                                uint8_t effectiveID = IRQgroupItem + (IrqGroupIndx_u8 * 64);
    137                                IrqModuleStartTime = getSysCount();        //acquire time before execute the IRQ //house keeping code                    //house keeping code 
   \       0xA0   0xE9D4 0x010A      LDRD     R0,R1,[R4, #+40]
   \       0xA4   0x78E7             LDRB     R7,[R4, #+3]
   \       0xA6   0xE9C4 0x0110      STRD     R0,R1,[R4, #+64]
   \       0xAA   0xEB07 0x178C      ADD      R7,R7,R12, LSL #+6
   \       0xAE   0xB2FF             UXTB     R7,R7
    138                                  if (getProcessInfoIndex(effectiveID) != INDEX_NOT_FOUND) 
   \       0xB0   0x4638             MOV      R0,R7
   \       0xB2   0x....'....        BL       getProcessInfoIndex
   \       0xB6   0x28FF             CMP      R0,#+255
   \       0xB8   0xD01D             BEQ.N    ??Sched_Run_8
    139                                  {
    140                                      (*processInfoTable[effectiveID].Sched_ModuleData.p_module_u32)(
    141                                           processInfoTable[effectiveID].Sched_ModuleData.moduleId_u8,      //which software isr module ID
    142                                           processInfoTable[effectiveID].Sched_ModuleData.irqState_u8,                                                           //this meaningless for prevState in interrupt
    143                                           processInfoTable[effectiveID].Sched_ModuleData.irqState_u8,      //entry point/state for interrupt call back
    144                                           processInfoTable[effectiveID].Sched_ModuleData.irqState_u8);                                             //the interrupt triggered module 
   \       0xBA   0xFB1A 0xF007      SMULBB   R0,R10,R7
   \       0xBE   0x1829             ADDS     R1,R5,R0
   \       0xC0   0xF8D1 0xC001      LDR      R12,[R1, #+1]
   \       0xC4   0x7A4B             LDRB     R3,[R1, #+9]
   \       0xC6   0x5C28             LDRB     R0,[R5, R0]
   \       0xC8   0x461A             MOV      R2,R3
   \       0xCA   0x4619             MOV      R1,R3
   \       0xCC   0x47E0             BLX      R12
    145                                      SoftwareIrqBitPt[IrqGroupIndx_u8] &= ~shifter_u8;
   \       0xCE   0xF894 0xC004      LDRB     R12,[R4, #+4]
   \       0xD2   0xF104 0x0008      ADD      R0,R4,#+8
   \       0xD6   0xEB00 0x00CC      ADD      R0,R0,R12, LSL #+3
   \       0xDA   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \       0xDE   0xE9D4 0x0118      LDRD     R0,R1,[R4, #+96]
   \       0xE2   0xEA22 0x0000      BIC      R0,R2,R0
   \       0xE6   0xF104 0x0208      ADD      R2,R4,#+8
   \       0xEA   0xEB02 0x02CC      ADD      R2,R2,R12, LSL #+3
   \       0xEE   0xEA23 0x0101      BIC      R1,R3,R1
   \       0xF2   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    146                                  }
    147                                  IrqModuleRunTime = getSysCount() - IrqModuleStartTime;                                                   //get this IRQ run time   rollover(tested) //house keeping code 
   \                     ??Sched_Run_8: (+1)
   \       0xF6   0xE9D4 0x230A      LDRD     R2,R3,[R4, #+40]
   \       0xFA   0xE9D4 0x0110      LDRD     R0,R1,[R4, #+64]
    148                                  if( IrqModuleRunTime > maxIRQTimeUsage) {                                                                //store the max IRQ run time and ID //house keeping code  
   \       0xFE   0xE9D4 0x8916      LDRD     R8,R9,[R4, #+88]
   \      0x102   0x1A10             SUBS     R0,R2,R0
   \      0x104   0xEB63 0x0101      SBC      R1,R3,R1
   \      0x108   0x4589             CMP      R9,R1
   \      0x10A   0xD804             BHI.N    ??Sched_Run_9
   \      0x10C   0xBF2E             ITEE     CS
   \      0x10E   0x4580             CMPCS    R8,R0
   \      0x110   0xE9C4 0x0116      STRDCC   R0,R1,[R4, #+88]
   \      0x114   0x70A7             STRBCC   R7,[R4, #+2]
    149                                      maxIRQTimeUsage = IrqModuleRunTime;                                                                                                      //house keeping code  
    150                                      maxTimeIRQ_ModuleId = effectiveID;                                                                                                       //house keeping code  
   \                     ??Sched_Run_9: (+1)
   \      0x116   0xE9C4 0x0112      STRD     R0,R1,[R4, #+72]
    151                                  }
    152                              }  
    153                            if((shifter_u8 <<= 1)  == 0) shifter_u8 = SHIFTER;
   \                     ??Sched_Run_7: (+1)
   \      0x11A   0xE9D4 0x0118      LDRD     R0,R1,[R4, #+96]
   \      0x11E   0x0049             LSLS     R1,R1,#+1
   \      0x120   0xEA41 0x71D0      ORR      R1,R1,R0, LSR #+31
   \      0x124   0x0040             LSLS     R0,R0,#+1
   \      0x126   0x2900             CMP      R1,#+0
   \      0x128   0xBF04             ITT      EQ
   \      0x12A   0x2800             CMPEQ    R0,#+0
   \      0x12C   0x2001             MOVEQ    R0,#+1
   \      0x12E   0xE9C4 0x0118      STRD     R0,R1,[R4, #+96]
    154                          }     
   \      0x132   0x78E0             LDRB     R0,[R4, #+3]
   \      0x134   0x1C40             ADDS     R0,R0,#+1
   \      0x136   0x70E0             STRB     R0,[R4, #+3]
   \      0x138   0xB2C0             UXTB     R0,R0
   \      0x13A   0x2840             CMP      R0,#+64
   \      0x13C   0xDBA1             BLT.N    ??Sched_Run_6
    155                        }              
    156                      }         
   \                     ??Sched_Run_5: (+1)
   \      0x13E   0x7920             LDRB     R0,[R4, #+4]
   \      0x140   0x1C40             ADDS     R0,R0,#+1
   \      0x142   0x7120             STRB     R0,[R4, #+4]
   \      0x144   0xB2C0             UXTB     R0,R0
   \      0x146   0x2804             CMP      R0,#+4
   \      0x148   0xDB89             BLT.N    ??Sched_Run_4
    157                  }
   \      0x14A   0x1C76             ADDS     R6,R6,#+1
   \      0x14C   0x2E09             CMP      R6,#+9
   \      0x14E   0xF73F 0xAF5D      BGT.W    ??Sched_Run_0
   \      0x152   0xE75C             B.N      ??Sched_Run_1
    158                  if(((!Ram_mallocError) || (!Ring_mallocError)) || (!reallocError))                      //check any Heap memory alocation error                 //house keeping code 
    159                  { //report to system error or the Error/Log handling module      
    160               //     setupSoftwareIRQ(255, MODULE_ERR_LOGHANDLE, 0xE1, 0x01, 0x00, NULL);  
    161                  } 
    162                  if( maxModuleTimeUsage > maxModuleRunTimeLimit)                                         //module exceed time limit error  check                 //house keeping code 
    163                  { //report to system error or the Error/Log handling module      
    164               //     setupSoftwareIRQ(255, MODULE_ERR_LOGHANDLE, 0xE2, 0x01, 0x00, NULL);   
    165                  }
    166                  else if( maxIRQTimeUsage > maxModuleRunTimeLimit)                                       //IRQ response module  exceed time limit error check    //house keeping code 
    167                  { //report to system error or the Error/Log handling module      
    168               //     setupSoftwareIRQ(255, MODULE_ERR_LOGHANDLE, 0xE3, 0x01, 0x00, NULL);  
    169                  }      
    170              }
    171          }
    172          
    173          

   \                                 In section .text, align 2, keep-with-next
    174          uint8_t getProcessInfoIndex(uint8_t moduleId_u8)                                   //return Process index from processInfo array with the appID
    175          {
   \                     getProcessInfoIndex: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x4601             MOV      R1,R0
    176              uint8_t idValue= 255;
   \        0x4   0x20FF             MOVS     R0,#+255
    177              for(int i =0; i < TOTAL_NUM_OF_PROCESSES ; i++)
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x....             LDR.N    R3,??DataTable6_1
    178              {
    179                 if(processInfoTable[i].Sched_ModuleData.moduleId_u8 == moduleId_u8)                               //find system appInfo of this driver
   \                     ??getProcessInfoIndex_0: (+1)
   \        0xA   0x2416             MOVS     R4,#+22
   \        0xC   0x4354             MULS     R4,R4,R2
   \        0xE   0x5D1D             LDRB     R5,[R3, R4]
   \       0x10   0x428D             CMP      R5,R1
   \       0x12   0xBF08             IT       EQ
   \       0x14   0x4610             MOVEQ    R0,R2
    180                 {
    181                    idValue = i;
    182                 }
    183              }
   \       0x16   0x1C52             ADDS     R2,R2,#+1
   \       0x18   0x2A0A             CMP      R2,#+10
   \       0x1A   0xDBF6             BLT.N    ??getProcessInfoIndex_0
    184              return idValue;                                                               //not found
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0xBD30             POP      {R4,R5,PC}       ;; return
    185          }
    186          /**
    187            * @brief  This function performs CRC calculation on BufSize bytes from input data buffer aDataBuf.
    188            * @param  BufSize Nb of bytes to be processed for CRC calculation
    189            * @retval 16-bit CRC value computed on input data buffer
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          uint16_t Calculate_CRC(uint16_t BufSize, unsigned char* aDataBuf)              //Pam Tested
    192          {
   \                     Calculate_CRC: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    193            register uint16_t index = 0;
    194            LL_CRC_ResetCRCCalculationUnit(CRC);
   \        0x2   0x....             LDR.N    R3,??DataTable6_2  ;; 0x40023000
   \        0x4   0x689C             LDR      R4,[R3, #+8]
   \        0x6   0xF044 0x0401      ORR      R4,R4,#0x1
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x609C             STR      R4,[R3, #+8]
    195            /* Compute the CRC of Data Buffer array*/
    196            for (index = 0; index < BufSize ; index++)
   \        0xE   0xE002             B.N      ??Calculate_CRC_0
    197            {
    198              LL_CRC_FeedData8(CRC,aDataBuf[index] );
   \                     ??Calculate_CRC_1: (+1)
   \       0x10   0x5D0C             LDRB     R4,[R1, R4]
   \       0x12   0x701C             STRB     R4,[R3, #+0]
    199            }
   \       0x14   0x1C52             ADDS     R2,R2,#+1
   \                     ??Calculate_CRC_0: (+1)
   \       0x16   0xB294             UXTH     R4,R2
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD3F9             BCC.N    ??Calculate_CRC_1
    200            /* Return computed CRC value */
    201            return (LL_CRC_ReadData16(CRC));
   \       0x1C   0x6818             LDR      R0,[R3, #+0]
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0xBD10             POP      {R4,PC}          ;; return
    202          }
    203          
    204          /**
    205            *************************************************************************************************************************************************************
    206            * @brief   Setup a software interrupt 
    207            * @details find out and set the correct bit in the software interrupt bit table SoftwareIrqBitPt[IrqGroupIndx_u8] 
    208            *             parameters:     SENDER_MODULE_ID        the module ID for the source of this interrupt
    209            *                             RECIVER_MODULE_ID       the module ID for the responding this interrupt
    210            *                             _irqType_u8             interrupt category of this interrupt
    211            *                             _irqDat_u8              data pass to the responding module
    212            *                             _irqDat1_len_u8         if _irqDatPt_u8 not equal to NULL this is the second byte of data pass to the responding module
    213            *                             _irqDatPt_u8            if data more than 2 byte can wrap it as pointer and use _irqDat1_len_u8 as the length of this data set
    214            * @return  
    215            *************************************************************************************************************************************************************
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void setupSoftwareIRQ(uint8_t SENDER_MODULE_ID, uint8_t RECIVER_MODULE_ID, uint8_t _irqType_u8, uint8_t _irqDat_u8, uint8_t _irqDat1_len_u8, uint8_t * _irqDatPt_u8) 
    218          { /**prepare software interrupt for the Ack timeout module**/                  
   \                     setupSoftwareIRQ: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4689             MOV      R9,R1
   \        0x6   0x461E             MOV      R6,R3
    219            uint8_t SoftwareIrqBitPtIndx = RECIVER_MODULE_ID / 64;     // get the interrupt pointer group of software IRQ point index
   \        0x8   0xEA4F 0x1399      LSR      R3,R9,#+6
    220            uint64_t IrqBitTempry = 0x01;
    221            SoftwareIrqBitPt[SoftwareIrqBitPtIndx] |= IrqBitTempry << (RECIVER_MODULE_ID - (SoftwareIrqBitPtIndx * 64)); //set software interrupt trigger bit
   \        0xC   0x....             LDR.N    R7,??DataTable6
   \        0xE   0xEB07 0x08C3      ADD      R8,R7,R3, LSL #+3
   \       0x12   0x4604             MOV      R4,R0
   \       0x14   0x4615             MOV      R5,R2
   \       0x16   0xE9D8 0xAB02      LDRD     R10,R11,[R8, #+8]
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0xEBA9 0x1283      SUB      R2,R9,R3, LSL #+6
   \       0x22   0x....'....        BL       __aeabi_llsl
   \       0x26   0xEA4A 0x0200      ORR      R2,R10,R0
   \       0x2A   0xEA4B 0x0301      ORR      R3,R11,R1
   \       0x2E   0xE9C8 0x2302      STRD     R2,R3,[R8, #+8]
    222            IrqTrigProcessID = SENDER_MODULE_ID;                                     /**set current module ID to let the IRQ response module know who triggered this interrupt  **/          
   \       0x32   0x703C             STRB     R4,[R7, #+0]
    223            //find out the ISR module and enter all the parameter for it to respone the interrupt, "this ACK time out error"
    224            uint8_t table_index_u8 = getProcessInfoIndex(RECIVER_MODULE_ID);  
   \       0x34   0x4648             MOV      R0,R9
   \       0x36   0x....'....        BL       getProcessInfoIndex
   \       0x3A   0x4601             MOV      R1,R0
    225            if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0x3C   0x29FF             CMP      R1,#+255
   \       0x3E   0xD00A             BEQ.N    ??setupSoftwareIRQ_0
    226              processInfoTable[table_index_u8].Sched_DrvData.irqType_u8 = _irqType_u8;                     /**inform the interrupt response module this is an error message**/
   \       0x40   0x2216             MOVS     R2,#+22
   \       0x42   0x....             LDR.N    R3,??DataTable6_1
   \       0x44   0x980A             LDR      R0,[SP, #+40]
   \       0x46   0x4351             MULS     R1,R2,R1
   \       0x48   0x4419             ADD      R1,R3,R1
    227              processInfoTable[table_index_u8].Sched_DrvData.irqDat_u8 = _irqDat_u8;                
    228              processInfoTable[table_index_u8].Sched_DrvData.irqDat1_len_u8 = _irqDat1_len_u8;      
   \       0x4A   0x7448             STRB     R0,[R1, #+17]
   \       0x4C   0x73CD             STRB     R5,[R1, #+15]
   \       0x4E   0x740E             STRB     R6,[R1, #+16]
    229              processInfoTable[table_index_u8].Sched_DrvData.irqDatPt_u8 = _irqDatPt_u8;                          //if no extend data so point to NULL                  
   \       0x50   0x980B             LDR      R0,[SP, #+44]
   \       0x52   0xF8C1 0x0012      STR      R0,[R1, #+18]
    230            }
    231          }
   \                     ??setupSoftwareIRQ_0: (+1)
   \       0x56   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    232          
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void HAL_SYSTICK_Callback(void) { //Using SysTick_Handler() instead //SPA
   \                     HAL_SYSTICK_Callback: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    235              tickCounter++; //SPA
   \        0x2   0x....             LDR.N    R0,??DataTable6
   \        0x4   0xE9D0 0x230A      LDRD     R2,R3,[R0, #+40]
   \        0x8   0x1C54             ADDS     R4,R2,#+1
   \        0xA   0xF163 0x35FF      SBC      R5,R3,#-1
   \        0xE   0xE9C0 0x450A      STRD     R4,R5,[R0, #+40]
    236          }
   \       0x12   0xBD30             POP      {R4,R5,PC}       ;; return
    237          

   \                                 In section .text, align 2, keep-with-next
    238          uint64_t getSysCount(void) 
    239          {
    240            return tickCounter; 
   \                     getSysCount: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable6
   \        0x2   0xE9D0 0x010A      LDRD     R0,R1,[R0, #+40]
   \        0x6   0x4770             BX       LR               ;; return
    241          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     IrqTrigProcessID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x4002'3000        DC32     0x40023000
    242          
    243          // void Watchdog_Initialize(uint8_t timeout_u8) {
    244          //     LL_IWDG_Enable(IWDG);                             // Start the Independent Watchdog.
    245          //     LL_IWDG_EnableWriteAccess(IWDG);                  // Enable write access to IWDG registers.
    246          //     LL_IWDG_SetPrescaler(IWDG, LL_IWDG_PRESCALER_4);  // IWDG timer clock will be (LSI / 32).
    247          //     LL_IWDG_SetReloadCounter(IWDG, timeout_u8 * 625); // (timeout_s * 625) must be between Min_Data=0 and Max_Data=0x0FFF
    248          //     while (LL_IWDG_IsReady(IWDG) != TRUE)             // Wait for the registers to be updated
    249          //     {
    250          //     }
    251          //     LL_IWDG_ReloadCounter(IWDG); // Reload the IWDG counter (kick the dog for once!).
    252          // }
    253          
    254          // void Watchdog_Reload(void) {
    255          //     LL_IWDG_ReloadCounter(IWDG);
    256          // }
    257          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Calculate_CRC
      12   HAL_SYSTICK_Callback
       8   Sched_Initialize
         8   -> SeqMem_InitBufs
         8   -> StructMem_InitBufs
      32   Sched_Run
        32   -- Indirect call
        32   -> getProcessInfoIndex
      12   getProcessInfoIndex
       0   getSysCount
      40   setupSoftwareIRQ
        40   -> getProcessInfoIndex
        40 __aeabi_llsl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  App_CRC
      34  Calculate_CRC
      20  HAL_SYSTICK_Callback
     104  IrqTrigProcessID
          maxTimeModuleId
          maxTimeIRQ_ModuleId
          IRQgroupItem
          IrqGroupIndx_u8
          SoftwareIrqBitPt
          tickCounter
          moduleStartTime
          moduleRunTime
          IrqModuleStartTime
          IrqModuleRunTime
          maxModuleTimeUsage
          maxIRQTimeUsage
          shifter_u8
      14  Sched_Initialize
     340  Sched_Run
      32  getProcessInfoIndex
       8  getSysCount
     220  processInfoTable
      90  setupSoftwareIRQ

 
 324 bytes in section .data
 550 bytes in section .text
   4 bytes in section app_crc32_rom
 
 550 bytes of CODE  memory
   4 bytes of CONST memory
 324 bytes of DATA  memory

Errors: none
Warnings: none
